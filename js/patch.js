/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var CABLES;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/cgl/cgl_shader_default_glsl.vert":
/*!***************************************************!*\
  !*** ./src/core/cgl/cgl_shader_default_glsl.vert ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"{{MODULES_HEAD}}\\nIN vec3 vPosition;\\nIN vec2 attrTexCoord;\\nIN vec3 attrVertNormal;\\nIN vec3 attrTangent,attrBiTangent;\\n\\nIN float attrVertIndex;\\n\\nOUT vec2 texCoord;\\nOUT vec3 norm;\\nUNI mat4 projMatrix;\\nUNI mat4 viewMatrix;\\nUNI mat4 modelMatrix;\\n\\nvoid main()\\n{\\n    texCoord=attrTexCoord;\\n    norm=attrVertNormal;\\n    vec4 pos=vec4(vPosition,  1.0);\\n    vec3 tangent=attrTangent;\\n    vec3 bitangent=attrBiTangent;\\n    mat4 mMatrix=modelMatrix;\\n    gl_PointSize=10.0;\\n\\n    {{MODULE_VERTEX_POSITION}}\\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl9kZWZhdWx0X2dsc2wudmVydC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl9kZWZhdWx0X2dsc2wudmVydD9jNTJmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwie3tNT0RVTEVTX0hFQUR9fVxcbklOIHZlYzMgdlBvc2l0aW9uO1xcbklOIHZlYzIgYXR0clRleENvb3JkO1xcbklOIHZlYzMgYXR0clZlcnROb3JtYWw7XFxuSU4gdmVjMyBhdHRyVGFuZ2VudCxhdHRyQmlUYW5nZW50O1xcblxcbklOIGZsb2F0IGF0dHJWZXJ0SW5kZXg7XFxuXFxuT1VUIHZlYzIgdGV4Q29vcmQ7XFxuT1VUIHZlYzMgbm9ybTtcXG5VTkkgbWF0NCBwcm9qTWF0cml4O1xcblVOSSBtYXQ0IHZpZXdNYXRyaXg7XFxuVU5JIG1hdDQgbW9kZWxNYXRyaXg7XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHRleENvb3JkPWF0dHJUZXhDb29yZDtcXG4gICAgbm9ybT1hdHRyVmVydE5vcm1hbDtcXG4gICAgdmVjNCBwb3M9dmVjNCh2UG9zaXRpb24sICAxLjApO1xcbiAgICB2ZWMzIHRhbmdlbnQ9YXR0clRhbmdlbnQ7XFxuICAgIHZlYzMgYml0YW5nZW50PWF0dHJCaVRhbmdlbnQ7XFxuICAgIG1hdDQgbU1hdHJpeD1tb2RlbE1hdHJpeDtcXG4gICAgZ2xfUG9pbnRTaXplPTEwLjA7XFxuXFxuICAgIHt7TU9EVUxFX1ZFUlRFWF9QT1NJVElPTn19XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvak1hdHJpeCAqICh2aWV3TWF0cml4Km1NYXRyaXgpICogcG9zO1xcbn1cXG5cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader_default_glsl.vert\n");

/***/ }),

/***/ "./src/core/cgp/cgl_shader_default.wgsl":
/*!**********************************************!*\
  !*** ./src/core/cgp/cgl_shader_default.wgsl ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct VSUniforms\\n{\\n    modelMatrix: mat4x4<f32>,\\n    viewMatrix: mat4x4<f32>,\\n    projMatrix: mat4x4<f32>,\\n};\\n\\nstruct FSUniforms\\n{\\n    color:vec4<f32>\\n};\\n\\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\\n\\nstruct MyVSInput\\n{\\n    @location(0) position: vec3<f32>,\\n    @location(1) normal: vec3<f32>,\\n    @location(2) texcoord: vec2<f32>,\\n};\\n\\nstruct MyVSOutput\\n{\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) normal: vec3<f32>,\\n    @location(1) texcoord: vec2<f32>,\\n};\\n\\n@vertex\\nfn myVSMain(v: MyVSInput) -> MyVSOutput\\n{\\n    var vsOut: MyVSOutput;\\n    var pos =vec4<f32>(v.position, 1.0);\\n\\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\\n\\n    vsOut.normal = v.normal;\\n    vsOut.texcoord = v.texcoord;\\n    return vsOut;\\n}\\n\\n@fragment\\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\\n{\\n    return fsUniforms.color+vec4<f32>(.5,.5,.5,1.0);\\n}\\n\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dsX3NoYWRlcl9kZWZhdWx0Lndnc2wuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NnbF9zaGFkZXJfZGVmYXVsdC53Z3NsPzZmYTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJzdHJ1Y3QgVlNVbmlmb3Jtc1xcbntcXG4gICAgbW9kZWxNYXRyaXg6IG1hdDR4NDxmMzI+LFxcbiAgICB2aWV3TWF0cml4OiBtYXQ0eDQ8ZjMyPixcXG4gICAgcHJvak1hdHJpeDogbWF0NHg0PGYzMj4sXFxufTtcXG5cXG5zdHJ1Y3QgRlNVbmlmb3Jtc1xcbntcXG4gICAgY29sb3I6dmVjNDxmMzI+XFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHZzVW5pZm9ybXM6IFZTVW5pZm9ybXM7XFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjx1bmlmb3JtPiBmc1VuaWZvcm1zOiBGU1VuaWZvcm1zO1xcblxcbnN0cnVjdCBNeVZTSW5wdXRcXG57XFxuICAgIEBsb2NhdGlvbigwKSBwb3NpdGlvbjogdmVjMzxmMzI+LFxcbiAgICBAbG9jYXRpb24oMSkgbm9ybWFsOiB2ZWMzPGYzMj4sXFxuICAgIEBsb2NhdGlvbigyKSB0ZXhjb29yZDogdmVjMjxmMzI+LFxcbn07XFxuXFxuc3RydWN0IE15VlNPdXRwdXRcXG57XFxuICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgICBAbG9jYXRpb24oMCkgbm9ybWFsOiB2ZWMzPGYzMj4sXFxuICAgIEBsb2NhdGlvbigxKSB0ZXhjb29yZDogdmVjMjxmMzI+LFxcbn07XFxuXFxuQHZlcnRleFxcbmZuIG15VlNNYWluKHY6IE15VlNJbnB1dCkgLT4gTXlWU091dHB1dFxcbntcXG4gICAgdmFyIHZzT3V0OiBNeVZTT3V0cHV0O1xcbiAgICB2YXIgcG9zID12ZWM0PGYzMj4odi5wb3NpdGlvbiwgMS4wKTtcXG5cXG4gICAgdmFyIG12TWF0cml4PXZzVW5pZm9ybXMudmlld01hdHJpeCAqIHZzVW5pZm9ybXMubW9kZWxNYXRyaXg7XFxuICAgIHZzT3V0LnBvc2l0aW9uID0gdnNVbmlmb3Jtcy5wcm9qTWF0cml4ICogbXZNYXRyaXggKiBwb3M7XFxuXFxuICAgIHZzT3V0Lm5vcm1hbCA9IHYubm9ybWFsO1xcbiAgICB2c091dC50ZXhjb29yZCA9IHYudGV4Y29vcmQ7XFxuICAgIHJldHVybiB2c091dDtcXG59XFxuXFxuQGZyYWdtZW50XFxuZm4gbXlGU01haW4odjogTXlWU091dHB1dCkgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPlxcbntcXG4gICAgcmV0dXJuIGZzVW5pZm9ybXMuY29sb3IrdmVjNDxmMzI+KC41LC41LC41LDEuMCk7XFxufVxcblxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgp/cgl_shader_default.wgsl\n");

/***/ }),

/***/ "./src/core/anim.js":
/*!**************************!*\
  !*** ./src/core/anim.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANIM\": () => (/* binding */ ANIM),\n/* harmony export */   \"Anim\": () => (/* binding */ Anim)\n/* harmony export */ });\n/* harmony import */ var _anim_key__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim_key */ \"./src/core/anim_key.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n\n\n\n\n\n/**\n * Keyframed interpolated animation.\n *\n * Available Easings:\n * <pre>\n * CONSTANTS.ANIM.EASING_LINEAR\n * CONSTANTS.ANIM.EASING_ABSOLUTE\n * CONSTANTS.ANIM.EASING_SMOOTHSTEP\n * CONSTANTS.ANIM.EASING_SMOOTHERSTEP\n * CONSTANTS.ANIM.EASING_CUBICSPLINE\n\n * CONSTANTS.ANIM.EASING_CUBIC_IN\n * CONSTANTS.ANIM.EASING_CUBIC_OUT\n * CONSTANTS.ANIM.EASING_CUBIC_INOUT\n\n * CONSTANTS.ANIM.EASING_EXPO_IN\n * CONSTANTS.ANIM.EASING_EXPO_OUT\n * CONSTANTS.ANIM.EASING_EXPO_INOUT\n\n * CONSTANTS.ANIM.EASING_SIN_IN\n * CONSTANTS.ANIM.EASING_SIN_OUT\n * CONSTANTS.ANIM.EASING_SIN_INOUT\n\n * CONSTANTS.ANIM.EASING_BACK_IN\n * CONSTANTS.ANIM.EASING_BACK_OUT\n * CONSTANTS.ANIM.EASING_BACK_INOUT\n\n * CONSTANTS.ANIM.EASING_ELASTIC_IN\n * CONSTANTS.ANIM.EASING_ELASTIC_OUT\n\n * CONSTANTS.ANIM.EASING_BOUNCE_IN\n * CONSTANTS.ANIM.EASING_BOUNCE_OUT\n\n * CONSTANTS.ANIM.EASING_QUART_IN\n * CONSTANTS.ANIM.EASING_QUART_OUT\n * CONSTANTS.ANIM.EASING_QUART_INOUT\n\n * CONSTANTS.ANIM.EASING_QUINT_IN\n * CONSTANTS.ANIM.EASING_QUINT_OUT\n * CONSTANTS.ANIM.EASING_QUINT_INOUT\n * </pre>\n * @hideconstructor\n * @external CABLES\n * @namespace Anim\n * @class\n * @example\n * var anim=new CABLES.Anim();\n * anim.setValue(0,0);  // set value 0 at 0 seconds\n * anim.setValue(10,1); // set value 1 at 10 seconds\n * anim.getValue(5);    // get value at 5 seconds - this returns 0.5\n */\n\nconst Anim = function (cfg)\n{\n    _eventtarget__WEBPACK_IMPORTED_MODULE_3__.EventTarget.apply(this);\n\n    cfg = cfg || {};\n    this.keys = [];\n    this.onChange = null;\n    this.stayInTimeline = false;\n    this.loop = false;\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\"Anim\");\n    this._lastKeyIndex = 0;\n    this._cachedIndex = 0;\n    this.name = cfg.name || null;\n\n    /**\n     * @member defaultEasing\n     * @memberof Anim\n     * @instance\n     * @type {Number}\n     */\n    this.defaultEasing = cfg.defaultEasing || _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_LINEAR;\n    this.onLooped = null;\n\n    this._timesLooped = 0;\n    this._needsSort = false;\n};\n\nAnim.prototype.forceChangeCallback = function ()\n{\n    if (this.onChange !== null) this.onChange();\n    this.emitEvent(\"onChange\", this);\n};\n\nAnim.prototype.getLoop = function ()\n{\n    return this.loop;\n};\n\nAnim.prototype.setLoop = function (target)\n{\n    this.loop = target;\n    this.emitEvent(\"onChange\", this);\n};\n\n/**\n * returns true if animation has ended at @time\n * checks if last key time is < time\n * @param {Number} time\n * @returns {Boolean}\n * @memberof Anim\n * @instance\n * @function\n */\nAnim.prototype.hasEnded = function (time)\n{\n    if (this.keys.length === 0) return true;\n    if (this.keys[this._lastKeyIndex].time <= time) return true;\n    return false;\n};\n\nAnim.prototype.isRising = function (time)\n{\n    if (this.hasEnded(time)) return false;\n    const ki = this.getKeyIndex(time);\n    if (this.keys[ki].value < this.keys[ki + 1].value) return true;\n    return false;\n};\n\n/**\n * remove all keys from animation before time\n * @param {Number} time\n * @memberof Anim\n * @instance\n * @function\n */\nAnim.prototype.clearBefore = function (time)\n{\n    const v = this.getValue(time);\n    const ki = this.getKeyIndex(time);\n\n    this.setValue(time, v);\n\n    if (ki > 1) this.keys.splice(0, ki);\n    this._updateLastIndex();\n};\n/**\n * remove all keys from animation\n * @param {Number} [time=0] set a new key at time with the old value at time\n * @memberof Anim\n * @instance\n * @function\n */\nAnim.prototype.clear = function (time)\n{\n    let v = 0;\n    if (time) v = this.getValue(time);\n    this.keys.length = 0;\n    this._updateLastIndex();\n    if (time) this.setValue(time, v);\n    if (this.onChange !== null) this.onChange();\n    this.emitEvent(\"onChange\", this);\n};\n\nAnim.prototype.sortKeys = function ()\n{\n    this.keys.sort((a, b) => { return parseFloat(a.time) - parseFloat(b.time); });\n    this._updateLastIndex();\n    this._needsSort = false;\n    if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);\n};\n\nAnim.prototype.getLength = function ()\n{\n    if (this.keys.length === 0) return 0;\n    return this.keys[this.keys.length - 1].time;\n};\n\nAnim.prototype.getKeyIndex = function (time)\n{\n    let index = 0;\n    let start = 0;\n    if (this._cachedIndex && this.keys.length > this._cachedIndex && time >= this.keys[this._cachedIndex].time) start = this._cachedIndex;\n    for (let i = start; i < this.keys.length; i++)\n    {\n        if (time >= this.keys[i].time) index = i;\n        if (this.keys[i].time > time)\n        {\n            if (time != 0) this._cachedIndex = index;\n            return index;\n        }\n    }\n\n    return index;\n};\n\n/**\n * set value at time\n * @function setValue\n * @memberof Anim\n * @instance\n * @param {Number} time\n * @param {Number} value\n * @param {Function} [callback] callback\n */\nAnim.prototype.setValue = function (time, value, cb)\n{\n    let found = null;\n\n    if (this.keys.length == 0 || time <= this.keys[this.keys.length - 1].time)\n        for (let i = 0; i < this.keys.length; i++)\n            if (this.keys[i].time == time)\n            {\n                found = this.keys[i];\n                this.keys[i].setValue(value);\n                this.keys[i].cb = cb;\n                break;\n            }\n\n    if (!found)\n    {\n        found = new _anim_key__WEBPACK_IMPORTED_MODULE_0__.Key(\n            {\n                \"time\": time,\n                \"value\": value,\n                \"e\": this.defaultEasing,\n                \"cb\": cb,\n            });\n        this.keys.push(found);\n\n        // if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);\n        this._updateLastIndex();\n    }\n\n    if (this.onChange) this.onChange();\n    this.emitEvent(\"onChange\", this);\n    this._needsSort = true;\n    return found;\n};\n\nAnim.prototype.setKeyEasing = function (index, e)\n{\n    if (this.keys[index])\n    {\n        this.keys[index].setEasing(e);\n        this.emitEvent(\"onChange\", this);\n    }\n};\n\nAnim.prototype.getSerialized = function ()\n{\n    const obj = {};\n    obj.keys = [];\n    obj.loop = this.loop;\n\n    for (let i = 0; i < this.keys.length; i++)\n        obj.keys.push(this.keys[i].getSerialized());\n\n    return obj;\n};\n\nAnim.prototype.getKey = function (time)\n{\n    const index = this.getKeyIndex(time);\n    return this.keys[index];\n};\n\nAnim.prototype.getNextKey = function (time)\n{\n    let index = this.getKeyIndex(time) + 1;\n    if (index >= this.keys.length) index = this.keys.length - 1;\n\n    return this.keys[index];\n};\n\nAnim.prototype.isFinished = function (time)\n{\n    if (this.keys.length <= 0) return true;\n    return time > this.keys[this.keys.length - 1].time;\n};\n\nAnim.prototype.isStarted = function (time)\n{\n    if (this.keys.length <= 0) return false;\n    return time >= this.keys[0].time;\n};\n\n/**\n * get value at time\n * @function getValue\n * @memberof Anim\n * @instance\n * @param {Number} [time] time\n * @returns {Number} interpolated value at time\n */\nAnim.prototype.getValue = function (time)\n{\n    if (this.keys.length === 0)\n    {\n        return 0;\n    }\n    if (this._needsSort) this.sortKeys();\n\n    if (!this.loop && time > this.keys[this._lastKeyIndex].time)\n    {\n        if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered) this.keys[this._lastKeyIndex].trigger();\n\n        return this.keys[this._lastKeyIndex].value;\n    }\n\n    if (time < this.keys[0].time)\n    {\n        // if (this.name)console.log(\"A\");\n\n        return this.keys[0].value;\n    }\n\n    if (this.loop && time > this.keys[this._lastKeyIndex].time)\n    {\n        const currentLoop = time / this.keys[this._lastKeyIndex].time;\n        if (currentLoop > this._timesLooped)\n        {\n            this._timesLooped++;\n            if (this.onLooped) this.onLooped();\n        }\n        time = (time - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time);\n        time += this.keys[0].time;\n    }\n\n    const index = this.getKeyIndex(time);\n    if (index >= this._lastKeyIndex)\n    {\n        if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered) this.keys[this._lastKeyIndex].trigger();\n\n        if (this.name)console.log(\"B\", this.keys[this._lastKeyIndex].cbTriggered);\n\n        return this.keys[this._lastKeyIndex].value;\n    }\n\n\n    const index2 = index + 1;\n    const key1 = this.keys[index];\n    const key2 = this.keys[index2];\n\n    if (key1.cb && !key1.cbTriggered) key1.trigger();\n\n    if (!key2) return -1;\n\n    const perc = (time - key1.time) / (key2.time - key1.time);\n\n    if (!key1.ease) this.log._warn(\"has no ease\", key1, key2);\n\n    return key1.ease(perc, key2);\n};\n\nAnim.prototype._updateLastIndex = function ()\n{\n    this._lastKeyIndex = this.keys.length - 1;\n};\n\nAnim.prototype.addKey = function (k)\n{\n    if (k.time === undefined)\n    {\n        this.log.warn(\"key time undefined, ignoring!\");\n    }\n    else\n    {\n        this.keys.push(k);\n        if (this.onChange !== null) this.onChange();\n        this.emitEvent(\"onChange\", this);\n    }\n    this._updateLastIndex();\n};\n\nAnim.prototype.easingFromString = function (str)\n{\n    if (str == \"linear\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_LINEAR;\n    if (str == \"absolute\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_ABSOLUTE;\n    if (str == \"smoothstep\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_SMOOTHSTEP;\n    if (str == \"smootherstep\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_SMOOTHERSTEP;\n\n    if (str == \"Cubic In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_CUBIC_IN;\n    if (str == \"Cubic Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_CUBIC_OUT;\n    if (str == \"Cubic In Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_CUBIC_INOUT;\n\n    if (str == \"Expo In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_EXPO_IN;\n    if (str == \"Expo Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_EXPO_OUT;\n    if (str == \"Expo In Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_EXPO_INOUT;\n\n    if (str == \"Sin In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_SIN_IN;\n    if (str == \"Sin Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_SIN_OUT;\n    if (str == \"Sin In Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_SIN_INOUT;\n\n    if (str == \"Back In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_BACK_IN;\n    if (str == \"Back Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_BACK_OUT;\n    if (str == \"Back In Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_BACK_INOUT;\n\n    if (str == \"Elastic In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_ELASTIC_IN;\n    if (str == \"Elastic Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_ELASTIC_OUT;\n\n    if (str == \"Bounce In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_BOUNCE_IN;\n    if (str == \"Bounce Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_BOUNCE_OUT;\n\n    if (str == \"Quart Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_QUART_OUT;\n    if (str == \"Quart In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_QUART_IN;\n    if (str == \"Quart In Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_QUART_INOUT;\n\n    if (str == \"Quint Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_QUINT_OUT;\n    if (str == \"Quint In\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_QUINT_IN;\n    if (str == \"Quint In Out\") return _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASING_QUINT_INOUT;\n};\n\nAnim.prototype.createPort = function (op, title, cb)\n{\n    const port = op.inDropDown(title, _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.ANIM.EASINGS);\n\n    // const port = op.addInPort(\n    //     new Port(op, title, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n    //         \"display\": \"dropdown\",\n    //         \"values\": CONSTANTS.ANIM.EASINGS,\n    //     }),\n    // );\n\n    port.set(\"linear\");\n    port.defaultValue = \"linear\";\n\n    port.onChange = function ()\n    {\n        this.defaultEasing = this.easingFromString(port.get());\n        this.emitEvent(\"onChangeDefaultEasing\", this);\n\n        if (cb) cb();\n    }.bind(this);\n\n    return port;\n};\n\n// ------------------------------\n\nAnim.slerpQuaternion = function (time, q, animx, animy, animz, animw)\n{\n    if (!Anim.slerpQuaternion.q1)\n    {\n        Anim.slerpQuaternion.q1 = quat.create();\n        Anim.slerpQuaternion.q2 = quat.create();\n    }\n\n    const i1 = animx.getKeyIndex(time);\n    let i2 = i1 + 1;\n    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;\n\n    if (i1 == i2)\n    {\n        quat.set(q, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);\n    }\n    else\n    {\n        const key1Time = animx.keys[i1].time;\n        const key2Time = animx.keys[i2].time;\n        const perc = (time - key1Time) / (key2Time - key1Time);\n\n        quat.set(Anim.slerpQuaternion.q1, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);\n\n        quat.set(Anim.slerpQuaternion.q2, animx.keys[i2].value, animy.keys[i2].value, animz.keys[i2].value, animw.keys[i2].value);\n\n        quat.slerp(q, Anim.slerpQuaternion.q1, Anim.slerpQuaternion.q2, perc);\n    }\n    return q;\n};\n\nconst ANIM = { \"Key\": _anim_key__WEBPACK_IMPORTED_MODULE_0__.Key };\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9hbmltLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2FuaW0uanM/M2FjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBLZXkgfSBmcm9tIFwiLi9hbmltX2tleVwiO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuL2NvcmVfbG9nZ2VyXCI7XG5pbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50dGFyZ2V0XCI7XG5cbi8qKlxuICogS2V5ZnJhbWVkIGludGVycG9sYXRlZCBhbmltYXRpb24uXG4gKlxuICogQXZhaWxhYmxlIEVhc2luZ3M6XG4gKiA8cHJlPlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0xJTkVBUlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0FCU09MVVRFXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfU01PT1RIU1RFUFxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NNT09USEVSU1RFUFxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDU1BMSU5FXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDX09VVFxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDX0lOT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRVhQT19PVVRcbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19TSU5fSU5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19TSU5fT1VUXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfU0lOX0lOT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19CQUNLX0lOXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19PVVRcbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19CQUNLX0lOT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX0lOXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRUxBU1RJQ19PVVRcblxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JPVU5DRV9JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JPVU5DRV9PVVRcblxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX0lOXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfT1VUXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfSU5PVVRcblxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVSU5UX0lOXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVJTlRfT1VUXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVJTlRfSU5PVVRcbiAqIDwvcHJlPlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICogQGV4dGVybmFsIENBQkxFU1xuICogQG5hbWVzcGFjZSBBbmltXG4gKiBAY2xhc3NcbiAqIEBleGFtcGxlXG4gKiB2YXIgYW5pbT1uZXcgQ0FCTEVTLkFuaW0oKTtcbiAqIGFuaW0uc2V0VmFsdWUoMCwwKTsgIC8vIHNldCB2YWx1ZSAwIGF0IDAgc2Vjb25kc1xuICogYW5pbS5zZXRWYWx1ZSgxMCwxKTsgLy8gc2V0IHZhbHVlIDEgYXQgMTAgc2Vjb25kc1xuICogYW5pbS5nZXRWYWx1ZSg1KTsgICAgLy8gZ2V0IHZhbHVlIGF0IDUgc2Vjb25kcyAtIHRoaXMgcmV0dXJucyAwLjVcbiAqL1xuXG5jb25zdCBBbmltID0gZnVuY3Rpb24gKGNmZylcbntcbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgIGNmZyA9IGNmZyB8fCB7fTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLm9uQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLnN0YXlJblRpbWVsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcIkFuaW1cIik7XG4gICAgdGhpcy5fbGFzdEtleUluZGV4ID0gMDtcbiAgICB0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG4gICAgdGhpcy5uYW1lID0gY2ZnLm5hbWUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgZGVmYXVsdEVhc2luZ1xuICAgICAqIEBtZW1iZXJvZiBBbmltXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRFYXNpbmcgPSBjZmcuZGVmYXVsdEVhc2luZyB8fCBDT05TVEFOVFMuQU5JTS5FQVNJTkdfTElORUFSO1xuICAgIHRoaXMub25Mb29wZWQgPSBudWxsO1xuXG4gICAgdGhpcy5fdGltZXNMb29wZWQgPSAwO1xuICAgIHRoaXMuX25lZWRzU29ydCA9IGZhbHNlO1xufTtcblxuQW5pbS5wcm90b3R5cGUuZm9yY2VDaGFuZ2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMub25DaGFuZ2UgIT09IG51bGwpIHRoaXMub25DaGFuZ2UoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMpO1xufTtcblxuQW5pbS5wcm90b3R5cGUuZ2V0TG9vcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMubG9vcDtcbn07XG5cbkFuaW0ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAodGFyZ2V0KVxue1xuICAgIHRoaXMubG9vcCA9IHRhcmdldDtcbiAgICB0aGlzLmVtaXRFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMpO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgYW5pbWF0aW9uIGhhcyBlbmRlZCBhdCBAdGltZVxuICogY2hlY2tzIGlmIGxhc3Qga2V5IHRpbWUgaXMgPCB0aW1lXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgQW5pbVxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb25cbiAqL1xuQW5pbS5wcm90b3R5cGUuaGFzRW5kZWQgPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRpbWUgPD0gdGltZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQW5pbS5wcm90b3R5cGUuaXNSaXNpbmcgPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBpZiAodGhpcy5oYXNFbmRlZCh0aW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGtpID0gdGhpcy5nZXRLZXlJbmRleCh0aW1lKTtcbiAgICBpZiAodGhpcy5rZXlzW2tpXS52YWx1ZSA8IHRoaXMua2V5c1traSArIDFdLnZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIHJlbW92ZSBhbGwga2V5cyBmcm9tIGFuaW1hdGlvbiBiZWZvcmUgdGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcbiAqIEBtZW1iZXJvZiBBbmltXG4gKiBAaW5zdGFuY2VcbiAqIEBmdW5jdGlvblxuICovXG5BbmltLnByb3RvdHlwZS5jbGVhckJlZm9yZSA9IGZ1bmN0aW9uICh0aW1lKVxue1xuICAgIGNvbnN0IHYgPSB0aGlzLmdldFZhbHVlKHRpbWUpO1xuICAgIGNvbnN0IGtpID0gdGhpcy5nZXRLZXlJbmRleCh0aW1lKTtcblxuICAgIHRoaXMuc2V0VmFsdWUodGltZSwgdik7XG5cbiAgICBpZiAoa2kgPiAxKSB0aGlzLmtleXMuc3BsaWNlKDAsIGtpKTtcbiAgICB0aGlzLl91cGRhdGVMYXN0SW5kZXgoKTtcbn07XG4vKipcbiAqIHJlbW92ZSBhbGwga2V5cyBmcm9tIGFuaW1hdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPTBdIHNldCBhIG5ldyBrZXkgYXQgdGltZSB3aXRoIHRoZSBvbGQgdmFsdWUgYXQgdGltZVxuICogQG1lbWJlcm9mIEFuaW1cbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uXG4gKi9cbkFuaW0ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgbGV0IHYgPSAwO1xuICAgIGlmICh0aW1lKSB2ID0gdGhpcy5nZXRWYWx1ZSh0aW1lKTtcbiAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl91cGRhdGVMYXN0SW5kZXgoKTtcbiAgICBpZiAodGltZSkgdGhpcy5zZXRWYWx1ZSh0aW1lLCB2KTtcbiAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwib25DaGFuZ2VcIiwgdGhpcyk7XG59O1xuXG5BbmltLnByb3RvdHlwZS5zb3J0S2V5cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5rZXlzLnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIHBhcnNlRmxvYXQoYS50aW1lKSAtIHBhcnNlRmxvYXQoYi50aW1lKTsgfSk7XG4gICAgdGhpcy5fdXBkYXRlTGFzdEluZGV4KCk7XG4gICAgdGhpcy5fbmVlZHNTb3J0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggJSAxMDAwID09IDApY29uc29sZS5sb2codGhpcy5uYW1lLCB0aGlzLmtleXMubGVuZ3RoKTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiB0aGlzLmtleXNbdGhpcy5rZXlzLmxlbmd0aCAtIDFdLnRpbWU7XG59O1xuXG5BbmltLnByb3RvdHlwZS5nZXRLZXlJbmRleCA9IGZ1bmN0aW9uICh0aW1lKVxue1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW5kZXggJiYgdGhpcy5rZXlzLmxlbmd0aCA+IHRoaXMuX2NhY2hlZEluZGV4ICYmIHRpbWUgPj0gdGhpcy5rZXlzW3RoaXMuX2NhY2hlZEluZGV4XS50aW1lKSBzdGFydCA9IHRoaXMuX2NhY2hlZEluZGV4O1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aW1lID49IHRoaXMua2V5c1tpXS50aW1lKSBpbmRleCA9IGk7XG4gICAgICAgIGlmICh0aGlzLmtleXNbaV0udGltZSA+IHRpbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aW1lICE9IDApIHRoaXMuX2NhY2hlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIHNldCB2YWx1ZSBhdCB0aW1lXG4gKiBAZnVuY3Rpb24gc2V0VmFsdWVcbiAqIEBtZW1iZXJvZiBBbmltXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2tcbiAqL1xuQW5pbS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUsIGNiKVxue1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA9PSAwIHx8IHRpbWUgPD0gdGhpcy5rZXlzW3RoaXMua2V5cy5sZW5ndGggLSAxXS50aW1lKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmtleXNbaV0udGltZSA9PSB0aW1lKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5rZXlzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpXS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzW2ldLmNiID0gY2I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICBpZiAoIWZvdW5kKVxuICAgIHtcbiAgICAgICAgZm91bmQgPSBuZXcgS2V5KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwidGltZVwiOiB0aW1lLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUsXG4gICAgICAgICAgICAgICAgXCJlXCI6IHRoaXMuZGVmYXVsdEVhc2luZyxcbiAgICAgICAgICAgICAgICBcImNiXCI6IGNiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGZvdW5kKTtcblxuICAgICAgICAvLyBpZiAodGhpcy5rZXlzLmxlbmd0aCAlIDEwMDAgPT0gMCljb25zb2xlLmxvZyh0aGlzLm5hbWUsIHRoaXMua2V5cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLl91cGRhdGVMYXN0SW5kZXgoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbkNoYW5nZSkgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwib25DaGFuZ2VcIiwgdGhpcyk7XG4gICAgdGhpcy5fbmVlZHNTb3J0ID0gdHJ1ZTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG5BbmltLnByb3RvdHlwZS5zZXRLZXlFYXNpbmcgPSBmdW5jdGlvbiAoaW5kZXgsIGUpXG57XG4gICAgaWYgKHRoaXMua2V5c1tpbmRleF0pXG4gICAge1xuICAgICAgICB0aGlzLmtleXNbaW5kZXhdLnNldEVhc2luZyhlKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvbkNoYW5nZVwiLCB0aGlzKTtcbiAgICB9XG59O1xuXG5BbmltLnByb3RvdHlwZS5nZXRTZXJpYWxpemVkID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBvYmoua2V5cyA9IFtdO1xuICAgIG9iai5sb29wID0gdGhpcy5sb29wO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgIG9iai5rZXlzLnB1c2godGhpcy5rZXlzW2ldLmdldFNlcmlhbGl6ZWQoKSk7XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuQW5pbS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEtleUluZGV4KHRpbWUpO1xuICAgIHJldHVybiB0aGlzLmtleXNbaW5kZXhdO1xufTtcblxuQW5pbS5wcm90b3R5cGUuZ2V0TmV4dEtleSA9IGZ1bmN0aW9uICh0aW1lKVxue1xuICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgodGltZSkgKyAxO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKSBpbmRleCA9IHRoaXMua2V5cy5sZW5ndGggLSAxO1xuXG4gICAgcmV0dXJuIHRoaXMua2V5c1tpbmRleF07XG59O1xuXG5BbmltLnByb3RvdHlwZS5pc0ZpbmlzaGVkID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPD0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRpbWUgPiB0aGlzLmtleXNbdGhpcy5rZXlzLmxlbmd0aCAtIDFdLnRpbWU7XG59O1xuXG5BbmltLnByb3RvdHlwZS5pc1N0YXJ0ZWQgPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA8PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRpbWUgPj0gdGhpcy5rZXlzWzBdLnRpbWU7XG59O1xuXG4vKipcbiAqIGdldCB2YWx1ZSBhdCB0aW1lXG4gKiBAZnVuY3Rpb24gZ2V0VmFsdWVcbiAqIEBtZW1iZXJvZiBBbmltXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gdGltZVxuICogQHJldHVybnMge051bWJlcn0gaW50ZXJwb2xhdGVkIHZhbHVlIGF0IHRpbWVcbiAqL1xuQW5pbS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbmVlZHNTb3J0KSB0aGlzLnNvcnRLZXlzKCk7XG5cbiAgICBpZiAoIXRoaXMubG9vcCAmJiB0aW1lID4gdGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0udGltZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS5jYiAmJiAhdGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0uY2JUcmlnZ2VyZWQpIHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRyaWdnZXIoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0udmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRpbWUgPCB0aGlzLmtleXNbMF0udGltZSlcbiAgICB7XG4gICAgICAgIC8vIGlmICh0aGlzLm5hbWUpY29uc29sZS5sb2coXCJBXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmtleXNbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubG9vcCAmJiB0aW1lID4gdGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0udGltZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb29wID0gdGltZSAvIHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRpbWU7XG4gICAgICAgIGlmIChjdXJyZW50TG9vcCA+IHRoaXMuX3RpbWVzTG9vcGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90aW1lc0xvb3BlZCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Mb29wZWQpIHRoaXMub25Mb29wZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lID0gKHRpbWUgLSB0aGlzLmtleXNbMF0udGltZSkgJSAodGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0udGltZSAtIHRoaXMua2V5c1swXS50aW1lKTtcbiAgICAgICAgdGltZSArPSB0aGlzLmtleXNbMF0udGltZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgodGltZSk7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2xhc3RLZXlJbmRleClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS5jYiAmJiAhdGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0uY2JUcmlnZ2VyZWQpIHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRyaWdnZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5uYW1lKWNvbnNvbGUubG9nKFwiQlwiLCB0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS5jYlRyaWdnZXJlZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnZhbHVlO1xuICAgIH1cblxuXG4gICAgY29uc3QgaW5kZXgyID0gaW5kZXggKyAxO1xuICAgIGNvbnN0IGtleTEgPSB0aGlzLmtleXNbaW5kZXhdO1xuICAgIGNvbnN0IGtleTIgPSB0aGlzLmtleXNbaW5kZXgyXTtcblxuICAgIGlmIChrZXkxLmNiICYmICFrZXkxLmNiVHJpZ2dlcmVkKSBrZXkxLnRyaWdnZXIoKTtcblxuICAgIGlmICgha2V5MikgcmV0dXJuIC0xO1xuXG4gICAgY29uc3QgcGVyYyA9ICh0aW1lIC0ga2V5MS50aW1lKSAvIChrZXkyLnRpbWUgLSBrZXkxLnRpbWUpO1xuXG4gICAgaWYgKCFrZXkxLmVhc2UpIHRoaXMubG9nLl93YXJuKFwiaGFzIG5vIGVhc2VcIiwga2V5MSwga2V5Mik7XG5cbiAgICByZXR1cm4ga2V5MS5lYXNlKHBlcmMsIGtleTIpO1xufTtcblxuQW5pbS5wcm90b3R5cGUuX3VwZGF0ZUxhc3RJbmRleCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbGFzdEtleUluZGV4ID0gdGhpcy5rZXlzLmxlbmd0aCAtIDE7XG59O1xuXG5BbmltLnByb3RvdHlwZS5hZGRLZXkgPSBmdW5jdGlvbiAoaylcbntcbiAgICBpZiAoay50aW1lID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICB0aGlzLmxvZy53YXJuKFwia2V5IHRpbWUgdW5kZWZpbmVkLCBpZ25vcmluZyFcIik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGspO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVMYXN0SW5kZXgoKTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmVhc2luZ0Zyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKVxue1xuICAgIGlmIChzdHIgPT0gXCJsaW5lYXJcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19MSU5FQVI7XG4gICAgaWYgKHN0ciA9PSBcImFic29sdXRlXCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQUJTT0xVVEU7XG4gICAgaWYgKHN0ciA9PSBcInNtb290aHN0ZXBcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhTVEVQO1xuICAgIGlmIChzdHIgPT0gXCJzbW9vdGhlcnN0ZXBcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhFUlNURVA7XG5cbiAgICBpZiAoc3RyID09IFwiQ3ViaWMgSW5cIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19JTjtcbiAgICBpZiAoc3RyID09IFwiQ3ViaWMgT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNfT1VUO1xuICAgIGlmIChzdHIgPT0gXCJDdWJpYyBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19JTk9VVDtcblxuICAgIGlmIChzdHIgPT0gXCJFeHBvIEluXCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRVhQT19JTjtcbiAgICBpZiAoc3RyID09IFwiRXhwbyBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX09VVDtcbiAgICBpZiAoc3RyID09IFwiRXhwbyBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOT1VUO1xuXG4gICAgaWYgKHN0ciA9PSBcIlNpbiBJblwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9JTjtcbiAgICBpZiAoc3RyID09IFwiU2luIE91dFwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9PVVQ7XG4gICAgaWYgKHN0ciA9PSBcIlNpbiBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19TSU5fSU5PVVQ7XG5cbiAgICBpZiAoc3RyID09IFwiQmFjayBJblwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JBQ0tfSU47XG4gICAgaWYgKHN0ciA9PSBcIkJhY2sgT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19PVVQ7XG4gICAgaWYgKHN0ciA9PSBcIkJhY2sgSW4gT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19JTk9VVDtcblxuICAgIGlmIChzdHIgPT0gXCJFbGFzdGljIEluXCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRUxBU1RJQ19JTjtcbiAgICBpZiAoc3RyID09IFwiRWxhc3RpYyBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX09VVDtcblxuICAgIGlmIChzdHIgPT0gXCJCb3VuY2UgSW5cIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19CT1VOQ0VfSU47XG4gICAgaWYgKHN0ciA9PSBcIkJvdW5jZSBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19CT1VOQ0VfT1VUO1xuXG4gICAgaWYgKHN0ciA9PSBcIlF1YXJ0IE91dFwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX09VVDtcbiAgICBpZiAoc3RyID09IFwiUXVhcnQgSW5cIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUFSVF9JTjtcbiAgICBpZiAoc3RyID09IFwiUXVhcnQgSW4gT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfSU5PVVQ7XG5cbiAgICBpZiAoc3RyID09IFwiUXVpbnQgT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVJTlRfT1VUO1xuICAgIGlmIChzdHIgPT0gXCJRdWludCBJblwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVSU5UX0lOO1xuICAgIGlmIChzdHIgPT0gXCJRdWludCBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9JTk9VVDtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmNyZWF0ZVBvcnQgPSBmdW5jdGlvbiAob3AsIHRpdGxlLCBjYilcbntcbiAgICBjb25zdCBwb3J0ID0gb3AuaW5Ecm9wRG93bih0aXRsZSwgQ09OU1RBTlRTLkFOSU0uRUFTSU5HUyk7XG5cbiAgICAvLyBjb25zdCBwb3J0ID0gb3AuYWRkSW5Qb3J0KFxuICAgIC8vICAgICBuZXcgUG9ydChvcCwgdGl0bGUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAvLyAgICAgICAgIFwiZGlzcGxheVwiOiBcImRyb3Bkb3duXCIsXG4gICAgLy8gICAgICAgICBcInZhbHVlc1wiOiBDT05TVEFOVFMuQU5JTS5FQVNJTkdTLFxuICAgIC8vICAgICB9KSxcbiAgICAvLyApO1xuXG4gICAgcG9ydC5zZXQoXCJsaW5lYXJcIik7XG4gICAgcG9ydC5kZWZhdWx0VmFsdWUgPSBcImxpbmVhclwiO1xuXG4gICAgcG9ydC5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmRlZmF1bHRFYXNpbmcgPSB0aGlzLmVhc2luZ0Zyb21TdHJpbmcocG9ydC5nZXQoKSk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25DaGFuZ2VEZWZhdWx0RWFzaW5nXCIsIHRoaXMpO1xuXG4gICAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gcG9ydDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5BbmltLnNsZXJwUXVhdGVybmlvbiA9IGZ1bmN0aW9uICh0aW1lLCBxLCBhbmlteCwgYW5pbXksIGFuaW16LCBhbmltdylcbntcbiAgICBpZiAoIUFuaW0uc2xlcnBRdWF0ZXJuaW9uLnExKVxuICAgIHtcbiAgICAgICAgQW5pbS5zbGVycFF1YXRlcm5pb24ucTEgPSBxdWF0LmNyZWF0ZSgpO1xuICAgICAgICBBbmltLnNsZXJwUXVhdGVybmlvbi5xMiA9IHF1YXQuY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaTEgPSBhbmlteC5nZXRLZXlJbmRleCh0aW1lKTtcbiAgICBsZXQgaTIgPSBpMSArIDE7XG4gICAgaWYgKGkyID49IGFuaW14LmtleXMubGVuZ3RoKSBpMiA9IGFuaW14LmtleXMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChpMSA9PSBpMilcbiAgICB7XG4gICAgICAgIHF1YXQuc2V0KHEsIGFuaW14LmtleXNbaTFdLnZhbHVlLCBhbmlteS5rZXlzW2kxXS52YWx1ZSwgYW5pbXoua2V5c1tpMV0udmFsdWUsIGFuaW13LmtleXNbaTFdLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc3Qga2V5MVRpbWUgPSBhbmlteC5rZXlzW2kxXS50aW1lO1xuICAgICAgICBjb25zdCBrZXkyVGltZSA9IGFuaW14LmtleXNbaTJdLnRpbWU7XG4gICAgICAgIGNvbnN0IHBlcmMgPSAodGltZSAtIGtleTFUaW1lKSAvIChrZXkyVGltZSAtIGtleTFUaW1lKTtcblxuICAgICAgICBxdWF0LnNldChBbmltLnNsZXJwUXVhdGVybmlvbi5xMSwgYW5pbXgua2V5c1tpMV0udmFsdWUsIGFuaW15LmtleXNbaTFdLnZhbHVlLCBhbmltei5rZXlzW2kxXS52YWx1ZSwgYW5pbXcua2V5c1tpMV0udmFsdWUpO1xuXG4gICAgICAgIHF1YXQuc2V0KEFuaW0uc2xlcnBRdWF0ZXJuaW9uLnEyLCBhbmlteC5rZXlzW2kyXS52YWx1ZSwgYW5pbXkua2V5c1tpMl0udmFsdWUsIGFuaW16LmtleXNbaTJdLnZhbHVlLCBhbmltdy5rZXlzW2kyXS52YWx1ZSk7XG5cbiAgICAgICAgcXVhdC5zbGVycChxLCBBbmltLnNsZXJwUXVhdGVybmlvbi5xMSwgQW5pbS5zbGVycFF1YXRlcm5pb24ucTIsIHBlcmMpO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbn07XG5cbmNvbnN0IEFOSU0gPSB7IFwiS2V5XCI6IEtleSB9O1xuXG5leHBvcnQgeyBBTklNIH07XG5leHBvcnQgeyBBbmltIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/anim.js\n");

/***/ }),

/***/ "./src/core/anim_key.js":
/*!******************************!*\
  !*** ./src/core/anim_key.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Key\": () => (/* binding */ Key),\n/* harmony export */   \"easeCubicIn\": () => (/* binding */ easeCubicIn),\n/* harmony export */   \"easeCubicInOut\": () => (/* binding */ easeCubicInOut),\n/* harmony export */   \"easeCubicOut\": () => (/* binding */ easeCubicOut),\n/* harmony export */   \"easeExpoIn\": () => (/* binding */ easeExpoIn),\n/* harmony export */   \"easeExpoInOut\": () => (/* binding */ easeExpoInOut),\n/* harmony export */   \"easeExpoOut\": () => (/* binding */ easeExpoOut)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n\n\nconst Key = function (obj)\n{\n    this.time = 0.0;\n    this.value = 0.0;\n    // this.ui = null;\n    this.onChange = null;\n    this._easing = 0;\n    // this.bezTangIn = 0;\n    // this.bezTangOut = 0;\n    // this.bezTime = 0.5;\n    // this.bezValue = 0;\n    // this.bezTimeIn = -0.5;\n    // this.bezValueIn = 0;\n\n    this.cb = null;\n    this.cbTriggered = false;\n\n    // const bezierAnim = null;\n    // this._updateBezier = false;\n\n    this.setEasing(_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_LINEAR);\n    this.set(obj);\n};\n\nKey.cubicSpline = function (perc, key1, key2)\n{\n    let\n        previousPoint = key1.value,\n        previousTangent = key1.bezTangOut,\n        nextPoint = key2.value,\n        nextTangent = key2.bezTangIn;\n    let t = perc;\n    let t2 = t * t;\n    let t3 = t2 * t;\n\n    return (2 * t3 - 3 * t2 + 1) * previousPoint + (t3 - 2 * t2 + t) * previousTangent + (-2 * t3 + 3 * t2) * nextPoint + (t3 - t2) * nextTangent;\n};\n\nKey.easeCubicSpline = function (perc, key2)\n{\n    return Key.cubicSpline(perc, this, key2);\n};\n\n\nKey.linear = function (perc, key1, key2)\n{\n    return parseFloat(key1.value) + parseFloat(key2.value - key1.value) * perc;\n};\n\nKey.easeLinear = function (perc, key2)\n{\n    return Key.linear(perc, this, key2);\n};\n\nKey.easeAbsolute = function (perc, key2)\n{\n    return this.value;\n};\n\nconst easeExpoIn = function (t)\n{\n    return (t = 2 ** (10 * (t - 1)));\n};\n\nKey.easeExpoIn = function (t, key2)\n{\n    t = easeExpoIn(t);\n    return Key.linear(t, this, key2);\n};\n\nconst easeExpoOut = function (t)\n{\n    t = -(2 ** (-10 * t)) + 1;\n    return t;\n};\n\nKey.easeExpoOut = function (t, key2)\n{\n    t = easeExpoOut(t);\n    return Key.linear(t, this, key2);\n};\n\nconst easeExpoInOut = function (t)\n{\n    t *= 2;\n    if (t < 1)\n    {\n        t = 0.5 * 2 ** (10 * (t - 1));\n    }\n    else\n    {\n        t--;\n        t = 0.5 * (-(2 ** (-10 * t)) + 2);\n    }\n    return t;\n};\n\nKey.easeExpoInOut = function (t, key2)\n{\n    t = easeExpoInOut(t);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSinIn = function (t, key2)\n{\n    t = -1 * Math.cos((t * Math.PI) / 2) + 1;\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSinOut = function (t, key2)\n{\n    t = Math.sin((t * Math.PI) / 2);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSinInOut = function (t, key2)\n{\n    t = -0.5 * (Math.cos(Math.PI * t) - 1.0);\n    return Key.linear(t, this, key2);\n};\n\nconst easeCubicIn = function (t)\n{\n    t = t * t * t;\n    return t;\n};\n\nKey.easeCubicIn = function (t, key2)\n{\n    t = easeCubicIn(t);\n    return Key.linear(t, this, key2);\n};\n\n\n// b 0\n// c 1/2 or 1\n// d always 1\n// easeOutCubic: function (x, t, b, c, d) {\n//     return c*((t=t/d-1)*t*t + 1) + b;\n\nKey.easeInQuint = function (t, key2)\n{\n    t = t * t * t * t * t;\n    return Key.linear(t, this, key2);\n};\nKey.easeOutQuint = function (t, key2)\n{\n    t = (t -= 1) * t * t * t * t + 1;\n    return Key.linear(t, this, key2);\n};\nKey.easeInOutQuint = function (t, key2)\n{\n    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t * t;\n    else t = 0.5 * ((t -= 2) * t * t * t * t + 2);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInQuart = function (t, key2)\n{\n    t = t * t * t * t;\n    return Key.linear(t, this, key2);\n};\n\nKey.easeOutQuart = function (t, key2)\n{\n    // return -c * ((t=t/d-1)*t*t*t - 1) + b;\n    t = -1 * ((t -= 1) * t * t * t - 1);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInOutQuart = function (t, key2)\n{\n    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t;\n    else t = -0.5 * ((t -= 2) * t * t * t - 2);\n    return Key.linear(t, this, key2);\n};\n\nKey.bounce = function (t)\n{\n    if ((t /= 1) < 1 / 2.75) t = 7.5625 * t * t;\n    else if (t < 2 / 2.75) t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n    else if (t < 2.5 / 2.75) t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n    else t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n    return t;\n};\n\nKey.easeInBounce = function (t, key2)\n{\n    return Key.linear(Key.bounce(t), this, key2);\n    // return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d);\n};\n\nKey.easeOutBounce = function (t, key2)\n{\n    return Key.linear(Key.bounce(t), this, key2);\n};\n\nKey.easeInElastic = function (t, key2)\n{\n    let s = 1.70158;\n    let p = 0;\n    let a = 1;\n\n    const b = 0;\n    const d = 1;\n    const c = 1;\n\n    if (t === 0) t = b;\n    else if ((t /= d) == 1) t = b + c;\n    else\n    {\n        if (!p) p = d * 0.3;\n        if (a < Math.abs(c))\n        {\n            a = c;\n            s = p / 4;\n        }\n        else s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        t = -(a * 2 ** (10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;\n    }\n\n    return Key.linear(t, this, key2);\n};\n\n\nKey.easeOutElastic = function (t, key2)\n{\n    let s = 1.70158;\n    let p = 0;\n    let a = 1;\n\n    const b = 0;\n    const d = 1;\n    const c = 1;\n\n    if (t === 0) t = b;\n    else if ((t /= d) == 1) t = b + c;\n    else\n    {\n        if (!p) p = d * 0.3;\n        if (a < Math.abs(c))\n        {\n            a = c;\n            s = p / 4;\n        }\n        else s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        t = a * 2 ** (-10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;\n    }\n\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInBack = function (t, key2)\n{\n    const s = 1.70158;\n    t = t * t * ((s + 1) * t - s);\n\n    return Key.linear(t, this, key2);\n};\n\nKey.easeOutBack = function (t, key2)\n{\n    const s = 1.70158;\n    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;\n\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInOutBack = function (t, key2)\n{\n    let s = 1.70158;\n    const c = 1 / 2;\n    if ((t /= 1 / 2) < 1) t = c * (t * t * (((s *= 1.525) + 1) * t - s));\n    else t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n\n    return Key.linear(t, this, key2);\n};\n\nconst easeCubicOut = function (t)\n{\n    t--;\n    t = t * t * t + 1;\n    return t;\n};\n\nKey.easeCubicOut = function (t, key2)\n{\n    t = easeCubicOut(t);\n    return Key.linear(t, this, key2);\n};\n\nconst easeCubicInOut = function (t)\n{\n    t *= 2;\n    if (t < 1) t = 0.5 * t * t * t;\n    else\n    {\n        t -= 2;\n        t = 0.5 * (t * t * t + 2);\n    }\n    return t;\n};\n\nKey.easeCubicInOut = function (t, key2)\n{\n    t = easeCubicInOut(t);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSmoothStep = function (perc, key2)\n{\n    // var x = Math.max(0, Math.min(1, (perc-0)/(1-0)));\n    const x = Math.max(0, Math.min(1, perc));\n    perc = x * x * (3 - 2 * x); // smoothstep\n    return Key.linear(perc, this, key2);\n};\n\nKey.easeSmootherStep = function (perc, key2)\n{\n    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));\n    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep\n    return Key.linear(perc, this, key2);\n};\n\nKey.prototype.setEasing = function (e)\n{\n    this._easing = e;\n\n    if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_LINEAR) this.ease = Key.easeLinear;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ABSOLUTE) this.ease = Key.easeAbsolute;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SMOOTHSTEP) this.ease = Key.easeSmoothStep;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SMOOTHERSTEP) this.ease = Key.easeSmootherStep;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBIC_IN) this.ease = Key.easeCubicIn;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBIC_OUT) this.ease = Key.easeCubicOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBIC_INOUT) this.ease = Key.easeCubicInOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_EXPO_IN) this.ease = Key.easeExpoIn;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_EXPO_OUT) this.ease = Key.easeExpoOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_EXPO_INOUT) this.ease = Key.easeExpoInOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SIN_IN) this.ease = Key.easeSinIn;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SIN_OUT) this.ease = Key.easeSinOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SIN_INOUT) this.ease = Key.easeSinInOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BACK_OUT) this.ease = Key.easeOutBack;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BACK_IN) this.ease = Key.easeInBack;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BACK_INOUT) this.ease = Key.easeInOutBack;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ELASTIC_IN) this.ease = Key.easeInElastic;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ELASTIC_OUT) this.ease = Key.easeOutElastic;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ELASTIC_INOUT) this.ease = Key.easeElasticInOut;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BOUNCE_IN) this.ease = Key.easeInBounce;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BOUNCE_OUT) this.ease = Key.easeOutBounce;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUART_OUT) this.ease = Key.easeOutQuart;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUART_IN) this.ease = Key.easeInQuart;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUART_INOUT) this.ease = Key.easeInOutQuart;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUINT_OUT) this.ease = Key.easeOutQuint;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUINT_IN) this.ease = Key.easeInQuint;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUINT_INOUT) this.ease = Key.easeInOutQuint;\n    else if (this._easing == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBICSPLINE)\n    {\n        // this._updateBezier = true;\n        this.ease = Key.easeCubicSpline;\n    }\n    else\n    {\n        this._easing = _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_LINEAR;\n        this.ease = Key.easeLinear;\n    }\n};\n\nKey.prototype.trigger = function ()\n{\n    this.cb();\n    this.cbTriggered = true;\n};\n\nKey.prototype.setValue = function (v)\n{\n    this.value = v;\n    // this._updateBezier = true;\n    if (this.onChange !== null) this.onChange();\n};\n\nKey.prototype.set = function (obj)\n{\n    if (obj)\n    {\n        if (obj.e) this.setEasing(obj.e);\n        if (obj.cb)\n        {\n            this.cb = obj.cb;\n            this.cbTriggered = false;\n        }\n\n        if (obj.b)\n        {\n            // this.bezTime = obj.b[0];\n            // this.bezValue = obj.b[1];\n            // this.bezTimeIn = obj.b[2];\n            // this.bezValueIn = obj.b[3];\n            // this._updateBezier = true;\n        }\n\n        if (obj.hasOwnProperty(\"t\")) this.time = obj.t;\n        if (obj.hasOwnProperty(\"time\")) this.time = obj.time;\n        if (obj.hasOwnProperty(\"v\")) this.value = obj.v;\n        else if (obj.hasOwnProperty(\"value\")) this.value = obj.value;\n    }\n    if (this.onChange !== null) this.onChange();\n};\n\nKey.prototype.getSerialized = function ()\n{\n    const obj = {};\n    obj.t = this.time;\n    obj.v = this.value;\n    obj.e = this._easing;\n    // if (this._easing == CONSTANTS.ANIM.EASING_CUBICSPLINE) obj.b = [this.bezTime, this.bezValue, this.bezTimeIn, this.bezValueIn];\n\n    return obj;\n};\n\nKey.prototype.getEasing = function ()\n{\n    return this._easing;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9hbmltX2tleS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvYW5pbV9rZXkuanM/MWQyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgS2V5ID0gZnVuY3Rpb24gKG9iailcbntcbiAgICB0aGlzLnRpbWUgPSAwLjA7XG4gICAgdGhpcy52YWx1ZSA9IDAuMDtcbiAgICAvLyB0aGlzLnVpID0gbnVsbDtcbiAgICB0aGlzLm9uQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9lYXNpbmcgPSAwO1xuICAgIC8vIHRoaXMuYmV6VGFuZ0luID0gMDtcbiAgICAvLyB0aGlzLmJlelRhbmdPdXQgPSAwO1xuICAgIC8vIHRoaXMuYmV6VGltZSA9IDAuNTtcbiAgICAvLyB0aGlzLmJlelZhbHVlID0gMDtcbiAgICAvLyB0aGlzLmJlelRpbWVJbiA9IC0wLjU7XG4gICAgLy8gdGhpcy5iZXpWYWx1ZUluID0gMDtcblxuICAgIHRoaXMuY2IgPSBudWxsO1xuICAgIHRoaXMuY2JUcmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIC8vIGNvbnN0IGJlemllckFuaW0gPSBudWxsO1xuICAgIC8vIHRoaXMuX3VwZGF0ZUJlemllciA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRFYXNpbmcoQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0xJTkVBUik7XG4gICAgdGhpcy5zZXQob2JqKTtcbn07XG5cbktleS5jdWJpY1NwbGluZSA9IGZ1bmN0aW9uIChwZXJjLCBrZXkxLCBrZXkyKVxue1xuICAgIGxldFxuICAgICAgICBwcmV2aW91c1BvaW50ID0ga2V5MS52YWx1ZSxcbiAgICAgICAgcHJldmlvdXNUYW5nZW50ID0ga2V5MS5iZXpUYW5nT3V0LFxuICAgICAgICBuZXh0UG9pbnQgPSBrZXkyLnZhbHVlLFxuICAgICAgICBuZXh0VGFuZ2VudCA9IGtleTIuYmV6VGFuZ0luO1xuICAgIGxldCB0ID0gcGVyYztcbiAgICBsZXQgdDIgPSB0ICogdDtcbiAgICBsZXQgdDMgPSB0MiAqIHQ7XG5cbiAgICByZXR1cm4gKDIgKiB0MyAtIDMgKiB0MiArIDEpICogcHJldmlvdXNQb2ludCArICh0MyAtIDIgKiB0MiArIHQpICogcHJldmlvdXNUYW5nZW50ICsgKC0yICogdDMgKyAzICogdDIpICogbmV4dFBvaW50ICsgKHQzIC0gdDIpICogbmV4dFRhbmdlbnQ7XG59O1xuXG5LZXkuZWFzZUN1YmljU3BsaW5lID0gZnVuY3Rpb24gKHBlcmMsIGtleTIpXG57XG4gICAgcmV0dXJuIEtleS5jdWJpY1NwbGluZShwZXJjLCB0aGlzLCBrZXkyKTtcbn07XG5cblxuS2V5LmxpbmVhciA9IGZ1bmN0aW9uIChwZXJjLCBrZXkxLCBrZXkyKVxue1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGtleTEudmFsdWUpICsgcGFyc2VGbG9hdChrZXkyLnZhbHVlIC0ga2V5MS52YWx1ZSkgKiBwZXJjO1xufTtcblxuS2V5LmVhc2VMaW5lYXIgPSBmdW5jdGlvbiAocGVyYywga2V5MilcbntcbiAgICByZXR1cm4gS2V5LmxpbmVhcihwZXJjLCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlQWJzb2x1dGUgPSBmdW5jdGlvbiAocGVyYywga2V5MilcbntcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlRXhwb0luID0gZnVuY3Rpb24gKHQpXG57XG4gICAgcmV0dXJuICh0ID0gMiAqKiAoMTAgKiAodCAtIDEpKSk7XG59O1xuXG5LZXkuZWFzZUV4cG9JbiA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlRXhwb0luKHQpO1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVhc2VFeHBvT3V0ID0gZnVuY3Rpb24gKHQpXG57XG4gICAgdCA9IC0oMiAqKiAoLTEwICogdCkpICsgMTtcbiAgICByZXR1cm4gdDtcbn07XG5cbktleS5lYXNlRXhwb091dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlRXhwb091dCh0KTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlRXhwb0luT3V0ID0gZnVuY3Rpb24gKHQpXG57XG4gICAgdCAqPSAyO1xuICAgIGlmICh0IDwgMSlcbiAgICB7XG4gICAgICAgIHQgPSAwLjUgKiAyICoqICgxMCAqICh0IC0gMSkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0LS07XG4gICAgICAgIHQgPSAwLjUgKiAoLSgyICoqICgtMTAgKiB0KSkgKyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUV4cG9Jbk91dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlRXhwb0luT3V0KHQpO1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuS2V5LmVhc2VTaW5JbiA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSAtMSAqIE1hdGguY29zKCh0ICogTWF0aC5QSSkgLyAyKSArIDE7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZVNpbk91dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZVNpbkluT3V0ID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgdCA9IC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMS4wKTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlQ3ViaWNJbiA9IGZ1bmN0aW9uICh0KVxue1xuICAgIHQgPSB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUN1YmljSW4gPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICB0ID0gZWFzZUN1YmljSW4odCk7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5cbi8vIGIgMFxuLy8gYyAxLzIgb3IgMVxuLy8gZCBhbHdheXMgMVxuLy8gZWFzZU91dEN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuLy8gICAgIHJldHVybiBjKigodD10L2QtMSkqdCp0ICsgMSkgKyBiO1xuXG5LZXkuZWFzZUluUXVpbnQgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICB0ID0gdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuS2V5LmVhc2VPdXRRdWludCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxO1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcbktleS5lYXNlSW5PdXRRdWludCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkgdCA9IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIGVsc2UgdCA9IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlSW5RdWFydCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSB0ICogdCAqIHQgKiB0O1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuS2V5LmVhc2VPdXRRdWFydCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIC8vIHJldHVybiAtYyAqICgodD10L2QtMSkqdCp0KnQgLSAxKSArIGI7XG4gICAgdCA9IC0xICogKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSk7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZUluT3V0UXVhcnQgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHQgPSAwLjUgKiB0ICogdCAqIHQgKiB0O1xuICAgIGVsc2UgdCA9IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5ib3VuY2UgPSBmdW5jdGlvbiAodClcbntcbiAgICBpZiAoKHQgLz0gMSkgPCAxIC8gMi43NSkgdCA9IDcuNTYyNSAqIHQgKiB0O1xuICAgIGVsc2UgaWYgKHQgPCAyIC8gMi43NSkgdCA9IDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIDAuNzU7XG4gICAgZWxzZSBpZiAodCA8IDIuNSAvIDIuNzUpIHQgPSA3LjU2MjUgKiAodCAtPSAyLjI1IC8gMi43NSkgKiB0ICsgMC45Mzc1O1xuICAgIGVsc2UgdCA9IDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0ICsgMC45ODQzNzU7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUluQm91bmNlID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgcmV0dXJuIEtleS5saW5lYXIoS2V5LmJvdW5jZSh0KSwgdGhpcywga2V5Mik7XG4gICAgLy8gcmV0dXJuIGMgLSBqUXVlcnkuZWFzaW5nLmVhc2VPdXRCb3VuY2UgKHgsIGQtdCwgMCwgYywgZCk7XG59O1xuXG5LZXkuZWFzZU91dEJvdW5jZSA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHJldHVybiBLZXkubGluZWFyKEtleS5ib3VuY2UodCksIHRoaXMsIGtleTIpO1xufTtcblxuS2V5LmVhc2VJbkVsYXN0aWMgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgbGV0IHAgPSAwO1xuICAgIGxldCBhID0gMTtcblxuICAgIGNvbnN0IGIgPSAwO1xuICAgIGNvbnN0IGQgPSAxO1xuICAgIGNvbnN0IGMgPSAxO1xuXG4gICAgaWYgKHQgPT09IDApIHQgPSBiO1xuICAgIGVsc2UgaWYgKCh0IC89IGQpID09IDEpIHQgPSBiICsgYztcbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoIXApIHAgPSBkICogMC4zO1xuICAgICAgICBpZiAoYSA8IE1hdGguYWJzKGMpKVxuICAgICAgICB7XG4gICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgPSAocCAvICgyICogTWF0aC5QSSkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgdCA9IC0oYSAqIDIgKiogKDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSkgKyBiO1xuICAgIH1cblxuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuXG5LZXkuZWFzZU91dEVsYXN0aWMgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgbGV0IHAgPSAwO1xuICAgIGxldCBhID0gMTtcblxuICAgIGNvbnN0IGIgPSAwO1xuICAgIGNvbnN0IGQgPSAxO1xuICAgIGNvbnN0IGMgPSAxO1xuXG4gICAgaWYgKHQgPT09IDApIHQgPSBiO1xuICAgIGVsc2UgaWYgKCh0IC89IGQpID09IDEpIHQgPSBiICsgYztcbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoIXApIHAgPSBkICogMC4zO1xuICAgICAgICBpZiAoYSA8IE1hdGguYWJzKGMpKVxuICAgICAgICB7XG4gICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgPSAocCAvICgyICogTWF0aC5QSSkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgdCA9IGEgKiAyICoqICgtMTAgKiB0KSAqIE1hdGguc2luKCgodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkgKyBjICsgYjtcbiAgICB9XG5cbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlSW5CYWNrID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgdCA9IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlT3V0QmFjayA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHQgPSAodCA9IHQgLyAxIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuXG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZUluT3V0QmFjayA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBjb25zdCBjID0gMSAvIDI7XG4gICAgaWYgKCh0IC89IDEgLyAyKSA8IDEpIHQgPSBjICogKHQgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgZWxzZSB0ID0gYyAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCArIHMpICsgMik7XG5cbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlQ3ViaWNPdXQgPSBmdW5jdGlvbiAodClcbntcbiAgICB0LS07XG4gICAgdCA9IHQgKiB0ICogdCArIDE7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUN1YmljT3V0ID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgdCA9IGVhc2VDdWJpY091dCh0KTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0KVxue1xuICAgIHQgKj0gMjtcbiAgICBpZiAodCA8IDEpIHQgPSAwLjUgKiB0ICogdCAqIHQ7XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdCAtPSAyO1xuICAgICAgICB0ID0gMC41ICogKHQgKiB0ICogdCArIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5cbktleS5lYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlQ3ViaWNJbk91dCh0KTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlU21vb3RoU3RlcCA9IGZ1bmN0aW9uIChwZXJjLCBrZXkyKVxue1xuICAgIC8vIHZhciB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBlcmMtMCkvKDEtMCkpKTtcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGVyYykpO1xuICAgIHBlcmMgPSB4ICogeCAqICgzIC0gMiAqIHgpOyAvLyBzbW9vdGhzdGVwXG4gICAgcmV0dXJuIEtleS5saW5lYXIocGVyYywgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZVNtb290aGVyU3RlcCA9IGZ1bmN0aW9uIChwZXJjLCBrZXkyKVxue1xuICAgIGNvbnN0IHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGVyYyAtIDApIC8gKDEgLSAwKSkpO1xuICAgIHBlcmMgPSB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTsgLy8gc21vb3RoZXJzdGVwXG4gICAgcmV0dXJuIEtleS5saW5lYXIocGVyYywgdGhpcywga2V5Mik7XG59O1xuXG5LZXkucHJvdG90eXBlLnNldEVhc2luZyA9IGZ1bmN0aW9uIChlKVxue1xuICAgIHRoaXMuX2Vhc2luZyA9IGU7XG5cbiAgICBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19MSU5FQVIpIHRoaXMuZWFzZSA9IEtleS5lYXNlTGluZWFyO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQUJTT0xVVEUpIHRoaXMuZWFzZSA9IEtleS5lYXNlQWJzb2x1dGU7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhTVEVQKSB0aGlzLmVhc2UgPSBLZXkuZWFzZVNtb290aFN0ZXA7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhFUlNURVApIHRoaXMuZWFzZSA9IEtleS5lYXNlU21vb3RoZXJTdGVwO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNfSU4pIHRoaXMuZWFzZSA9IEtleS5lYXNlQ3ViaWNJbjtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDX09VVCkgdGhpcy5lYXNlID0gS2V5LmVhc2VDdWJpY091dDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUN1YmljSW5PdXQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUV4cG9JbjtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0VYUE9fT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUV4cG9PdXQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUV4cG9Jbk91dDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9JTikgdGhpcy5lYXNlID0gS2V5LmVhc2VTaW5JbjtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlU2luT3V0O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfU0lOX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZVNpbkluT3V0O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlT3V0QmFjaztcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JBQ0tfSU4pIHRoaXMuZWFzZSA9IEtleS5lYXNlSW5CYWNrO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19JTk9VVCkgdGhpcy5lYXNlID0gS2V5LmVhc2VJbk91dEJhY2s7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX0lOKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUluRWxhc3RpYztcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0VMQVNUSUNfT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZU91dEVsYXN0aWM7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUVsYXN0aWNJbk91dDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JPVU5DRV9JTikgdGhpcy5lYXNlID0gS2V5LmVhc2VJbkJvdW5jZTtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JPVU5DRV9PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlT3V0Qm91bmNlO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZU91dFF1YXJ0O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfSU4pIHRoaXMuZWFzZSA9IEtleS5lYXNlSW5RdWFydDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUluT3V0UXVhcnQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlT3V0UXVpbnQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9JTikgdGhpcy5lYXNlID0gS2V5LmVhc2VJblF1aW50O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVJTlRfSU5PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlSW5PdXRRdWludDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDU1BMSU5FKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5fdXBkYXRlQmV6aWVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lYXNlID0gS2V5LmVhc2VDdWJpY1NwbGluZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fZWFzaW5nID0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0xJTkVBUjtcbiAgICAgICAgdGhpcy5lYXNlID0gS2V5LmVhc2VMaW5lYXI7XG4gICAgfVxufTtcblxuS2V5LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmNiKCk7XG4gICAgdGhpcy5jYlRyaWdnZXJlZCA9IHRydWU7XG59O1xuXG5LZXkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdGhpcy52YWx1ZSA9IHY7XG4gICAgLy8gdGhpcy5fdXBkYXRlQmV6aWVyID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xufTtcblxuS2V5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqKVxue1xuICAgIGlmIChvYmopXG4gICAge1xuICAgICAgICBpZiAob2JqLmUpIHRoaXMuc2V0RWFzaW5nKG9iai5lKTtcbiAgICAgICAgaWYgKG9iai5jYilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYiA9IG9iai5jYjtcbiAgICAgICAgICAgIHRoaXMuY2JUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouYilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcy5iZXpUaW1lID0gb2JqLmJbMF07XG4gICAgICAgICAgICAvLyB0aGlzLmJlelZhbHVlID0gb2JqLmJbMV07XG4gICAgICAgICAgICAvLyB0aGlzLmJlelRpbWVJbiA9IG9iai5iWzJdO1xuICAgICAgICAgICAgLy8gdGhpcy5iZXpWYWx1ZUluID0gb2JqLmJbM107XG4gICAgICAgICAgICAvLyB0aGlzLl91cGRhdGVCZXppZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcInRcIikpIHRoaXMudGltZSA9IG9iai50O1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KFwidGltZVwiKSkgdGhpcy50aW1lID0gb2JqLnRpbWU7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoXCJ2XCIpKSB0aGlzLnZhbHVlID0gb2JqLnY7XG4gICAgICAgIGVsc2UgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB0aGlzLnZhbHVlID0gb2JqLnZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xufTtcblxuS2V5LnByb3RvdHlwZS5nZXRTZXJpYWxpemVkID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBvYmoudCA9IHRoaXMudGltZTtcbiAgICBvYmoudiA9IHRoaXMudmFsdWU7XG4gICAgb2JqLmUgPSB0aGlzLl9lYXNpbmc7XG4gICAgLy8gaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNTUExJTkUpIG9iai5iID0gW3RoaXMuYmV6VGltZSwgdGhpcy5iZXpWYWx1ZSwgdGhpcy5iZXpUaW1lSW4sIHRoaXMuYmV6VmFsdWVJbl07XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuS2V5LnByb3RvdHlwZS5nZXRFYXNpbmcgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9lYXNpbmc7XG59O1xuXG5leHBvcnQgeyBLZXkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/anim_key.js\n");

/***/ }),

/***/ "./src/core/banchprofiler.js":
/*!***********************************!*\
  !*** ./src/core/banchprofiler.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Branch\": () => (/* binding */ Branch),\n/* harmony export */   \"BranchStack\": () => (/* binding */ BranchStack)\n/* harmony export */ });\nclass Branch\n{\n    constructor(name)\n    {\n        this.name = name;\n        this.dur = 0;\n        this._startTime = 0;\n        this.childs = [];\n    }\n\n    start()\n    {\n        this._startTime = performance.now();\n    }\n\n    end()\n    {\n        this.dur = performance.now() - this._startTime;\n    }\n\n    push(name)\n    {\n        const b = new Branch(name);\n        this.childs.push(b);\n        b.start();\n        return b;\n    }\n\n    print(level)\n    {\n        level = level || 0;\n\n        let str = \"\";\n        for (let i = 0; i < level; i++) str += \"  \";\n\n        for (let i = 0; i < this.childs.length; i++)\n        {\n            this.childs[i].print(level + 1);\n        }\n    }\n}\n\n// //////////////////////////////////////////\n\nclass BranchStack\n{\n    constructor()\n    {\n    }\n\n    start()\n    {\n        this.root = new Branch(\"Root\");\n        this.root.start();\n\n        this.current = this.root;\n    }\n\n    push(name)\n    {\n        if (!this.current) this.start();\n\n        const prev = this.current;\n        this.current = this.current.push(name);\n        this.current.prev = prev;\n        this.current.start();\n        return this.current;\n    }\n\n    pop()\n    {\n        if (!this.current) return;\n        this.current.end();\n        this.current = this.current.prev;\n    }\n\n    finish()\n    {\n        this.current.end();\n        this.root.print();\n        this.current = null;\n    }\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9iYW5jaHByb2ZpbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2JhbmNocHJvZmlsZXIuanM/ODgzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBCcmFuY2hcbntcbiAgICBjb25zdHJ1Y3RvcihuYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kdXIgPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmNoaWxkcyA9IFtdO1xuICAgIH1cblxuICAgIHN0YXJ0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIGVuZCgpXG4gICAge1xuICAgICAgICB0aGlzLmR1ciA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fc3RhcnRUaW1lO1xuICAgIH1cblxuICAgIHB1c2gobmFtZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGIgPSBuZXcgQnJhbmNoKG5hbWUpO1xuICAgICAgICB0aGlzLmNoaWxkcy5wdXNoKGIpO1xuICAgICAgICBiLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIHByaW50KGxldmVsKVxuICAgIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuXG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsOyBpKyspIHN0ciArPSBcIiAgXCI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHNbaV0ucHJpbnQobGV2ZWwgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmNsYXNzIEJyYW5jaFN0YWNrXG57XG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICB9XG5cbiAgICBzdGFydCgpXG4gICAge1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgQnJhbmNoKFwiUm9vdFwiKTtcbiAgICAgICAgdGhpcy5yb290LnN0YXJ0KCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgIH1cblxuICAgIHB1c2gobmFtZSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50KSB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnB1c2gobmFtZSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5jdXJyZW50LnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgcG9wKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIHRoaXMuY3VycmVudC5lbmQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnByZXY7XG4gICAgfVxuXG4gICAgZmluaXNoKClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudC5lbmQoKTtcbiAgICAgICAgdGhpcy5yb290LnByaW50KCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCcmFuY2hTdGFjayB9O1xuZXhwb3J0IHsgQnJhbmNoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/banchprofiler.js\n");

/***/ }),

/***/ "./src/core/base64.js":
/*!****************************!*\
  !*** ./src/core/base64.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"b64decTypedArray\": () => (/* binding */ b64decTypedArray),\n/* harmony export */   \"b64encTypesArray\": () => (/* binding */ b64encTypesArray),\n/* harmony export */   \"base64Chars\": () => (/* binding */ base64Chars),\n/* harmony export */   \"base64lookup\": () => (/* binding */ base64lookup)\n/* harmony export */ });\nconst base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n// Use a lookup table to find the index.\nconst _base64lookup = new Uint8Array(256);\nfor (let i = 0; i < base64Chars.length; i++) _base64lookup[base64Chars.charCodeAt(i)] = i;\n\nconst base64lookup = _base64lookup;\n\nconst b64encTypesArray = function (arraybuffer)\n{\n    if (arraybuffer.buffer) arraybuffer = arraybuffer.buffer;\n    let bytes = new Uint8Array(arraybuffer),\n        i,\n        len = bytes.length,\n        base64 = \"\";\n\n    for (i = 0; i < len; i += 3)\n    {\n        base64 += base64Chars[bytes[i] >> 2];\n        base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += base64Chars[bytes[i + 2] & 63];\n    }\n\n    if (len % 3 === 2) base64 = base64.substring(0, base64.length - 1) + \"=\";\n    else if (len % 3 === 1) base64 = base64.substring(0, base64.length - 2) + \"==\";\n\n    return base64;\n};\n\nconst b64decTypedArray = function (base64)\n{\n    let bufferLength = base64.length * 0.75,\n        len = base64.length,\n        i,\n        p = 0,\n        encoded1,\n        encoded2,\n        encoded3,\n        encoded4;\n\n    if (base64[base64.length - 1] === \"=\")\n    {\n        bufferLength--;\n        if (base64[base64.length - 2] === \"=\") bufferLength--;\n    }\n\n    let arraybuffer = new ArrayBuffer(bufferLength),\n        bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i += 4)\n    {\n        encoded1 = base64lookup[base64.charCodeAt(i)];\n        encoded2 = base64lookup[base64.charCodeAt(i + 1)];\n        encoded3 = base64lookup[base64.charCodeAt(i + 2)];\n        encoded4 = base64lookup[base64.charCodeAt(i + 3)];\n\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9iYXNlNjQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvYmFzZTY0LmpzPzlkNTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGJhc2U2NENoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbi8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbmNvbnN0IF9iYXNlNjRsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlNjRDaGFycy5sZW5ndGg7IGkrKykgX2Jhc2U2NGxvb2t1cFtiYXNlNjRDaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG5cbmV4cG9ydCBjb25zdCBiYXNlNjRsb29rdXAgPSBfYmFzZTY0bG9va3VwO1xuXG5leHBvcnQgY29uc3QgYjY0ZW5jVHlwZXNBcnJheSA9IGZ1bmN0aW9uIChhcnJheWJ1ZmZlcilcbntcbiAgICBpZiAoYXJyYXlidWZmZXIuYnVmZmVyKSBhcnJheWJ1ZmZlciA9IGFycmF5YnVmZmVyLmJ1ZmZlcjtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgICAgIGksXG4gICAgICAgIGxlbiA9IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMylcbiAgICB7XG4gICAgICAgIGJhc2U2NCArPSBiYXNlNjRDaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgICBiYXNlNjQgKz0gYmFzZTY0Q2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAobGVuICUgMyA9PT0gMikgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcblxuICAgIHJldHVybiBiYXNlNjQ7XG59O1xuXG5leHBvcnQgY29uc3QgYjY0ZGVjVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChiYXNlNjQpXG57XG4gICAgbGV0IGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgICAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLFxuICAgICAgICBpLFxuICAgICAgICBwID0gMCxcbiAgICAgICAgZW5jb2RlZDEsXG4gICAgICAgIGVuY29kZWQyLFxuICAgICAgICBlbmNvZGVkMyxcbiAgICAgICAgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpXG4gICAge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSBidWZmZXJMZW5ndGgtLTtcbiAgICB9XG5cbiAgICBsZXQgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpXG4gICAge1xuICAgICAgICBlbmNvZGVkMSA9IGJhc2U2NGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGVuY29kZWQyID0gYmFzZTY0bG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgIGVuY29kZWQzID0gYmFzZTY0bG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgIGVuY29kZWQ0ID0gYmFzZTY0bG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG5cbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/base64.js\n");

/***/ }),

/***/ "./src/core/cg/cg_boundingbox.js":
/*!***************************************!*\
  !*** ./src/core/cg/cg_boundingbox.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BoundingBox\": () => (/* binding */ BoundingBox)\n/* harmony export */ });\n\n\n/**\n * bounding box\n * @class\n * @external CGL\n * @namespace BoundingBox\n * @param {Geometry} geometry or bounding box\n */\nclass BoundingBox\n{\n    constructor(geom)\n    {\n        this._init();\n        this._first = true;\n        this._wireMesh = null;\n\n        if (geom) this.apply(geom);\n    }\n\n    _init()\n    {\n        this._max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];\n        this._min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];\n        this._center = [0, 0, 0];\n        this._size = [0, 0, 0];\n        this._maxAxis = 0.0;\n        this._first = true;\n    }\n\n    /**\n     * get biggest number of maxX,maxY,maxZ\n     * @type {Number}\n     */\n    get maxAxis() { return this._maxAxis || 1; }\n\n    /**\n     * size of bounding box\n     * @type {vec3}\n     */\n    get size() { return this._size; }\n\n    /**\n     * center of bounding box\n     * @type {vec3}\n     */\n    get center() { return this._center; }\n\n    /**\n     * center x\n     * @type {Number}\n     */\n    get x() { return this._center[0]; }\n\n    /**\n     * center y\n     * @type {Number}\n     */\n    get y() { return this._center[1]; }\n\n    /**\n     * center z\n     * @type {Number}\n     */\n    get z() { return this._center[2]; }\n\n\n    /**\n     * minimum x\n     * @type {Number}\n     */\n    get minX() { return this._min[0]; }\n\n    /**\n     * minimum y\n     * @type {Number}\n     */\n    get minY() { return this._min[1]; }\n\n    /**\n     * minimum z\n     * @type {Number}\n     */\n    get minZ() { return this._min[2]; }\n\n    /**\n     * maximum x\n     * @type {Number}\n     */\n    get maxX() { return this._max[0]; }\n\n    /**\n     * maximum y\n     * @type {Number}\n     */\n    get maxY() { return this._max[1]; }\n\n    /**\n     * maximum z\n     * @type {Number}\n     */\n    get maxZ() { return this._max[2]; }\n\n\n    apply(geom, mat)\n    {\n        if (!geom)\n        {\n            // console.warn(\"[boundingbox] no geom/vertices\", geom);\n            return;\n        }\n\n        if (geom instanceof BoundingBox)\n        {\n            const bb = geom;\n\n            this.applyPos(bb.maxX, bb.maxY, bb.maxZ);\n            this.applyPos(bb.minX, bb.minY, bb.minZ);\n        }\n        else\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n                // if (geom.vertices[i] == geom.vertices[i] || geom.vertices[i] != null)\n                // {\n            // if(mat)\n            // {\n                this.applyPos(geom.vertices[i], geom.vertices[i + 1], geom.vertices[i + 2]);\n            // }\n            // else\n            // {\n            //     this.applyPos(geom.vertices[i + 0],geom.vertices[i + 1],geom.vertices[i + 2]);\n            // }\n                // }\n        }\n        this.calcCenterSize();\n    }\n\n    /**\n     * returns a copy of the bounding box\n     * @function copy\n     * @memberof BoundingBox\n     * @instance\n     */\n    copy()\n    {\n        return new BoundingBox(this);\n    }\n\n    get changed()\n    {\n        return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);\n    }\n\n    applyPos(x, y, z)\n    {\n        if (x == Number.MAX_VALUE || x == -Number.MAX_VALUE ||\n            y == Number.MAX_VALUE || y == -Number.MAX_VALUE ||\n            z == Number.MAX_VALUE || z == -Number.MAX_VALUE) return;\n\n        if (!CABLES.UTILS.isNumeric(x) || !CABLES.UTILS.isNumeric(y) || !CABLES.UTILS.isNumeric(z)) return;\n\n        if (this._first)\n        {\n            this._max[0] = x;\n            this._max[1] = y;\n            this._max[2] = z;\n\n            this._min[0] = x;\n            this._min[1] = y;\n            this._min[2] = z;\n            this._first = false;\n            return;\n        }\n\n        this._max[0] = Math.max(this._max[0], x);\n        this._max[1] = Math.max(this._max[1], y);\n        this._max[2] = Math.max(this._max[2], z);\n\n        this._min[0] = Math.min(this._min[0], x);\n        this._min[1] = Math.min(this._min[1], y);\n        this._min[2] = Math.min(this._min[2], z);\n    }\n\n    calcCenterSize()\n    {\n        if (this._first) return;\n        // this._size[0]=Math.abs(this._min[0])+Math.abs(this._max[0]);\n        // this._size[1]=Math.abs(this._min[1])+Math.abs(this._max[1]);\n        // this._size[2]=Math.abs(this._min[2])+Math.abs(this._max[2]);\n        this._size[0] = this._max[0] - this._min[0];\n        this._size[1] = this._max[1] - this._min[1];\n        this._size[2] = this._max[2] - this._min[2];\n\n        this._center[0] = (this._min[0] + this._max[0]) / 2;\n        this._center[1] = (this._min[1] + this._max[1]) / 2;\n        this._center[2] = (this._min[2] + this._max[2]) / 2;\n\n        this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));\n    }\n\n    mulMat4(m)\n    {\n        if (this._first)\n        {\n            this._max[0] = 0;\n            this._max[1] = 0;\n            this._max[2] = 0;\n\n            this._min[0] = 0;\n            this._min[1] = 0;\n            this._min[2] = 0;\n            this._first = false;\n        }\n        vec3.transformMat4(this._max, this._max, m);\n        vec3.transformMat4(this._min, this._min, m);\n        this.calcCenterSize();\n    }\n\n    render(cgl, shader)\n    {\n        if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);\n\n        cgl.pushModelMatrix();\n        mat4.translate(cgl.mMatrix, cgl.mMatrix, this._center);\n        this._wireMesh.render(cgl, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);\n        cgl.popModelMatrix();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19ib3VuZGluZ2JveC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvY2dfYm91bmRpbmdib3guanM/ZDc4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBCb3VuZGluZ0JveCB9O1xuXG4vKipcbiAqIGJvdW5kaW5nIGJveFxuICogQGNsYXNzXG4gKiBAZXh0ZXJuYWwgQ0dMXG4gKiBAbmFtZXNwYWNlIEJvdW5kaW5nQm94XG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBvciBib3VuZGluZyBib3hcbiAqL1xuY2xhc3MgQm91bmRpbmdCb3hcbntcbiAgICBjb25zdHJ1Y3RvcihnZW9tKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB0aGlzLl9maXJzdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3dpcmVNZXNoID0gbnVsbDtcblxuICAgICAgICBpZiAoZ2VvbSkgdGhpcy5hcHBseShnZW9tKTtcbiAgICB9XG5cbiAgICBfaW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLl9tYXggPSBbLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRV07XG4gICAgICAgIHRoaXMuX21pbiA9IFtOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFXTtcbiAgICAgICAgdGhpcy5fY2VudGVyID0gWzAsIDAsIDBdO1xuICAgICAgICB0aGlzLl9zaXplID0gWzAsIDAsIDBdO1xuICAgICAgICB0aGlzLl9tYXhBeGlzID0gMC4wO1xuICAgICAgICB0aGlzLl9maXJzdCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGJpZ2dlc3QgbnVtYmVyIG9mIG1heFgsbWF4WSxtYXhaXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWF4QXhpcygpIHsgcmV0dXJuIHRoaXMuX21heEF4aXMgfHwgMTsgfVxuXG4gICAgLyoqXG4gICAgICogc2l6ZSBvZiBib3VuZGluZyBib3hcbiAgICAgKiBAdHlwZSB7dmVjM31cbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuX3NpemU7IH1cblxuICAgIC8qKlxuICAgICAqIGNlbnRlciBvZiBib3VuZGluZyBib3hcbiAgICAgKiBAdHlwZSB7dmVjM31cbiAgICAgKi9cbiAgICBnZXQgY2VudGVyKCkgeyByZXR1cm4gdGhpcy5fY2VudGVyOyB9XG5cbiAgICAvKipcbiAgICAgKiBjZW50ZXIgeFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLl9jZW50ZXJbMF07IH1cblxuICAgIC8qKlxuICAgICAqIGNlbnRlciB5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuX2NlbnRlclsxXTsgfVxuXG4gICAgLyoqXG4gICAgICogY2VudGVyIHpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB6KCkgeyByZXR1cm4gdGhpcy5fY2VudGVyWzJdOyB9XG5cblxuICAgIC8qKlxuICAgICAqIG1pbmltdW0geFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1pblgoKSB7IHJldHVybiB0aGlzLl9taW5bMF07IH1cblxuICAgIC8qKlxuICAgICAqIG1pbmltdW0geVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1pblkoKSB7IHJldHVybiB0aGlzLl9taW5bMV07IH1cblxuICAgIC8qKlxuICAgICAqIG1pbmltdW0gelxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1pblooKSB7IHJldHVybiB0aGlzLl9taW5bMl07IH1cblxuICAgIC8qKlxuICAgICAqIG1heGltdW0geFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1heFgoKSB7IHJldHVybiB0aGlzLl9tYXhbMF07IH1cblxuICAgIC8qKlxuICAgICAqIG1heGltdW0geVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1heFkoKSB7IHJldHVybiB0aGlzLl9tYXhbMV07IH1cblxuICAgIC8qKlxuICAgICAqIG1heGltdW0gelxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1heFooKSB7IHJldHVybiB0aGlzLl9tYXhbMl07IH1cblxuXG4gICAgYXBwbHkoZ2VvbSwgbWF0KVxuICAgIHtcbiAgICAgICAgaWYgKCFnZW9tKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJbYm91bmRpbmdib3hdIG5vIGdlb20vdmVydGljZXNcIiwgZ2VvbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBiYiA9IGdlb207XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQb3MoYmIubWF4WCwgYmIubWF4WSwgYmIubWF4Wik7XG4gICAgICAgICAgICB0aGlzLmFwcGx5UG9zKGJiLm1pblgsIGJiLm1pblksIGJiLm1pblopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tLnZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgICAgIC8vIGlmIChnZW9tLnZlcnRpY2VzW2ldID09IGdlb20udmVydGljZXNbaV0gfHwgZ2VvbS52ZXJ0aWNlc1tpXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vIGlmKG1hdClcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zKGdlb20udmVydGljZXNbaV0sIGdlb20udmVydGljZXNbaSArIDFdLCBnZW9tLnZlcnRpY2VzW2kgKyAyXSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5hcHBseVBvcyhnZW9tLnZlcnRpY2VzW2kgKyAwXSxnZW9tLnZlcnRpY2VzW2kgKyAxXSxnZW9tLnZlcnRpY2VzW2kgKyAyXSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY0NlbnRlclNpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgY29weSBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICogQGZ1bmN0aW9uIGNvcHlcbiAgICAgKiBAbWVtYmVyb2YgQm91bmRpbmdCb3hcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb3B5KClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0IGNoYW5nZWQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5fbWF4WzBdID09IC1OdW1iZXIuTUFYX1ZBTFVFICYmIHRoaXMuX21heFsxXSA9PSAtTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLl9tYXhbMl0gPT0gLU51bWJlci5NQVhfVkFMVUUpO1xuICAgIH1cblxuICAgIGFwcGx5UG9zKHgsIHksIHopXG4gICAge1xuICAgICAgICBpZiAoeCA9PSBOdW1iZXIuTUFYX1ZBTFVFIHx8IHggPT0gLU51bWJlci5NQVhfVkFMVUUgfHxcbiAgICAgICAgICAgIHkgPT0gTnVtYmVyLk1BWF9WQUxVRSB8fCB5ID09IC1OdW1iZXIuTUFYX1ZBTFVFIHx8XG4gICAgICAgICAgICB6ID09IE51bWJlci5NQVhfVkFMVUUgfHwgeiA9PSAtTnVtYmVyLk1BWF9WQUxVRSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghQ0FCTEVTLlVUSUxTLmlzTnVtZXJpYyh4KSB8fCAhQ0FCTEVTLlVUSUxTLmlzTnVtZXJpYyh5KSB8fCAhQ0FCTEVTLlVUSUxTLmlzTnVtZXJpYyh6KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLl9maXJzdClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbWF4WzBdID0geDtcbiAgICAgICAgICAgIHRoaXMuX21heFsxXSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9tYXhbMl0gPSB6O1xuXG4gICAgICAgICAgICB0aGlzLl9taW5bMF0gPSB4O1xuICAgICAgICAgICAgdGhpcy5fbWluWzFdID0geTtcbiAgICAgICAgICAgIHRoaXMuX21pblsyXSA9IHo7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWF4WzBdID0gTWF0aC5tYXgodGhpcy5fbWF4WzBdLCB4KTtcbiAgICAgICAgdGhpcy5fbWF4WzFdID0gTWF0aC5tYXgodGhpcy5fbWF4WzFdLCB5KTtcbiAgICAgICAgdGhpcy5fbWF4WzJdID0gTWF0aC5tYXgodGhpcy5fbWF4WzJdLCB6KTtcblxuICAgICAgICB0aGlzLl9taW5bMF0gPSBNYXRoLm1pbih0aGlzLl9taW5bMF0sIHgpO1xuICAgICAgICB0aGlzLl9taW5bMV0gPSBNYXRoLm1pbih0aGlzLl9taW5bMV0sIHkpO1xuICAgICAgICB0aGlzLl9taW5bMl0gPSBNYXRoLm1pbih0aGlzLl9taW5bMl0sIHopO1xuICAgIH1cblxuICAgIGNhbGNDZW50ZXJTaXplKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCkgcmV0dXJuO1xuICAgICAgICAvLyB0aGlzLl9zaXplWzBdPU1hdGguYWJzKHRoaXMuX21pblswXSkrTWF0aC5hYnModGhpcy5fbWF4WzBdKTtcbiAgICAgICAgLy8gdGhpcy5fc2l6ZVsxXT1NYXRoLmFicyh0aGlzLl9taW5bMV0pK01hdGguYWJzKHRoaXMuX21heFsxXSk7XG4gICAgICAgIC8vIHRoaXMuX3NpemVbMl09TWF0aC5hYnModGhpcy5fbWluWzJdKStNYXRoLmFicyh0aGlzLl9tYXhbMl0pO1xuICAgICAgICB0aGlzLl9zaXplWzBdID0gdGhpcy5fbWF4WzBdIC0gdGhpcy5fbWluWzBdO1xuICAgICAgICB0aGlzLl9zaXplWzFdID0gdGhpcy5fbWF4WzFdIC0gdGhpcy5fbWluWzFdO1xuICAgICAgICB0aGlzLl9zaXplWzJdID0gdGhpcy5fbWF4WzJdIC0gdGhpcy5fbWluWzJdO1xuXG4gICAgICAgIHRoaXMuX2NlbnRlclswXSA9ICh0aGlzLl9taW5bMF0gKyB0aGlzLl9tYXhbMF0pIC8gMjtcbiAgICAgICAgdGhpcy5fY2VudGVyWzFdID0gKHRoaXMuX21pblsxXSArIHRoaXMuX21heFsxXSkgLyAyO1xuICAgICAgICB0aGlzLl9jZW50ZXJbMl0gPSAodGhpcy5fbWluWzJdICsgdGhpcy5fbWF4WzJdKSAvIDI7XG5cbiAgICAgICAgdGhpcy5fbWF4QXhpcyA9IE1hdGgubWF4KHRoaXMuX3NpemVbMl0sIE1hdGgubWF4KHRoaXMuX3NpemVbMF0sIHRoaXMuX3NpemVbMV0pKTtcbiAgICB9XG5cbiAgICBtdWxNYXQ0KG0pXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZmlyc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX21heFswXSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9tYXhbMV0gPSAwO1xuICAgICAgICAgICAgdGhpcy5fbWF4WzJdID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fbWluWzBdID0gMDtcbiAgICAgICAgICAgIHRoaXMuX21pblsxXSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9taW5bMl0gPSAwO1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy5fbWF4LCB0aGlzLl9tYXgsIG0pO1xuICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy5fbWluLCB0aGlzLl9taW4sIG0pO1xuICAgICAgICB0aGlzLmNhbGNDZW50ZXJTaXplKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGNnbCwgc2hhZGVyKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl93aXJlTWVzaCkgdGhpcy5fd2lyZU1lc2ggPSBuZXcgQ0dMLldpcmVDdWJlKGNnbCk7XG5cbiAgICAgICAgY2dsLnB1c2hNb2RlbE1hdHJpeCgpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShjZ2wubU1hdHJpeCwgY2dsLm1NYXRyaXgsIHRoaXMuX2NlbnRlcik7XG4gICAgICAgIHRoaXMuX3dpcmVNZXNoLnJlbmRlcihjZ2wsIHRoaXMuX3NpemVbMF0gLyAyLCB0aGlzLl9zaXplWzFdIC8gMiwgdGhpcy5fc2l6ZVsyXSAvIDIpO1xuICAgICAgICBjZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/cg_boundingbox.js\n");

/***/ }),

/***/ "./src/core/cg/cg_canvas.js":
/*!**********************************!*\
  !*** ./src/core/cg/cg_canvas.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CgCanvas\": () => (/* binding */ CgCanvas)\n/* harmony export */ });\nclass CgCanvas\n{\n    constructor(options)\n    {\n        if (!options)\n        {\n            console.error(\"CgCanvas no options\");\n        }\n        else\n        {\n            this._canvasEle = options.canvasEle;\n        }\n\n        if (!options.cg)console.error(\"CgCanvas options has no cg\");\n        if (!options.canvasEle)console.error(\"CgCanvas options has no canvasEle\");\n\n        this._cg = options.cg;\n        this.pixelDensity = 1;\n        this.canvasWidth = this.canvasEle.clientWidth;\n        this.canvasHeight = this.canvasEle.clientHeight;\n\n        this._oldWidthRp = -1;\n        this._oldHeightRp = -1;\n\n        this.setSize(this.canvasWidth, this.canvasHeight);\n    }\n\n    get canvasEle() { return this._canvasEle; }\n\n\n    setSize(w, h, ignorestyle)\n    {\n        if (this._oldWidthRp != w * this.pixelDensity || this._oldHeightRp != h * this.pixelDensity)\n        {\n            this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;\n            this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;\n\n            if (!ignorestyle)\n            {\n                this.canvasEle.style.width = w + \"px\";\n                this.canvasEle.style.height = h + \"px\";\n            }\n\n            this.updateSize();\n\n            this._cg.emitEvent(\"resize\");\n        }\n    }\n\n    updateSize()\n    {\n        this.canvasEle.width = this.canvasWidth = this.canvasEle.clientWidth * this.pixelDensity;\n        this.canvasEle.height = this.canvasHeight = this.canvasEle.clientHeight * this.pixelDensity;\n    }\n\n    dispose()\n    {\n        this._canvasEle.remove();\n        this._canvasEle = null;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19jYW52YXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnL2NnX2NhbnZhcy5qcz9jNjkyIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIENnQ2FudmFzXG57XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucylcbiAgICB7XG4gICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNnQ2FudmFzIG5vIG9wdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXNFbGUgPSBvcHRpb25zLmNhbnZhc0VsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5jZyljb25zb2xlLmVycm9yKFwiQ2dDYW52YXMgb3B0aW9ucyBoYXMgbm8gY2dcIik7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYW52YXNFbGUpY29uc29sZS5lcnJvcihcIkNnQ2FudmFzIG9wdGlvbnMgaGFzIG5vIGNhbnZhc0VsZVwiKTtcblxuICAgICAgICB0aGlzLl9jZyA9IG9wdGlvbnMuY2c7XG4gICAgICAgIHRoaXMucGl4ZWxEZW5zaXR5ID0gMTtcbiAgICAgICAgdGhpcy5jYW52YXNXaWR0aCA9IHRoaXMuY2FudmFzRWxlLmNsaWVudFdpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IHRoaXMuY2FudmFzRWxlLmNsaWVudEhlaWdodDtcblxuICAgICAgICB0aGlzLl9vbGRXaWR0aFJwID0gLTE7XG4gICAgICAgIHRoaXMuX29sZEhlaWdodFJwID0gLTE7XG5cbiAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBnZXQgY2FudmFzRWxlKCkgeyByZXR1cm4gdGhpcy5fY2FudmFzRWxlOyB9XG5cblxuICAgIHNldFNpemUodywgaCwgaWdub3Jlc3R5bGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fb2xkV2lkdGhScCAhPSB3ICogdGhpcy5waXhlbERlbnNpdHkgfHwgdGhpcy5fb2xkSGVpZ2h0UnAgIT0gaCAqIHRoaXMucGl4ZWxEZW5zaXR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRXaWR0aFJwID0gdGhpcy5jYW52YXNFbGUud2lkdGggPSB3ICogdGhpcy5waXhlbERlbnNpdHk7XG4gICAgICAgICAgICB0aGlzLl9vbGRIZWlnaHRScCA9IHRoaXMuY2FudmFzRWxlLmhlaWdodCA9IGggKiB0aGlzLnBpeGVsRGVuc2l0eTtcblxuICAgICAgICAgICAgaWYgKCFpZ25vcmVzdHlsZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0VsZS5zdHlsZS53aWR0aCA9IHcgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNFbGUuc3R5bGUuaGVpZ2h0ID0gaCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NnLmVtaXRFdmVudChcInJlc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVNpemUoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jYW52YXNFbGUud2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXNFbGUuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsRGVuc2l0eTtcbiAgICAgICAgdGhpcy5jYW52YXNFbGUuaGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc0VsZS5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsRGVuc2l0eTtcbiAgICB9XG5cbiAgICBkaXNwb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENnQ2FudmFzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/cg_canvas.js\n");

/***/ }),

/***/ "./src/core/cg/cg_constants.js":
/*!*************************************!*\
  !*** ./src/core/cg/cg_constants.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CG\": () => (/* binding */ CG)\n/* harmony export */ });\n/* harmony import */ var _cg_boundingbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cg_boundingbox */ \"./src/core/cg/cg_boundingbox.js\");\n/* harmony import */ var _cg_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cg_canvas */ \"./src/core/cg/cg_canvas.js\");\n/* harmony import */ var _cg_geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cg_geom */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _sg_fpscounter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sg_fpscounter */ \"./src/core/cg/sg_fpscounter.js\");\n\n\n\n\n\nconst CG = {\n\n    \"GAPI_WEBGL\": 0,\n    \"GAPI_WEBGPU\": 1,\n\n    \"DEPTH_COMPARE_NEVER\": 0,\n    \"DEPTH_COMPARE_LESS\": 1,\n    \"DEPTH_COMPARE_EQUAL\": 2,\n    \"DEPTH_COMPARE_LESSEQUAL\": 3,\n    \"DEPTH_COMPARE_GREATER\": 4,\n    \"DEPTH_COMPARE_NOTEQUAL\": 5,\n    \"DEPTH_COMPARE_GREATEREQUAL\": 6,\n    \"DEPTH_COMPARE_ALWAYS\": 7,\n\n    \"CULL_NONE\": 0,\n    \"CULL_BACK\": 1,\n    \"CULL_FRONT\": 2,\n    \"CULL_BOTH\": 3,\n\n\n    \"Geometry\": _cg_geom__WEBPACK_IMPORTED_MODULE_2__.Geometry,\n    \"BoundingBox\": _cg_boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox,\n    \"FpsCounter\": _sg_fpscounter__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n\n    \"CgCanvas\": _cg_canvas__WEBPACK_IMPORTED_MODULE_1__.CgCanvas\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnL2NnX2NvbnN0YW50cy5qcz8xOTJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvdW5kaW5nQm94IH0gZnJvbSBcIi4vY2dfYm91bmRpbmdib3hcIjtcbmltcG9ydCB7IENnQ2FudmFzIH0gZnJvbSBcIi4vY2dfY2FudmFzXCI7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCIuL2NnX2dlb21cIjtcbmltcG9ydCBGcHNDb3VudGVyIGZyb20gXCIuL3NnX2Zwc2NvdW50ZXJcIjtcblxuY29uc3QgQ0cgPSB7XG5cbiAgICBcIkdBUElfV0VCR0xcIjogMCxcbiAgICBcIkdBUElfV0VCR1BVXCI6IDEsXG5cbiAgICBcIkRFUFRIX0NPTVBBUkVfTkVWRVJcIjogMCxcbiAgICBcIkRFUFRIX0NPTVBBUkVfTEVTU1wiOiAxLFxuICAgIFwiREVQVEhfQ09NUEFSRV9FUVVBTFwiOiAyLFxuICAgIFwiREVQVEhfQ09NUEFSRV9MRVNTRVFVQUxcIjogMyxcbiAgICBcIkRFUFRIX0NPTVBBUkVfR1JFQVRFUlwiOiA0LFxuICAgIFwiREVQVEhfQ09NUEFSRV9OT1RFUVVBTFwiOiA1LFxuICAgIFwiREVQVEhfQ09NUEFSRV9HUkVBVEVSRVFVQUxcIjogNixcbiAgICBcIkRFUFRIX0NPTVBBUkVfQUxXQVlTXCI6IDcsXG5cbiAgICBcIkNVTExfTk9ORVwiOiAwLFxuICAgIFwiQ1VMTF9CQUNLXCI6IDEsXG4gICAgXCJDVUxMX0ZST05UXCI6IDIsXG4gICAgXCJDVUxMX0JPVEhcIjogMyxcblxuXG4gICAgXCJHZW9tZXRyeVwiOiBHZW9tZXRyeSxcbiAgICBcIkJvdW5kaW5nQm94XCI6IEJvdW5kaW5nQm94LFxuICAgIFwiRnBzQ291bnRlclwiOiBGcHNDb3VudGVyLFxuXG4gICAgXCJDZ0NhbnZhc1wiOiBDZ0NhbnZhc1xufTtcblxuXG5leHBvcnQgeyBDRyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cg/cg_constants.js\n");

/***/ }),

/***/ "./src/core/cg/cg_geom.js":
/*!********************************!*\
  !*** ./src/core/cg/cg_geom.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Geometry\": () => (/* binding */ Geometry)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base64 */ \"./src/core/base64.js\");\n/* harmony import */ var _cg_boundingbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cg_boundingbox */ \"./src/core/cg/cg_boundingbox.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n// import { vec2, vec3 } from \"gl-matrix\";\n\n\n\n\n\n/**\n * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.\n * @external CGL\n * @namespace Geometry\n * @param {String} name\n * @class\n * @example\n * // create a triangle with all attributes\n * const geom=new Geometry(\"triangle\"),\n *\n * geom.vertices = [\n *      0.0,           sizeH.get(),  0.0,\n *     -sizeW.get(),  -sizeH.get(),  0.0,\n *      sizeW.get(),  -sizeH.get(),  0.0 ];\n *\n * geom.vertexNormals = [\n *      0.0,  0.0,  1.0,\n *      0.0,  0.0,  1.0,\n *      0.0,  0.0,  1.0 ];\n *\n * geom.tangents = [\n *     1,0,0,\n *     1,0,0,\n *     1,0,0 ];\n *\n * geom.biTangents = [\n *     0,1,0,\n *     0,1,0,\n *     0,1,0 ];\n *\n * geom.texCoords = [\n *      0.5,  0.0,\n *      1.0,  1.0,\n *      0.0,  1.0, ];\n *\n * geom.verticesIndices = [\n *     0, 1, 2 ];\n *\n */\nconst Geometry = function (name)\n{\n    this.name = name || \"unknown\";\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"cgl_geometry\");\n\n    this.faceVertCount = 3;\n    this.glPrimitive = null;\n    this._attributes = {};\n\n    this._vertices = [];\n    this.verticesIndices = [];\n\n    this.isGeometry = true;\n\n    this.morphTargets = [];\n\n    Object.defineProperty(this, \"vertices\", {\n        get()\n        {\n            return this._vertices;\n        },\n        set(v)\n        {\n            this.setVertices(v);\n        },\n    });\n\n    Object.defineProperty(this, \"texCoords\", {\n        get()\n        {\n            const att = this.getAttribute(\"texCoords\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"texCoords\", v, 2);\n        },\n    });\n\n    Object.defineProperty(this, \"vertexNormals\", {\n        get()\n        {\n            const att = this.getAttribute(\"vertexNormals\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"vertexNormals\", v, 3);\n        },\n    });\n\n    Object.defineProperty(this, \"tangents\", {\n        get()\n        {\n            const att = this.getAttribute(\"tangents\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"tangents\", v, 3);\n        },\n    });\n\n    Object.defineProperty(this, \"biTangents\", {\n        get()\n        {\n            const att = this.getAttribute(\"biTangents\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"biTangents\", v, 3);\n        },\n    });\n\n    Object.defineProperty(this, \"vertexColors\", {\n        get()\n        {\n            const att = this.getAttribute(\"vertexColors\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"vertexColors\", v, 4);\n        },\n    });\n};\n\n/**\n * @function clear\n * @memberof Geometry\n * @instance\n * @description clear all buffers/set them to length 0\n */\nGeometry.prototype.clear = function ()\n{\n    this._vertices = new Float32Array([]);\n    this.verticesIndices = [];\n    this.texCoords = new Float32Array([]);\n    this.vertexNormals = new Float32Array([]);\n    this.tangents = [];\n    this.biTangents = [];\n    this._attributes = {};\n};\n\n\n\n/**\n * @function getAttributes\n   @memberof Geometry\n * @instance\n * @return {Array<Object>} returns array of attribute objects\n */\nGeometry.prototype.getAttributes = function ()\n{\n    return this._attributes;\n};\n\n/**\n * @function getAttribute\n * @memberof Geometry\n * @instance\n * @param {String} name\n * @return {Object}\n */\nGeometry.prototype.getAttribute = function (name)\n{\n    for (const i in this._attributes)\n    {\n        if (this._attributes[i].name == name) return this._attributes[i];\n    }\n    return null;\n};\n\n/**\n * @function setAttribute\n * @description create an attribute\n * @memberof Geometry\n * @instance\n * @param {String} name\n * @param {Array} data\n * @param {Number} itemsize\n */\nGeometry.prototype.setAttribute = function (name, arr, itemSize)\n{\n    let attrType = \"\";\n    if (!itemSize || itemSize > 4)\n    {\n        console.log(\"itemsize wrong?\", itemSize, name);\n        this._log.stack(\"itemsize\");\n\n        itemSize = 3;\n    }\n\n    if (itemSize == 1) attrType = \"float\";\n    else if (itemSize == 2) attrType = \"vec2\";\n    else if (itemSize == 3) attrType = \"vec3\";\n    else if (itemSize == 4) attrType = \"vec4\";\n\n\n    const attr = {\n        \"name\": name,\n        \"data\": arr,\n        \"itemSize\": itemSize,\n        \"type\": attrType,\n    };\n\n    this._attributes[name] = attr;\n};\n\nGeometry.prototype.copyAttribute = function (name, newgeom)\n{\n    const attr = this.getAttribute(name);\n    newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);\n};\n\n\n/**\n * @function setVertices\n * @memberof Geometry\n * @instance\n * @description set vertices\n * @param {Array|Float32Array} data [x,y,z,x,y,z,...]\n */\nGeometry.prototype.setVertices = function (arr)\n{\n    if (arr instanceof Float32Array) this._vertices = arr;\n    else this._vertices = new Float32Array(arr);\n};\n\n/**\n * @function setTexCoords\n * @memberof Geometry\n * @instance\n * @description set texcoords\n * @param {Array|Float32Array} data [u,v,u,v,...]\n */\nGeometry.prototype.setTexCoords = function (arr)\n{\n    if (arr instanceof Float32Array) this.texCoords = arr;\n    else this.texCoords = new Float32Array(arr);\n};\n\n// Geometry.prototype.testIndices = function ()\n// {\n//     var foundError = false;\n//     for (var i = 0; i < this.verticesIndices.length; i++)\n//     {\n//         if (this.verticesIndices[i * 3 + 0] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 1] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 2] >= this._vertices.length / 3)\n//         {\n//             foundError = true;\n//             console.log(\"index error!\");\n//         }\n//     }\n// };\n\n// deprecated\nGeometry.prototype.calcNormals = function (smooth)\n{\n    const options = { \"smooth\": smooth };\n\n\n    this.calculateNormals(options);\n};\n\n/**\n * @function flipNormals\n * @memberof Geometry\n * @description flip normals\n */\nGeometry.prototype.flipNormals = function (x, y, z)\n{\n    let vec = vec3.create();\n\n    if (x == undefined)x = 1;\n    if (y == undefined)y = 1;\n    if (z == undefined)z = 1;\n\n\n    for (let i = 0; i < this.vertexNormals.length; i += 3)\n    {\n        vec3.set(vec,\n            this.vertexNormals[i + 0],\n            this.vertexNormals[i + 1],\n            this.vertexNormals[i + 2]);\n\n        vec[0] *= -x;\n        vec[1] *= -y;\n        vec[2] *= -z;\n\n        vec3.normalize(vec, vec);\n\n        this.vertexNormals[i + 0] = vec[0];\n        this.vertexNormals[i + 1] = vec[1];\n        this.vertexNormals[i + 2] = vec[2];\n    }\n};\n\nGeometry.prototype.getNumTriangles = function ()\n{\n    if (this.verticesIndices && this.verticesIndices.length) return this.verticesIndices.length / 3;\n    return this.vertices.length / 3;\n};\n\n\n/**\n * @function flipVertDir\n * @memberof Geometry\n * @description flip order of vertices in geom faces\n */\nGeometry.prototype.flipVertDir = function ()\n{\n    const newInd = [];\n    newInd.length = this.verticesIndices.length;\n    for (let i = 0; i < this.verticesIndices.length; i += 3)\n    {\n        newInd[i] = this.verticesIndices[i + 2];\n        newInd[i + 1] = this.verticesIndices[i + 1];\n        newInd[i + 2] = this.verticesIndices[i];\n    }\n    this.verticesIndices = newInd;\n};\n\n\nGeometry.prototype.setPointVertices = function (verts)\n{\n    if (verts.length % 3 !== 0)\n    {\n        this._log.error(\"SetPointVertices: Array must be multiple of three.\");\n        return;\n    }\n\n    if (!(verts instanceof Float32Array)) this.vertices = new Float32Array(verts);\n    else this.vertices = verts;\n\n    if (!(this.texCoords instanceof Float32Array)) this.texCoords = new Float32Array((verts.length / 3) * 2);\n\n    // this.texCoords.length=verts.length/3*2;\n    this.verticesIndices.length = verts.length / 3;\n    // this.verticesIndices=[];\n\n    for (let i = 0; i < verts.length / 3; i++)\n    {\n        this.verticesIndices[i] = i;\n        this.texCoords[i * 2] = 0;\n        this.texCoords[i * 2 + 1] = 0;\n    }\n};\n\n/**\n * merge a different geometry into the this geometry\n * @function merge\n * @param {Geometry} geom\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.merge = function (geom)\n{\n    if (!geom) return;\n\n    if (this.isIndexed() != geom.isIndexed())\n    {\n        if (this.isIndexed())\n        {\n            this.unIndex(false, true);\n        }\n        if (geom.isIndexed())\n        {\n            const g = geom.copy();\n            g.unIndex(false, true);\n            geom = g;\n        }\n    }\n\n    const oldIndizesLength = this.verticesIndices.length;\n    const vertLength = this._vertices.length / 3;\n\n    this.verticesIndices.length = this.verticesIndices.length + geom.verticesIndices.length;\n    for (let i = 0; i < geom.verticesIndices.length; i++)\n        this.verticesIndices[oldIndizesLength + i] = geom.verticesIndices[i] + vertLength;\n\n    this.vertices = _utils__WEBPACK_IMPORTED_MODULE_0__.UTILS.float32Concat(this._vertices, geom.vertices);\n    this.texCoords = _utils__WEBPACK_IMPORTED_MODULE_0__.UTILS.float32Concat(this.texCoords, geom.texCoords);\n    this.vertexNormals = _utils__WEBPACK_IMPORTED_MODULE_0__.UTILS.float32Concat(this.vertexNormals, geom.vertexNormals);\n    this.tangents = _utils__WEBPACK_IMPORTED_MODULE_0__.UTILS.float32Concat(this.tangents, geom.tangents);\n    this.biTangents = _utils__WEBPACK_IMPORTED_MODULE_0__.UTILS.float32Concat(this.biTangents, geom.biTangents);\n};\n\n/**\n * create a copy of the geometry\n * @function copy\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.copy = function ()\n{\n    const geom = new Geometry(this.name + \" copy\");\n    geom.faceVertCount = this.faceVertCount;\n    geom.glPrimitive = this.glPrimitive;\n\n    geom.setVertices(this._vertices.slice(0));\n\n    if (this.verticesIndices)\n    {\n        geom.verticesIndices.length = this.verticesIndices.length;\n        for (let i = 0; i < this.verticesIndices.length; i++) geom.verticesIndices[i] = this.verticesIndices[i];\n    }\n\n    for (let i in this._attributes) this.copyAttribute(i, geom);\n\n    geom.morphTargets.length = this.morphTargets.length;\n    for (let i = 0; i < this.morphTargets.length; i++) geom.morphTargets[i] = this.morphTargets[i];\n\n    return geom;\n};\n\n/**\n * Calculaten normals\n * @function calculateNormals\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.calculateNormals = function (options)\n{\n    // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152\n    options = options || {};\n    if (options.smooth === false) this.unIndex();\n\n    const u = vec3.create();\n    const v = vec3.create();\n    const n = vec3.create();\n\n    function calcNormal(triangle)\n    {\n        vec3.subtract(u, triangle[0], triangle[1]);\n        vec3.subtract(v, triangle[0], triangle[2]);\n        vec3.cross(n, u, v);\n        vec3.normalize(n, n);\n\n        if (options && options.forceZUp)\n        {\n            if (n[2] < 0)\n            {\n                n[0] *= -1;\n                n[1] *= -1;\n                n[2] *= -1;\n            }\n        }\n        return n;\n    }\n\n    this.getVertexVec = function (which)\n    {\n        const vec = [0, 0, 0];\n        vec[0] = this.vertices[which * 3 + 0];\n        vec[1] = this.vertices[which * 3 + 1];\n        vec[2] = this.vertices[which * 3 + 2];\n        return vec;\n    };\n\n    if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length) this.vertexNormals = new Float32Array(this.vertices.length);\n\n    for (let i = 0; i < this.vertices.length; i++)\n    {\n        this.vertexNormals[i] = 0;\n    }\n\n    if (!this.isIndexed())\n    {\n        const norms = [];\n        for (let i = 0; i < this.vertices.length; i += 9)\n        {\n            const triangle = [[this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]], [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]], [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]]];\n            const nn = calcNormal(triangle);\n            norms.push(nn[0], nn[1], nn[2], nn[0], nn[1], nn[2], nn[0], nn[1], nn[2]);\n        }\n        this.vertexNormals = norms;\n    }\n    else\n    {\n        const faceNormals = [];\n\n        faceNormals.length = Math.floor(this.verticesIndices.length / 3);\n\n        for (let i = 0; i < this.verticesIndices.length; i += 3)\n        {\n            const triangle = [this.getVertexVec(this.verticesIndices[i + 0]), this.getVertexVec(this.verticesIndices[i + 1]), this.getVertexVec(this.verticesIndices[i + 2])];\n\n            faceNormals[i / 3] = calcNormal(triangle);\n\n            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] += faceNormals[i / 3][0];\n            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] += faceNormals[i / 3][1];\n            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] += faceNormals[i / 3][2];\n\n            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] += faceNormals[i / 3][0];\n            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] += faceNormals[i / 3][1];\n            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] += faceNormals[i / 3][2];\n\n            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] += faceNormals[i / 3][0];\n            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] += faceNormals[i / 3][1];\n            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] += faceNormals[i / 3][2];\n        }\n\n\n        for (let i = 0; i < this.verticesIndices.length; i += 3) // faces\n        {\n            for (let k = 0; k < 3; k++) // triangles\n            {\n                const vv = [this.vertexNormals[this.verticesIndices[i + k] * 3 + 0], this.vertexNormals[this.verticesIndices[i + k] * 3 + 1], this.vertexNormals[this.verticesIndices[i + k] * 3 + 2]];\n                vec3.normalize(vv, vv);\n                this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];\n                this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];\n                this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];\n            }\n        }\n    }\n};\n\n/**\n * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from\n * Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”.\n * Terathon Software 3D Graphics Library.\n * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf\n *\n * @function calcTangentsBitangents\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.calcTangentsBitangents = function ()\n{\n    if (!this.vertices.length)\n    {\n        // this._log.error(\"Cannot calculate tangents/bitangents without vertices.\");\n        return;\n    }\n    if (!this.vertexNormals.length)\n    {\n        // this._log.error(\"Cannot calculate tangents/bitangents without normals.\");\n        return;\n    }\n    if (!this.texCoords.length)\n    {\n        // console.warn(\"No texcoords. Replacing with default values [0, 0].\");\n        const texCoordLength = (this.vertices.length / 3) * 2;\n        this.texCoords = new Float32Array(texCoordLength);\n        for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;\n    }\n    if (!this.verticesIndices || !this.verticesIndices.length)\n    {\n        // this._log.error(\"Cannot calculate tangents/bitangents without vertex indices.\");\n        return;\n    }\n    // this code assumes that we have three indices per triangle\n    if (this.verticesIndices.length % 3 !== 0)\n    {\n        this._log.error(\"Vertex indices mismatch!\");\n        return;\n    }\n\n    const triangleCount = this.verticesIndices.length / 3;\n    const vertexCount = this.vertices.length / 3;\n\n    this.tangents = new Float32Array(this.vertexNormals.length);\n    this.biTangents = new Float32Array(this.vertexNormals.length);\n\n    // temporary buffers\n    const tempVertices = [];\n    tempVertices.length = vertexCount * 2;\n    const v1 = vec3.create();\n    const v2 = vec3.create();\n    const v3 = vec3.create();\n\n    const w1 = vec2.create();\n    const w2 = vec2.create();\n    const w3 = vec2.create();\n\n    const sdir = vec3.create();\n    const tdir = vec3.create();\n\n    // for details on calculation, see article referenced above\n    for (let tri = 0; tri < triangleCount; tri += 1)\n    {\n        // indices of the three vertices for a triangle\n        const i1 = this.verticesIndices[tri * 3];\n        const i2 = this.verticesIndices[tri * 3 + 1];\n        const i3 = this.verticesIndices[tri * 3 + 2];\n\n        // vertex position as vec3\n        vec3.set(v1, this.vertices[i1 * 3], this.vertices[i1 * 3 + 1], this.vertices[i1 * 3 + 2]);\n        vec3.set(v2, this.vertices[i2 * 3], this.vertices[i2 * 3 + 1], this.vertices[i2 * 3 + 2]);\n        vec3.set(v3, this.vertices[i3 * 3], this.vertices[i3 * 3 + 1], this.vertices[i3 * 3 + 2]);\n\n        // texture coordinate as vec2\n        vec2.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);\n        vec2.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);\n        vec2.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);\n\n        const x1 = v2[0] - v1[0];\n        const x2 = v3[0] - v1[0];\n        const y1 = v2[1] - v1[1];\n        const y2 = v3[1] - v1[1];\n        const z1 = v2[2] - v1[2];\n        const z2 = v3[2] - v1[2];\n\n        const s1 = w2[0] - w1[0];\n        const s2 = w3[0] - w1[0];\n        const t1 = w2[1] - w1[1];\n        const t2 = w3[1] - w1[1];\n\n        const r = 1.0 / (s1 * t2 - s2 * t1);\n\n        vec3.set(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);\n        vec3.set(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\n        tempVertices[i1] = sdir;\n        tempVertices[i2] = sdir;\n        tempVertices[i3] = sdir;\n\n        tempVertices[i1 + vertexCount] = tdir;\n        tempVertices[i2 + vertexCount] = tdir;\n        tempVertices[i3 + vertexCount] = tdir;\n    }\n\n    const normal = vec3.create();\n    const tempVert = vec3.create();\n    const tan = vec3.create();\n    const bitan = vec3.create();\n    const temp1 = vec3.create();\n    const temp2 = vec3.create();\n    const crossPd = vec3.create();\n    const normalized = vec3.create();\n\n    for (let vert = 0; vert < vertexCount; vert += 1)\n    {\n        // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex\n        if (!tempVertices[vert]) continue;\n\n        vec3.set(normal, this.vertexNormals[vert * 3], this.vertexNormals[vert * 3 + 1], this.vertexNormals[vert * 3 + 2]);\n        vec3.set(tempVert, tempVertices[vert][0], tempVertices[vert][1], tempVertices[vert][2]);\n\n        // Gram-Schmidt orthagonalize\n        const _dp = vec3.dot(normal, tempVert);\n        vec3.scale(temp1, normal, _dp);\n        vec3.subtract(temp2, tempVert, temp1);\n\n        vec3.normalize(normalized, temp2);\n        vec3.cross(crossPd, normal, tempVert);\n\n        const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);\n        const w = 1.0;// intermDot < 0.0 ? -1.0 : 1.0;\n\n        vec3.scale(tan, normalized, 1 / w);\n        vec3.cross(bitan, normal, tan);\n\n        this.tangents[vert * 3 + 0] = tan[0];\n        this.tangents[vert * 3 + 1] = tan[1];\n        this.tangents[vert * 3 + 2] = tan[2];\n        this.biTangents[vert * 3 + 0] = bitan[0];\n        this.biTangents[vert * 3 + 1] = bitan[1];\n        this.biTangents[vert * 3 + 2] = bitan[2];\n    }\n};\n\nGeometry.prototype.isIndexed = function ()\n{\n    if (this._vertices.length == 0) return true;\n    return this.verticesIndices.length != 0;\n};\n\n/**\n * @function unIndex\n * @memberof Geometry\n * @instance\n * @param {Boolean}\n * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle\n */\nGeometry.prototype.unIndex = function (reIndex, dontCalcNormals)\n{\n    const newVerts = [];\n    const newIndizes = [];\n    let count = 0;\n\n    for (let j in this._attributes)\n    {\n        const attr = this._attributes[j];\n        let na = [];\n\n        for (let i = 0; i < this.verticesIndices.length; i += 3)\n        {\n            for (let s = 0; s < 3; s++)\n            {\n                if (attr.itemSize == 3)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s] * 3 + 0],\n                        attr.data[this.verticesIndices[i + s] * 3 + 1],\n                        attr.data[this.verticesIndices[i + s] * 3 + 2]);\n                else if (attr.itemSize == 4)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s] * 4 + 0],\n                        attr.data[this.verticesIndices[i + s] * 4 + 1],\n                        attr.data[this.verticesIndices[i + s] * 4 + 2],\n                        attr.data[this.verticesIndices[i + s] * 4 + 3]);\n                else if (attr.itemSize == 2)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s] * 2 + 0],\n                        attr.data[this.verticesIndices[i + s] * 2 + 1]);\n                else if (attr.itemSize == 1)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s]]);\n                else console.log(\"unknown attr\", attr);\n            }\n        }\n        this.setAttribute(attr.name, na, attr.itemSize);\n    }\n\n    for (let i = 0; i < this.verticesIndices.length; i += 3)\n    {\n        newVerts.push(\n            this.vertices[this.verticesIndices[i + 0] * 3 + 0],\n            this.vertices[this.verticesIndices[i + 0] * 3 + 1],\n            this.vertices[this.verticesIndices[i + 0] * 3 + 2]);\n\n        newIndizes.push(count);\n        count++;\n\n        newVerts.push(\n            this.vertices[this.verticesIndices[i + 1] * 3 + 0],\n            this.vertices[this.verticesIndices[i + 1] * 3 + 1],\n            this.vertices[this.verticesIndices[i + 1] * 3 + 2]);\n\n        newIndizes.push(count);\n        count++;\n\n        newVerts.push(\n            this.vertices[this.verticesIndices[i + 2] * 3 + 0],\n            this.vertices[this.verticesIndices[i + 2] * 3 + 1],\n            this.vertices[this.verticesIndices[i + 2] * 3 + 2]);\n\n        newIndizes.push(count);\n        count++;\n    }\n\n    this.vertices = newVerts;\n\n    this.verticesIndices = [];\n    if (reIndex) this.verticesIndices = newIndizes;\n\n    if (!dontCalcNormals) this.calculateNormals();\n};\n\nGeometry.prototype.calcBarycentric = function ()\n{\n    let barycentrics = [];\n    barycentrics.length = this.vertices.length;\n    for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;\n\n    let count = 0;\n    for (let i = 0; i < this.vertices.length; i += 3)\n    {\n        barycentrics[i + count] = 1;\n        count++;\n        if (count == 3) count = 0;\n    }\n\n    this.setAttribute(\"attrBarycentric\", barycentrics, 3);\n};\n\nGeometry.prototype.getBounds = function ()\n{\n    return new _cg_boundingbox__WEBPACK_IMPORTED_MODULE_2__.BoundingBox(this);\n};\n\nGeometry.prototype.center = function (x, y, z)\n{\n    if (x === undefined)\n    {\n        x = true;\n        y = true;\n        z = true;\n    }\n\n    let i = 0;\n    const bounds = this.getBounds();\n    const offset = [bounds.minX + (bounds.maxX - bounds.minX) / 2, bounds.minY + (bounds.maxY - bounds.minY) / 2, bounds.minZ + (bounds.maxZ - bounds.minZ) / 2];\n\n    for (i = 0; i < this.vertices.length; i += 3)\n    {\n        if (this.vertices[i + 0] == this.vertices[i + 0])\n        {\n            if (x) this.vertices[i + 0] -= offset[0];\n            if (y) this.vertices[i + 1] -= offset[1];\n            if (z) this.vertices[i + 2] -= offset[2];\n        }\n    }\n\n    return offset;\n};\n\nGeometry.prototype.mapTexCoords2d = function ()\n{\n    const bounds = this.getBounds();\n    const num = this.vertices.length / 3;\n\n    this.texCoords = new Float32Array(num * 2);\n\n    for (let i = 0; i < num; i++)\n    {\n        const vertX = this.vertices[i * 3 + 0];\n        const vertY = this.vertices[i * 3 + 1];\n        this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;\n        this.texCoords[i * 2 + 1] = 1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;\n    }\n};\n\n\nGeometry.prototype.getInfoOneLine = function ()\n{\n    let txt = \"\";\n    if (this.faceVertCount == 3 && this.verticesIndices)txt += this.verticesIndices.length / 3;\n    else txt += 0;\n\n    txt += \" tris \";\n\n    if (this.vertices)txt += this.vertices.length / 3;\n    else txt += 0;\n\n    txt += \" verts\";\n\n    return txt;\n};\n\nGeometry.prototype.getInfo = function ()\n{\n    const info = {};\n\n    if (this.faceVertCount == 3 && this.verticesIndices)info.numFaces = this.verticesIndices.length / 3;\n    else info.numFaces = 0;\n\n    if (this.verticesIndices && this.verticesIndices.length)info.indices = this.verticesIndices.length;\n\n    if (this.vertices)info.numVerts = this.vertices.length / 3;\n    else info.numVerts = 0;\n\n    if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;\n    else info.numNormals = 0;\n\n    if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;\n    else info.numTexCoords = 0;\n\n    if (this.tangents) info.numTangents = this.tangents.length / 3;\n    else info.numTangents = 0;\n\n    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;\n    else info.numBiTangents = 0;\n\n    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;\n    else info.numBiTangents = 0;\n\n    if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;\n    else info.numVertexColors = 0;\n\n    if (this.getAttributes()) info.numAttribs = Object.keys(this.getAttributes()).length;\n    else info.numAttribs = 0;\n\n    info.isIndexed = this.isIndexed();\n\n    return info;\n};\n\n// -----------------\n\n// TODO : move this into \"old\" circle op\nGeometry.buildFromFaces = function (arr, name, optimize)\n{\n    const vertices = [];\n    const verticesIndices = [];\n\n    for (let i = 0; i < arr.length; i += 3)\n    {\n        const a = arr[i + 0];\n        const b = arr[i + 1];\n        const c = arr[i + 2];\n        const face = [-1, -1, -1];\n\n        if (optimize)\n            for (let iv = 0; iv < vertices.length; iv += 3)\n            {\n                if (vertices[iv + 0] == a[0] && vertices[iv + 1] == a[1] && vertices[iv + 2] == a[2]) face[0] = iv / 3;\n                if (vertices[iv + 0] == b[0] && vertices[iv + 1] == b[1] && vertices[iv + 2] == b[2]) face[1] = iv / 3;\n                if (vertices[iv + 0] == c[0] && vertices[iv + 1] == c[1] && vertices[iv + 2] == c[2]) face[2] = iv / 3;\n            }\n\n        if (face[0] == -1)\n        {\n            vertices.push(a[0], a[1], a[2]);\n            face[0] = (vertices.length - 1) / 3;\n        }\n\n        if (face[1] == -1)\n        {\n            vertices.push(b[0], b[1], b[2]);\n            face[1] = (vertices.length - 1) / 3;\n        }\n\n        if (face[2] == -1)\n        {\n            vertices.push(c[0], c[1], c[2]);\n            face[2] = (vertices.length - 1) / 3;\n        }\n\n        verticesIndices.push(parseInt(face[0], 10));\n        verticesIndices.push(parseInt(face[1], 10));\n        verticesIndices.push(parseInt(face[2], 10));\n    }\n\n    const geom = new Geometry(name);\n    geom.name = name;\n    geom.vertices = vertices;\n    geom.verticesIndices = verticesIndices;\n\n    return geom;\n};\n\n// TODO: not needed anymore ?! move to deprecated ops?\nGeometry.json2geom = function (jsonMesh)\n{\n    const geom = new Geometry(\"jsonMeshGeom\");\n    geom.verticesIndices = [];\n\n    geom.vertices = jsonMesh.vertices || [];\n    geom.vertexNormals = jsonMesh.normals || [];\n    geom.vertexColors = jsonMesh.colors || [];\n    geom.tangents = jsonMesh.tangents || [];\n    geom.biTangents = jsonMesh.bitangents || [];\n    if (jsonMesh.texturecoords) geom.setTexCoords(jsonMesh.texturecoords[0]);\n\n    if (jsonMesh.vertices_b64)geom.vertices = new Float32Array((0,_base64__WEBPACK_IMPORTED_MODULE_1__.b64decTypedArray)(jsonMesh.vertices_b64));\n    if (jsonMesh.normals_b64) geom.vertexNormals = new Float32Array((0,_base64__WEBPACK_IMPORTED_MODULE_1__.b64decTypedArray)(jsonMesh.normals_b64));\n    if (jsonMesh.tangents_b64) geom.tangents = new Float32Array((0,_base64__WEBPACK_IMPORTED_MODULE_1__.b64decTypedArray)(jsonMesh.tangents_b64));\n    if (jsonMesh.bitangents_b64) geom.biTangents = new Float32Array((0,_base64__WEBPACK_IMPORTED_MODULE_1__.b64decTypedArray)(jsonMesh.bitangents_b64));\n    if (jsonMesh.texturecoords_b64) geom.setTexCoords(new Float32Array((0,_base64__WEBPACK_IMPORTED_MODULE_1__.b64decTypedArray)(jsonMesh.texturecoords_b64[0])));\n\n    if (jsonMesh.faces_b64)\n    {\n        geom.verticesIndices = new Uint32Array((0,_base64__WEBPACK_IMPORTED_MODULE_1__.b64decTypedArray)(jsonMesh.faces_b64));\n    }\n    else\n    {\n        geom.verticesIndices.length = jsonMesh.faces.length * 3;\n        for (let i = 0; i < jsonMesh.faces.length; i++)\n        {\n            geom.verticesIndices[i * 3] = jsonMesh.faces[i][0];\n            geom.verticesIndices[i * 3 + 1] = jsonMesh.faces[i][1];\n            geom.verticesIndices[i * 3 + 2] = jsonMesh.faces[i][2];\n        }\n    }\n\n    return geom;\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19nZW9tLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvY2dfZ2VvbS5qcz9mMTQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7IHZlYzIsIHZlYzMgfSBmcm9tIFwiZ2wtbWF0cml4XCI7XG5pbXBvcnQgeyBVVElMUyB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IHsgYjY0ZGVjVHlwZWRBcnJheSB9IGZyb20gXCIuLi9iYXNlNjRcIjtcbmltcG9ydCB7IEJvdW5kaW5nQm94IH0gZnJvbSBcIi4vY2dfYm91bmRpbmdib3hcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5cbi8qKlxuICogYSBnZW9tZXRyeSBjb250YWlucyBhbGwgaW5mb3JtYXRpb24gYWJvdXQgYSBtZXNoLCB2ZXJ0aWNlcywgdGV4dHVyZWNvb3JkaW5hdGVzIGV0Yy4gZXRjLlxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBHZW9tZXRyeVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSBhIHRyaWFuZ2xlIHdpdGggYWxsIGF0dHJpYnV0ZXNcbiAqIGNvbnN0IGdlb209bmV3IEdlb21ldHJ5KFwidHJpYW5nbGVcIiksXG4gKlxuICogZ2VvbS52ZXJ0aWNlcyA9IFtcbiAqICAgICAgMC4wLCAgICAgICAgICAgc2l6ZUguZ2V0KCksICAwLjAsXG4gKiAgICAgLXNpemVXLmdldCgpLCAgLXNpemVILmdldCgpLCAgMC4wLFxuICogICAgICBzaXplVy5nZXQoKSwgIC1zaXplSC5nZXQoKSwgIDAuMCBdO1xuICpcbiAqIGdlb20udmVydGV4Tm9ybWFscyA9IFtcbiAqICAgICAgMC4wLCAgMC4wLCAgMS4wLFxuICogICAgICAwLjAsICAwLjAsICAxLjAsXG4gKiAgICAgIDAuMCwgIDAuMCwgIDEuMCBdO1xuICpcbiAqIGdlb20udGFuZ2VudHMgPSBbXG4gKiAgICAgMSwwLDAsXG4gKiAgICAgMSwwLDAsXG4gKiAgICAgMSwwLDAgXTtcbiAqXG4gKiBnZW9tLmJpVGFuZ2VudHMgPSBbXG4gKiAgICAgMCwxLDAsXG4gKiAgICAgMCwxLDAsXG4gKiAgICAgMCwxLDAgXTtcbiAqXG4gKiBnZW9tLnRleENvb3JkcyA9IFtcbiAqICAgICAgMC41LCAgMC4wLFxuICogICAgICAxLjAsICAxLjAsXG4gKiAgICAgIDAuMCwgIDEuMCwgXTtcbiAqXG4gKiBnZW9tLnZlcnRpY2VzSW5kaWNlcyA9IFtcbiAqICAgICAwLCAxLCAyIF07XG4gKlxuICovXG5jb25zdCBHZW9tZXRyeSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJ1bmtub3duXCI7XG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNnbF9nZW9tZXRyeVwiKTtcblxuICAgIHRoaXMuZmFjZVZlcnRDb3VudCA9IDM7XG4gICAgdGhpcy5nbFByaW1pdGl2ZSA9IG51bGw7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdGhpcy5fdmVydGljZXMgPSBbXTtcbiAgICB0aGlzLnZlcnRpY2VzSW5kaWNlcyA9IFtdO1xuXG4gICAgdGhpcy5pc0dlb21ldHJ5ID0gdHJ1ZTtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gW107XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJ0aWNlc1wiLCB7XG4gICAgICAgIGdldCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmVydGljZXModik7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXhDb29yZHNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInRleENvb3Jkc1wiKTtcbiAgICAgICAgICAgIGlmICghYXR0KSByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gYXR0LmRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcInRleENvb3Jkc1wiLCB2LCAyKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRleE5vcm1hbHNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInZlcnRleE5vcm1hbHNcIik7XG4gICAgICAgICAgICBpZiAoIWF0dCkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIGF0dC5kYXRhO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ2ZXJ0ZXhOb3JtYWxzXCIsIHYsIDMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFuZ2VudHNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInRhbmdlbnRzXCIpO1xuICAgICAgICAgICAgaWYgKCFhdHQpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhdHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFuZ2VudHNcIiwgdiwgMyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiaVRhbmdlbnRzXCIsIHtcbiAgICAgICAgZ2V0KClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgYXR0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJiaVRhbmdlbnRzXCIpO1xuICAgICAgICAgICAgaWYgKCFhdHQpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhdHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYmlUYW5nZW50c1wiLCB2LCAzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRleENvbG9yc1wiLCB7XG4gICAgICAgIGdldCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwidmVydGV4Q29sb3JzXCIpO1xuICAgICAgICAgICAgaWYgKCFhdHQpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhdHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidmVydGV4Q29sb3JzXCIsIHYsIDQpO1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY2xlYXJcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gY2xlYXIgYWxsIGJ1ZmZlcnMvc2V0IHRoZW0gdG8gbGVuZ3RoIDBcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl92ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW10pO1xuICAgIHRoaXMudmVydGljZXNJbmRpY2VzID0gW107XG4gICAgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KFtdKTtcbiAgICB0aGlzLnZlcnRleE5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KFtdKTtcbiAgICB0aGlzLnRhbmdlbnRzID0gW107XG4gICAgdGhpcy5iaVRhbmdlbnRzID0gW107XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xufTtcblxuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNcbiAgIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSByZXR1cm5zIGFycmF5IG9mIGF0dHJpYnV0ZSBvYmplY3RzXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlcztcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0QXR0cmlidXRlXG4gKiBAZGVzY3JpcHRpb24gY3JlYXRlIGFuIGF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gaXRlbXNpemVcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCBhcnIsIGl0ZW1TaXplKVxue1xuICAgIGxldCBhdHRyVHlwZSA9IFwiXCI7XG4gICAgaWYgKCFpdGVtU2l6ZSB8fCBpdGVtU2l6ZSA+IDQpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcIml0ZW1zaXplIHdyb25nP1wiLCBpdGVtU2l6ZSwgbmFtZSk7XG4gICAgICAgIHRoaXMuX2xvZy5zdGFjayhcIml0ZW1zaXplXCIpO1xuXG4gICAgICAgIGl0ZW1TaXplID0gMztcbiAgICB9XG5cbiAgICBpZiAoaXRlbVNpemUgPT0gMSkgYXR0clR5cGUgPSBcImZsb2F0XCI7XG4gICAgZWxzZSBpZiAoaXRlbVNpemUgPT0gMikgYXR0clR5cGUgPSBcInZlYzJcIjtcbiAgICBlbHNlIGlmIChpdGVtU2l6ZSA9PSAzKSBhdHRyVHlwZSA9IFwidmVjM1wiO1xuICAgIGVsc2UgaWYgKGl0ZW1TaXplID09IDQpIGF0dHJUeXBlID0gXCJ2ZWM0XCI7XG5cblxuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICAgIFwibmFtZVwiOiBuYW1lLFxuICAgICAgICBcImRhdGFcIjogYXJyLFxuICAgICAgICBcIml0ZW1TaXplXCI6IGl0ZW1TaXplLFxuICAgICAgICBcInR5cGVcIjogYXR0clR5cGUsXG4gICAgfTtcblxuICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyO1xufTtcblxuR2VvbWV0cnkucHJvdG90eXBlLmNvcHlBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgbmV3Z2VvbSlcbntcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbmV3Z2VvbS5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEZsb2F0MzJBcnJheShhdHRyLmRhdGEpLCBhdHRyLml0ZW1TaXplKTtcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0VmVydGljZXNcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gc2V0IHZlcnRpY2VzXG4gKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gZGF0YSBbeCx5LHoseCx5LHosLi4uXVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0VmVydGljZXMgPSBmdW5jdGlvbiAoYXJyKVxue1xuICAgIGlmIChhcnIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHRoaXMuX3ZlcnRpY2VzID0gYXJyO1xuICAgIGVsc2UgdGhpcy5fdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGFycik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBzZXRUZXhDb29yZHNcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gc2V0IHRleGNvb3Jkc1xuICogQHBhcmFtIHtBcnJheXxGbG9hdDMyQXJyYXl9IGRhdGEgW3Usdix1LHYsLi4uXVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0VGV4Q29vcmRzID0gZnVuY3Rpb24gKGFycilcbntcbiAgICBpZiAoYXJyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB0aGlzLnRleENvb3JkcyA9IGFycjtcbiAgICBlbHNlIHRoaXMudGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShhcnIpO1xufTtcblxuLy8gR2VvbWV0cnkucHJvdG90eXBlLnRlc3RJbmRpY2VzID0gZnVuY3Rpb24gKClcbi8vIHtcbi8vICAgICB2YXIgZm91bmRFcnJvciA9IGZhbHNlO1xuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpKyspXG4vLyAgICAge1xuLy8gICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXNbaSAqIDMgKyAwXSA+PSB0aGlzLl92ZXJ0aWNlcy5sZW5ndGggLyAzIHx8IHRoaXMudmVydGljZXNJbmRpY2VzW2kgKiAzICsgMV0gPj0gdGhpcy5fdmVydGljZXMubGVuZ3RoIC8gMyB8fCB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICogMyArIDJdID49IHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCAvIDMpXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbmRleCBlcnJvciFcIik7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9O1xuXG4vLyBkZXByZWNhdGVkXG5HZW9tZXRyeS5wcm90b3R5cGUuY2FsY05vcm1hbHMgPSBmdW5jdGlvbiAoc21vb3RoKVxue1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IFwic21vb3RoXCI6IHNtb290aCB9O1xuXG5cbiAgICB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBmbGlwTm9ybWFsc1xuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAZGVzY3JpcHRpb24gZmxpcCBub3JtYWxzXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5mbGlwTm9ybWFscyA9IGZ1bmN0aW9uICh4LCB5LCB6KVxue1xuICAgIGxldCB2ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgaWYgKHggPT0gdW5kZWZpbmVkKXggPSAxO1xuICAgIGlmICh5ID09IHVuZGVmaW5lZCl5ID0gMTtcbiAgICBpZiAoeiA9PSB1bmRlZmluZWQpeiA9IDE7XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSArPSAzKVxuICAgIHtcbiAgICAgICAgdmVjMy5zZXQodmVjLFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW2kgKyAwXSxcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1tpICsgMV0sXG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDJdKTtcblxuICAgICAgICB2ZWNbMF0gKj0gLXg7XG4gICAgICAgIHZlY1sxXSAqPSAteTtcbiAgICAgICAgdmVjWzJdICo9IC16O1xuXG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYywgdmVjKTtcblxuICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDBdID0gdmVjWzBdO1xuICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDFdID0gdmVjWzFdO1xuICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cbn07XG5cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXROdW1UcmlhbmdsZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnZlcnRpY2VzSW5kaWNlcyAmJiB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGgpIHJldHVybiB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzO1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDM7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGZsaXBWZXJ0RGlyXG4gKiBAbWVtYmVyb2YgR2VvbWV0cnlcbiAqIEBkZXNjcmlwdGlvbiBmbGlwIG9yZGVyIG9mIHZlcnRpY2VzIGluIGdlb20gZmFjZXNcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLmZsaXBWZXJ0RGlyID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBuZXdJbmQgPSBbXTtcbiAgICBuZXdJbmQubGVuZ3RoID0gdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAge1xuICAgICAgICBuZXdJbmRbaV0gPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl07XG4gICAgICAgIG5ld0luZFtpICsgMV0gPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV07XG4gICAgICAgIG5ld0luZFtpICsgMl0gPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpXTtcbiAgICB9XG4gICAgdGhpcy52ZXJ0aWNlc0luZGljZXMgPSBuZXdJbmQ7XG59O1xuXG5cbkdlb21ldHJ5LnByb3RvdHlwZS5zZXRQb2ludFZlcnRpY2VzID0gZnVuY3Rpb24gKHZlcnRzKVxue1xuICAgIGlmICh2ZXJ0cy5sZW5ndGggJSAzICE9PSAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiU2V0UG9pbnRWZXJ0aWNlczogQXJyYXkgbXVzdCBiZSBtdWx0aXBsZSBvZiB0aHJlZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh2ZXJ0cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICBlbHNlIHRoaXMudmVydGljZXMgPSB2ZXJ0cztcblxuICAgIGlmICghKHRoaXMudGV4Q29vcmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCh2ZXJ0cy5sZW5ndGggLyAzKSAqIDIpO1xuXG4gICAgLy8gdGhpcy50ZXhDb29yZHMubGVuZ3RoPXZlcnRzLmxlbmd0aC8zKjI7XG4gICAgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoID0gdmVydHMubGVuZ3RoIC8gMztcbiAgICAvLyB0aGlzLnZlcnRpY2VzSW5kaWNlcz1bXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoIC8gMzsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0luZGljZXNbaV0gPSBpO1xuICAgICAgICB0aGlzLnRleENvb3Jkc1tpICogMl0gPSAwO1xuICAgICAgICB0aGlzLnRleENvb3Jkc1tpICogMiArIDFdID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIG1lcmdlIGEgZGlmZmVyZW50IGdlb21ldHJ5IGludG8gdGhlIHRoaXMgZ2VvbWV0cnlcbiAqIEBmdW5jdGlvbiBtZXJnZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbVxuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAaW5zdGFuY2VcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGdlb20pXG57XG4gICAgaWYgKCFnZW9tKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5pc0luZGV4ZWQoKSAhPSBnZW9tLmlzSW5kZXhlZCgpKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmRleGVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5JbmRleChmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb20uaXNJbmRleGVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBnZW9tLmNvcHkoKTtcbiAgICAgICAgICAgIGcudW5JbmRleChmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW9tID0gZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9sZEluZGl6ZXNMZW5ndGggPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmVydExlbmd0aCA9IHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cbiAgICB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggKyBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0luZGljZXNbb2xkSW5kaXplc0xlbmd0aCArIGldID0gZ2VvbS52ZXJ0aWNlc0luZGljZXNbaV0gKyB2ZXJ0TGVuZ3RoO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFVUSUxTLmZsb2F0MzJDb25jYXQodGhpcy5fdmVydGljZXMsIGdlb20udmVydGljZXMpO1xuICAgIHRoaXMudGV4Q29vcmRzID0gVVRJTFMuZmxvYXQzMkNvbmNhdCh0aGlzLnRleENvb3JkcywgZ2VvbS50ZXhDb29yZHMpO1xuICAgIHRoaXMudmVydGV4Tm9ybWFscyA9IFVUSUxTLmZsb2F0MzJDb25jYXQodGhpcy52ZXJ0ZXhOb3JtYWxzLCBnZW9tLnZlcnRleE5vcm1hbHMpO1xuICAgIHRoaXMudGFuZ2VudHMgPSBVVElMUy5mbG9hdDMyQ29uY2F0KHRoaXMudGFuZ2VudHMsIGdlb20udGFuZ2VudHMpO1xuICAgIHRoaXMuYmlUYW5nZW50cyA9IFVUSUxTLmZsb2F0MzJDb25jYXQodGhpcy5iaVRhbmdlbnRzLCBnZW9tLmJpVGFuZ2VudHMpO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgYSBjb3B5IG9mIHRoZSBnZW9tZXRyeVxuICogQGZ1bmN0aW9uIGNvcHlcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBnZW9tID0gbmV3IEdlb21ldHJ5KHRoaXMubmFtZSArIFwiIGNvcHlcIik7XG4gICAgZ2VvbS5mYWNlVmVydENvdW50ID0gdGhpcy5mYWNlVmVydENvdW50O1xuICAgIGdlb20uZ2xQcmltaXRpdmUgPSB0aGlzLmdsUHJpbWl0aXZlO1xuXG4gICAgZ2VvbS5zZXRWZXJ0aWNlcyh0aGlzLl92ZXJ0aWNlcy5zbGljZSgwKSk7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXMpXG4gICAge1xuICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpKyspIGdlb20udmVydGljZXNJbmRpY2VzW2ldID0gdGhpcy52ZXJ0aWNlc0luZGljZXNbaV07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSBpbiB0aGlzLl9hdHRyaWJ1dGVzKSB0aGlzLmNvcHlBdHRyaWJ1dGUoaSwgZ2VvbSk7XG5cbiAgICBnZW9tLm1vcnBoVGFyZ2V0cy5sZW5ndGggPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkrKykgZ2VvbS5tb3JwaFRhcmdldHNbaV0gPSB0aGlzLm1vcnBoVGFyZ2V0c1tpXTtcblxuICAgIHJldHVybiBnZW9tO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVuIG5vcm1hbHNcbiAqIEBmdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzXG4gKiBAbWVtYmVyb2YgR2VvbWV0cnlcbiAqIEBpbnN0YW5jZVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUuY2FsY3VsYXRlTm9ybWFscyA9IGZ1bmN0aW9uIChvcHRpb25zKVxue1xuICAgIC8vIHRvZG86IHNob3VsZCBjaGVjayBhbmdsZSBvZiBub3JtYWxzIHRvIGdldCBlZGdlcyAgICBodHRwczovL2NvbW11bml0eS5raHJvbm9zLm9yZy90L2NhbGN1bGF0aW5nLWFjY3VyYXRlLXZlcnRleC1ub3JtYWxzLzI4MTUyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMuc21vb3RoID09PSBmYWxzZSkgdGhpcy51bkluZGV4KCk7XG5cbiAgICBjb25zdCB1ID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB2ID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCBuID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGNhbGNOb3JtYWwodHJpYW5nbGUpXG4gICAge1xuICAgICAgICB2ZWMzLnN1YnRyYWN0KHUsIHRyaWFuZ2xlWzBdLCB0cmlhbmdsZVsxXSk7XG4gICAgICAgIHZlYzMuc3VidHJhY3QodiwgdHJpYW5nbGVbMF0sIHRyaWFuZ2xlWzJdKTtcbiAgICAgICAgdmVjMy5jcm9zcyhuLCB1LCB2KTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUobiwgbik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZVpVcClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5bMl0gPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5bMF0gKj0gLTE7XG4gICAgICAgICAgICAgICAgblsxXSAqPSAtMTtcbiAgICAgICAgICAgICAgICBuWzJdICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0VmVydGV4VmVjID0gZnVuY3Rpb24gKHdoaWNoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdmVjID0gWzAsIDAsIDBdO1xuICAgICAgICB2ZWNbMF0gPSB0aGlzLnZlcnRpY2VzW3doaWNoICogMyArIDBdO1xuICAgICAgICB2ZWNbMV0gPSB0aGlzLnZlcnRpY2VzW3doaWNoICogMyArIDFdO1xuICAgICAgICB2ZWNbMl0gPSB0aGlzLnZlcnRpY2VzW3doaWNoICogMyArIDJdO1xuICAgICAgICByZXR1cm4gdmVjO1xuICAgIH07XG5cbiAgICBpZiAoISh0aGlzLnZlcnRleE5vcm1hbHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHx8IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGggIT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHRoaXMudmVydGV4Tm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW2ldID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNJbmRleGVkKCkpXG4gICAge1xuICAgICAgICBjb25zdCBub3JtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlID0gW1t0aGlzLnZlcnRpY2VzW2kgKyAwXSwgdGhpcy52ZXJ0aWNlc1tpICsgMV0sIHRoaXMudmVydGljZXNbaSArIDJdXSwgW3RoaXMudmVydGljZXNbaSArIDNdLCB0aGlzLnZlcnRpY2VzW2kgKyA0XSwgdGhpcy52ZXJ0aWNlc1tpICsgNV1dLCBbdGhpcy52ZXJ0aWNlc1tpICsgNl0sIHRoaXMudmVydGljZXNbaSArIDddLCB0aGlzLnZlcnRpY2VzW2kgKyA4XV1dO1xuICAgICAgICAgICAgY29uc3Qgbm4gPSBjYWxjTm9ybWFsKHRyaWFuZ2xlKTtcbiAgICAgICAgICAgIG5vcm1zLnB1c2gobm5bMF0sIG5uWzFdLCBublsyXSwgbm5bMF0sIG5uWzFdLCBublsyXSwgbm5bMF0sIG5uWzFdLCBublsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzID0gbm9ybXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnN0IGZhY2VOb3JtYWxzID0gW107XG5cbiAgICAgICAgZmFjZU5vcm1hbHMubGVuZ3RoID0gTWF0aC5mbG9vcih0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB0cmlhbmdsZSA9IFt0aGlzLmdldFZlcnRleFZlYyh0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMF0pLCB0aGlzLmdldFZlcnRleFZlYyh0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV0pLCB0aGlzLmdldFZlcnRleFZlYyh0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl0pXTtcblxuICAgICAgICAgICAgZmFjZU5vcm1hbHNbaSAvIDNdID0gY2FsY05vcm1hbCh0cmlhbmdsZSk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMF0gKiAzICsgMF0gKz0gZmFjZU5vcm1hbHNbaSAvIDNdWzBdO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAwXSAqIDMgKyAxXSArPSBmYWNlTm9ybWFsc1tpIC8gM11bMV07XG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDBdICogMyArIDJdICs9IGZhY2VOb3JtYWxzW2kgLyAzXVsyXTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAxXSAqIDMgKyAwXSArPSBmYWNlTm9ybWFsc1tpIC8gM11bMF07XG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDFdICogMyArIDFdICs9IGZhY2VOb3JtYWxzW2kgLyAzXVsxXTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV0gKiAzICsgMl0gKz0gZmFjZU5vcm1hbHNbaSAvIDNdWzJdO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDJdICogMyArIDBdICs9IGZhY2VOb3JtYWxzW2kgLyAzXVswXTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl0gKiAzICsgMV0gKz0gZmFjZU5vcm1hbHNbaSAvIDNdWzFdO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAyXSAqIDMgKyAyXSArPSBmYWNlTm9ybWFsc1tpIC8gM11bMl07XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpICs9IDMpIC8vIGZhY2VzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMzsgaysrKSAvLyB0cmlhbmdsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2diA9IFt0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDBdLCB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDFdLCB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDJdXTtcbiAgICAgICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2diwgdnYpO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsga10gKiAzICsgMF0gPSB2dlswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDFdID0gdnZbMV07XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBrXSAqIDMgKyAyXSA9IHZ2WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRhbmdlbnRzICYgYml0YW5nZW50cyB3aXRoIHRoZSBoZWxwIG9mIHV2LWNvb3JkaW5hdGVzLiBBZGFwdGVkIGZyb21cbiAqIExlbmd5ZWwsIEVyaWMuIOKAnENvbXB1dGluZyBUYW5nZW50IFNwYWNlIEJhc2lzIFZlY3RvcnMgZm9yIGFuIEFyYml0cmFyeSBNZXNo4oCdLlxuICogVGVyYXRob24gU29mdHdhcmUgM0QgR3JhcGhpY3MgTGlicmFyeS5cbiAqIGh0dHBzOi8vZmVuaXgudGVjbmljby51bGlzYm9hLnB0L2Rvd25sb2FkRmlsZS84NDUwNDM0MDU0NDkwNzMvVGFuZ2VudCUyMFNwYWNlJTIwQ2FsY3VsYXRpb24ucGRmXG4gKlxuICogQGZ1bmN0aW9uIGNhbGNUYW5nZW50c0JpdGFuZ2VudHNcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5jYWxjVGFuZ2VudHNCaXRhbmdlbnRzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMudmVydGljZXMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5fbG9nLmVycm9yKFwiQ2Fubm90IGNhbGN1bGF0ZSB0YW5nZW50cy9iaXRhbmdlbnRzIHdpdGhvdXQgdmVydGljZXMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIC8vIHRoaXMuX2xvZy5lcnJvcihcIkNhbm5vdCBjYWxjdWxhdGUgdGFuZ2VudHMvYml0YW5nZW50cyB3aXRob3V0IG5vcm1hbHMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy50ZXhDb29yZHMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKFwiTm8gdGV4Y29vcmRzLiBSZXBsYWNpbmcgd2l0aCBkZWZhdWx0IHZhbHVlcyBbMCwgMF0uXCIpO1xuICAgICAgICBjb25zdCB0ZXhDb29yZExlbmd0aCA9ICh0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDMpICogMjtcbiAgICAgICAgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KHRleENvb3JkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXhDb29yZExlbmd0aDsgaSArPSAxKSB0aGlzLnRleENvb3Jkc1tpXSA9IDA7XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJ0aWNlc0luZGljZXMgfHwgIXRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIC8vIHRoaXMuX2xvZy5lcnJvcihcIkNhbm5vdCBjYWxjdWxhdGUgdGFuZ2VudHMvYml0YW5nZW50cyB3aXRob3V0IHZlcnRleCBpbmRpY2VzLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGlzIGNvZGUgYXNzdW1lcyB0aGF0IHdlIGhhdmUgdGhyZWUgaW5kaWNlcyBwZXIgdHJpYW5nbGVcbiAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoICUgMyAhPT0gMClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIlZlcnRleCBpbmRpY2VzIG1pc21hdGNoIVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaWFuZ2xlQ291bnQgPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IHZlcnRleENvdW50ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXG4gICAgdGhpcy50YW5nZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCk7XG4gICAgdGhpcy5iaVRhbmdlbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRleE5vcm1hbHMubGVuZ3RoKTtcblxuICAgIC8vIHRlbXBvcmFyeSBidWZmZXJzXG4gICAgY29uc3QgdGVtcFZlcnRpY2VzID0gW107XG4gICAgdGVtcFZlcnRpY2VzLmxlbmd0aCA9IHZlcnRleENvdW50ICogMjtcbiAgICBjb25zdCB2MSA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgdjIgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHYzID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIGNvbnN0IHcxID0gdmVjMi5jcmVhdGUoKTtcbiAgICBjb25zdCB3MiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgY29uc3QgdzMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgY29uc3Qgc2RpciA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgdGRpciA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICAvLyBmb3IgZGV0YWlscyBvbiBjYWxjdWxhdGlvbiwgc2VlIGFydGljbGUgcmVmZXJlbmNlZCBhYm92ZVxuICAgIGZvciAobGV0IHRyaSA9IDA7IHRyaSA8IHRyaWFuZ2xlQ291bnQ7IHRyaSArPSAxKVxuICAgIHtcbiAgICAgICAgLy8gaW5kaWNlcyBvZiB0aGUgdGhyZWUgdmVydGljZXMgZm9yIGEgdHJpYW5nbGVcbiAgICAgICAgY29uc3QgaTEgPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1t0cmkgKiAzXTtcbiAgICAgICAgY29uc3QgaTIgPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1t0cmkgKiAzICsgMV07XG4gICAgICAgIGNvbnN0IGkzID0gdGhpcy52ZXJ0aWNlc0luZGljZXNbdHJpICogMyArIDJdO1xuXG4gICAgICAgIC8vIHZlcnRleCBwb3NpdGlvbiBhcyB2ZWMzXG4gICAgICAgIHZlYzMuc2V0KHYxLCB0aGlzLnZlcnRpY2VzW2kxICogM10sIHRoaXMudmVydGljZXNbaTEgKiAzICsgMV0sIHRoaXMudmVydGljZXNbaTEgKiAzICsgMl0pO1xuICAgICAgICB2ZWMzLnNldCh2MiwgdGhpcy52ZXJ0aWNlc1tpMiAqIDNdLCB0aGlzLnZlcnRpY2VzW2kyICogMyArIDFdLCB0aGlzLnZlcnRpY2VzW2kyICogMyArIDJdKTtcbiAgICAgICAgdmVjMy5zZXQodjMsIHRoaXMudmVydGljZXNbaTMgKiAzXSwgdGhpcy52ZXJ0aWNlc1tpMyAqIDMgKyAxXSwgdGhpcy52ZXJ0aWNlc1tpMyAqIDMgKyAyXSk7XG5cbiAgICAgICAgLy8gdGV4dHVyZSBjb29yZGluYXRlIGFzIHZlYzJcbiAgICAgICAgdmVjMi5zZXQodzEsIHRoaXMudGV4Q29vcmRzW2kxICogMl0sIHRoaXMudGV4Q29vcmRzW2kxICogMiArIDFdKTtcbiAgICAgICAgdmVjMi5zZXQodzIsIHRoaXMudGV4Q29vcmRzW2kyICogMl0sIHRoaXMudGV4Q29vcmRzW2kyICogMiArIDFdKTtcbiAgICAgICAgdmVjMi5zZXQodzMsIHRoaXMudGV4Q29vcmRzW2kzICogMl0sIHRoaXMudGV4Q29vcmRzW2kzICogMiArIDFdKTtcblxuICAgICAgICBjb25zdCB4MSA9IHYyWzBdIC0gdjFbMF07XG4gICAgICAgIGNvbnN0IHgyID0gdjNbMF0gLSB2MVswXTtcbiAgICAgICAgY29uc3QgeTEgPSB2MlsxXSAtIHYxWzFdO1xuICAgICAgICBjb25zdCB5MiA9IHYzWzFdIC0gdjFbMV07XG4gICAgICAgIGNvbnN0IHoxID0gdjJbMl0gLSB2MVsyXTtcbiAgICAgICAgY29uc3QgejIgPSB2M1syXSAtIHYxWzJdO1xuXG4gICAgICAgIGNvbnN0IHMxID0gdzJbMF0gLSB3MVswXTtcbiAgICAgICAgY29uc3QgczIgPSB3M1swXSAtIHcxWzBdO1xuICAgICAgICBjb25zdCB0MSA9IHcyWzFdIC0gdzFbMV07XG4gICAgICAgIGNvbnN0IHQyID0gdzNbMV0gLSB3MVsxXTtcblxuICAgICAgICBjb25zdCByID0gMS4wIC8gKHMxICogdDIgLSBzMiAqIHQxKTtcblxuICAgICAgICB2ZWMzLnNldChzZGlyLCAodDIgKiB4MSAtIHQxICogeDIpICogciwgKHQyICogeTEgLSB0MSAqIHkyKSAqIHIsICh0MiAqIHoxIC0gdDEgKiB6MikgKiByKTtcbiAgICAgICAgdmVjMy5zZXQodGRpciwgKHMxICogeDIgLSBzMiAqIHgxKSAqIHIsIChzMSAqIHkyIC0gczIgKiB5MSkgKiByLCAoczEgKiB6MiAtIHMyICogejEpICogcik7XG5cbiAgICAgICAgdGVtcFZlcnRpY2VzW2kxXSA9IHNkaXI7XG4gICAgICAgIHRlbXBWZXJ0aWNlc1tpMl0gPSBzZGlyO1xuICAgICAgICB0ZW1wVmVydGljZXNbaTNdID0gc2RpcjtcblxuICAgICAgICB0ZW1wVmVydGljZXNbaTEgKyB2ZXJ0ZXhDb3VudF0gPSB0ZGlyO1xuICAgICAgICB0ZW1wVmVydGljZXNbaTIgKyB2ZXJ0ZXhDb3VudF0gPSB0ZGlyO1xuICAgICAgICB0ZW1wVmVydGljZXNbaTMgKyB2ZXJ0ZXhDb3VudF0gPSB0ZGlyO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgdGVtcFZlcnQgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHRhbiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgYml0YW4gPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHRlbXAxID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB0ZW1wMiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgY3Jvc3NQZCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICBmb3IgKGxldCB2ZXJ0ID0gMDsgdmVydCA8IHZlcnRleENvdW50OyB2ZXJ0ICs9IDEpXG4gICAge1xuICAgICAgICAvLyBOT1RFOiBzb21lIG1lc2hlcyBkb24ndCBoYXZlIGluZGV4IDAgLSBuIGluIHRoZWlyIGluZGV4YnVmZmVyLCBpZiB0aGlzIGlzIHRoZSBjYXNlLCBza2lwIGNhbGN1bGF0aW9uIG9mIHRoaXMgdmVydGV4XG4gICAgICAgIGlmICghdGVtcFZlcnRpY2VzW3ZlcnRdKSBjb250aW51ZTtcblxuICAgICAgICB2ZWMzLnNldChub3JtYWwsIHRoaXMudmVydGV4Tm9ybWFsc1t2ZXJ0ICogM10sIHRoaXMudmVydGV4Tm9ybWFsc1t2ZXJ0ICogMyArIDFdLCB0aGlzLnZlcnRleE5vcm1hbHNbdmVydCAqIDMgKyAyXSk7XG4gICAgICAgIHZlYzMuc2V0KHRlbXBWZXJ0LCB0ZW1wVmVydGljZXNbdmVydF1bMF0sIHRlbXBWZXJ0aWNlc1t2ZXJ0XVsxXSwgdGVtcFZlcnRpY2VzW3ZlcnRdWzJdKTtcblxuICAgICAgICAvLyBHcmFtLVNjaG1pZHQgb3J0aGFnb25hbGl6ZVxuICAgICAgICBjb25zdCBfZHAgPSB2ZWMzLmRvdChub3JtYWwsIHRlbXBWZXJ0KTtcbiAgICAgICAgdmVjMy5zY2FsZSh0ZW1wMSwgbm9ybWFsLCBfZHApO1xuICAgICAgICB2ZWMzLnN1YnRyYWN0KHRlbXAyLCB0ZW1wVmVydCwgdGVtcDEpO1xuXG4gICAgICAgIHZlYzMubm9ybWFsaXplKG5vcm1hbGl6ZWQsIHRlbXAyKTtcbiAgICAgICAgdmVjMy5jcm9zcyhjcm9zc1BkLCBub3JtYWwsIHRlbXBWZXJ0KTtcblxuICAgICAgICBjb25zdCBpbnRlcm1Eb3QgPSB2ZWMzLmRvdChjcm9zc1BkLCB0ZW1wVmVydGljZXNbdmVydCArIHZlcnRleENvdW50XSk7XG4gICAgICAgIGNvbnN0IHcgPSAxLjA7Ly8gaW50ZXJtRG90IDwgMC4wID8gLTEuMCA6IDEuMDtcblxuICAgICAgICB2ZWMzLnNjYWxlKHRhbiwgbm9ybWFsaXplZCwgMSAvIHcpO1xuICAgICAgICB2ZWMzLmNyb3NzKGJpdGFuLCBub3JtYWwsIHRhbik7XG5cbiAgICAgICAgdGhpcy50YW5nZW50c1t2ZXJ0ICogMyArIDBdID0gdGFuWzBdO1xuICAgICAgICB0aGlzLnRhbmdlbnRzW3ZlcnQgKiAzICsgMV0gPSB0YW5bMV07XG4gICAgICAgIHRoaXMudGFuZ2VudHNbdmVydCAqIDMgKyAyXSA9IHRhblsyXTtcbiAgICAgICAgdGhpcy5iaVRhbmdlbnRzW3ZlcnQgKiAzICsgMF0gPSBiaXRhblswXTtcbiAgICAgICAgdGhpcy5iaVRhbmdlbnRzW3ZlcnQgKiAzICsgMV0gPSBiaXRhblsxXTtcbiAgICAgICAgdGhpcy5iaVRhbmdlbnRzW3ZlcnQgKiAzICsgMl0gPSBiaXRhblsyXTtcbiAgICB9XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUuaXNJbmRleGVkID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fdmVydGljZXMubGVuZ3RoID09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggIT0gMDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHVuSW5kZXhcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59XG4gKiBAZGVzY3JpcHRpb24gcmVtb3ZlIGFsbCB2ZXJ0ZXggaW5kaXplcywgdmVydGljZXMgYXJyYXkgd2lsbCBjb250YWluIDMqWFlaIGZvciBldmVyeSB0cmlhbmdsZVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUudW5JbmRleCA9IGZ1bmN0aW9uIChyZUluZGV4LCBkb250Q2FsY05vcm1hbHMpXG57XG4gICAgY29uc3QgbmV3VmVydHMgPSBbXTtcbiAgICBjb25zdCBuZXdJbmRpemVzID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAobGV0IGogaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzW2pdO1xuICAgICAgICBsZXQgbmEgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDM7IHMrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5pdGVtU2l6ZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICBuYS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXSAqIDMgKyAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YVt0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgc10gKiAzICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogMyArIDJdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLml0ZW1TaXplID09IDQpXG4gICAgICAgICAgICAgICAgICAgIG5hLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogNCArIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXSAqIDQgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YVt0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgc10gKiA0ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogNCArIDNdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLml0ZW1TaXplID09IDIpXG4gICAgICAgICAgICAgICAgICAgIG5hLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogMiArIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXSAqIDIgKyAxXSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ci5pdGVtU2l6ZSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICBuYS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXV0pO1xuICAgICAgICAgICAgICAgIGVsc2UgY29uc29sZS5sb2coXCJ1bmtub3duIGF0dHJcIiwgYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBuYSwgYXR0ci5pdGVtU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7IGkgKz0gMylcbiAgICB7XG4gICAgICAgIG5ld1ZlcnRzLnB1c2goXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAwXSAqIDMgKyAwXSxcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDBdICogMyArIDFdLFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMF0gKiAzICsgMl0pO1xuXG4gICAgICAgIG5ld0luZGl6ZXMucHVzaChjb3VudCk7XG4gICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgbmV3VmVydHMucHVzaChcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDFdICogMyArIDBdLFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV0gKiAzICsgMV0sXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAxXSAqIDMgKyAyXSk7XG5cbiAgICAgICAgbmV3SW5kaXplcy5wdXNoKGNvdW50KTtcbiAgICAgICAgY291bnQrKztcblxuICAgICAgICBuZXdWZXJ0cy5wdXNoKFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl0gKiAzICsgMF0sXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAyXSAqIDMgKyAxXSxcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDJdICogMyArIDJdKTtcblxuICAgICAgICBuZXdJbmRpemVzLnB1c2goY291bnQpO1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIHRoaXMudmVydGljZXMgPSBuZXdWZXJ0cztcblxuICAgIHRoaXMudmVydGljZXNJbmRpY2VzID0gW107XG4gICAgaWYgKHJlSW5kZXgpIHRoaXMudmVydGljZXNJbmRpY2VzID0gbmV3SW5kaXplcztcblxuICAgIGlmICghZG9udENhbGNOb3JtYWxzKSB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMoKTtcbn07XG5cbkdlb21ldHJ5LnByb3RvdHlwZS5jYWxjQmFyeWNlbnRyaWMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCBiYXJ5Y2VudHJpY3MgPSBbXTtcbiAgICBiYXJ5Y2VudHJpY3MubGVuZ3RoID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSBiYXJ5Y2VudHJpY3NbaV0gPSAwO1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAge1xuICAgICAgICBiYXJ5Y2VudHJpY3NbaSArIGNvdW50XSA9IDE7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChjb3VudCA9PSAzKSBjb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhdHRyQmFyeWNlbnRyaWNcIiwgYmFyeWNlbnRyaWNzLCAzKTtcbn07XG5cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcyk7XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKHgsIHksIHopXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHggPSB0cnVlO1xuICAgICAgICB5ID0gdHJ1ZTtcbiAgICAgICAgeiA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gW2JvdW5kcy5taW5YICsgKGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgpIC8gMiwgYm91bmRzLm1pblkgKyAoYm91bmRzLm1heFkgLSBib3VuZHMubWluWSkgLyAyLCBib3VuZHMubWluWiArIChib3VuZHMubWF4WiAtIGJvdW5kcy5taW5aKSAvIDJdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAge1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc1tpICsgMF0gPT0gdGhpcy52ZXJ0aWNlc1tpICsgMF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh4KSB0aGlzLnZlcnRpY2VzW2kgKyAwXSAtPSBvZmZzZXRbMF07XG4gICAgICAgICAgICBpZiAoeSkgdGhpcy52ZXJ0aWNlc1tpICsgMV0gLT0gb2Zmc2V0WzFdO1xuICAgICAgICAgICAgaWYgKHopIHRoaXMudmVydGljZXNbaSArIDJdIC09IG9mZnNldFsyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUubWFwVGV4Q29vcmRzMmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3QgbnVtID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXG4gICAgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KG51bSAqIDIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKylcbiAgICB7XG4gICAgICAgIGNvbnN0IHZlcnRYID0gdGhpcy52ZXJ0aWNlc1tpICogMyArIDBdO1xuICAgICAgICBjb25zdCB2ZXJ0WSA9IHRoaXMudmVydGljZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgdGhpcy50ZXhDb29yZHNbaSAqIDIgKyAwXSA9IHZlcnRYIC8gKGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgpICsgMC41O1xuICAgICAgICB0aGlzLnRleENvb3Jkc1tpICogMiArIDFdID0gMS4wIC0gdmVydFkgLyAoYm91bmRzLm1heFkgLSBib3VuZHMubWluWSkgKyAwLjU7XG4gICAgfVxufTtcblxuXG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0SW5mb09uZUxpbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCB0eHQgPSBcIlwiO1xuICAgIGlmICh0aGlzLmZhY2VWZXJ0Q291bnQgPT0gMyAmJiB0aGlzLnZlcnRpY2VzSW5kaWNlcyl0eHQgKz0gdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoIC8gMztcbiAgICBlbHNlIHR4dCArPSAwO1xuXG4gICAgdHh0ICs9IFwiIHRyaXMgXCI7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNlcyl0eHQgKz0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgIGVsc2UgdHh0ICs9IDA7XG5cbiAgICB0eHQgKz0gXCIgdmVydHNcIjtcblxuICAgIHJldHVybiB0eHQ7XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0SW5mbyA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3QgaW5mbyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuZmFjZVZlcnRDb3VudCA9PSAzICYmIHRoaXMudmVydGljZXNJbmRpY2VzKWluZm8ubnVtRmFjZXMgPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1GYWNlcyA9IDA7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXMgJiYgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoKWluZm8uaW5kaWNlcyA9IHRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2VzKWluZm8ubnVtVmVydHMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgZWxzZSBpbmZvLm51bVZlcnRzID0gMDtcblxuICAgIGlmICh0aGlzLnZlcnRleE5vcm1hbHMpIGluZm8ubnVtTm9ybWFscyA9IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1Ob3JtYWxzID0gMDtcblxuICAgIGlmICh0aGlzLnRleENvb3JkcykgaW5mby5udW1UZXhDb29yZHMgPSB0aGlzLnRleENvb3Jkcy5sZW5ndGggLyAyO1xuICAgIGVsc2UgaW5mby5udW1UZXhDb29yZHMgPSAwO1xuXG4gICAgaWYgKHRoaXMudGFuZ2VudHMpIGluZm8ubnVtVGFuZ2VudHMgPSB0aGlzLnRhbmdlbnRzLmxlbmd0aCAvIDM7XG4gICAgZWxzZSBpbmZvLm51bVRhbmdlbnRzID0gMDtcblxuICAgIGlmICh0aGlzLmJpVGFuZ2VudHMpIGluZm8ubnVtQmlUYW5nZW50cyA9IHRoaXMuYmlUYW5nZW50cy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1CaVRhbmdlbnRzID0gMDtcblxuICAgIGlmICh0aGlzLmJpVGFuZ2VudHMpIGluZm8ubnVtQmlUYW5nZW50cyA9IHRoaXMuYmlUYW5nZW50cy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1CaVRhbmdlbnRzID0gMDtcblxuICAgIGlmICh0aGlzLnZlcnRleENvbG9ycykgaW5mby5udW1WZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycy5sZW5ndGggLyA0O1xuICAgIGVsc2UgaW5mby5udW1WZXJ0ZXhDb2xvcnMgPSAwO1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlcygpKSBpbmZvLm51bUF0dHJpYnMgPSBPYmplY3Qua2V5cyh0aGlzLmdldEF0dHJpYnV0ZXMoKSkubGVuZ3RoO1xuICAgIGVsc2UgaW5mby5udW1BdHRyaWJzID0gMDtcblxuICAgIGluZm8uaXNJbmRleGVkID0gdGhpcy5pc0luZGV4ZWQoKTtcblxuICAgIHJldHVybiBpbmZvO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVE9ETyA6IG1vdmUgdGhpcyBpbnRvIFwib2xkXCIgY2lyY2xlIG9wXG5HZW9tZXRyeS5idWlsZEZyb21GYWNlcyA9IGZ1bmN0aW9uIChhcnIsIG5hbWUsIG9wdGltaXplKVxue1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3QgdmVydGljZXNJbmRpY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMylcbiAgICB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJbaSArIDBdO1xuICAgICAgICBjb25zdCBiID0gYXJyW2kgKyAxXTtcbiAgICAgICAgY29uc3QgYyA9IGFycltpICsgMl07XG4gICAgICAgIGNvbnN0IGZhY2UgPSBbLTEsIC0xLCAtMV07XG5cbiAgICAgICAgaWYgKG9wdGltaXplKVxuICAgICAgICAgICAgZm9yIChsZXQgaXYgPSAwOyBpdiA8IHZlcnRpY2VzLmxlbmd0aDsgaXYgKz0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbaXYgKyAwXSA9PSBhWzBdICYmIHZlcnRpY2VzW2l2ICsgMV0gPT0gYVsxXSAmJiB2ZXJ0aWNlc1tpdiArIDJdID09IGFbMl0pIGZhY2VbMF0gPSBpdiAvIDM7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzW2l2ICsgMF0gPT0gYlswXSAmJiB2ZXJ0aWNlc1tpdiArIDFdID09IGJbMV0gJiYgdmVydGljZXNbaXYgKyAyXSA9PSBiWzJdKSBmYWNlWzFdID0gaXYgLyAzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tpdiArIDBdID09IGNbMF0gJiYgdmVydGljZXNbaXYgKyAxXSA9PSBjWzFdICYmIHZlcnRpY2VzW2l2ICsgMl0gPT0gY1syXSkgZmFjZVsyXSA9IGl2IC8gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAoZmFjZVswXSA9PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgICAgIGZhY2VbMF0gPSAodmVydGljZXMubGVuZ3RoIC0gMSkgLyAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhY2VbMV0gPT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goYlswXSwgYlsxXSwgYlsyXSk7XG4gICAgICAgICAgICBmYWNlWzFdID0gKHZlcnRpY2VzLmxlbmd0aCAtIDEpIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWNlWzJdID09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNbMF0sIGNbMV0sIGNbMl0pO1xuICAgICAgICAgICAgZmFjZVsyXSA9ICh2ZXJ0aWNlcy5sZW5ndGggLSAxKSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICB2ZXJ0aWNlc0luZGljZXMucHVzaChwYXJzZUludChmYWNlWzBdLCAxMCkpO1xuICAgICAgICB2ZXJ0aWNlc0luZGljZXMucHVzaChwYXJzZUludChmYWNlWzFdLCAxMCkpO1xuICAgICAgICB2ZXJ0aWNlc0luZGljZXMucHVzaChwYXJzZUludChmYWNlWzJdLCAxMCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGdlb20gPSBuZXcgR2VvbWV0cnkobmFtZSk7XG4gICAgZ2VvbS5uYW1lID0gbmFtZTtcbiAgICBnZW9tLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgZ2VvbS52ZXJ0aWNlc0luZGljZXMgPSB2ZXJ0aWNlc0luZGljZXM7XG5cbiAgICByZXR1cm4gZ2VvbTtcbn07XG5cbi8vIFRPRE86IG5vdCBuZWVkZWQgYW55bW9yZSA/ISBtb3ZlIHRvIGRlcHJlY2F0ZWQgb3BzP1xuR2VvbWV0cnkuanNvbjJnZW9tID0gZnVuY3Rpb24gKGpzb25NZXNoKVxue1xuICAgIGNvbnN0IGdlb20gPSBuZXcgR2VvbWV0cnkoXCJqc29uTWVzaEdlb21cIik7XG4gICAgZ2VvbS52ZXJ0aWNlc0luZGljZXMgPSBbXTtcblxuICAgIGdlb20udmVydGljZXMgPSBqc29uTWVzaC52ZXJ0aWNlcyB8fCBbXTtcbiAgICBnZW9tLnZlcnRleE5vcm1hbHMgPSBqc29uTWVzaC5ub3JtYWxzIHx8IFtdO1xuICAgIGdlb20udmVydGV4Q29sb3JzID0ganNvbk1lc2guY29sb3JzIHx8IFtdO1xuICAgIGdlb20udGFuZ2VudHMgPSBqc29uTWVzaC50YW5nZW50cyB8fCBbXTtcbiAgICBnZW9tLmJpVGFuZ2VudHMgPSBqc29uTWVzaC5iaXRhbmdlbnRzIHx8IFtdO1xuICAgIGlmIChqc29uTWVzaC50ZXh0dXJlY29vcmRzKSBnZW9tLnNldFRleENvb3Jkcyhqc29uTWVzaC50ZXh0dXJlY29vcmRzWzBdKTtcblxuICAgIGlmIChqc29uTWVzaC52ZXJ0aWNlc19iNjQpZ2VvbS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYjY0ZGVjVHlwZWRBcnJheShqc29uTWVzaC52ZXJ0aWNlc19iNjQpKTtcbiAgICBpZiAoanNvbk1lc2gubm9ybWFsc19iNjQpIGdlb20udmVydGV4Tm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYjY0ZGVjVHlwZWRBcnJheShqc29uTWVzaC5ub3JtYWxzX2I2NCkpO1xuICAgIGlmIChqc29uTWVzaC50YW5nZW50c19iNjQpIGdlb20udGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KGI2NGRlY1R5cGVkQXJyYXkoanNvbk1lc2gudGFuZ2VudHNfYjY0KSk7XG4gICAgaWYgKGpzb25NZXNoLmJpdGFuZ2VudHNfYjY0KSBnZW9tLmJpVGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KGI2NGRlY1R5cGVkQXJyYXkoanNvbk1lc2guYml0YW5nZW50c19iNjQpKTtcbiAgICBpZiAoanNvbk1lc2gudGV4dHVyZWNvb3Jkc19iNjQpIGdlb20uc2V0VGV4Q29vcmRzKG5ldyBGbG9hdDMyQXJyYXkoYjY0ZGVjVHlwZWRBcnJheShqc29uTWVzaC50ZXh0dXJlY29vcmRzX2I2NFswXSkpKTtcblxuICAgIGlmIChqc29uTWVzaC5mYWNlc19iNjQpXG4gICAge1xuICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShiNjRkZWNUeXBlZEFycmF5KGpzb25NZXNoLmZhY2VzX2I2NCkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggPSBqc29uTWVzaC5mYWNlcy5sZW5ndGggKiAzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb25NZXNoLmZhY2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlc1tpICogM10gPSBqc29uTWVzaC5mYWNlc1tpXVswXTtcbiAgICAgICAgICAgIGdlb20udmVydGljZXNJbmRpY2VzW2kgKiAzICsgMV0gPSBqc29uTWVzaC5mYWNlc1tpXVsxXTtcbiAgICAgICAgICAgIGdlb20udmVydGljZXNJbmRpY2VzW2kgKiAzICsgMl0gPSBqc29uTWVzaC5mYWNlc1tpXVsyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZW9tO1xufTtcblxuXG5leHBvcnQgeyBHZW9tZXRyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cg/cg_geom.js\n");

/***/ }),

/***/ "./src/core/cg/cg_matrixstack.js":
/*!***************************************!*\
  !*** ./src/core/cg/cg_matrixstack.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MatrixStack\": () => (/* binding */ MatrixStack)\n/* harmony export */ });\n\nconst MatrixStack = function ()\n{\n    this._arr = [mat4.create()];\n    this._index = 0;\n    this.stateCounter = 0;\n};\n\nMatrixStack.prototype.push = function (m)\n{\n    this._index++;\n    this.stateCounter++;\n\n    if (this._index == this._arr.length)\n    {\n        const copy = mat4.create();\n        this._arr.push(copy);\n    }\n\n    mat4.copy(this._arr[this._index], m || this._arr[this._index - 1]);\n\n    return this._arr[this._index];\n};\n\nMatrixStack.prototype.pop = function ()\n{\n    this.stateCounter++;\n\n    this._index--;\n    if (this._index < 0) this._index = 0;\n\n    return this._arr[this._index];\n};\n\nMatrixStack.prototype.length = function ()\n{\n    return this._index;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19tYXRyaXhzdGFjay5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZy9jZ19tYXRyaXhzdGFjay5qcz84MDU5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgTWF0cml4U3RhY2sgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2FyciA9IFttYXQ0LmNyZWF0ZSgpXTtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgdGhpcy5zdGF0ZUNvdW50ZXIgPSAwO1xufTtcblxuTWF0cml4U3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobSlcbntcbiAgICB0aGlzLl9pbmRleCsrO1xuICAgIHRoaXMuc3RhdGVDb3VudGVyKys7XG5cbiAgICBpZiAodGhpcy5faW5kZXggPT0gdGhpcy5fYXJyLmxlbmd0aClcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLl9hcnIucHVzaChjb3B5KTtcbiAgICB9XG5cbiAgICBtYXQ0LmNvcHkodGhpcy5fYXJyW3RoaXMuX2luZGV4XSwgbSB8fCB0aGlzLl9hcnJbdGhpcy5faW5kZXggLSAxXSk7XG5cbiAgICByZXR1cm4gdGhpcy5fYXJyW3RoaXMuX2luZGV4XTtcbn07XG5cbk1hdHJpeFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuc3RhdGVDb3VudGVyKys7XG5cbiAgICB0aGlzLl9pbmRleC0tO1xuICAgIGlmICh0aGlzLl9pbmRleCA8IDApIHRoaXMuX2luZGV4ID0gMDtcblxuICAgIHJldHVybiB0aGlzLl9hcnJbdGhpcy5faW5kZXhdO1xufTtcblxuTWF0cml4U3RhY2sucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xufTtcblxuZXhwb3J0IHsgTWF0cml4U3RhY2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cg/cg_matrixstack.js\n");

/***/ }),

/***/ "./src/core/cg/cg_state.js":
/*!*********************************!*\
  !*** ./src/core/cg/cg_state.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CGState\": () => (/* binding */ CGState)\n/* harmony export */ });\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../eventtarget */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _cg_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cg_canvas */ \"./src/core/cg/cg_canvas.js\");\n/* harmony import */ var _cg_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cg_constants */ \"./src/core/cg/cg_constants.js\");\n/* harmony import */ var _cg_matrixstack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cg_matrixstack */ \"./src/core/cg/cg_matrixstack.js\");\n/* harmony import */ var _preproc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./preproc */ \"./src/core/cg/preproc.js\");\n\n\n\n\n\n\n\n// const CGState ()\nclass CGState extends _eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget\n{\n    constructor(_patch)\n    {\n        super();\n        // this.canvas = null;\n\n        this.fpsCounter = new CABLES.CG.FpsCounter();\n        this._identView = vec3.create();\n        this._ident = vec3.create();\n        vec3.set(this._identView, 0, 0, -2);\n        vec3.set(this._ident, 0, 0, 0);\n\n        this.patch = _patch;\n\n\n\n        this.DEPTH_COMPARE_FUNC_NEVER = 0;\n        this.DEPTH_COMPARE_FUNC_LESS = 1;\n        this.DEPTH_COMPARE_FUNC_EQUAL = 2;\n        this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;\n        this.DEPTH_COMPARE_FUNC_GREATER = 4;\n        this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;\n        this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;\n        this.DEPTH_COMPARE_FUNC_ALWAYS = 7;\n\n\n        /**\n             * Current projection matrix\n             * @memberof Context\n             * @instance\n             * @type {mat4}\n             */\n        this.pMatrix = mat4.create();\n\n        /**\n             * Current model matrix\n             * @memberof Context\n             * @instance\n             * @type {mat4}\n             */\n        this.mMatrix = mat4.create();\n\n        /**\n             * Current view matrix\n             * @memberof Context\n             * @instance\n             * @type {mat4}\n             */\n        this.vMatrix = mat4.create();\n        this._textureslots = [];\n\n        this._pMatrixStack = new _cg_matrixstack__WEBPACK_IMPORTED_MODULE_3__.MatrixStack();\n        this._mMatrixStack = new _cg_matrixstack__WEBPACK_IMPORTED_MODULE_3__.MatrixStack();\n        this._vMatrixStack = new _cg_matrixstack__WEBPACK_IMPORTED_MODULE_3__.MatrixStack();\n\n        this.canvasScale = 1;\n\n        mat4.identity(this.mMatrix);\n        mat4.identity(this.vMatrix);\n\n\n        window.matchMedia(\"screen and (min-resolution: 2dppx)\")\n            .addEventListener(\"change\", (e) =>\n            {\n                this.emitEvent(\"resize\");\n            });\n    }\n\n    get canvasWidth()\n    {\n        return this.cgCanvas.canvasWidth;\n    }\n\n    get canvasHeight()\n    {\n        return this.cgCanvas.canvasHeight;\n    }\n\n    set pixelDensity(p)\n    {\n        if (this.cgCanvas.pixelDensity != p)\n        {\n            this.cgCanvas.pixelDensity = p;\n            this.cgCanvas.updateSize();\n            this.emitEvent(\"resize\");\n        }\n    }\n\n    get pixelDensity()\n    {\n        return this.cgCanvas.pixelDensity;\n    }\n\n\n    getGApiName()\n    {\n        return [\"WebGL\", \"WebGPU\"][this.gApi];\n    }\n\n    get canvas()\n    {\n        return this.cgCanvas.canvasEle;\n    }\n\n    setCanvas(canvEle)\n    {\n        if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle) return;\n        if (typeof canvEle === \"string\") canvEle = document.getElementById(canvEle);\n\n        this.cgCanvas = new _cg_canvas__WEBPACK_IMPORTED_MODULE_1__.CgCanvas({ \"canvasEle\": canvEle, \"cg\": this });\n\n        if (this._setCanvas) this._setCanvas(canvEle);\n\n        this.updateSize();\n    }\n\n    updateSize()\n    {\n        this.cgCanvas.updateSize();\n    }\n\n    setSize(w, h, ignorestyle)\n    {\n        this.cgCanvas.setSize(w, h, ignorestyle);\n    }\n\n    _resizeToWindowSize()\n    {\n        this.setSize(window.innerWidth, window.innerHeight);\n        this.updateSize();\n    }\n\n    _resizeToParentSize()\n    {\n        const p = this.canvas.parentElement;\n        if (!p)\n        {\n            this._log.error(\"cables: can not resize to container element\");\n            return;\n        }\n        this.setSize(p.clientWidth, p.clientHeight);\n\n        this.updateSize();\n    }\n\n    setAutoResize(parent)\n    {\n        window.removeEventListener(\"resize\", this._resizeToWindowSize.bind(this));\n        window.removeEventListener(\"resize\", this._resizeToParentSize.bind(this));\n\n        if (parent == \"window\")\n        {\n            window.addEventListener(\"resize\", this._resizeToWindowSize.bind(this));\n            window.addEventListener(\"orientationchange\", this._resizeToWindowSize.bind(this));\n            this._resizeToWindowSize();\n        }\n        if (parent == \"parent\")\n        {\n            window.addEventListener(\"resize\", this._resizeToParentSize.bind(this));\n            this._resizeToParentSize();\n        }\n    }\n\n\n    /**\n * push a matrix to the projection matrix stack\n * @function pushPMatrix\n * @memberof Context\n * @instance\n * @param {mat4} projectionmatrix\n */\n    pushPMatrix()\n    {\n        this.pMatrix = this._pMatrixStack.push(this.pMatrix);\n    }\n\n    /**\n  * pop projection matrix stack\n  * @function popPMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current projectionmatrix\n  */\n    popPMatrix()\n    {\n        this.pMatrix = this._pMatrixStack.pop();\n        return this.pMatrix;\n    }\n\n    getProjectionMatrixStateCount()\n    {\n        return this._pMatrixStack.stateCounter;\n    }\n\n    /**\n  * push a matrix to the model matrix stack\n  * @function pushModelMatrix\n  * @memberof Context\n  * @instance\n  * @param {mat4} modelmatrix\n  * @example\n  * // see source code of translate op:\n  * cgl.pushModelMatrix();\n  * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);\n  * trigger.trigger();\n  * cgl.popModelMatrix();\n  */\n    pushModelMatrix()\n    {\n        this.mMatrix = this._mMatrixStack.push(this.mMatrix);\n    }\n\n    /**\n  * pop model matrix stack\n  * @function popModelMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current modelmatrix\n  */\n    popModelMatrix()\n    {\n        // todo: DEPRECATE\n        // if (this._mMatrixStack.length === 0) throw \"Invalid modelview popMatrix!\";\n        this.mMatrix = this._mMatrixStack.pop();\n        return this.mMatrix;\n    }\n\n    /**\n  * get model matrix\n  * @function modelMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current modelmatrix\n  */\n    modelMatrix()\n    {\n        return this.mMatrix;\n    }\n\n\n    /**\n * push a matrix to the view matrix stack\n * @function pushviewMatrix\n * @memberof Context\n * @instance\n * @param {mat4} viewmatrix\n */\n    pushViewMatrix()\n    {\n        this.vMatrix = this._vMatrixStack.push(this.vMatrix);\n    }\n\n    /**\n  * pop view matrix stack\n  * @function popViewMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current viewmatrix\n  * @function\n  */\n    popViewMatrix()\n    {\n        this.vMatrix = this._vMatrixStack.pop();\n    }\n\n    getViewMatrixStateCount()\n    {\n        return this._vMatrixStack.stateCounter;\n    }\n\n    _startMatrixStacks(identTranslate, identTranslateView)\n    {\n        identTranslate = identTranslate || this._ident;\n        identTranslateView = identTranslateView || this._identView;\n\n        mat4.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, 0.1, 1000.0);\n\n        mat4.identity(this.mMatrix);\n        mat4.identity(this.vMatrix);\n        mat4.translate(this.mMatrix, this.mMatrix, identTranslate);\n        mat4.translate(this.vMatrix, this.vMatrix, identTranslateView);\n\n        this.pushPMatrix();\n        this.pushModelMatrix();\n        this.pushViewMatrix();\n    }\n\n    _endMatrixStacks()\n    {\n        this.popViewMatrix();\n        this.popModelMatrix();\n        this.popPMatrix();\n    }\n\n    dispose()\n    {\n        this.aborted = true;\n        if (this.cgCanvas) this.cgCanvas.dispose();\n        if (this._dispose) this._dispose();\n    }\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19zdGF0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvY2dfc3RhdGUuanM/MGNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuLi9ldmVudHRhcmdldFwiO1xuaW1wb3J0IHsgQ2dDYW52YXMgfSBmcm9tIFwiLi9jZ19jYW52YXNcIjtcbmltcG9ydCB7IENHIH0gZnJvbSBcIi4vY2dfY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBNYXRyaXhTdGFjayB9IGZyb20gXCIuL2NnX21hdHJpeHN0YWNrXCI7XG5pbXBvcnQgUHJlcHJvY2Vzc29yIGZyb20gXCIuL3ByZXByb2NcIjtcblxuXG4vLyBjb25zdCBDR1N0YXRlICgpXG5jbGFzcyBDR1N0YXRlIGV4dGVuZHMgRXZlbnRUYXJnZXRcbntcbiAgICBjb25zdHJ1Y3RvcihfcGF0Y2gpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5mcHNDb3VudGVyID0gbmV3IENBQkxFUy5DRy5GcHNDb3VudGVyKCk7XG4gICAgICAgIHRoaXMuX2lkZW50VmlldyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuX2lkZW50ID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgdmVjMy5zZXQodGhpcy5faWRlbnRWaWV3LCAwLCAwLCAtMik7XG4gICAgICAgIHZlYzMuc2V0KHRoaXMuX2lkZW50LCAwLCAwLCAwKTtcblxuICAgICAgICB0aGlzLnBhdGNoID0gX3BhdGNoO1xuXG5cblxuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19ORVZFUiA9IDA7XG4gICAgICAgIHRoaXMuREVQVEhfQ09NUEFSRV9GVU5DX0xFU1MgPSAxO1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19FUVVBTCA9IDI7XG4gICAgICAgIHRoaXMuREVQVEhfQ09NUEFSRV9GVU5DX0xFU1NFUVVBTCA9IDM7XG4gICAgICAgIHRoaXMuREVQVEhfQ09NUEFSRV9GVU5DX0dSRUFURVIgPSA0O1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19OT1RFUVVBTCA9IDU7XG4gICAgICAgIHRoaXMuREVQVEhfQ09NUEFSRV9GVU5DX0dSRUFURVJFUVVBTCA9IDY7XG4gICAgICAgIHRoaXMuREVQVEhfQ09NUEFSRV9GVU5DX0FMV0FZUyA9IDc7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEN1cnJlbnQgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHttYXQ0fVxuICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMucE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDdXJyZW50IG1vZGVsIG1hdHJpeFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHR5cGUge21hdDR9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEN1cnJlbnQgdmlldyBtYXRyaXhcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHttYXQ0fVxuICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMudk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzbG90cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3BNYXRyaXhTdGFjayA9IG5ldyBNYXRyaXhTdGFjaygpO1xuICAgICAgICB0aGlzLl9tTWF0cml4U3RhY2sgPSBuZXcgTWF0cml4U3RhY2soKTtcbiAgICAgICAgdGhpcy5fdk1hdHJpeFN0YWNrID0gbmV3IE1hdHJpeFN0YWNrKCk7XG5cbiAgICAgICAgdGhpcy5jYW52YXNTY2FsZSA9IDE7XG5cbiAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLm1NYXRyaXgpO1xuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMudk1hdHJpeCk7XG5cblxuICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYShcInNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweClcIilcbiAgICAgICAgICAgIC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicmVzaXplXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IGNhbnZhc1dpZHRoKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNnQ2FudmFzLmNhbnZhc1dpZHRoO1xuICAgIH1cblxuICAgIGdldCBjYW52YXNIZWlnaHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2dDYW52YXMuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIHNldCBwaXhlbERlbnNpdHkocClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNnQ2FudmFzLnBpeGVsRGVuc2l0eSAhPSBwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNnQ2FudmFzLnBpeGVsRGVuc2l0eSA9IHA7XG4gICAgICAgICAgICB0aGlzLmNnQ2FudmFzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicmVzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBpeGVsRGVuc2l0eSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jZ0NhbnZhcy5waXhlbERlbnNpdHk7XG4gICAgfVxuXG5cbiAgICBnZXRHQXBpTmFtZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gW1wiV2ViR0xcIiwgXCJXZWJHUFVcIl1bdGhpcy5nQXBpXTtcbiAgICB9XG5cbiAgICBnZXQgY2FudmFzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNnQ2FudmFzLmNhbnZhc0VsZTtcbiAgICB9XG5cbiAgICBzZXRDYW52YXMoY2FudkVsZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNnQ2FudmFzICYmIGNhbnZFbGUgPT0gdGhpcy5jZ0NhbnZhcy5jYW52YXNFbGUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBjYW52RWxlID09PSBcInN0cmluZ1wiKSBjYW52RWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudkVsZSk7XG5cbiAgICAgICAgdGhpcy5jZ0NhbnZhcyA9IG5ldyBDZ0NhbnZhcyh7IFwiY2FudmFzRWxlXCI6IGNhbnZFbGUsIFwiY2dcIjogdGhpcyB9KTtcblxuICAgICAgICBpZiAodGhpcy5fc2V0Q2FudmFzKSB0aGlzLl9zZXRDYW52YXMoY2FudkVsZSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2l6ZSgpXG4gICAge1xuICAgICAgICB0aGlzLmNnQ2FudmFzLnVwZGF0ZVNpemUoKTtcbiAgICB9XG5cbiAgICBzZXRTaXplKHcsIGgsIGlnbm9yZXN0eWxlKVxuICAgIHtcbiAgICAgICAgdGhpcy5jZ0NhbnZhcy5zZXRTaXplKHcsIGgsIGlnbm9yZXN0eWxlKTtcbiAgICB9XG5cbiAgICBfcmVzaXplVG9XaW5kb3dTaXplKClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuXG4gICAgX3Jlc2l6ZVRvUGFyZW50U2l6ZSgpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5jYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJjYWJsZXM6IGNhbiBub3QgcmVzaXplIHRvIGNvbnRhaW5lciBlbGVtZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2l6ZShwLmNsaWVudFdpZHRoLCBwLmNsaWVudEhlaWdodCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0QXV0b1Jlc2l6ZShwYXJlbnQpXG4gICAge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVUb1dpbmRvd1NpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZVRvUGFyZW50U2l6ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAocGFyZW50ID09IFwid2luZG93XCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZVRvV2luZG93U2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplVG9XaW5kb3dTaXplLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplVG9XaW5kb3dTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCA9PSBcInBhcmVudFwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVUb1BhcmVudFNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVUb1BhcmVudFNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gKiBwdXNoIGEgbWF0cml4IHRvIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBzdGFja1xuICogQGZ1bmN0aW9uIHB1c2hQTWF0cml4XG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge21hdDR9IHByb2plY3Rpb25tYXRyaXhcbiAqL1xuICAgIHB1c2hQTWF0cml4KClcbiAgICB7XG4gICAgICAgIHRoaXMucE1hdHJpeCA9IHRoaXMuX3BNYXRyaXhTdGFjay5wdXNoKHRoaXMucE1hdHJpeCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICogcG9wIHByb2plY3Rpb24gbWF0cml4IHN0YWNrXG4gICogQGZ1bmN0aW9uIHBvcFBNYXRyaXhcbiAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAqIEBpbnN0YW5jZVxuICAqIEByZXR1cm5zIHttYXQ0fSBjdXJyZW50IHByb2plY3Rpb25tYXRyaXhcbiAgKi9cbiAgICBwb3BQTWF0cml4KClcbiAgICB7XG4gICAgICAgIHRoaXMucE1hdHJpeCA9IHRoaXMuX3BNYXRyaXhTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucE1hdHJpeDtcbiAgICB9XG5cbiAgICBnZXRQcm9qZWN0aW9uTWF0cml4U3RhdGVDb3VudCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fcE1hdHJpeFN0YWNrLnN0YXRlQ291bnRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgKiBwdXNoIGEgbWF0cml4IHRvIHRoZSBtb2RlbCBtYXRyaXggc3RhY2tcbiAgKiBAZnVuY3Rpb24gcHVzaE1vZGVsTWF0cml4XG4gICogQG1lbWJlcm9mIENvbnRleHRcbiAgKiBAaW5zdGFuY2VcbiAgKiBAcGFyYW0ge21hdDR9IG1vZGVsbWF0cml4XG4gICogQGV4YW1wbGVcbiAgKiAvLyBzZWUgc291cmNlIGNvZGUgb2YgdHJhbnNsYXRlIG9wOlxuICAqIGNnbC5wdXNoTW9kZWxNYXRyaXgoKTtcbiAgKiBtYXQ0LnRyYW5zbGF0ZShjZ2wubU1hdHJpeCxjZ2wubU1hdHJpeCwgdmVjKTtcbiAgKiB0cmlnZ2VyLnRyaWdnZXIoKTtcbiAgKiBjZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgKi9cbiAgICBwdXNoTW9kZWxNYXRyaXgoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tTWF0cml4ID0gdGhpcy5fbU1hdHJpeFN0YWNrLnB1c2godGhpcy5tTWF0cml4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgKiBwb3AgbW9kZWwgbWF0cml4IHN0YWNrXG4gICogQGZ1bmN0aW9uIHBvcE1vZGVsTWF0cml4XG4gICogQG1lbWJlcm9mIENvbnRleHRcbiAgKiBAaW5zdGFuY2VcbiAgKiBAcmV0dXJucyB7bWF0NH0gY3VycmVudCBtb2RlbG1hdHJpeFxuICAqL1xuICAgIHBvcE1vZGVsTWF0cml4KClcbiAgICB7XG4gICAgICAgIC8vIHRvZG86IERFUFJFQ0FURVxuICAgICAgICAvLyBpZiAodGhpcy5fbU1hdHJpeFN0YWNrLmxlbmd0aCA9PT0gMCkgdGhyb3cgXCJJbnZhbGlkIG1vZGVsdmlldyBwb3BNYXRyaXghXCI7XG4gICAgICAgIHRoaXMubU1hdHJpeCA9IHRoaXMuX21NYXRyaXhTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubU1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgKiBnZXQgbW9kZWwgbWF0cml4XG4gICogQGZ1bmN0aW9uIG1vZGVsTWF0cml4XG4gICogQG1lbWJlcm9mIENvbnRleHRcbiAgKiBAaW5zdGFuY2VcbiAgKiBAcmV0dXJucyB7bWF0NH0gY3VycmVudCBtb2RlbG1hdHJpeFxuICAqL1xuICAgIG1vZGVsTWF0cml4KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm1NYXRyaXg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAqIHB1c2ggYSBtYXRyaXggdG8gdGhlIHZpZXcgbWF0cml4IHN0YWNrXG4gKiBAZnVuY3Rpb24gcHVzaHZpZXdNYXRyaXhcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7bWF0NH0gdmlld21hdHJpeFxuICovXG4gICAgcHVzaFZpZXdNYXRyaXgoKVxuICAgIHtcbiAgICAgICAgdGhpcy52TWF0cml4ID0gdGhpcy5fdk1hdHJpeFN0YWNrLnB1c2godGhpcy52TWF0cml4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgKiBwb3AgdmlldyBtYXRyaXggc3RhY2tcbiAgKiBAZnVuY3Rpb24gcG9wVmlld01hdHJpeFxuICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICogQGluc3RhbmNlXG4gICogQHJldHVybnMge21hdDR9IGN1cnJlbnQgdmlld21hdHJpeFxuICAqIEBmdW5jdGlvblxuICAqL1xuICAgIHBvcFZpZXdNYXRyaXgoKVxuICAgIHtcbiAgICAgICAgdGhpcy52TWF0cml4ID0gdGhpcy5fdk1hdHJpeFN0YWNrLnBvcCgpO1xuICAgIH1cblxuICAgIGdldFZpZXdNYXRyaXhTdGF0ZUNvdW50KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl92TWF0cml4U3RhY2suc3RhdGVDb3VudGVyO1xuICAgIH1cblxuICAgIF9zdGFydE1hdHJpeFN0YWNrcyhpZGVudFRyYW5zbGF0ZSwgaWRlbnRUcmFuc2xhdGVWaWV3KVxuICAgIHtcbiAgICAgICAgaWRlbnRUcmFuc2xhdGUgPSBpZGVudFRyYW5zbGF0ZSB8fCB0aGlzLl9pZGVudDtcbiAgICAgICAgaWRlbnRUcmFuc2xhdGVWaWV3ID0gaWRlbnRUcmFuc2xhdGVWaWV3IHx8IHRoaXMuX2lkZW50VmlldztcblxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucE1hdHJpeCwgNDUsIHRoaXMuY2FudmFzV2lkdGggLyB0aGlzLmNhbnZhc0hlaWdodCwgMC4xLCAxMDAwLjApO1xuXG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy5tTWF0cml4KTtcbiAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLnZNYXRyaXgpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLm1NYXRyaXgsIHRoaXMubU1hdHJpeCwgaWRlbnRUcmFuc2xhdGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnZNYXRyaXgsIHRoaXMudk1hdHJpeCwgaWRlbnRUcmFuc2xhdGVWaWV3KTtcblxuICAgICAgICB0aGlzLnB1c2hQTWF0cml4KCk7XG4gICAgICAgIHRoaXMucHVzaE1vZGVsTWF0cml4KCk7XG4gICAgICAgIHRoaXMucHVzaFZpZXdNYXRyaXgoKTtcbiAgICB9XG5cbiAgICBfZW5kTWF0cml4U3RhY2tzKClcbiAgICB7XG4gICAgICAgIHRoaXMucG9wVmlld01hdHJpeCgpO1xuICAgICAgICB0aGlzLnBvcE1vZGVsTWF0cml4KCk7XG4gICAgICAgIHRoaXMucG9wUE1hdHJpeCgpO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuY2dDYW52YXMpIHRoaXMuY2dDYW52YXMuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZSkgdGhpcy5fZGlzcG9zZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ0dTdGF0ZSB9O1xuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cg/cg_state.js\n");

/***/ }),

/***/ "./src/core/cg/cg_uniform.js":
/*!***********************************!*\
  !*** ./src/core/cg/cg_uniform.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _core_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core_port */ \"./src/core/core_port.js\");\n\n\n\nclass CgUniform\n{\n    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n    {\n        this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cg_uniform\");\n        this._type = __type;\n        this._name = __name;\n        this._shader = __shader;\n        this._value = 0.00001;\n        this._oldValue = null;\n        this._port = null;\n        this._structName = _structName;\n        this._structUniformName = _structUniformName;\n        this._propertyName = _propertyName;\n\n        this._shader._addUniform(this);\n        this.needsUpdate = true;\n        this.shaderType = null;\n        this.comment = null;\n\n        if (__type == \"f\")\n        {\n            this.set = this.setValue = this.setValueF.bind(this);\n            this.updateValue = this.updateValueF.bind(this);\n        }\n        else if (__type == \"f[]\")\n        {\n            this.set = this.setValue = this.setValueArrayF.bind(this);\n            this.updateValue = this.updateValueArrayF.bind(this);\n        }\n        else if (__type == \"2f[]\")\n        {\n            this.set = this.setValue = this.setValueArray2F.bind(this);\n            this.updateValue = this.updateValueArray2F.bind(this);\n        }\n        else if (__type == \"3f[]\")\n        {\n            this.set = this.setValue = this.setValueArray3F.bind(this);\n            this.updateValue = this.updateValueArray3F.bind(this);\n        }\n        else if (__type == \"4f[]\")\n        {\n            this.set = this.setValue = this.setValueArray4F.bind(this);\n            this.updateValue = this.updateValueArray4F.bind(this);\n        }\n        else if (__type == \"i\")\n        {\n            this.set = this.setValue = this.setValueI.bind(this);\n            this.updateValue = this.updateValueI.bind(this);\n        }\n        else if (__type == \"2i\")\n        {\n            this.set = this.setValue = this.setValue2I.bind(this);\n            this.updateValue = this.updateValue2I.bind(this);\n        }\n        else if (__type == \"3i\")\n        {\n            this.set = this.setValue = this.setValue3I.bind(this);\n            this.updateValue = this.updateValue3I.bind(this);\n        }\n        else if (__type == \"4i\")\n        {\n            this.set = this.setValue = this.setValue4I.bind(this);\n            this.updateValue = this.updateValue4I.bind(this);\n        }\n        else if (__type == \"b\")\n        {\n            this.set = this.setValue = this.setValueBool.bind(this);\n            this.updateValue = this.updateValueBool.bind(this);\n        }\n        else if (__type == \"4f\")\n        {\n            this.set = this.setValue = this.setValue4F.bind(this);\n            this.updateValue = this.updateValue4F.bind(this);\n        }\n        else if (__type == \"3f\")\n        {\n            this.set = this.setValue = this.setValue3F.bind(this);\n            this.updateValue = this.updateValue3F.bind(this);\n        }\n        else if (__type == \"2f\")\n        {\n            this.set = this.setValue = this.setValue2F.bind(this);\n            this.updateValue = this.updateValue2F.bind(this);\n        }\n        else if (__type == \"t\")\n        {\n            this.set = this.setValue = this.setValueT.bind(this);\n            this.updateValue = this.updateValueT.bind(this);\n        }\n        else if (__type == \"tc\")\n        {\n            this.set = this.setValue = this.setValueT.bind(this);\n            this.updateValue = this.updateValueT.bind(this);\n        }\n        else if (__type == \"t[]\")\n        {\n            this.set = this.setValue = this.setValueArrayT.bind(this);\n            this.updateValue = this.updateValueArrayT.bind(this);\n        }\n        else if (__type == \"m4\" || __type == \"m4[]\")\n        {\n            this.set = this.setValue = this.setValueM4.bind(this);\n            this.updateValue = this.updateValueM4.bind(this);\n        }\n        else throw new Error(\"Unknown uniform type\");\n\n        if (typeof _value == \"object\" && _value instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port)\n        {\n            this._port = _value;\n            this._value = this._port.get();\n\n\n            if (_port2 && _port3 && _port4)\n            {\n                if (!(_port2 instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port) || !(_port3 instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port) || !(_port4 instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port))\n                {\n                    this._log.error(\"[cgl_uniform] mixed port/value parameter for vec4 \", this._name);\n                }\n\n                this._value = [0, 0, 0, 0];\n                this._port2 = _port2;\n                this._port3 = _port3;\n                this._port4 = _port4;\n\n                this._port.on(\"change\", this.updateFromPort4f.bind(this));\n                this._port2.on(\"change\", this.updateFromPort4f.bind(this));\n                this._port3.on(\"change\", this.updateFromPort4f.bind(this));\n                this._port4.on(\"change\", this.updateFromPort4f.bind(this));\n\n                // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);\n                this.updateFromPort4f();\n            }\n            else if (_port2 && _port3)\n            {\n                if (!(_port2 instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port) || !(_port3 instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port))\n                {\n                    this._log.error(\"[cgl_uniform] mixed port/value parameter for vec4 \", this._name);\n                }\n\n                this._value = [0, 0, 0];\n                this._port2 = _port2;\n                this._port3 = _port3;\n                // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);\n                this._port.on(\"change\", this.updateFromPort3f.bind(this));\n                this._port2.on(\"change\", this.updateFromPort3f.bind(this));\n                this._port3.on(\"change\", this.updateFromPort3f.bind(this));\n\n                this.updateFromPort3f();\n            }\n            else if (_port2)\n            {\n                if (!(_port2 instanceof _core_port__WEBPACK_IMPORTED_MODULE_1__.Port))\n                {\n                    this._log.error(\"[cgl_uniform] mixed port/value parameter for vec4 \", this._name);\n                }\n\n                this._value = [0, 0];\n                this._port2 = _port2;\n                // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);\n                this._port.on(\"change\", this.updateFromPort2f.bind(this));\n                this._port2.on(\"change\", this.updateFromPort2f.bind(this));\n\n                this.updateFromPort2f();\n            }\n            else\n            {\n                // this._port.on = this.updateFromPort.bind(this);\n                this._port.on(\"change\", this.updateFromPort.bind(this));\n            }\n        }\n        else this._value = _value;\n\n        this.setValue(this._value);\n        this.needsUpdate = true;\n    }\n\n\n    getType()\n    {\n        return this._type;\n    }\n\n    getName()\n    {\n        return this._name;\n    }\n\n    getValue()\n    {\n        return this._value;\n    }\n\n    getShaderType()\n    {\n        return this.shaderType;\n    }\n\n    isStructMember()\n    {\n        return !!this._structName;\n    }\n\n\n    updateFromPort4f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this._value[3] = this._port4.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort3f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort2f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort()\n    {\n        this.setValue(this._port.get());\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CgUniform);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ191bmlmb3JtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvY2dfdW5pZm9ybS5qcz9mMmVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5pbXBvcnQgeyBQb3J0IH0gZnJvbSBcIi4uL2NvcmVfcG9ydFwiO1xuXG5jbGFzcyBDZ1VuaWZvcm1cbntcbiAgICBjb25zdHJ1Y3RvcihfX3NoYWRlciwgX190eXBlLCBfX25hbWUsIF92YWx1ZSwgX3BvcnQyLCBfcG9ydDMsIF9wb3J0NCwgX3N0cnVjdFVuaWZvcm1OYW1lLCBfc3RydWN0TmFtZSwgX3Byb3BlcnR5TmFtZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ191bmlmb3JtXCIpO1xuICAgICAgICB0aGlzLl90eXBlID0gX190eXBlO1xuICAgICAgICB0aGlzLl9uYW1lID0gX19uYW1lO1xuICAgICAgICB0aGlzLl9zaGFkZXIgPSBfX3NoYWRlcjtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAwLjAwMDAxO1xuICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHJ1Y3ROYW1lID0gX3N0cnVjdE5hbWU7XG4gICAgICAgIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lID0gX3N0cnVjdFVuaWZvcm1OYW1lO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWUgPSBfcHJvcGVydHlOYW1lO1xuXG4gICAgICAgIHRoaXMuX3NoYWRlci5fYWRkVW5pZm9ybSh0aGlzKTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKF9fdHlwZSA9PSBcImZcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUYuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcImZbXVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IHRoaXMuc2V0VmFsdWUgPSB0aGlzLnNldFZhbHVlQXJyYXlGLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZUFycmF5Ri5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjJmW11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5MkYuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQXJyYXkyRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjNmW11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5M0YuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQXJyYXkzRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjRmW11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5NEYuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQXJyYXk0Ri5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcImlcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlSS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjJpXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUySS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUySS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjNpXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUzSS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUzSS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjRpXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWU0SS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWU0SS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcImJcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUJvb2wuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQm9vbC5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjRmXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWU0Ri5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWU0Ri5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjNmXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUzRi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUzRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjJmXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUyRi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUyRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcInRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZVQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlVC5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcInRjXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWVULmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZVQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfX3R5cGUgPT0gXCJ0W11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5VC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWVBcnJheVQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfX3R5cGUgPT0gXCJtNFwiIHx8IF9fdHlwZSA9PSBcIm00W11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZU00LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZU00LmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaWZvcm0gdHlwZVwiKTtcblxuICAgICAgICBpZiAodHlwZW9mIF92YWx1ZSA9PSBcIm9iamVjdFwiICYmIF92YWx1ZSBpbnN0YW5jZW9mIFBvcnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSBfdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3BvcnQuZ2V0KCk7XG5cblxuICAgICAgICAgICAgaWYgKF9wb3J0MiAmJiBfcG9ydDMgJiYgX3BvcnQ0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghKF9wb3J0MiBpbnN0YW5jZW9mIFBvcnQpIHx8ICEoX3BvcnQzIGluc3RhbmNlb2YgUG9ydCkgfHwgIShfcG9ydDQgaW5zdGFuY2VvZiBQb3J0KSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltjZ2xfdW5pZm9ybV0gbWl4ZWQgcG9ydC92YWx1ZSBwYXJhbWV0ZXIgZm9yIHZlYzQgXCIsIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyID0gX3BvcnQyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQzID0gX3BvcnQzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQ0ID0gX3BvcnQ0O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydC5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0NGYuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydDIub24oXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVGcm9tUG9ydDRmLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQzLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlRnJvbVBvcnQ0Zi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0NC5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0NGYuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9wb3J0Lm9uQ2hhbmdlID0gdGhpcy5fcG9ydDIub25DaGFuZ2UgPSB0aGlzLl9wb3J0My5vbkNoYW5nZSA9IHRoaXMuX3BvcnQ0Lm9uQ2hhbmdlID0gdGhpcy51cGRhdGVGcm9tUG9ydDRmLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUG9ydDRmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfcG9ydDIgJiYgX3BvcnQzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghKF9wb3J0MiBpbnN0YW5jZW9mIFBvcnQpIHx8ICEoX3BvcnQzIGluc3RhbmNlb2YgUG9ydCkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJbY2dsX3VuaWZvcm1dIG1peGVkIHBvcnQvdmFsdWUgcGFyYW1ldGVyIGZvciB2ZWM0IFwiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0MiA9IF9wb3J0MjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0MyA9IF9wb3J0MztcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9wb3J0Lm9uQ2hhbmdlID0gdGhpcy5fcG9ydDIub25DaGFuZ2UgPSB0aGlzLl9wb3J0My5vbkNoYW5nZSA9IHRoaXMudXBkYXRlRnJvbVBvcnQzZi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQub24oXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVGcm9tUG9ydDNmLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlRnJvbVBvcnQzZi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0My5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0M2YuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21Qb3J0M2YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9wb3J0MilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIShfcG9ydDIgaW5zdGFuY2VvZiBQb3J0KSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltjZ2xfdW5pZm9ybV0gbWl4ZWQgcG9ydC92YWx1ZSBwYXJhbWV0ZXIgZm9yIHZlYzQgXCIsIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyID0gX3BvcnQyO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3BvcnQub25DaGFuZ2UgPSB0aGlzLl9wb3J0Mi5vbkNoYW5nZSA9IHRoaXMudXBkYXRlRnJvbVBvcnQyZi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQub24oXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVGcm9tUG9ydDJmLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlRnJvbVBvcnQyZi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVBvcnQyZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3BvcnQub24gPSB0aGlzLnVwZGF0ZUZyb21Qb3J0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydC5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG5cbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgZ2V0VHlwZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICBnZXROYW1lKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIGdldFZhbHVlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBnZXRTaGFkZXJUeXBlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlclR5cGU7XG4gICAgfVxuXG4gICAgaXNTdHJ1Y3RNZW1iZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc3RydWN0TmFtZTtcbiAgICB9XG5cblxuICAgIHVwZGF0ZUZyb21Qb3J0NGYoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWVbMF0gPSB0aGlzLl9wb3J0LmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsxXSA9IHRoaXMuX3BvcnQyLmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsyXSA9IHRoaXMuX3BvcnQzLmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVszXSA9IHRoaXMuX3BvcnQ0LmdldCgpO1xuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tUG9ydDNmKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzBdID0gdGhpcy5fcG9ydC5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMV0gPSB0aGlzLl9wb3J0Mi5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMl0gPSB0aGlzLl9wb3J0My5nZXQoKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRnJvbVBvcnQyZigpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZVswXSA9IHRoaXMuX3BvcnQuZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzFdID0gdGhpcy5fcG9ydDIuZ2V0KCk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZUZyb21Qb3J0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fcG9ydC5nZXQoKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDZ1VuaWZvcm07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/cg_uniform.js\n");

/***/ }),

/***/ "./src/core/cg/preproc.js":
/*!********************************!*\
  !*** ./src/core/cg/preproc.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n   * @type {!RegExp}\n   * @inner\n   */\nlet GLOB_EXP = /(?:^|[^\\\\])\\*/;\n\n/**\n    * @type {!RegExp}\n    * @inner\n    */\nlet NOT_LINE_ENDING = /[^\\r\\n]/g;\n\n/**\n    * Constructs a new Preprocessor.\n    * @exports Preprocessor\n    * @class Provides pre-processing of JavaScript source files, e.g. to build different versions of a library.\n    * @param {string} source Source to process\n    * @param {string|Object.<string,string>=} baseDirOrIncludes Source base directory used for includes (node.js only)\n    *  or an object containing all the included sources by filename. Defaults to the current working directory.\n    * @param {boolean} preserveLineNumbers When removing blocks of code, replace the block with blank lines so that\n    *  line numbers are preserved, as long as #include is not used\n    * @constructor\n    */\nconst Preprocessor = function Preprocessor(source, baseDirOrIncludes, preserveLineNumbers)\n{\n    /**\n      * Source code to pre-process.\n      * @type {string}\n      * @expose\n      */\n    this.source = \"\" + source;\n\n    /**\n      * Source base directory.\n      * @type {string}\n      * @expose\n      */\n    this.baseDir = typeof baseDirOrIncludes === \"string\" ? baseDirOrIncludes : \".\";\n\n    /**\n      * Included sources by filename.\n      * @type {Object.<string, string>}\n      */\n    this.includes = typeof baseDirOrIncludes === \"object\" ? baseDirOrIncludes : {};\n\n    /**\n      * Preserve line numbers when removing blocks of code\n      * @type {boolean}\n      */\n    this.preserveLineNumbers = typeof preserveLineNumbers === \"boolean\" ? preserveLineNumbers : false;\n\n    /**\n      * Whether running inside of node.js or not.\n      * @type {boolean}\n      * @expose\n      */\n    this.isNode = (typeof window === \"undefined\" || !window.window) && \"function\" === \"function\";\n\n    /**\n      * Error reporting source ahead length.\n      * @type {number}\n      * @expose\n      */\n    this.errorSourceAhead = 50;\n\n    /**\n      * Runtime defines.\n      * @type {Array.<string>}\n      */\n    this.defines = [];\n};\n\n/**\n    * Definition expression\n    * @type {!RegExp}\n    */\nPreprocessor.EXPR = /([ ]*)\\/\\/[ ]+#(include_once|include|ifn?def|if|endif|else|elif|put|define)/g;\n\n/**\n    * #* EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.ALL = /([^\\r\\n]*)\\r?(?:\\n|$)/;\n\n/**\n    * #include \"path/to/file\". Requires node.js' \"fs\" module.\n    * @type {!RegExp}\n    */\nPreprocessor.INCLUDE = /(include_once|include)[ ]+\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"[ ]*\\r?(?:\\n|$)/g;\n\n/**\n    * #ifdef/#ifndef SOMEDEFINE, #if EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.IF = /(ifdef|ifndef|if)[ ]*([^\\r\\n]+)\\r?\\n/g;\n\n/**\n    * #endif/#else, #elif EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.ENDIF = /(endif|else|elif)([ ]+[^\\r\\n]+)?\\r?(?:\\n|$)/g;\n\n/**\n    * #put EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.PUT = /put[ ]+([^\\n]+)[ ]*/g;\n\n/**\n    * #define EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.DEFINE = /define[ ]+([^\\n\\r]+)\\r?(?:\\n|$)/g;\n\n/**\n    * #define EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.VAR = /define[ ]+var[ ]+([a-zA-Z_][a-zA-Z0-9_]*)[ ]*=[ ]*(.+)/g;\n\n/**\n    * #define EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.BOOLVAR = /define[ ]+([a-zA-Z_][a-zA-Z0-9_]*)[ ]*/g;\n\n/**\n    * #define EXPRESSION\n    * @type {!RegExp}\n    */\nPreprocessor.FUNCTION = /define[ ]+function[ ]+([a-zA-Z_][a-zA-Z0-9_]*)[ ]*(.+)/g;\n\n/**\n    * Strips slashes from an escaped string.\n    * @param {string} str Escaped string\n    * @return {string} Unescaped string\n    * @expose\n    */\nPreprocessor.stripSlashes = function (str)\n{\n    // ref: http://phpjs.org/functions/stripslashes/\n    return (str + \"\").replace(/\\\\(.?)/g, function (s, n1)\n    {\n        switch (n1)\n        {\n        case \"\\\\\": return \"\\\\\";\n        case \"0\": return \"\\u0000\";\n        case \"\": return \"\";\n        default: return n1;\n        }\n    });\n};\n\n/**\n    * Adds slashes to an unescaped string.\n    * @param {string} str Unescaped string\n    * @return {string} Escaped string\n    * @expose\n    */\nPreprocessor.addSlashes = function (str)\n{\n    return (str + \"\").replace(/([\\\\\"'])/g, \"\\\\$1\").replace(/\\0/g, \"\\\\0\");\n};\n\n/**\n    * Indents a multi-line string.\n    * @param {string} str Multi-line string to indent\n    * @param {string} indent Indent to use\n    * @return {string} Indented string\n    * @expose\n    */\nPreprocessor.indent = function (str, indent)\n{\n    let lines = str.split(\"\\n\");\n    for (let i = 0; i < lines.length; i++)\n    {\n        lines[i] = indent + lines[i];\n    }\n    return lines.join(\"\\n\");\n};\n\n/**\n    * Transforms a string for display in error messages.\n    * @param {string} str String to transform\n    * @return {string}\n    * @expose\n    */\nPreprocessor.nlToStr = function (str)\n{\n    return \"[\" + str.replace(/\\r/g, \"\").replace(/\\n/g, \"\\\\n\") + \"]\";\n};\n\n/**\n    * Evaluates an expression.\n    * @param {object.<string,string>} defines Defines\n    * @param {string=} expr Expression to evaluate\n    * @return {*} Expression result\n    * @throws {Error} If the expression cannot be evaluated\n    * @expose\n    */\nPreprocessor.evaluate = function (defines, expr)\n{\n    let evalFunction = function ()\n    {\n        for (let key in defines)\n        {\n            if (defines.hasOwnProperty(key))\n            {\n                if (defines[key].type === \"var\")\n                {\n                    eval(\"var \" + key + \" = \" + defines[key].value + \";\");\n                }\n                else\n                {\n                    eval(\"function \" + key + defines[key].value);\n                }\n            }\n        }\n\n        return eval(expr);\n    };\n    return evalFunction();\n};\n\n/**\n    * Preprocesses.\n    * @param {object.<string,string>} defines Defines\n    * @param {function(string)=} verbose Print verbose processing information to\n    *    the specified function as the first parameter. Defaults to not print debug information.\n    * @return {string} Processed source\n    * @throws {Error} If the source cannot be pre-processed\n    * @expose\n    */\nPreprocessor.prototype.process = function (defines, verbose)\n{\n    defines = defines || {};\n    verbose = typeof verbose === \"function\" ? verbose : function () {};\n    verbose(\"Defines: \" + JSON.stringify(defines));\n\n    let match, match2, match3, include, p, stack = [], before;\n    let isSkip = false;\n\n    while ((match = Preprocessor.EXPR.exec(this.source)) !== null)\n    {\n        verbose(match[2] + \" @ \" + match.index + \"-\" + Preprocessor.EXPR.lastIndex);\n        let indent = match[1];\n\n        if (isSkip && stack.length > 0 && match[2] !== \"endif\" && match[2] !== \"else\" && match[2] !== \"elif\")\n        {\n            before = stack.pop();\n            verbose(\"  pop (\" + stack.length + \"): \" + JSON.stringify(before));\n\n            Preprocessor.ALL.lastIndex = match.index;\n            if ((match2 = Preprocessor.ALL.exec(this.source)) === null)\n            {\n                throw (new Error(\"Illegal #\" + match[2] + \": \" +\n             this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n            }\n\n            stack.push(p = {\n                \"include\": before.include,\n                \"index\": before.index,\n                \"lastIndex\": Preprocessor.ALL.lastIndex\n            });\n            verbose(\"  push (\" + stack.length + \"): \" + JSON.stringify(p));\n            continue;\n        }\n\n        switch (match[2])\n        {\n        // case \"include_once\":\n        // case \"include\":\n        // Preprocessor.INCLUDE.lastIndex = match.index;\n        // if ((match2 = Preprocessor.INCLUDE.exec(this.source)) === null)\n        // {\n        //     throw (new Error(\"Illegal #\" + match[2] + \": \" +\n        //    this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n        // }\n        // include = Preprocessor.stripSlashes(match2[2]);\n        // if (typeof this.includes[include] !== \"undefined\")\n        // { // Do we already know it?\n        //     if (match2[1] === \"include_once\")\n        //     {\n        //         verbose(\"  skip incl: \" + include);\n        //         include = \"\";\n        //     }\n        //     else\n        //     {\n        //         verbose(\"  incl: \" + include);\n        //         include = this.includes[include];\n        //     }\n        // }\n        // else\n        // { // Load it if in node.js...\n        //     if (!this.isNode)\n        //     {\n        //         throw (new Error(\"Failed to resolve include: \" + this.baseDir + \"/\" + include));\n        //     }\n        //     try\n        //     {\n        //         let key = include,\n        //             fs = require(\"fs\");\n        //         if (GLOB_EXP.test(include))\n        //         {\n        //             let glob = require(\"glob\");\n        //             verbose(\"  glob incl: \" + this.baseDir + \"/\" + include);\n        //             let _this = this;\n        //             /* eslint no-loop-func: 0 */\n        //             let files = glob(this.baseDir + \"/\" + include, { \"sync\": true });\n        //             include = \"\";\n        //             for (let i = 0; i < files.length; i++)\n        //             {\n        //                 verbose(\"  incl: \" + files[i]);\n        //                 let contents = fs.readFileSync(files[i]) + \"\";\n        //                 _this.includes[key] = contents;\n        //                 include += contents;\n        //             }\n        //         }\n        //         else\n        //         {\n        //             verbose(\"  incl: \" + include);\n        //             include = fs.readFileSync(this.baseDir + \"/\" + include) + \"\";\n        //             this.includes[key] = include;\n        //         }\n        //     }\n        //     catch (e)\n        //     {\n        //         throw (new Error(\"Include failed: \" + include + \" (\" + e + \")\"));\n        //     }\n        // }\n        // this.source = this.source.substring(0, match.index) +\n        //  Preprocessor.indent(include, indent) + this.source.substring(Preprocessor.INCLUDE.lastIndex);\n        // Preprocessor.EXPR.lastIndex = stack.length > 0 ? stack[stack.length - 1].lastIndex : 0; // Start over again\n        // verbose(\"  continue at \" + Preprocessor.EXPR.lastIndex);\n        // break;\n        // case \"put\":\n        //     Preprocessor.PUT.lastIndex = match.index;\n        //     if ((match2 = Preprocessor.PUT.exec(this.source)) === null)\n        //     {\n        //         throw (new Error(\"Illegal #\" + match[2] + \": \" +\n        //        this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n        //     }\n        //     include = match2[1];\n        //     verbose(\"  expr: \" + include);\n        //     include = Preprocessor.evaluate(defines, include);\n        //     verbose(\"  value: \" + Preprocessor.nlToStr(include));\n        //     this.source = this.source.substring(0, match.index) + indent + include +\n        //      this.source.substring(Preprocessor.PUT.lastIndex);\n        //     Preprocessor.EXPR.lastIndex = match.index + include.length;\n        //     verbose(\"  continue at \" + Preprocessor.EXPR.lastIndex);\n        //     break;\n        case \"ifdef\":\n        case \"ifndef\":\n        case \"if\":\n            Preprocessor.IF.lastIndex = match.index;\n            if ((match2 = Preprocessor.IF.exec(this.source)) === null)\n            {\n                throw (new Error(\"Illegal #\" + match[2] + \": \" +\n               this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n            }\n            verbose(\"  test: \" + match2[2]);\n            verbose(\"  defines  \" + JSON.stringify(defines));\n            if (match2[1] === \"ifdef\")\n            {\n                include = defines[match2[2]] !== undefined;\n            }\n            else if (match2[1] === \"ifndef\")\n            {\n                include = defines[match2[2]] === undefined;\n            }\n            else\n            {\n                include = Preprocessor.evaluate(defines, match2[2]);\n            }\n            isSkip = !include;\n            verbose(\"  value: \" + include + \", isSkip: \" + isSkip);\n            stack.push(p = {\n                \"include\": include,\n                \"index\": match.index,\n                \"lastIndex\": Preprocessor.IF.lastIndex\n            });\n            verbose(\"  push (\" + stack.length + \"): \" + JSON.stringify(p));\n            break;\n        case \"endif\":\n        case \"else\":\n        case \"elif\":\n            Preprocessor.ENDIF.lastIndex = match.index;\n            if ((match2 = Preprocessor.ENDIF.exec(this.source)) === null)\n            {\n                throw (new Error(\"Illegal #\" + match[2] + \": \\\"\" +\n               this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n            }\n            if (stack.length === 0)\n            {\n                throw (new Error(\"Unexpected #\" + match2[1] + \": \\\"\" +\n               this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n            }\n            before = stack.pop();\n            verbose(\"  pop (\" + stack.length + \"): \" + JSON.stringify(before));\n\n            if (this.preserveLineNumbers)\n            {\n                include = this.source.substring(before.index, before.lastIndex).replace(NOT_LINE_ENDING, \"\") +\n               this.source.substring(before.lastIndex, match.index) +\n               this.source.substring(match.index, Preprocessor.ENDIF.lastIndex).replace(NOT_LINE_ENDING, \"\");\n            }\n            else\n            {\n                include = this.source.substring(before.lastIndex, match.index);\n            }\n\n            if (before.include)\n            {\n                verbose(\"  incl: \" + Preprocessor.nlToStr(include) + \", 0-\" + before.index +\n               \" + \" + include.length + \" bytes + \" + Preprocessor.ENDIF.lastIndex + \"-\" + this.source.length);\n                this.source = this.source.substring(0, before.index) + include +\n               this.source.substring(Preprocessor.ENDIF.lastIndex);\n            }\n            else if (this.preserveLineNumbers)\n            {\n                verbose(\"  excl(\\\\n): \" + Preprocessor.nlToStr(include) + \", 0-\" + before.index +\n               \" + \" + Preprocessor.ENDIF.lastIndex + \"-\" + this.source.length);\n                include = include.replace(NOT_LINE_ENDING, \"\");\n                this.source = this.source.substring(0, before.index) + include +\n               this.source.substring(Preprocessor.ENDIF.lastIndex);\n            }\n            else\n            {\n                verbose(\"  excl: \" + Preprocessor.nlToStr(include) + \", 0-\" + before.index +\n               \" + \" + Preprocessor.ENDIF.lastIndex + \"-\" + this.source.length);\n                include = \"\";\n                this.source = this.source.substring(0, before.index) +\n               this.source.substring(Preprocessor.ENDIF.lastIndex);\n            }\n            if (this.source === \"\")\n            {\n                verbose(\"  result empty\");\n            }\n            isSkip = false;\n            Preprocessor.EXPR.lastIndex = before.index + include.length;\n            verbose(\"  continue at \" + Preprocessor.EXPR.lastIndex);\n            if (match2[1] === \"else\" || match2[1] === \"elif\")\n            {\n                if (match2[1] === \"else\")\n                {\n                    include = !before.include;\n                }\n                else\n                {\n                    include = Preprocessor.evaluate(defines, match2[2]);\n                }\n                isSkip = !include;\n                verbose(\"  isSkip: \" + isSkip);\n                stack.push(p = {\n                    \"include\": include,\n                    \"index\": Preprocessor.EXPR.lastIndex,\n                    \"lastIndex\": Preprocessor.EXPR.lastIndex\n                });\n                verbose(\"  push (\" + stack.length + \"): \" + JSON.stringify(p));\n            }\n            break;\n        case \"define\":\n            Preprocessor.DEFINE.lastIndex = match.index;\n            Preprocessor.VAR.lastIndex = match.index;\n            Preprocessor.FUNCTION.lastIndex = match.index;\n            Preprocessor.BOOLVAR.lastIndex = match.index;\n\n            if ((match2 = Preprocessor.DEFINE.exec(this.source)) === null)\n            {\n                throw (new Error(\"Illegal #\" + match[2] + \": \" +\n               this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n            }\n            var define = match2[1];\n            verbose(\"  def: \\\"\" + define + \"\\\"\");\n\n            var identifier, value, type;\n            if ((match3 = Preprocessor.VAR.exec(this.source)) !== null)\n            {\n                type = \"var\";\n                identifier = match3[1];\n                value = match3[2];\n                verbose(\" match3(var): \" + JSON.stringify(match3));\n            }\n            else if ((match3 = Preprocessor.FUNCTION.exec(this.source)) !== null)\n            {\n                type = \"function\";\n                identifier = match3[1];\n                value = match3[2];\n                verbose(\" match3(function): \" + JSON.stringify(match3));\n            }\n            else if ((match3 = Preprocessor.BOOLVAR.exec(this.source)) !== null)\n            {\n                type = \"var\";\n                identifier = match3[1];\n                value = true;\n                verbose(\" match3(boolvar): \" + JSON.stringify(match3));\n            }\n            else\n            {\n                throw (new Error(\"Illegal #\" + match[2] + \": \" +\n               this.source.substring(match.index, match.index + this.errorSourceAhead) + \"...\"));\n            }\n\n            verbose(\"  type: \" + type);\n            verbose(\"  identifier: \" + identifier);\n            verbose(\"  value: \" + value);\n\n            defines[identifier] = {\n                \"type\": type,\n                \"value\": value\n            };\n\n            verbose(\"  defines  \" + JSON.stringify(defines));\n\n            var lineEnding = \"\";\n            if (this.preserveLineNumbers)\n            {\n                lineEnding = this.source.substring(match.index, Preprocessor.DEFINE.lastIndex).replace(NOT_LINE_ENDING, \"\");\n            }\n            this.source = this.source.substring(0, match.index) + indent +\n             lineEnding + this.source.substring(Preprocessor.DEFINE.lastIndex);\n            Preprocessor.EXPR.lastIndex = match.index;\n            verbose(\"  continue at \" + Preprocessor.EXPR.lastIndex);\n            break;\n        default:\n            break;\n        }\n    }\n    if (stack.length > 0)\n    {\n        verbose(\"Still on stack (\" + stack.length + \"): \" + JSON.stringify(stack.pop()));\n    }\n    return this.source;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Preprocessor);\n\n\n// const pp = new Preprocessor(\"// #define AAAA\\nhallo AAAA!\\n// #ifdef AAAA\\njaja is defined!\\n// #else\\n hurziburzi\\n// #endif\\nhuhu\", \".\", true);\n// // debugger;\n// const r = pp.process({ \"a\": 1 });\n// console.log(r);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9wcmVwcm9jLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvcHJlcHJvYy5qcz82ODQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiBAdHlwZSB7IVJlZ0V4cH1cbiAgICogQGlubmVyXG4gICAqL1xubGV0IEdMT0JfRVhQID0gLyg/Ol58W15cXFxcXSlcXCovO1xuXG4vKipcbiAgICAqIEB0eXBlIHshUmVnRXhwfVxuICAgICogQGlubmVyXG4gICAgKi9cbmxldCBOT1RfTElORV9FTkRJTkcgPSAvW15cXHJcXG5dL2c7XG5cbi8qKlxuICAgICogQ29uc3RydWN0cyBhIG5ldyBQcmVwcm9jZXNzb3IuXG4gICAgKiBAZXhwb3J0cyBQcmVwcm9jZXNzb3JcbiAgICAqIEBjbGFzcyBQcm92aWRlcyBwcmUtcHJvY2Vzc2luZyBvZiBKYXZhU2NyaXB0IHNvdXJjZSBmaWxlcywgZS5nLiB0byBidWlsZCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgYSBsaWJyYXJ5LlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgdG8gcHJvY2Vzc1xuICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsc3RyaW5nPj19IGJhc2VEaXJPckluY2x1ZGVzIFNvdXJjZSBiYXNlIGRpcmVjdG9yeSB1c2VkIGZvciBpbmNsdWRlcyAobm9kZS5qcyBvbmx5KVxuICAgICogIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5jbHVkZWQgc291cmNlcyBieSBmaWxlbmFtZS4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXNlcnZlTGluZU51bWJlcnMgV2hlbiByZW1vdmluZyBibG9ja3Mgb2YgY29kZSwgcmVwbGFjZSB0aGUgYmxvY2sgd2l0aCBibGFuayBsaW5lcyBzbyB0aGF0XG4gICAgKiAgbGluZSBudW1iZXJzIGFyZSBwcmVzZXJ2ZWQsIGFzIGxvbmcgYXMgI2luY2x1ZGUgaXMgbm90IHVzZWRcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICovXG5jb25zdCBQcmVwcm9jZXNzb3IgPSBmdW5jdGlvbiBQcmVwcm9jZXNzb3Ioc291cmNlLCBiYXNlRGlyT3JJbmNsdWRlcywgcHJlc2VydmVMaW5lTnVtYmVycylcbntcbiAgICAvKipcbiAgICAgICogU291cmNlIGNvZGUgdG8gcHJlLXByb2Nlc3MuXG4gICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAqIEBleHBvc2VcbiAgICAgICovXG4gICAgdGhpcy5zb3VyY2UgPSBcIlwiICsgc291cmNlO1xuXG4gICAgLyoqXG4gICAgICAqIFNvdXJjZSBiYXNlIGRpcmVjdG9yeS5cbiAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICogQGV4cG9zZVxuICAgICAgKi9cbiAgICB0aGlzLmJhc2VEaXIgPSB0eXBlb2YgYmFzZURpck9ySW5jbHVkZXMgPT09IFwic3RyaW5nXCIgPyBiYXNlRGlyT3JJbmNsdWRlcyA6IFwiLlwiO1xuXG4gICAgLyoqXG4gICAgICAqIEluY2x1ZGVkIHNvdXJjZXMgYnkgZmlsZW5hbWUuXG4gICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn1cbiAgICAgICovXG4gICAgdGhpcy5pbmNsdWRlcyA9IHR5cGVvZiBiYXNlRGlyT3JJbmNsdWRlcyA9PT0gXCJvYmplY3RcIiA/IGJhc2VEaXJPckluY2x1ZGVzIDoge307XG5cbiAgICAvKipcbiAgICAgICogUHJlc2VydmUgbGluZSBudW1iZXJzIHdoZW4gcmVtb3ZpbmcgYmxvY2tzIG9mIGNvZGVcbiAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAqL1xuICAgIHRoaXMucHJlc2VydmVMaW5lTnVtYmVycyA9IHR5cGVvZiBwcmVzZXJ2ZUxpbmVOdW1iZXJzID09PSBcImJvb2xlYW5cIiA/IHByZXNlcnZlTGluZU51bWJlcnMgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAgKiBXaGV0aGVyIHJ1bm5pbmcgaW5zaWRlIG9mIG5vZGUuanMgb3Igbm90LlxuICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICogQGV4cG9zZVxuICAgICAgKi9cbiAgICB0aGlzLmlzTm9kZSA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cud2luZG93KSAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gICAgLyoqXG4gICAgICAqIEVycm9yIHJlcG9ydGluZyBzb3VyY2UgYWhlYWQgbGVuZ3RoLlxuICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgKiBAZXhwb3NlXG4gICAgICAqL1xuICAgIHRoaXMuZXJyb3JTb3VyY2VBaGVhZCA9IDUwO1xuXG4gICAgLyoqXG4gICAgICAqIFJ1bnRpbWUgZGVmaW5lcy5cbiAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgKi9cbiAgICB0aGlzLmRlZmluZXMgPSBbXTtcbn07XG5cbi8qKlxuICAgICogRGVmaW5pdGlvbiBleHByZXNzaW9uXG4gICAgKiBAdHlwZSB7IVJlZ0V4cH1cbiAgICAqL1xuUHJlcHJvY2Vzc29yLkVYUFIgPSAvKFsgXSopXFwvXFwvWyBdKyMoaW5jbHVkZV9vbmNlfGluY2x1ZGV8aWZuP2RlZnxpZnxlbmRpZnxlbHNlfGVsaWZ8cHV0fGRlZmluZSkvZztcblxuLyoqXG4gICAgKiAjKiBFWFBSRVNTSU9OXG4gICAgKiBAdHlwZSB7IVJlZ0V4cH1cbiAgICAqL1xuUHJlcHJvY2Vzc29yLkFMTCA9IC8oW15cXHJcXG5dKilcXHI/KD86XFxufCQpLztcblxuLyoqXG4gICAgKiAjaW5jbHVkZSBcInBhdGgvdG8vZmlsZVwiLiBSZXF1aXJlcyBub2RlLmpzJyBcImZzXCIgbW9kdWxlLlxuICAgICogQHR5cGUgeyFSZWdFeHB9XG4gICAgKi9cblByZXByb2Nlc3Nvci5JTkNMVURFID0gLyhpbmNsdWRlX29uY2V8aW5jbHVkZSlbIF0rXCIoW15cIlxcXFxdKihcXFxcLlteXCJcXFxcXSopKilcIlsgXSpcXHI/KD86XFxufCQpL2c7XG5cbi8qKlxuICAgICogI2lmZGVmLyNpZm5kZWYgU09NRURFRklORSwgI2lmIEVYUFJFU1NJT05cbiAgICAqIEB0eXBlIHshUmVnRXhwfVxuICAgICovXG5QcmVwcm9jZXNzb3IuSUYgPSAvKGlmZGVmfGlmbmRlZnxpZilbIF0qKFteXFxyXFxuXSspXFxyP1xcbi9nO1xuXG4vKipcbiAgICAqICNlbmRpZi8jZWxzZSwgI2VsaWYgRVhQUkVTU0lPTlxuICAgICogQHR5cGUgeyFSZWdFeHB9XG4gICAgKi9cblByZXByb2Nlc3Nvci5FTkRJRiA9IC8oZW5kaWZ8ZWxzZXxlbGlmKShbIF0rW15cXHJcXG5dKyk/XFxyPyg/OlxcbnwkKS9nO1xuXG4vKipcbiAgICAqICNwdXQgRVhQUkVTU0lPTlxuICAgICogQHR5cGUgeyFSZWdFeHB9XG4gICAgKi9cblByZXByb2Nlc3Nvci5QVVQgPSAvcHV0WyBdKyhbXlxcbl0rKVsgXSovZztcblxuLyoqXG4gICAgKiAjZGVmaW5lIEVYUFJFU1NJT05cbiAgICAqIEB0eXBlIHshUmVnRXhwfVxuICAgICovXG5QcmVwcm9jZXNzb3IuREVGSU5FID0gL2RlZmluZVsgXSsoW15cXG5cXHJdKylcXHI/KD86XFxufCQpL2c7XG5cbi8qKlxuICAgICogI2RlZmluZSBFWFBSRVNTSU9OXG4gICAgKiBAdHlwZSB7IVJlZ0V4cH1cbiAgICAqL1xuUHJlcHJvY2Vzc29yLlZBUiA9IC9kZWZpbmVbIF0rdmFyWyBdKyhbYS16QS1aX11bYS16QS1aMC05X10qKVsgXSo9WyBdKiguKykvZztcblxuLyoqXG4gICAgKiAjZGVmaW5lIEVYUFJFU1NJT05cbiAgICAqIEB0eXBlIHshUmVnRXhwfVxuICAgICovXG5QcmVwcm9jZXNzb3IuQk9PTFZBUiA9IC9kZWZpbmVbIF0rKFthLXpBLVpfXVthLXpBLVowLTlfXSopWyBdKi9nO1xuXG4vKipcbiAgICAqICNkZWZpbmUgRVhQUkVTU0lPTlxuICAgICogQHR5cGUgeyFSZWdFeHB9XG4gICAgKi9cblByZXByb2Nlc3Nvci5GVU5DVElPTiA9IC9kZWZpbmVbIF0rZnVuY3Rpb25bIF0rKFthLXpBLVpfXVthLXpBLVowLTlfXSopWyBdKiguKykvZztcblxuLyoqXG4gICAgKiBTdHJpcHMgc2xhc2hlcyBmcm9tIGFuIGVzY2FwZWQgc3RyaW5nLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBFc2NhcGVkIHN0cmluZ1xuICAgICogQHJldHVybiB7c3RyaW5nfSBVbmVzY2FwZWQgc3RyaW5nXG4gICAgKiBAZXhwb3NlXG4gICAgKi9cblByZXByb2Nlc3Nvci5zdHJpcFNsYXNoZXMgPSBmdW5jdGlvbiAoc3RyKVxue1xuICAgIC8vIHJlZjogaHR0cDovL3BocGpzLm9yZy9mdW5jdGlvbnMvc3RyaXBzbGFzaGVzL1xuICAgIHJldHVybiAoc3RyICsgXCJcIikucmVwbGFjZSgvXFxcXCguPykvZywgZnVuY3Rpb24gKHMsIG4xKVxuICAgIHtcbiAgICAgICAgc3dpdGNoIChuMSlcbiAgICAgICAge1xuICAgICAgICBjYXNlIFwiXFxcXFwiOiByZXR1cm4gXCJcXFxcXCI7XG4gICAgICAgIGNhc2UgXCIwXCI6IHJldHVybiBcIlxcdTAwMDBcIjtcbiAgICAgICAgY2FzZSBcIlwiOiByZXR1cm4gXCJcIjtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIG4xO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAgICAqIEFkZHMgc2xhc2hlcyB0byBhbiB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBVbmVzY2FwZWQgc3RyaW5nXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVzY2FwZWQgc3RyaW5nXG4gICAgKiBAZXhwb3NlXG4gICAgKi9cblByZXByb2Nlc3Nvci5hZGRTbGFzaGVzID0gZnVuY3Rpb24gKHN0cilcbntcbiAgICByZXR1cm4gKHN0ciArIFwiXCIpLnJlcGxhY2UoLyhbXFxcXFwiJ10pL2csIFwiXFxcXCQxXCIpLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpO1xufTtcblxuLyoqXG4gICAgKiBJbmRlbnRzIGEgbXVsdGktbGluZSBzdHJpbmcuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIE11bHRpLWxpbmUgc3RyaW5nIHRvIGluZGVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBJbmRlbnQgdG8gdXNlXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IEluZGVudGVkIHN0cmluZ1xuICAgICogQGV4cG9zZVxuICAgICovXG5QcmVwcm9jZXNzb3IuaW5kZW50ID0gZnVuY3Rpb24gKHN0ciwgaW5kZW50KVxue1xuICAgIGxldCBsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgbGluZXNbaV0gPSBpbmRlbnQgKyBsaW5lc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG59O1xuXG4vKipcbiAgICAqIFRyYW5zZm9ybXMgYSBzdHJpbmcgZm9yIGRpc3BsYXkgaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB0cmFuc2Zvcm1cbiAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAqIEBleHBvc2VcbiAgICAqL1xuUHJlcHJvY2Vzc29yLm5sVG9TdHIgPSBmdW5jdGlvbiAoc3RyKVxue1xuICAgIHJldHVybiBcIltcIiArIHN0ci5yZXBsYWNlKC9cXHIvZywgXCJcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikgKyBcIl1cIjtcbn07XG5cbi8qKlxuICAgICogRXZhbHVhdGVzIGFuIGV4cHJlc3Npb24uXG4gICAgKiBAcGFyYW0ge29iamVjdC48c3RyaW5nLHN0cmluZz59IGRlZmluZXMgRGVmaW5lc1xuICAgICogQHBhcmFtIHtzdHJpbmc9fSBleHByIEV4cHJlc3Npb24gdG8gZXZhbHVhdGVcbiAgICAqIEByZXR1cm4geyp9IEV4cHJlc3Npb24gcmVzdWx0XG4gICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGV4cHJlc3Npb24gY2Fubm90IGJlIGV2YWx1YXRlZFxuICAgICogQGV4cG9zZVxuICAgICovXG5QcmVwcm9jZXNzb3IuZXZhbHVhdGUgPSBmdW5jdGlvbiAoZGVmaW5lcywgZXhwcilcbntcbiAgICBsZXQgZXZhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBkZWZpbmVzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGVmaW5lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVzW2tleV0udHlwZSA9PT0gXCJ2YXJcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV2YWwoXCJ2YXIgXCIgKyBrZXkgKyBcIiA9IFwiICsgZGVmaW5lc1trZXldLnZhbHVlICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBldmFsKFwiZnVuY3Rpb24gXCIgKyBrZXkgKyBkZWZpbmVzW2tleV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmFsKGV4cHIpO1xuICAgIH07XG4gICAgcmV0dXJuIGV2YWxGdW5jdGlvbigpO1xufTtcblxuLyoqXG4gICAgKiBQcmVwcm9jZXNzZXMuXG4gICAgKiBAcGFyYW0ge29iamVjdC48c3RyaW5nLHN0cmluZz59IGRlZmluZXMgRGVmaW5lc1xuICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpPX0gdmVyYm9zZSBQcmludCB2ZXJib3NlIHByb2Nlc3NpbmcgaW5mb3JtYXRpb24gdG9cbiAgICAqICAgIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gRGVmYXVsdHMgdG8gbm90IHByaW50IGRlYnVnIGluZm9ybWF0aW9uLlxuICAgICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgc291cmNlXG4gICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcHJlLXByb2Nlc3NlZFxuICAgICogQGV4cG9zZVxuICAgICovXG5QcmVwcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoZGVmaW5lcywgdmVyYm9zZSlcbntcbiAgICBkZWZpbmVzID0gZGVmaW5lcyB8fCB7fTtcbiAgICB2ZXJib3NlID0gdHlwZW9mIHZlcmJvc2UgPT09IFwiZnVuY3Rpb25cIiA/IHZlcmJvc2UgOiBmdW5jdGlvbiAoKSB7fTtcbiAgICB2ZXJib3NlKFwiRGVmaW5lczogXCIgKyBKU09OLnN0cmluZ2lmeShkZWZpbmVzKSk7XG5cbiAgICBsZXQgbWF0Y2gsIG1hdGNoMiwgbWF0Y2gzLCBpbmNsdWRlLCBwLCBzdGFjayA9IFtdLCBiZWZvcmU7XG4gICAgbGV0IGlzU2tpcCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKChtYXRjaCA9IFByZXByb2Nlc3Nvci5FWFBSLmV4ZWModGhpcy5zb3VyY2UpKSAhPT0gbnVsbClcbiAgICB7XG4gICAgICAgIHZlcmJvc2UobWF0Y2hbMl0gKyBcIiBAIFwiICsgbWF0Y2guaW5kZXggKyBcIi1cIiArIFByZXByb2Nlc3Nvci5FWFBSLmxhc3RJbmRleCk7XG4gICAgICAgIGxldCBpbmRlbnQgPSBtYXRjaFsxXTtcblxuICAgICAgICBpZiAoaXNTa2lwICYmIHN0YWNrLmxlbmd0aCA+IDAgJiYgbWF0Y2hbMl0gIT09IFwiZW5kaWZcIiAmJiBtYXRjaFsyXSAhPT0gXCJlbHNlXCIgJiYgbWF0Y2hbMl0gIT09IFwiZWxpZlwiKVxuICAgICAgICB7XG4gICAgICAgICAgICBiZWZvcmUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHZlcmJvc2UoXCIgIHBvcCAoXCIgKyBzdGFjay5sZW5ndGggKyBcIik6IFwiICsgSlNPTi5zdHJpbmdpZnkoYmVmb3JlKSk7XG5cbiAgICAgICAgICAgIFByZXByb2Nlc3Nvci5BTEwubGFzdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBpZiAoKG1hdGNoMiA9IFByZXByb2Nlc3Nvci5BTEwuZXhlYyh0aGlzLnNvdXJjZSkpID09PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJJbGxlZ2FsICNcIiArIG1hdGNoWzJdICsgXCI6IFwiICtcbiAgICAgICAgICAgICB0aGlzLnNvdXJjZS5zdWJzdHJpbmcobWF0Y2guaW5kZXgsIG1hdGNoLmluZGV4ICsgdGhpcy5lcnJvclNvdXJjZUFoZWFkKSArIFwiLi4uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2sucHVzaChwID0ge1xuICAgICAgICAgICAgICAgIFwiaW5jbHVkZVwiOiBiZWZvcmUuaW5jbHVkZSxcbiAgICAgICAgICAgICAgICBcImluZGV4XCI6IGJlZm9yZS5pbmRleCxcbiAgICAgICAgICAgICAgICBcImxhc3RJbmRleFwiOiBQcmVwcm9jZXNzb3IuQUxMLmxhc3RJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2ZXJib3NlKFwiICBwdXNoIChcIiArIHN0YWNrLmxlbmd0aCArIFwiKTogXCIgKyBKU09OLnN0cmluZ2lmeShwKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobWF0Y2hbMl0pXG4gICAgICAgIHtcbiAgICAgICAgLy8gY2FzZSBcImluY2x1ZGVfb25jZVwiOlxuICAgICAgICAvLyBjYXNlIFwiaW5jbHVkZVwiOlxuICAgICAgICAvLyBQcmVwcm9jZXNzb3IuSU5DTFVERS5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgLy8gaWYgKChtYXRjaDIgPSBQcmVwcm9jZXNzb3IuSU5DTFVERS5leGVjKHRoaXMuc291cmNlKSkgPT09IG51bGwpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIHRocm93IChuZXcgRXJyb3IoXCJJbGxlZ2FsICNcIiArIG1hdGNoWzJdICsgXCI6IFwiICtcbiAgICAgICAgLy8gICAgdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIHRoaXMuZXJyb3JTb3VyY2VBaGVhZCkgKyBcIi4uLlwiKSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaW5jbHVkZSA9IFByZXByb2Nlc3Nvci5zdHJpcFNsYXNoZXMobWF0Y2gyWzJdKTtcbiAgICAgICAgLy8gaWYgKHR5cGVvZiB0aGlzLmluY2x1ZGVzW2luY2x1ZGVdICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAvLyB7IC8vIERvIHdlIGFscmVhZHkga25vdyBpdD9cbiAgICAgICAgLy8gICAgIGlmIChtYXRjaDJbMV0gPT09IFwiaW5jbHVkZV9vbmNlXCIpXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgdmVyYm9zZShcIiAgc2tpcCBpbmNsOiBcIiArIGluY2x1ZGUpO1xuICAgICAgICAvLyAgICAgICAgIGluY2x1ZGUgPSBcIlwiO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgZWxzZVxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHZlcmJvc2UoXCIgIGluY2w6IFwiICsgaW5jbHVkZSk7XG4gICAgICAgIC8vICAgICAgICAgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZXNbaW5jbHVkZV07XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyB7IC8vIExvYWQgaXQgaWYgaW4gbm9kZS5qcy4uLlxuICAgICAgICAvLyAgICAgaWYgKCF0aGlzLmlzTm9kZSlcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlc29sdmUgaW5jbHVkZTogXCIgKyB0aGlzLmJhc2VEaXIgKyBcIi9cIiArIGluY2x1ZGUpKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHRyeVxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIGxldCBrZXkgPSBpbmNsdWRlLFxuICAgICAgICAvLyAgICAgICAgICAgICBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoR0xPQl9FWFAudGVzdChpbmNsdWRlKSlcbiAgICAgICAgLy8gICAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGxldCBnbG9iID0gcmVxdWlyZShcImdsb2JcIik7XG4gICAgICAgIC8vICAgICAgICAgICAgIHZlcmJvc2UoXCIgIGdsb2IgaW5jbDogXCIgKyB0aGlzLmJhc2VEaXIgKyBcIi9cIiArIGluY2x1ZGUpO1xuICAgICAgICAvLyAgICAgICAgICAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tbG9vcC1mdW5jOiAwICovXG4gICAgICAgIC8vICAgICAgICAgICAgIGxldCBmaWxlcyA9IGdsb2IodGhpcy5iYXNlRGlyICsgXCIvXCIgKyBpbmNsdWRlLCB7IFwic3luY1wiOiB0cnVlIH0pO1xuICAgICAgICAvLyAgICAgICAgICAgICBpbmNsdWRlID0gXCJcIjtcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgLy8gICAgICAgICAgICAge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdmVyYm9zZShcIiAgaW5jbDogXCIgKyBmaWxlc1tpXSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBsZXQgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXNbaV0pICsgXCJcIjtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIF90aGlzLmluY2x1ZGVzW2tleV0gPSBjb250ZW50cztcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGluY2x1ZGUgKz0gY29udGVudHM7XG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgZWxzZVxuICAgICAgICAvLyAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgdmVyYm9zZShcIiAgaW5jbDogXCIgKyBpbmNsdWRlKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgaW5jbHVkZSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLmJhc2VEaXIgKyBcIi9cIiArIGluY2x1ZGUpICsgXCJcIjtcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5pbmNsdWRlc1trZXldID0gaW5jbHVkZTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICBjYXRjaCAoZSlcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiSW5jbHVkZSBmYWlsZWQ6IFwiICsgaW5jbHVkZSArIFwiIChcIiArIGUgKyBcIilcIikpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHRoaXMuc291cmNlID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KSArXG4gICAgICAgIC8vICBQcmVwcm9jZXNzb3IuaW5kZW50KGluY2x1ZGUsIGluZGVudCkgKyB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoUHJlcHJvY2Vzc29yLklOQ0xVREUubGFzdEluZGV4KTtcbiAgICAgICAgLy8gUHJlcHJvY2Vzc29yLkVYUFIubGFzdEluZGV4ID0gc3RhY2subGVuZ3RoID4gMCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmxhc3RJbmRleCA6IDA7IC8vIFN0YXJ0IG92ZXIgYWdhaW5cbiAgICAgICAgLy8gdmVyYm9zZShcIiAgY29udGludWUgYXQgXCIgKyBQcmVwcm9jZXNzb3IuRVhQUi5sYXN0SW5kZXgpO1xuICAgICAgICAvLyBicmVhaztcbiAgICAgICAgLy8gY2FzZSBcInB1dFwiOlxuICAgICAgICAvLyAgICAgUHJlcHJvY2Vzc29yLlBVVC5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgLy8gICAgIGlmICgobWF0Y2gyID0gUHJlcHJvY2Vzc29yLlBVVC5leGVjKHRoaXMuc291cmNlKSkgPT09IG51bGwpXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIklsbGVnYWwgI1wiICsgbWF0Y2hbMl0gKyBcIjogXCIgK1xuICAgICAgICAvLyAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIHRoaXMuZXJyb3JTb3VyY2VBaGVhZCkgKyBcIi4uLlwiKSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICBpbmNsdWRlID0gbWF0Y2gyWzFdO1xuICAgICAgICAvLyAgICAgdmVyYm9zZShcIiAgZXhwcjogXCIgKyBpbmNsdWRlKTtcbiAgICAgICAgLy8gICAgIGluY2x1ZGUgPSBQcmVwcm9jZXNzb3IuZXZhbHVhdGUoZGVmaW5lcywgaW5jbHVkZSk7XG4gICAgICAgIC8vICAgICB2ZXJib3NlKFwiICB2YWx1ZTogXCIgKyBQcmVwcm9jZXNzb3IubmxUb1N0cihpbmNsdWRlKSk7XG4gICAgICAgIC8vICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuc291cmNlLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCkgKyBpbmRlbnQgKyBpbmNsdWRlICtcbiAgICAgICAgLy8gICAgICB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoUHJlcHJvY2Vzc29yLlBVVC5sYXN0SW5kZXgpO1xuICAgICAgICAvLyAgICAgUHJlcHJvY2Vzc29yLkVYUFIubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBpbmNsdWRlLmxlbmd0aDtcbiAgICAgICAgLy8gICAgIHZlcmJvc2UoXCIgIGNvbnRpbnVlIGF0IFwiICsgUHJlcHJvY2Vzc29yLkVYUFIubGFzdEluZGV4KTtcbiAgICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWZkZWZcIjpcbiAgICAgICAgY2FzZSBcImlmbmRlZlwiOlxuICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgIFByZXByb2Nlc3Nvci5JRi5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIGlmICgobWF0Y2gyID0gUHJlcHJvY2Vzc29yLklGLmV4ZWModGhpcy5zb3VyY2UpKSA9PT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiSWxsZWdhbCAjXCIgKyBtYXRjaFsyXSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5zdWJzdHJpbmcobWF0Y2guaW5kZXgsIG1hdGNoLmluZGV4ICsgdGhpcy5lcnJvclNvdXJjZUFoZWFkKSArIFwiLi4uXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlcmJvc2UoXCIgIHRlc3Q6IFwiICsgbWF0Y2gyWzJdKTtcbiAgICAgICAgICAgIHZlcmJvc2UoXCIgIGRlZmluZXMgIFwiICsgSlNPTi5zdHJpbmdpZnkoZGVmaW5lcykpO1xuICAgICAgICAgICAgaWYgKG1hdGNoMlsxXSA9PT0gXCJpZmRlZlwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBkZWZpbmVzW21hdGNoMlsyXV0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoMlsxXSA9PT0gXCJpZm5kZWZcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlID0gZGVmaW5lc1ttYXRjaDJbMl1dID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZSA9IFByZXByb2Nlc3Nvci5ldmFsdWF0ZShkZWZpbmVzLCBtYXRjaDJbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNTa2lwID0gIWluY2x1ZGU7XG4gICAgICAgICAgICB2ZXJib3NlKFwiICB2YWx1ZTogXCIgKyBpbmNsdWRlICsgXCIsIGlzU2tpcDogXCIgKyBpc1NraXApO1xuICAgICAgICAgICAgc3RhY2sucHVzaChwID0ge1xuICAgICAgICAgICAgICAgIFwiaW5jbHVkZVwiOiBpbmNsdWRlLFxuICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgXCJsYXN0SW5kZXhcIjogUHJlcHJvY2Vzc29yLklGLmxhc3RJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2ZXJib3NlKFwiICBwdXNoIChcIiArIHN0YWNrLmxlbmd0aCArIFwiKTogXCIgKyBKU09OLnN0cmluZ2lmeShwKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZGlmXCI6XG4gICAgICAgIGNhc2UgXCJlbHNlXCI6XG4gICAgICAgIGNhc2UgXCJlbGlmXCI6XG4gICAgICAgICAgICBQcmVwcm9jZXNzb3IuRU5ESUYubGFzdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBpZiAoKG1hdGNoMiA9IFByZXByb2Nlc3Nvci5FTkRJRi5leGVjKHRoaXMuc291cmNlKSkgPT09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIklsbGVnYWwgI1wiICsgbWF0Y2hbMl0gKyBcIjogXFxcIlwiICtcbiAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyB0aGlzLmVycm9yU291cmNlQWhlYWQpICsgXCIuLi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiVW5leHBlY3RlZCAjXCIgKyBtYXRjaDJbMV0gKyBcIjogXFxcIlwiICtcbiAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyB0aGlzLmVycm9yU291cmNlQWhlYWQpICsgXCIuLi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmVmb3JlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB2ZXJib3NlKFwiICBwb3AgKFwiICsgc3RhY2subGVuZ3RoICsgXCIpOiBcIiArIEpTT04uc3RyaW5naWZ5KGJlZm9yZSkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZUxpbmVOdW1iZXJzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoYmVmb3JlLmluZGV4LCBiZWZvcmUubGFzdEluZGV4KS5yZXBsYWNlKE5PVF9MSU5FX0VORElORywgXCJcIikgK1xuICAgICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKGJlZm9yZS5sYXN0SW5kZXgsIG1hdGNoLmluZGV4KSArXG4gICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5zdWJzdHJpbmcobWF0Y2guaW5kZXgsIFByZXByb2Nlc3Nvci5FTkRJRi5sYXN0SW5kZXgpLnJlcGxhY2UoTk9UX0xJTkVfRU5ESU5HLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKGJlZm9yZS5sYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJlZm9yZS5pbmNsdWRlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZlcmJvc2UoXCIgIGluY2w6IFwiICsgUHJlcHJvY2Vzc29yLm5sVG9TdHIoaW5jbHVkZSkgKyBcIiwgMC1cIiArIGJlZm9yZS5pbmRleCArXG4gICAgICAgICAgICAgICBcIiArIFwiICsgaW5jbHVkZS5sZW5ndGggKyBcIiBieXRlcyArIFwiICsgUHJlcHJvY2Vzc29yLkVORElGLmxhc3RJbmRleCArIFwiLVwiICsgdGhpcy5zb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuc291cmNlLnN1YnN0cmluZygwLCBiZWZvcmUuaW5kZXgpICsgaW5jbHVkZSArXG4gICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoUHJlcHJvY2Vzc29yLkVORElGLmxhc3RJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByZXNlcnZlTGluZU51bWJlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmVyYm9zZShcIiAgZXhjbChcXFxcbik6IFwiICsgUHJlcHJvY2Vzc29yLm5sVG9TdHIoaW5jbHVkZSkgKyBcIiwgMC1cIiArIGJlZm9yZS5pbmRleCArXG4gICAgICAgICAgICAgICBcIiArIFwiICsgUHJlcHJvY2Vzc29yLkVORElGLmxhc3RJbmRleCArIFwiLVwiICsgdGhpcy5zb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZS5yZXBsYWNlKE5PVF9MSU5FX0VORElORywgXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoMCwgYmVmb3JlLmluZGV4KSArIGluY2x1ZGUgK1xuICAgICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKFByZXByb2Nlc3Nvci5FTkRJRi5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZlcmJvc2UoXCIgIGV4Y2w6IFwiICsgUHJlcHJvY2Vzc29yLm5sVG9TdHIoaW5jbHVkZSkgKyBcIiwgMC1cIiArIGJlZm9yZS5pbmRleCArXG4gICAgICAgICAgICAgICBcIiArIFwiICsgUHJlcHJvY2Vzc29yLkVORElGLmxhc3RJbmRleCArIFwiLVwiICsgdGhpcy5zb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpbmNsdWRlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuc291cmNlLnN1YnN0cmluZygwLCBiZWZvcmUuaW5kZXgpICtcbiAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnN1YnN0cmluZyhQcmVwcm9jZXNzb3IuRU5ESUYubGFzdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gXCJcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2ZXJib3NlKFwiICByZXN1bHQgZW1wdHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1NraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIFByZXByb2Nlc3Nvci5FWFBSLmxhc3RJbmRleCA9IGJlZm9yZS5pbmRleCArIGluY2x1ZGUubGVuZ3RoO1xuICAgICAgICAgICAgdmVyYm9zZShcIiAgY29udGludWUgYXQgXCIgKyBQcmVwcm9jZXNzb3IuRVhQUi5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoMlsxXSA9PT0gXCJlbHNlXCIgfHwgbWF0Y2gyWzFdID09PSBcImVsaWZcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gyWzFdID09PSBcImVsc2VcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSAhYmVmb3JlLmluY2x1ZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBQcmVwcm9jZXNzb3IuZXZhbHVhdGUoZGVmaW5lcywgbWF0Y2gyWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNTa2lwID0gIWluY2x1ZGU7XG4gICAgICAgICAgICAgICAgdmVyYm9zZShcIiAgaXNTa2lwOiBcIiArIGlzU2tpcCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwID0ge1xuICAgICAgICAgICAgICAgICAgICBcImluY2x1ZGVcIjogaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleFwiOiBQcmVwcm9jZXNzb3IuRVhQUi5sYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIFwibGFzdEluZGV4XCI6IFByZXByb2Nlc3Nvci5FWFBSLmxhc3RJbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZlcmJvc2UoXCIgIHB1c2ggKFwiICsgc3RhY2subGVuZ3RoICsgXCIpOiBcIiArIEpTT04uc3RyaW5naWZ5KHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVmaW5lXCI6XG4gICAgICAgICAgICBQcmVwcm9jZXNzb3IuREVGSU5FLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgUHJlcHJvY2Vzc29yLlZBUi5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIFByZXByb2Nlc3Nvci5GVU5DVElPTi5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIFByZXByb2Nlc3Nvci5CT09MVkFSLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuXG4gICAgICAgICAgICBpZiAoKG1hdGNoMiA9IFByZXByb2Nlc3Nvci5ERUZJTkUuZXhlYyh0aGlzLnNvdXJjZSkpID09PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJJbGxlZ2FsICNcIiArIG1hdGNoWzJdICsgXCI6IFwiICtcbiAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyB0aGlzLmVycm9yU291cmNlQWhlYWQpICsgXCIuLi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlZmluZSA9IG1hdGNoMlsxXTtcbiAgICAgICAgICAgIHZlcmJvc2UoXCIgIGRlZjogXFxcIlwiICsgZGVmaW5lICsgXCJcXFwiXCIpO1xuXG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllciwgdmFsdWUsIHR5cGU7XG4gICAgICAgICAgICBpZiAoKG1hdGNoMyA9IFByZXByb2Nlc3Nvci5WQVIuZXhlYyh0aGlzLnNvdXJjZSkpICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcInZhclwiO1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBtYXRjaDNbMV07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaDNbMl07XG4gICAgICAgICAgICAgICAgdmVyYm9zZShcIiBtYXRjaDModmFyKTogXCIgKyBKU09OLnN0cmluZ2lmeShtYXRjaDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaDMgPSBQcmVwcm9jZXNzb3IuRlVOQ1RJT04uZXhlYyh0aGlzLnNvdXJjZSkpICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IG1hdGNoM1sxXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoM1syXTtcbiAgICAgICAgICAgICAgICB2ZXJib3NlKFwiIG1hdGNoMyhmdW5jdGlvbik6IFwiICsgSlNPTi5zdHJpbmdpZnkobWF0Y2gzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgobWF0Y2gzID0gUHJlcHJvY2Vzc29yLkJPT0xWQVIuZXhlYyh0aGlzLnNvdXJjZSkpICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcInZhclwiO1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBtYXRjaDNbMV07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZlcmJvc2UoXCIgbWF0Y2gzKGJvb2x2YXIpOiBcIiArIEpTT04uc3RyaW5naWZ5KG1hdGNoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJJbGxlZ2FsICNcIiArIG1hdGNoWzJdICsgXCI6IFwiICtcbiAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyB0aGlzLmVycm9yU291cmNlQWhlYWQpICsgXCIuLi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZXJib3NlKFwiICB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgdmVyYm9zZShcIiAgaWRlbnRpZmllcjogXCIgKyBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHZlcmJvc2UoXCIgIHZhbHVlOiBcIiArIHZhbHVlKTtcblxuICAgICAgICAgICAgZGVmaW5lc1tpZGVudGlmaWVyXSA9IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogdHlwZSxcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2ZXJib3NlKFwiICBkZWZpbmVzICBcIiArIEpTT04uc3RyaW5naWZ5KGRlZmluZXMpKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVFbmRpbmcgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlc2VydmVMaW5lTnVtYmVycylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5lRW5kaW5nID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKG1hdGNoLmluZGV4LCBQcmVwcm9jZXNzb3IuREVGSU5FLmxhc3RJbmRleCkucmVwbGFjZShOT1RfTElORV9FTkRJTkcsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpICsgaW5kZW50ICtcbiAgICAgICAgICAgICBsaW5lRW5kaW5nICsgdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKFByZXByb2Nlc3Nvci5ERUZJTkUubGFzdEluZGV4KTtcbiAgICAgICAgICAgIFByZXByb2Nlc3Nvci5FWFBSLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgdmVyYm9zZShcIiAgY29udGludWUgYXQgXCIgKyBQcmVwcm9jZXNzb3IuRVhQUi5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIHZlcmJvc2UoXCJTdGlsbCBvbiBzdGFjayAoXCIgKyBzdGFjay5sZW5ndGggKyBcIik6IFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhY2sucG9wKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJlcHJvY2Vzc29yO1xuXG5cbi8vIGNvbnN0IHBwID0gbmV3IFByZXByb2Nlc3NvcihcIi8vICNkZWZpbmUgQUFBQVxcbmhhbGxvIEFBQUEhXFxuLy8gI2lmZGVmIEFBQUFcXG5qYWphIGlzIGRlZmluZWQhXFxuLy8gI2Vsc2VcXG4gaHVyemlidXJ6aVxcbi8vICNlbmRpZlxcbmh1aHVcIiwgXCIuXCIsIHRydWUpO1xuLy8gLy8gZGVidWdnZXI7XG4vLyBjb25zdCByID0gcHAucHJvY2Vzcyh7IFwiYVwiOiAxIH0pO1xuLy8gY29uc29sZS5sb2cocik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/preproc.js\n");

/***/ }),

/***/ "./src/core/cg/sg_fpscounter.js":
/*!**************************************!*\
  !*** ./src/core/cg/sg_fpscounter.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FpsCounter)\n/* harmony export */ });\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../eventtarget */ \"./src/core/eventtarget.js\");\n\n\nclass FpsCounter extends _eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget\n{\n    constructor()\n    {\n        super();\n        this._timeStartFrame = 0;\n        this._timeStartSecond = 0;\n        this._fpsCounter = 0;\n        this._msCounter = 0;\n        this._frameCount = 0;\n\n        this.stats = { \"ms\": 0, \"fps\": 0 };\n    }\n\n    get frameCount()\n    {\n        return this._frameCount;\n    }\n\n    startFrame()\n    {\n        this._timeStartFrame = CABLES.now();\n    }\n\n    endFrame()\n    {\n        this._frameCount++;\n        this._fpsCounter++;\n\n        const timeFrame = CABLES.now() - this._timeStartFrame;\n        this._msCounter += timeFrame;\n\n        if (CABLES.now() - this._timeStartSecond > 1000)\n        {\n            this.endSecond();\n        }\n    }\n\n    endSecond()\n    {\n        this.stats.fps = this._fpsCounter;\n        this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100;\n\n        this.emitEvent(\"performance\", this.stats);\n\n        // reset\n        this._fpsCounter = 0;\n        this._msCounter = 0;\n        this._timeStartSecond = CABLES.now();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9zZ19mcHNjb3VudGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnL3NnX2Zwc2NvdW50ZXIuanM/YTBjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuLi9ldmVudHRhcmdldFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcHNDb3VudGVyIGV4dGVuZHMgRXZlbnRUYXJnZXRcbntcbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90aW1lU3RhcnRGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWVTdGFydFNlY29uZCA9IDA7XG4gICAgICAgIHRoaXMuX2Zwc0NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9tc0NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9mcmFtZUNvdW50ID0gMDtcblxuICAgICAgICB0aGlzLnN0YXRzID0geyBcIm1zXCI6IDAsIFwiZnBzXCI6IDAgfTtcbiAgICB9XG5cbiAgICBnZXQgZnJhbWVDb3VudCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVDb3VudDtcbiAgICB9XG5cbiAgICBzdGFydEZyYW1lKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3RpbWVTdGFydEZyYW1lID0gQ0FCTEVTLm5vdygpO1xuICAgIH1cblxuICAgIGVuZEZyYW1lKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2ZyYW1lQ291bnQrKztcbiAgICAgICAgdGhpcy5fZnBzQ291bnRlcisrO1xuXG4gICAgICAgIGNvbnN0IHRpbWVGcmFtZSA9IENBQkxFUy5ub3coKSAtIHRoaXMuX3RpbWVTdGFydEZyYW1lO1xuICAgICAgICB0aGlzLl9tc0NvdW50ZXIgKz0gdGltZUZyYW1lO1xuXG4gICAgICAgIGlmIChDQUJMRVMubm93KCkgLSB0aGlzLl90aW1lU3RhcnRTZWNvbmQgPiAxMDAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmVuZFNlY29uZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5kU2Vjb25kKClcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdHMuZnBzID0gdGhpcy5fZnBzQ291bnRlcjtcbiAgICAgICAgdGhpcy5zdGF0cy5tcyA9IE1hdGgucm91bmQodGhpcy5fbXNDb3VudGVyIC8gdGhpcy5fZnBzQ291bnRlciAqIDEwMCkgLyAxMDA7XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJwZXJmb3JtYW5jZVwiLCB0aGlzLnN0YXRzKTtcblxuICAgICAgICAvLyByZXNldFxuICAgICAgICB0aGlzLl9mcHNDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fbXNDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fdGltZVN0YXJ0U2Vjb25kID0gQ0FCTEVTLm5vdygpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cg/sg_fpscounter.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_framebuffer.js":
/*!*****************************************!*\
  !*** ./src/core/cgl/cgl_framebuffer.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Framebuffer\": () => (/* binding */ Framebuffer)\n/* harmony export */ });\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _cgl_texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_texture */ \"./src/core/cgl/cgl_texture.js\");\n\n\n\n// todo: convert to prototyped...\n\n/**\n * a framebuffer\n * @external CGL\n * @namespace Framebuffer\n * @constructor\n * @param {Context} cgl\n * @param {Number} width\n * @param {Number} height\n * @param {Object} [options]\n */\nconst Framebuffer = function (_cgl, _w, _h, options)\n{\n    const cgl = _cgl;\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Framebuffer\");\n    this.valid = true;\n\n    let depthTextureExt = cgl.gl.DEPTH_TEXTURE;\n    if (!depthTextureExt) depthTextureExt = cgl.enableExtension(\"WEBGL_depth_texture\");\n    if (!depthTextureExt) depthTextureExt = cgl.enableExtension(\"WEBKIT_WEBGL_depth_texture\");\n    if (!depthTextureExt) depthTextureExt = cgl.enableExtension(\"MOZ_WEBGL_depth_texture\");\n\n    if (!depthTextureExt)\n    {\n        cgl.exitError(\"NO_DEPTH_TEXTURE\", \"no depth texture support\");\n        // return;\n    }\n\n    let width = _w || 512;\n    let height = _h || 512;\n\n    options = options || {\n        \"isFloatingPointTexture\": false,\n    };\n\n    if (!options.hasOwnProperty(\"clear\")) options.clear = true;\n    if (!options.hasOwnProperty(\"filter\")) options.filter = _cgl_texture__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_LINEAR;\n\n    const texture = new _cgl_texture__WEBPACK_IMPORTED_MODULE_1__.Texture(cgl, {\n        \"isFloatingPointTexture\": options.isFloatingPointTexture,\n        \"filter\": options.filter,\n        \"wrap\": options.wrap || _cgl_texture__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_TO_EDGE\n    });\n\n    let textureDepth = null;\n    if (depthTextureExt)\n    {\n        textureDepth = new _cgl_texture__WEBPACK_IMPORTED_MODULE_1__.Texture(cgl, {\n            \"isDepthTexture\": true,\n        });\n    }\n    this._options = options;\n\n    const frameBuf = cgl.gl.createFramebuffer();\n    const depthBuffer = cgl.gl.createRenderbuffer();\n\n    this.getWidth = function ()\n    {\n        return width;\n    };\n    this.getHeight = function ()\n    {\n        return height;\n    };\n\n    /**\n     * get native gl framebuffer\n     * @function getGlFrameBuffer\n     * @memberof Framebuffer\n     * @returns {Object} framebuffer\n     */\n    this.getGlFrameBuffer = function ()\n    {\n        return frameBuf;\n    };\n\n    /**\n     * get depth renderbuffer\n     * @function getDepthRenderBuffer\n     * @memberof Framebuffer\n     * @returns {Object} renderbuffer\n     */\n    this.getDepthRenderBuffer = function ()\n    {\n        return depthBuffer;\n    };\n\n    /**\n     * get color texture\n     * @function getTextureColor\n     * @memberof Framebuffer\n     * @returns {Texture} rgba texture\n     */\n    this.getTextureColor = function ()\n    {\n        return texture;\n    };\n\n    /**\n     * get depth texture\n     * @function getTextureDepth\n     * @memberof Framebuffer\n     * @returns {Texture} depth texture\n     */\n    this.getTextureDepth = function ()\n    {\n        return textureDepth;\n    };\n\n    this.setFilter = function (f)\n    {\n        texture.filter = f;\n        texture.setSize(width, height);\n    };\n\n    this.setSize = function (w, h)\n    {\n        if (w < 2) w = 2;\n        if (h < 2) h = 2;\n\n        width = Math.ceil(w);\n        height = Math.ceil(h);\n\n        cgl.profileData.profileFrameBuffercreate++;\n\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);\n        cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, depthBuffer);\n\n        texture.setSize(width, height);\n        if (textureDepth) textureDepth.setSize(width, height);\n\n        // if(depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width,height);\n        if (depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width, height);\n\n        cgl.gl.framebufferTexture2D(cgl.gl.FRAMEBUFFER, cgl.gl.COLOR_ATTACHMENT0, cgl.gl.TEXTURE_2D, texture.tex, 0);\n\n        if (depthTextureExt)\n        {\n            cgl.gl.framebufferRenderbuffer(cgl.gl.FRAMEBUFFER, cgl.gl.DEPTH_ATTACHMENT, cgl.gl.RENDERBUFFER, depthBuffer);\n            cgl.gl.framebufferTexture2D(\n                cgl.gl.FRAMEBUFFER,\n                cgl.gl.DEPTH_ATTACHMENT, // safari needs DEPTH_ATTACHMENT NOT DEPTH_ATTACHMENT16\n                // cgl.gl.DEPTH_COMPONENT16,\n                cgl.gl.TEXTURE_2D,\n                textureDepth.tex,\n                0,\n            );\n        }\n\n        if (!cgl.gl.isFramebuffer(frameBuf)) throw new Error(\"Invalid framebuffer\");\n        const status = cgl.gl.checkFramebufferStatus(cgl.gl.FRAMEBUFFER);\n\n        switch (status)\n        {\n        case cgl.gl.FRAMEBUFFER_COMPLETE:\n            break;\n        case cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT...\", width, height, texture.tex, depthBuffer);\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\n        case cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n        case cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n        case cgl.gl.FRAMEBUFFER_UNSUPPORTED:\n            this._log.warn(\"FRAMEBUFFER_UNSUPPORTED\");\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED\");\n        case 0x8CDB:\n            this._log.warn(\"Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour.\");\n            this.valid = false;\n            break;\n        default:\n            this._log.warn(\"incomplete framebuffer\", status);\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: \" + status);\n            // throw(\"Incomplete framebuffer: \" + status);\n        }\n\n        cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);\n        cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, null);\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);\n    };\n\n    this.renderStart = function ()\n    {\n        cgl.pushModelMatrix();\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);\n        cgl.pushGlFrameBuffer(frameBuf);\n        cgl.pushFrameBuffer(this);\n\n        cgl.pushPMatrix();\n        cgl.gl.viewport(0, 0, width, height);\n\n        if (this._options.clear)\n        {\n            cgl.gl.clearColor(0, 0, 0, 0);\n            cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);\n        }\n    };\n\n    this.renderEnd = function ()\n    {\n        cgl.popPMatrix();\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, cgl.popGlFrameBuffer());\n        cgl.popFrameBuffer();\n\n        cgl.popModelMatrix();\n        cgl.resetViewPort();\n    };\n\n\n    this.delete = function ()\n    {\n        texture.delete();\n        this.valid = false;\n        if (textureDepth) textureDepth.delete();\n        cgl.gl.deleteRenderbuffer(depthBuffer);\n        cgl.gl.deleteFramebuffer(frameBuf);\n    };\n\n    this.dispose = this.delete;\n\n    this.setSize(width, height);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX2ZyYW1lYnVmZmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9mcmFtZWJ1ZmZlci5qcz80NmNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4vY2dsX3RleHR1cmVcIjtcblxuLy8gdG9kbzogY29udmVydCB0byBwcm90b3R5cGVkLi4uXG5cbi8qKlxuICogYSBmcmFtZWJ1ZmZlclxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBGcmFtZWJ1ZmZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNnbFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbmNvbnN0IEZyYW1lYnVmZmVyID0gZnVuY3Rpb24gKF9jZ2wsIF93LCBfaCwgb3B0aW9ucylcbntcbiAgICBjb25zdCBjZ2wgPSBfY2dsO1xuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJGcmFtZWJ1ZmZlclwiKTtcbiAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcblxuICAgIGxldCBkZXB0aFRleHR1cmVFeHQgPSBjZ2wuZ2wuREVQVEhfVEVYVFVSRTtcbiAgICBpZiAoIWRlcHRoVGV4dHVyZUV4dCkgZGVwdGhUZXh0dXJlRXh0ID0gY2dsLmVuYWJsZUV4dGVuc2lvbihcIldFQkdMX2RlcHRoX3RleHR1cmVcIik7XG4gICAgaWYgKCFkZXB0aFRleHR1cmVFeHQpIGRlcHRoVGV4dHVyZUV4dCA9IGNnbC5lbmFibGVFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZVwiKTtcbiAgICBpZiAoIWRlcHRoVGV4dHVyZUV4dCkgZGVwdGhUZXh0dXJlRXh0ID0gY2dsLmVuYWJsZUV4dGVuc2lvbihcIk1PWl9XRUJHTF9kZXB0aF90ZXh0dXJlXCIpO1xuXG4gICAgaWYgKCFkZXB0aFRleHR1cmVFeHQpXG4gICAge1xuICAgICAgICBjZ2wuZXhpdEVycm9yKFwiTk9fREVQVEhfVEVYVFVSRVwiLCBcIm5vIGRlcHRoIHRleHR1cmUgc3VwcG9ydFwiKTtcbiAgICAgICAgLy8gcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB3aWR0aCA9IF93IHx8IDUxMjtcbiAgICBsZXQgaGVpZ2h0ID0gX2ggfHwgNTEyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICBcImlzRmxvYXRpbmdQb2ludFRleHR1cmVcIjogZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNsZWFyXCIpKSBvcHRpb25zLmNsZWFyID0gdHJ1ZTtcbiAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJmaWx0ZXJcIikpIG9wdGlvbnMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTElORUFSO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGNnbCwge1xuICAgICAgICBcImlzRmxvYXRpbmdQb2ludFRleHR1cmVcIjogb3B0aW9ucy5pc0Zsb2F0aW5nUG9pbnRUZXh0dXJlLFxuICAgICAgICBcImZpbHRlclwiOiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgXCJ3cmFwXCI6IG9wdGlvbnMud3JhcCB8fCBUZXh0dXJlLkNMQU1QX1RPX0VER0VcbiAgICB9KTtcblxuICAgIGxldCB0ZXh0dXJlRGVwdGggPSBudWxsO1xuICAgIGlmIChkZXB0aFRleHR1cmVFeHQpXG4gICAge1xuICAgICAgICB0ZXh0dXJlRGVwdGggPSBuZXcgVGV4dHVyZShjZ2wsIHtcbiAgICAgICAgICAgIFwiaXNEZXB0aFRleHR1cmVcIjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgY29uc3QgZnJhbWVCdWYgPSBjZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBjb25zdCBkZXB0aEJ1ZmZlciA9IGNnbC5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgIHRoaXMuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgdGhpcy5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IG5hdGl2ZSBnbCBmcmFtZWJ1ZmZlclxuICAgICAqIEBmdW5jdGlvbiBnZXRHbEZyYW1lQnVmZmVyXG4gICAgICogQG1lbWJlcm9mIEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gZnJhbWVidWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLmdldEdsRnJhbWVCdWZmZXIgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZyYW1lQnVmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZGVwdGggcmVuZGVyYnVmZmVyXG4gICAgICogQGZ1bmN0aW9uIGdldERlcHRoUmVuZGVyQnVmZmVyXG4gICAgICogQG1lbWJlcm9mIEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVuZGVyYnVmZmVyXG4gICAgICovXG4gICAgdGhpcy5nZXREZXB0aFJlbmRlckJ1ZmZlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gZGVwdGhCdWZmZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBjb2xvciB0ZXh0dXJlXG4gICAgICogQGZ1bmN0aW9uIGdldFRleHR1cmVDb2xvclxuICAgICAqIEBtZW1iZXJvZiBGcmFtZWJ1ZmZlclxuICAgICAqIEByZXR1cm5zIHtUZXh0dXJlfSByZ2JhIHRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmdldFRleHR1cmVDb2xvciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGRlcHRoIHRleHR1cmVcbiAgICAgKiBAZnVuY3Rpb24gZ2V0VGV4dHVyZURlcHRoXG4gICAgICogQG1lbWJlcm9mIEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge1RleHR1cmV9IGRlcHRoIHRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmdldFRleHR1cmVEZXB0aCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGV4dHVyZURlcHRoO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEZpbHRlciA9IGZ1bmN0aW9uIChmKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZS5maWx0ZXIgPSBmO1xuICAgICAgICB0ZXh0dXJlLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3LCBoKVxuICAgIHtcbiAgICAgICAgaWYgKHcgPCAyKSB3ID0gMjtcbiAgICAgICAgaWYgKGggPCAyKSBoID0gMjtcblxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3KTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGgpO1xuXG4gICAgICAgIGNnbC5wcm9maWxlRGF0YS5wcm9maWxlRnJhbWVCdWZmZXJjcmVhdGUrKztcblxuICAgICAgICBjZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKGNnbC5nbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWYpO1xuICAgICAgICBjZ2wuZ2wuYmluZFJlbmRlcmJ1ZmZlcihjZ2wuZ2wuUkVOREVSQlVGRkVSLCBkZXB0aEJ1ZmZlcik7XG5cbiAgICAgICAgdGV4dHVyZS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAodGV4dHVyZURlcHRoKSB0ZXh0dXJlRGVwdGguc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBpZihkZXB0aFRleHR1cmVFeHQpIGNnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKGNnbC5nbC5SRU5ERVJCVUZGRVIsIGNnbC5nbC5ERVBUSF9DT01QT05FTlQxNiwgd2lkdGgsaGVpZ2h0KTtcbiAgICAgICAgaWYgKGRlcHRoVGV4dHVyZUV4dCkgY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoY2dsLmdsLlJFTkRFUkJVRkZFUiwgY2dsLmdsLkRFUFRIX0NPTVBPTkVOVDE2LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBjZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoY2dsLmdsLkZSQU1FQlVGRkVSLCBjZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGNnbC5nbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleCwgMCk7XG5cbiAgICAgICAgaWYgKGRlcHRoVGV4dHVyZUV4dClcbiAgICAgICAge1xuICAgICAgICAgICAgY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGNnbC5nbC5GUkFNRUJVRkZFUiwgY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIGNnbC5nbC5SRU5ERVJCVUZGRVIsIGRlcHRoQnVmZmVyKTtcbiAgICAgICAgICAgIGNnbC5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICAgICAgICBjZ2wuZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIC8vIHNhZmFyaSBuZWVkcyBERVBUSF9BVFRBQ0hNRU5UIE5PVCBERVBUSF9BVFRBQ0hNRU5UMTZcbiAgICAgICAgICAgICAgICAvLyBjZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXG4gICAgICAgICAgICAgICAgY2dsLmdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZURlcHRoLnRleCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2dsLmdsLmlzRnJhbWVidWZmZXIoZnJhbWVCdWYpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZyYW1lYnVmZmVyXCIpO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBjZ2wuZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhjZ2wuZ2wuRlJBTUVCVUZGRVIpO1xuXG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKVxuICAgICAgICB7XG4gICAgICAgIGNhc2UgY2dsLmdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY2dsLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5ULi4uXCIsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmUudGV4LCBkZXB0aEJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIik7XG4gICAgICAgIGNhc2UgY2dsLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpO1xuICAgICAgICBjYXNlIGNnbC5nbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgY2FzZSBjZ2wuZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCIpO1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7XG4gICAgICAgIGNhc2UgMHg4Q0RCOlxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJJbmNvbXBsZXRlOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RSQVdfQlVGRkVSIGZyb20gZXh0LiBPciBTYWZhcmkvaU9TIHVuZGVmaW5lZCBiZWhhdmlvdXIuXCIpO1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcImluY29tcGxldGUgZnJhbWVidWZmZXJcIiwgc3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IFwiICsgc3RhdHVzKTtcbiAgICAgICAgICAgIC8vIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBzdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2dsLmdsLmJpbmRUZXh0dXJlKGNnbC5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIoY2dsLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGNnbC5nbC5iaW5kRnJhbWVidWZmZXIoY2dsLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJTdGFydCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjZ2wucHVzaE1vZGVsTWF0cml4KCk7XG4gICAgICAgIGNnbC5nbC5iaW5kRnJhbWVidWZmZXIoY2dsLmdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1Zik7XG4gICAgICAgIGNnbC5wdXNoR2xGcmFtZUJ1ZmZlcihmcmFtZUJ1Zik7XG4gICAgICAgIGNnbC5wdXNoRnJhbWVCdWZmZXIodGhpcyk7XG5cbiAgICAgICAgY2dsLnB1c2hQTWF0cml4KCk7XG4gICAgICAgIGNnbC5nbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGVhcilcbiAgICAgICAge1xuICAgICAgICAgICAgY2dsLmdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBjZ2wuZ2wuY2xlYXIoY2dsLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCBjZ2wuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJFbmQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY2dsLnBvcFBNYXRyaXgoKTtcbiAgICAgICAgY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcihjZ2wuZ2wuRlJBTUVCVUZGRVIsIGNnbC5wb3BHbEZyYW1lQnVmZmVyKCkpO1xuICAgICAgICBjZ2wucG9wRnJhbWVCdWZmZXIoKTtcblxuICAgICAgICBjZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgICAgICAgY2dsLnJlc2V0Vmlld1BvcnQoKTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIGlmICh0ZXh0dXJlRGVwdGgpIHRleHR1cmVEZXB0aC5kZWxldGUoKTtcbiAgICAgICAgY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihkZXB0aEJ1ZmZlcik7XG4gICAgICAgIGNnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1Zik7XG4gICAgfTtcblxuICAgIHRoaXMuZGlzcG9zZSA9IHRoaXMuZGVsZXRlO1xuXG4gICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xufTtcblxuZXhwb3J0IHsgRnJhbWVidWZmZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_framebuffer.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_framebuffer2.js":
/*!******************************************!*\
  !*** ./src/core/cgl/cgl_framebuffer2.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Framebuffer2\": () => (/* binding */ Framebuffer2)\n/* harmony export */ });\n/* harmony import */ var _cgl_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_texture */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n// * see framebuffer1\n\n\n\n\n\n\nconst Framebuffer2 = function (cgl, w, h, options)\n{\n    if (cgl.glVersion == 1) return console.log(\"framebuffer2 used on webgl1\");\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"cgl_framebuffer2\");\n    this.Framebuffer2DrawTargetsDefault = null;\n    this.Framebuffer2BlittingFramebuffer = null;\n    this.Framebuffer2FinalFramebuffer = null;\n    this._cgl = cgl;\n\n    this._cgl.printError(\"before framebuffer2 constructor\");\n\n    this._width = 0;\n    this._height = 0;\n    this.valid = true;\n\n    this._depthRenderbuffer = null;\n    this._frameBuffer = null;\n    this._textureFrameBuffer = null;\n    this._colorRenderbuffers = [];\n    this._drawTargetArray = [];\n    this._disposed = false;\n\n    if (!this.Framebuffer2BlittingFramebuffer) this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();\n    if (!this.Framebuffer2FinalFramebuffer) this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();\n\n    if (!this.Framebuffer2DrawTargetsDefault) this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];\n\n    this._options = options || {\n        \"isFloatingPointTexture\": false,\n    };\n\n    // this._cgl.printError(\"fb2 before\");\n\n    this.name = this._options.name || \"unknown\";\n\n    this._cgl.profileData.addHeavyEvent(\"framebuffer create\", this.name);\n\n    if (!this._options.hasOwnProperty(\"numRenderBuffers\")) this._options.numRenderBuffers = 1;\n    if (!this._options.hasOwnProperty(\"depth\")) this._options.depth = true;\n    if (!this._options.hasOwnProperty(\"clear\")) this._options.clear = true;\n    if (!this._options.hasOwnProperty(\"multisampling\"))\n    {\n        this._options.multisampling = false;\n        this._options.multisamplingSamples = 0;\n    }\n\n    if (this._options.multisamplingSamples)\n    {\n        if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;\n        if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;\n        else this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples);\n    }\n\n    if (!this._options.hasOwnProperty(\"filter\")) this._options.filter = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_LINEAR;\n    if (!this._options.hasOwnProperty(\"wrap\")) this._options.wrap = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_REPEAT;\n\n    this._numRenderBuffers = this._options.numRenderBuffers;\n    this._colorTextures = [];\n\n    if (!options.pixelFormat)\n    {\n        if (options.isFloatingPointTexture) this._options.pixelFormat = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.PFORMATSTR_RGBA32F;\n        else this._options.pixelFormat = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.PFORMATSTR_RGBA8UB;\n    }\n\n\n    for (let i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._colorTextures[i] = new _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture(cgl, {\n            \"name\": \"fb2 \" + this.name + \" \" + i,\n            \"isFloatingPointTexture\": this._options.isFloatingPointTexture,\n            \"anisotropic\": this._options.anisotropic || 0,\n            \"pixelFormat\": this._options.pixelFormat,\n            \"filter\": this._options.filter,\n            \"wrap\": this._options.wrap,\n        });\n    }\n\n\n\n    let fil = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_NEAREST;\n    if (this._options.shadowMap) fil = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_LINEAR;\n\n    const defaultTexSize = 512;\n\n    if (this._options.depth)\n    {\n        this._textureDepth = new _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture(cgl,\n            {\n                \"name\": \"fb2 depth \" + this.name,\n                \"isDepthTexture\": true,\n                \"filter\": fil,\n                \"shadowMap\": this._options.shadowMap || false,\n                \"width\": w || defaultTexSize,\n                \"height\": h || defaultTexSize,\n            });\n    }\n\n    if (cgl.aborted) return;\n\n    this.setSize(w || defaultTexSize, h || defaultTexSize);\n\n    this._cgl.printError(\"framebuffer2 constructor\");\n};\n\nFramebuffer2.prototype.getWidth = function ()\n{\n    return this._width;\n};\nFramebuffer2.prototype.getHeight = function ()\n{\n    return this._height;\n};\n\nFramebuffer2.prototype.getGlFrameBuffer = function ()\n{\n    return this._frameBuffer;\n};\n\nFramebuffer2.prototype.getDepthRenderBuffer = function ()\n{\n    return this._depthRenderbuffer;\n};\n\nFramebuffer2.prototype.getTextureColor = function ()\n{\n    return this._colorTextures[0];\n};\n\nFramebuffer2.prototype.getTextureColorNum = function (i)\n{\n    return this._colorTextures[i];\n};\n\nFramebuffer2.prototype.getTextureDepth = function ()\n{\n    return this._textureDepth;\n};\n\nFramebuffer2.prototype.setFilter = function (f)\n{\n    for (let i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._colorTextures[i].filter = f;\n        this._colorTextures[i].setSize(this._width, this._height);\n    }\n};\n\nFramebuffer2.prototype.delete = Framebuffer2.prototype.dispose = function ()\n{\n    this._disposed = true;\n    let i = 0;\n    for (i = 0; i < this._numRenderBuffers; i++) this._colorTextures[i].delete();\n    // this._texture.delete();\n    if (this._textureDepth) this._textureDepth.delete();\n    for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);\n    this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);\n    this._cgl.gl.deleteFramebuffer(this._frameBuffer);\n    this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);\n};\n\nFramebuffer2.prototype.setSize = function (w, h)\n{\n    if (this._disposed) return this._log.warn(\"disposed framebuffer setsize...\");\n    this._cgl.profileData.addHeavyEvent(\"framebuffer resize\", this.name);\n\n    let i = 0;\n    this._width = Math.floor(w);\n    this._height = Math.floor(h);\n    this._width = Math.min(this._width, this._cgl.maxTexSize);\n    this._height = Math.min(this._height, this._cgl.maxTexSize);\n\n    this._cgl.profileData.profileFrameBuffercreate++;\n\n    if (this._frameBuffer)\n    {\n        for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);\n        // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);\n        this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);\n        this._cgl.gl.deleteFramebuffer(this._frameBuffer);\n        this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);\n    }\n\n    this._frameBuffer = this._cgl.gl.createFramebuffer();\n    this._textureFrameBuffer = this._cgl.gl.createFramebuffer();\n\n    const depth = this._options.depth;\n\n    for (i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._colorTextures[i].setSize(this._width, this._height);\n    }\n\n\n\n    for (i = 0; i < this._numRenderBuffers; i++)\n    {\n        const renderBuffer = this._cgl.gl.createRenderbuffer();\n\n        // color renderbuffer\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);\n\n        const info = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.setUpGlPixelFormat(this._cgl, this._options.pixelFormat);\n        let internFormat = info.glInternalFormat;\n\n        // if (this._options.isFloatingPointTexture)\n        // {\n        if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat))\n        {\n            const extcb = this._cgl.enableExtension(\"EXT_color_buffer_half_float\");\n\n            if (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n            {\n                this._options.filter = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_NEAREST;\n                this.setFilter(this._options.filter);\n            }\n        }\n        else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat))\n        {\n            if (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n            {\n                console.log(\"no linear pixelformat,using nearest\");\n                this._options.filter = _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_NEAREST;\n                this.setFilter(this._options.filter);\n            }\n        }\n        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F\n        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F\n        // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)\n        // {\n        //     const extcb = this._cgl.enableExtension(\"EXT_color_buffer_float\");\n\n        //     if (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n        //     {\n        //         console.log(\"no linear pixelformat,switching to nearest\");\n        //         this._options.filter = Texture.FILTER_NEAREST;\n        //         this.setFilter(this._options.filter);\n        //     }\n        // }\n        // }\n\n        if (this._options.multisampling && this._options.multisamplingSamples)\n        {\n            this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, internFormat, this._width, this._height);\n        }\n        else\n        {\n            this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, internFormat, this._width, this._height);\n        }\n\n\n\n        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, renderBuffer);\n        this._colorRenderbuffers[i] = renderBuffer;\n    }\n\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);\n\n    for (i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);\n    }\n\n    if (this._options.depth)\n    {\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);\n    }\n\n    // depth renderbuffer\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n\n\n    let depthType = this._cgl.gl.DEPTH_COMPONENT32F;\n\n    if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;\n    if (depth)\n    {\n        this._textureDepth.setSize(this._width, this._height);\n        this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();\n\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);\n        if (this._options.isFloatingPointTexture)\n        {\n            if (this._options.multisampling) this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);\n            else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);\n        }\n        else if (this._options.multisampling)\n        {\n            this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);\n            // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);\n        }\n        else\n        {\n            this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);\n        }\n\n        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);\n    }\n\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);\n\n    this._drawTargetArray.length = 0;\n    for (i = 0; i < this._numRenderBuffers; i++) this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);\n\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n\n\n    if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer)) this._log.warn(\"invalid framebuffer\");// throw new Error(\"Invalid framebuffer\");\n    const status = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);\n\n    if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE)\n    {\n        this._log.error(\"framebuffer incomplete: \" + this.name, this);\n        switch (status)\n        {\n        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT...\", this);\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\n        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n        case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:\n            this._log.warn(\"FRAMEBUFFER_UNSUPPORTED\");\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED\");\n        default:\n            this.valid = false;\n            this._log.warn(\"incomplete framebuffer\", status, this._frameBuffer);\n            this._cgl.printError();\n            this._cgl.exitError(\"Framebuffer incomplete...\");\n\n            this._frameBuffer = null;\n            // debugger;\n            throw new Error(\"Incomplete framebuffer: \" + status);\n        // throw(\"Incomplete framebuffer: \" + status);\n        }\n    }\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n    this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);\n\n    // this._cgl.printError(\"fb setsize\");\n};\n\nFramebuffer2.prototype.renderStart = function ()\n{\n    if (this._disposed) return this._log.warn(\"disposed framebuffer renderStart...\");\n    this._cgl.checkFrameStarted(\"fb2 renderstart\");\n    this._cgl.pushModelMatrix(); // needed ??\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n    this._cgl.pushGlFrameBuffer(this._frameBuffer);\n    this._cgl.pushFrameBuffer(this);\n\n    this._cgl.pushPMatrix();\n    // this._cgl.gl.viewport(0, 0, this._width, this._height);\n    this._cgl.pushViewPort(0, 0, this._width, this._height);\n\n    this._cgl.gl.drawBuffers(this._drawTargetArray);\n\n\n    // for (let i = 0; i <= this._numRenderBuffers; i++)\n    // {\n    //     this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);\n    //     this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [1.0, 0.0, 0.0, 0.0]);\n    // }\n\n    // this.clear();\n    if (this._options.clear)\n    {\n        this._cgl.gl.clearColor(0, 0, 0, 0);\n        this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT);\n    }\n};\n\nFramebuffer2.prototype.clear = function ()\n{\n    if (this._numRenderBuffers <= 1)\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);\n    }\n    else this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n\n    this._cgl.gl.drawBuffers(this._drawTargetArray);\n\n    for (let i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);\n        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 0.0]);\n    }\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n};\n\nFramebuffer2.prototype.renderEnd = function ()\n{\n    if (this._disposed) return this._log.warn(\"disposed framebuffer renderEnd...\");\n    this._cgl.popPMatrix();\n\n    this._cgl.profileData.profileFramebuffer++;\n\n\n    if (this._numRenderBuffers <= 1)\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);\n\n        // const a = this._cgl.gl.getFramebufferAttachmentParameter(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING);\n        // if (a == this._cgl.gl.SRGB)console.log(\"SRGB\", this._cgl.gl.SRGB);\n        // else if (a == this._cgl.gl.LINEAR)console.log(\"LINEAR\", this._cgl.gl.LINEAR);\n\n\n        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);\n        this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);\n    }\n    else\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);\n        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);\n\n        // console.log(\"fb this._numRenderBuffers\", this._numRenderBuffers);\n        for (let i = 0; i < this._numRenderBuffers; i++)\n        {\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);\n            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);\n\n\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);\n            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);\n\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);\n\n            // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);\n\n\n\n            let flags = this._cgl.gl.COLOR_BUFFER_BIT;\n            if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;\n\n            this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, flags, this._cgl.gl.NEAREST);\n        }\n    }\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());\n    this._cgl.popFrameBuffer();\n\n    this._cgl.popModelMatrix();\n    // this._cgl.resetViewPort();\n    this._cgl.popViewPort();\n\n\n    if (this._colorTextures[0].filter == _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_MIPMAP)\n    {\n        for (let i = 0; i < this._numRenderBuffers; i++)\n        {\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex);\n            this._colorTextures[i].updateMipMap();\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n        }\n    }\n};\n\n\n\n/// ///////\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX2ZyYW1lYnVmZmVyMi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9mcmFtZWJ1ZmZlcjIuanM/OGI1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAqIHNlZSBmcmFtZWJ1ZmZlcjFcblxuXG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4vY2dsX3RleHR1cmVcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5cblxuY29uc3QgRnJhbWVidWZmZXIyID0gZnVuY3Rpb24gKGNnbCwgdywgaCwgb3B0aW9ucylcbntcbiAgICBpZiAoY2dsLmdsVmVyc2lvbiA9PSAxKSByZXR1cm4gY29uc29sZS5sb2coXCJmcmFtZWJ1ZmZlcjIgdXNlZCBvbiB3ZWJnbDFcIik7XG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNnbF9mcmFtZWJ1ZmZlcjJcIik7XG4gICAgdGhpcy5GcmFtZWJ1ZmZlcjJEcmF3VGFyZ2V0c0RlZmF1bHQgPSBudWxsO1xuICAgIHRoaXMuRnJhbWVidWZmZXIyQmxpdHRpbmdGcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5GcmFtZWJ1ZmZlcjJGaW5hbEZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9jZ2wgPSBjZ2w7XG5cbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcImJlZm9yZSBmcmFtZWJ1ZmZlcjIgY29uc3RydWN0b3JcIik7XG5cbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9mcmFtZUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvclJlbmRlcmJ1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLl9kcmF3VGFyZ2V0QXJyYXkgPSBbXTtcbiAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLkZyYW1lYnVmZmVyMkJsaXR0aW5nRnJhbWVidWZmZXIpIHRoaXMuRnJhbWVidWZmZXIyQmxpdHRpbmdGcmFtZWJ1ZmZlciA9IGNnbC5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGlmICghdGhpcy5GcmFtZWJ1ZmZlcjJGaW5hbEZyYW1lYnVmZmVyKSB0aGlzLkZyYW1lYnVmZmVyMkZpbmFsRnJhbWVidWZmZXIgPSBjZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgIGlmICghdGhpcy5GcmFtZWJ1ZmZlcjJEcmF3VGFyZ2V0c0RlZmF1bHQpIHRoaXMuRnJhbWVidWZmZXIyRHJhd1RhcmdldHNEZWZhdWx0ID0gW2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG5cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIFwiaXNGbG9hdGluZ1BvaW50VGV4dHVyZVwiOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgLy8gdGhpcy5fY2dsLnByaW50RXJyb3IoXCJmYjIgYmVmb3JlXCIpO1xuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5fb3B0aW9ucy5uYW1lIHx8IFwidW5rbm93blwiO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJmcmFtZWJ1ZmZlciBjcmVhdGVcIiwgdGhpcy5uYW1lKTtcblxuICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcIm51bVJlbmRlckJ1ZmZlcnNcIikpIHRoaXMuX29wdGlvbnMubnVtUmVuZGVyQnVmZmVycyA9IDE7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KFwiZGVwdGhcIikpIHRoaXMuX29wdGlvbnMuZGVwdGggPSB0cnVlO1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNsZWFyXCIpKSB0aGlzLl9vcHRpb25zLmNsZWFyID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJtdWx0aXNhbXBsaW5nXCIpKVxuICAgIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZ1NhbXBsZXMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2NnbC5nbFNsb3dSZW5kZXJlcikgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcyA9IDA7XG4gICAgICAgIGlmICghdGhpcy5fY2dsLmdsLk1BWF9TQU1QTEVTKSB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzID0gMDtcbiAgICAgICAgZWxzZSB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzID0gTWF0aC5taW4odGhpcy5fY2dsLm1heFNhbXBsZXMsIHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZ1NhbXBsZXMpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImZpbHRlclwiKSkgdGhpcy5fb3B0aW9ucy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9MSU5FQVI7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KFwid3JhcFwiKSkgdGhpcy5fb3B0aW9ucy53cmFwID0gVGV4dHVyZS5XUkFQX1JFUEVBVDtcblxuICAgIHRoaXMuX251bVJlbmRlckJ1ZmZlcnMgPSB0aGlzLl9vcHRpb25zLm51bVJlbmRlckJ1ZmZlcnM7XG4gICAgdGhpcy5fY29sb3JUZXh0dXJlcyA9IFtdO1xuXG4gICAgaWYgKCFvcHRpb25zLnBpeGVsRm9ybWF0KVxuICAgIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZSkgdGhpcy5fb3B0aW9ucy5waXhlbEZvcm1hdCA9IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGO1xuICAgICAgICBlbHNlIHRoaXMuX29wdGlvbnMucGl4ZWxGb3JtYXQgPSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQThVQjtcbiAgICB9XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY29sb3JUZXh0dXJlc1tpXSA9IG5ldyBUZXh0dXJlKGNnbCwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZmIyIFwiICsgdGhpcy5uYW1lICsgXCIgXCIgKyBpLFxuICAgICAgICAgICAgXCJpc0Zsb2F0aW5nUG9pbnRUZXh0dXJlXCI6IHRoaXMuX29wdGlvbnMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZSxcbiAgICAgICAgICAgIFwiYW5pc290cm9waWNcIjogdGhpcy5fb3B0aW9ucy5hbmlzb3Ryb3BpYyB8fCAwLFxuICAgICAgICAgICAgXCJwaXhlbEZvcm1hdFwiOiB0aGlzLl9vcHRpb25zLnBpeGVsRm9ybWF0LFxuICAgICAgICAgICAgXCJmaWx0ZXJcIjogdGhpcy5fb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBcIndyYXBcIjogdGhpcy5fb3B0aW9ucy53cmFwLFxuICAgICAgICB9KTtcbiAgICB9XG5cblxuXG4gICAgbGV0IGZpbCA9IFRleHR1cmUuRklMVEVSX05FQVJFU1Q7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2hhZG93TWFwKSBmaWwgPSBUZXh0dXJlLkZJTFRFUl9MSU5FQVI7XG5cbiAgICBjb25zdCBkZWZhdWx0VGV4U2l6ZSA9IDUxMjtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRlcHRoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZURlcHRoID0gbmV3IFRleHR1cmUoY2dsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZiMiBkZXB0aCBcIiArIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBcImlzRGVwdGhUZXh0dXJlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJmaWx0ZXJcIjogZmlsLFxuICAgICAgICAgICAgICAgIFwic2hhZG93TWFwXCI6IHRoaXMuX29wdGlvbnMuc2hhZG93TWFwIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogdyB8fCBkZWZhdWx0VGV4U2l6ZSxcbiAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBoIHx8IGRlZmF1bHRUZXhTaXplLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNnbC5hYm9ydGVkKSByZXR1cm47XG5cbiAgICB0aGlzLnNldFNpemUodyB8fCBkZWZhdWx0VGV4U2l6ZSwgaCB8fCBkZWZhdWx0VGV4U2l6ZSk7XG5cbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcImZyYW1lYnVmZmVyMiBjb25zdHJ1Y3RvclwiKTtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZ2V0R2xGcmFtZUJ1ZmZlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lQnVmZmVyO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5nZXREZXB0aFJlbmRlckJ1ZmZlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5nZXRUZXh0dXJlQ29sb3IgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9jb2xvclRleHR1cmVzWzBdO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5nZXRUZXh0dXJlQ29sb3JOdW0gPSBmdW5jdGlvbiAoaSlcbntcbiAgICByZXR1cm4gdGhpcy5fY29sb3JUZXh0dXJlc1tpXTtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZ2V0VGV4dHVyZURlcHRoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZURlcHRoO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoZilcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV0uZmlsdGVyID0gZjtcbiAgICAgICAgdGhpcy5fY29sb3JUZXh0dXJlc1tpXS5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZGVsZXRlID0gRnJhbWVidWZmZXIyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV0uZGVsZXRlKCk7XG4gICAgLy8gdGhpcy5fdGV4dHVyZS5kZWxldGUoKTtcbiAgICBpZiAodGhpcy5fdGV4dHVyZURlcHRoKSB0aGlzLl90ZXh0dXJlRGVwdGguZGVsZXRlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKykgdGhpcy5fY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9jb2xvclJlbmRlcmJ1ZmZlcnNbaV0pO1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5fZGVwdGhSZW5kZXJidWZmZXIpO1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgdGhpcy5fY2dsLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX3RleHR1cmVGcmFtZUJ1ZmZlcik7XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAodywgaClcbntcbiAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHJldHVybiB0aGlzLl9sb2cud2FybihcImRpc3Bvc2VkIGZyYW1lYnVmZmVyIHNldHNpemUuLi5cIik7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJmcmFtZWJ1ZmZlciByZXNpemVcIiwgdGhpcy5uYW1lKTtcblxuICAgIGxldCBpID0gMDtcbiAgICB0aGlzLl93aWR0aCA9IE1hdGguZmxvb3Iodyk7XG4gICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5mbG9vcihoKTtcbiAgICB0aGlzLl93aWR0aCA9IE1hdGgubWluKHRoaXMuX3dpZHRoLCB0aGlzLl9jZ2wubWF4VGV4U2l6ZSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5taW4odGhpcy5faGVpZ2h0LCB0aGlzLl9jZ2wubWF4VGV4U2l6ZSk7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZUZyYW1lQnVmZmVyY3JlYXRlKys7XG5cbiAgICBpZiAodGhpcy5fZnJhbWVCdWZmZXIpXG4gICAge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX2NvbG9yUmVuZGVyYnVmZmVyc1tpXSk7XG4gICAgICAgIC8vIHRoaXMuX2NnbC5nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5fY29sb3JSZW5kZXJidWZmZXIpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX2ZyYW1lQnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX3RleHR1cmVGcmFtZUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVCdWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgIGNvbnN0IGRlcHRoID0gdGhpcy5fb3B0aW9ucy5kZXB0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLl9jb2xvclRleHR1cmVzW2ldLnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspXG4gICAge1xuICAgICAgICBjb25zdCByZW5kZXJCdWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cbiAgICAgICAgLy8gY29sb3IgcmVuZGVyYnVmZmVyXG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyQnVmZmVyKTtcblxuICAgICAgICBjb25zdCBpbmZvID0gVGV4dHVyZS5zZXRVcEdsUGl4ZWxGb3JtYXQodGhpcy5fY2dsLCB0aGlzLl9vcHRpb25zLnBpeGVsRm9ybWF0KTtcbiAgICAgICAgbGV0IGludGVybkZvcm1hdCA9IGluZm8uZ2xJbnRlcm5hbEZvcm1hdDtcblxuICAgICAgICAvLyBpZiAodGhpcy5fb3B0aW9ucy5pc0Zsb2F0aW5nUG9pbnRUZXh0dXJlKVxuICAgICAgICAvLyB7XG4gICAgICAgIGlmIChDR0wuVGV4dHVyZS5pc1BpeGVsRm9ybWF0SGFsZkZsb2F0KGluZm8ucGl4ZWxGb3JtYXQpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBleHRjYiA9IHRoaXMuX2NnbC5lbmFibGVFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIik7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fY2dsLmVuYWJsZUV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZpbHRlciA9IFRleHR1cmUuRklMVEVSX05FQVJFU1Q7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIodGhpcy5fb3B0aW9ucy5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENHTC5UZXh0dXJlLmlzUGl4ZWxGb3JtYXRGbG9hdChpbmZvLnBpeGVsRm9ybWF0KSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm8gbGluZWFyIHBpeGVsZm9ybWF0LHVzaW5nIG5lYXJlc3RcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsdGVyKHRoaXMuX29wdGlvbnMuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGlmIChpbmZvLnBpeGVsRm9ybWF0ID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGIHx8IGluZm8ucGl4ZWxGb3JtYXQgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1IxMUZHMTFGQjEwRlxuICAgICAgICAvLyBlbHNlIGlmIChpbmZvLnBpeGVsRm9ybWF0ID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGIHx8IGluZm8ucGl4ZWxGb3JtYXQgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1IxMUZHMTFGQjEwRlxuICAgICAgICAvLyBlbHNlIGlmIChpbmZvLnBpeGVsRm9ybWF0ID09IFRleHR1cmUuUEZPUk1BVFNUUl9SRzE2RilcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgY29uc3QgZXh0Y2IgPSB0aGlzLl9jZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKTtcblxuICAgICAgICAvLyAgICAgaWYgKCF0aGlzLl9jZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpKVxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwibm8gbGluZWFyIHBpeGVsZm9ybWF0LHN3aXRjaGluZyB0byBuZWFyZXN0XCIpO1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuX29wdGlvbnMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTkVBUkVTVDtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnNldEZpbHRlcih0aGlzLl9vcHRpb25zLmZpbHRlcik7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmcgJiYgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzLCBpbnRlcm5Gb3JtYXQsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgaW50ZXJuRm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCB0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJCdWZmZXIpO1xuICAgICAgICB0aGlzLl9jb2xvclJlbmRlcmJ1ZmZlcnNbaV0gPSByZW5kZXJCdWZmZXI7XG4gICAgfVxuXG4gICAgLy8gdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyKTtcbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fY29sb3JUZXh0dXJlc1tpXS50ZXgsIDApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRlcHRoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlRGVwdGgudGV4LCAwKTtcbiAgICB9XG5cbiAgICAvLyBkZXB0aCByZW5kZXJidWZmZXJcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XG5cblxuICAgIGxldCBkZXB0aFR5cGUgPSB0aGlzLl9jZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuXG4gICAgaWYgKHRoaXMuX2NnbC5nbFNsb3dSZW5kZXJlcikgZGVwdGhUeXBlID0gdGhpcy5fY2dsLmdsLkRFUFRIX0NPTVBPTkVOVDE2O1xuICAgIGlmIChkZXB0aClcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVEZXB0aC5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB0aGlzLl9kZXB0aFJlbmRlcmJ1ZmZlciA9IHRoaXMuX2NnbC5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9kZXB0aFJlbmRlcmJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmlzRmxvYXRpbmdQb2ludFRleHR1cmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmcpIHRoaXMuX2NnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcywgZGVwdGhUeXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgZGVwdGhUeXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcywgZGVwdGhUeXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIHRoaXMuX2NnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsZGVwdGhUeXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIGRlcHRoVHlwZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuREVQVEhfQVRUQUNITUVOVCwgdGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fZGVwdGhSZW5kZXJidWZmZXIpO1xuICAgIH1cblxuICAgIC8vIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAvLyB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyKTtcblxuICAgIHRoaXMuX2RyYXdUYXJnZXRBcnJheS5sZW5ndGggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspIHRoaXMuX2RyYXdUYXJnZXRBcnJheS5wdXNoKHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkpO1xuXG4gICAgLy8gdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cbiAgICBpZiAoIXRoaXMuX2NnbC5nbC5pc0ZyYW1lYnVmZmVyKHRoaXMuX3RleHR1cmVGcmFtZUJ1ZmZlcikpIHRoaXMuX2xvZy53YXJuKFwiaW52YWxpZCBmcmFtZWJ1ZmZlclwiKTsvLyB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZyYW1lYnVmZmVyXCIpO1xuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuX2NnbC5nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUik7XG5cbiAgICBpZiAoc3RhdHVzICE9IHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUl9DT01QTEVURSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcImZyYW1lYnVmZmVyIGluY29tcGxldGU6IFwiICsgdGhpcy5uYW1lLCB0aGlzKTtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpXG4gICAgICAgIHtcbiAgICAgICAgY2FzZSB0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQuLi5cIiwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIik7XG4gICAgICAgIGNhc2UgdGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpO1xuICAgICAgICBjYXNlIHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgY2FzZSB0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcImluY29tcGxldGUgZnJhbWVidWZmZXJcIiwgc3RhdHVzLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcigpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmV4aXRFcnJvcihcIkZyYW1lYnVmZmVyIGluY29tcGxldGUuLi5cIik7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGRlYnVnZ2VyO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBzdGF0dXMpO1xuICAgICAgICAvLyB0aHJvdyhcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IFwiICsgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB0aGlzLl9jZ2wuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblxuICAgIC8vIHRoaXMuX2NnbC5wcmludEVycm9yKFwiZmIgc2V0c2l6ZVwiKTtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUucmVuZGVyU3RhcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkgcmV0dXJuIHRoaXMuX2xvZy53YXJuKFwiZGlzcG9zZWQgZnJhbWVidWZmZXIgcmVuZGVyU3RhcnQuLi5cIik7XG4gICAgdGhpcy5fY2dsLmNoZWNrRnJhbWVTdGFydGVkKFwiZmIyIHJlbmRlcnN0YXJ0XCIpO1xuICAgIHRoaXMuX2NnbC5wdXNoTW9kZWxNYXRyaXgoKTsgLy8gbmVlZGVkID8/XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWZmZXIpO1xuICAgIHRoaXMuX2NnbC5wdXNoR2xGcmFtZUJ1ZmZlcih0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgdGhpcy5fY2dsLnB1c2hGcmFtZUJ1ZmZlcih0aGlzKTtcblxuICAgIHRoaXMuX2NnbC5wdXNoUE1hdHJpeCgpO1xuICAgIC8vIHRoaXMuX2NnbC5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB0aGlzLl9jZ2wucHVzaFZpZXdQb3J0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuXG4gICAgdGhpcy5fY2dsLmdsLmRyYXdCdWZmZXJzKHRoaXMuX2RyYXdUYXJnZXRBcnJheSk7XG5cblxuICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKylcbiAgICAvLyB7XG4gICAgLy8gICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2NvbG9yUmVuZGVyYnVmZmVyc1tpXSk7XG4gICAgLy8gICAgIHRoaXMuX2NnbC5nbC5jbGVhckJ1ZmZlcmZ2KHRoaXMuX2NnbC5nbC5DT0xPUiwgaSwgWzEuMCwgMC4wLCAwLjAsIDAuMF0pO1xuICAgIC8vIH1cblxuICAgIC8vIHRoaXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGVhcilcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuY2xlYXIodGhpcy5fY2dsLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLl9jZ2wuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgfVxufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX251bVJlbmRlckJ1ZmZlcnMgPD0gMSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWZmZXIpO1xuXG4gICAgdGhpcy5fY2dsLmdsLmRyYXdCdWZmZXJzKHRoaXMuX2RyYXdUYXJnZXRBcnJheSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl9jb2xvclRleHR1cmVzW2ldLnRleCwgMCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5jbGVhckJ1ZmZlcmZ2KHRoaXMuX2NnbC5nbC5DT0xPUiwgaSwgWzAuMCwgMC4wLCAwLjAsIDAuMF0pO1xuICAgIH1cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLnJlbmRlckVuZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSByZXR1cm4gdGhpcy5fbG9nLndhcm4oXCJkaXNwb3NlZCBmcmFtZWJ1ZmZlciByZW5kZXJFbmQuLi5cIik7XG4gICAgdGhpcy5fY2dsLnBvcFBNYXRyaXgoKTtcblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlRnJhbWVidWZmZXIrKztcblxuXG4gICAgaWYgKHRoaXMuX251bVJlbmRlckJ1ZmZlcnMgPD0gMSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyKTtcblxuICAgICAgICAvLyBjb25zdCBhID0gdGhpcy5fY2dsLmdsLmdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09MT1JfRU5DT0RJTkcpO1xuICAgICAgICAvLyBpZiAoYSA9PSB0aGlzLl9jZ2wuZ2wuU1JHQiljb25zb2xlLmxvZyhcIlNSR0JcIiwgdGhpcy5fY2dsLmdsLlNSR0IpO1xuICAgICAgICAvLyBlbHNlIGlmIChhID09IHRoaXMuX2NnbC5nbC5MSU5FQVIpY29uc29sZS5sb2coXCJMSU5FQVJcIiwgdGhpcy5fY2dsLmdsLkxJTkVBUik7XG5cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuY2xlYXJCdWZmZXJmdih0aGlzLl9jZ2wuZ2wuQ09MT1IsIDAsIFswLjAsIDAuMCwgMC4wLCAxLjBdKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJsaXRGcmFtZWJ1ZmZlcigwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCAwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuX2NnbC5nbC5ERVBUSF9CVUZGRVJfQklULCB0aGlzLl9jZ2wuZ2wuTkVBUkVTVCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLkZyYW1lYnVmZmVyMkJsaXR0aW5nRnJhbWVidWZmZXIpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuREVQVEhfQVRUQUNITUVOVCwgdGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fZGVwdGhSZW5kZXJidWZmZXIpO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLkZyYW1lYnVmZmVyMkZpbmFsRnJhbWVidWZmZXIpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuREVQVEhfQVRUQUNITUVOVCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVEZXB0aC50ZXgsIDApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZmIgdGhpcy5fbnVtUmVuZGVyQnVmZmVyc1wiLCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLkZyYW1lYnVmZmVyMkJsaXR0aW5nRnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9jb2xvclJlbmRlcmJ1ZmZlcnNbaV0pO1xuXG5cbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLkZyYW1lYnVmZmVyMkZpbmFsRnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fY29sb3JUZXh0dXJlc1tpXS50ZXgsIDApO1xuXG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuRnJhbWVidWZmZXIyQmxpdHRpbmdGcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLkZyYW1lYnVmZmVyMkZpbmFsRnJhbWVidWZmZXIpO1xuXG4gICAgICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wuY2xlYXJCdWZmZXJmdih0aGlzLl9jZ2wuZ2wuQ09MT1IsIGksIFswLjAsIDAuMCwgMC4wLCAxLjBdKTtcblxuXG5cbiAgICAgICAgICAgIGxldCBmbGFncyA9IHRoaXMuX2NnbC5nbC5DT0xPUl9CVUZGRVJfQklUO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkgZmxhZ3MgfD0gdGhpcy5fY2dsLmdsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5ibGl0RnJhbWVidWZmZXIoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgZmxhZ3MsIHRoaXMuX2NnbC5nbC5ORUFSRVNUKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wucG9wR2xGcmFtZUJ1ZmZlcigpKTtcbiAgICB0aGlzLl9jZ2wucG9wRnJhbWVCdWZmZXIoKTtcblxuICAgIHRoaXMuX2NnbC5wb3BNb2RlbE1hdHJpeCgpO1xuICAgIC8vIHRoaXMuX2NnbC5yZXNldFZpZXdQb3J0KCk7XG4gICAgdGhpcy5fY2dsLnBvcFZpZXdQb3J0KCk7XG5cblxuICAgIGlmICh0aGlzLl9jb2xvclRleHR1cmVzWzBdLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl9jb2xvclRleHR1cmVzW2ldLnRleCk7XG4gICAgICAgICAgICB0aGlzLl9jb2xvclRleHR1cmVzW2ldLnVwZGF0ZU1pcE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7IEZyYW1lYnVmZmVyMiB9O1xuXG4vLy8gLy8vLy8vL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_framebuffer2.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_marker.js":
/*!************************************!*\
  !*** ./src/core/cgl/cgl_marker.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Marker\": () => (/* binding */ Marker),\n/* harmony export */   \"WireCube\": () => (/* binding */ WireCube),\n/* harmony export */   \"WirePoint\": () => (/* binding */ WirePoint)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_geom */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _cgl_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_mesh */ \"./src/core/cgl/cgl_mesh.js\");\n/* harmony import */ var _cgl_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_shader */ \"./src/core/cgl/cgl_shader.js\");\n/* harmony import */ var _cgl_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_utils */ \"./src/core/cgl/cgl_utils.js\");\n// import { vec3, mat4 } from \"gl-matrix\";\n\n\n\n\n\n\nconst Marker = function (_cgl)\n{\n    const geom = new _cg_cg_geom__WEBPACK_IMPORTED_MODULE_0__.Geometry(\"marker\");\n    geom.setPointVertices(\n        [\n            0.00001, 0, 0, 1, 0, 0,\n            0, 0.00001, 0, 0, 1, 0,\n            0, 0, 0.00001, 0, 0, 1,\n        ]\n    );\n    const mesh = new _cgl_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh(_cgl, geom, _cgl.gl.LINES);\n    mesh.setGeom(geom);\n\n    const shader = new _cgl_shader__WEBPACK_IMPORTED_MODULE_2__.Shader(_cgl, \"markermaterial\");\n\n    const frag = \"\"\n        .endl() + \"precision highp float;\"\n        .endl() + \"IN vec3 axisColor;\"\n\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"    vec4 col=vec4(axisColor,1.0);\"\n        .endl() + \"    outColor = col;\"\n        .endl() + \"}\";\n\n    const vert = \"\"\n        .endl() + \"IN vec3 vPosition;\"\n        .endl() + \"UNI mat4 projMatrix;\"\n        .endl() + \"UNI mat4 mvMatrix;\"\n        .endl() + \"OUT vec3 axisColor;\"\n\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"   vec4 pos=vec4(vPosition, 1.0);\"\n        .endl() + \"   if(pos.x!=0.0)axisColor=vec3(1.0,0.3,0.0);\"\n        .endl() + \"   if(pos.y!=0.0)axisColor=vec3(0.0,1.0,0.2);\"\n        .endl() + \"   if(pos.z!=0.0)axisColor=vec3(0.0,0.5,1.0);\"\n\n        .endl() + \"   gl_Position = projMatrix * mvMatrix * pos;\"\n        .endl() + \"}\";\n\n    shader.setSource(vert, frag);\n\n    this._vScale = vec3.create();\n\n    this.draw = function (cgl, _size, depthTest)\n    {\n        const size = _size || 2;\n        cgl.pushModelMatrix();\n\n        cgl.pushShader(shader);\n\n        vec3.set(this._vScale, size, size, size);\n        mat4.scale(cgl.mvMatrix, cgl.mvMatrix, this._vScale);\n\n        // cgl.gl.disable(cgl.gl.DEPTH_TEST);\n        cgl.pushDepthTest(depthTest == true);\n\n        mesh.render(cgl.getShader());\n\n        // cgl.gl.enable(cgl.gl.DEPTH_TEST);\n        cgl.popDepthTest();\n        cgl.popShader();\n\n        cgl.popModelMatrix();\n    };\n};\n\n\nconst WirePoint = function (cgl)\n{\n    const buffer = cgl.gl.createBuffer();\n    const vScale = vec3.create();\n\n    function bufferData()\n    {\n        const points = [];\n        const segments = 24;\n        let i = 0, degInRad = 0;\n        const radius = 0.5;\n\n        for (i = 0; i <= Math.round(segments); i++)\n        {\n            degInRad = (360.0 / Math.round(segments)) * i * _cgl_utils__WEBPACK_IMPORTED_MODULE_3__.DEG2RAD;\n            points.push(Math.cos(degInRad) * radius);\n            points.push(0);\n            points.push(Math.sin(degInRad) * radius);\n        }\n\n        for (i = 0; i <= Math.round(segments); i++)\n        {\n            degInRad = (360.0 / Math.round(segments)) * i * _cgl_utils__WEBPACK_IMPORTED_MODULE_3__.DEG2RAD;\n            points.push(Math.cos(degInRad) * radius);\n            points.push(Math.sin(degInRad) * radius);\n            points.push(0);\n        }\n\n        for (i = 0; i <= Math.round(segments); i++)\n        {\n            degInRad = (360.0 / Math.round(segments)) * i * _cgl_utils__WEBPACK_IMPORTED_MODULE_3__.DEG2RAD;\n            points.push(0);\n            points.push(Math.cos(degInRad) * radius);\n            points.push(Math.sin(degInRad) * radius);\n        }\n\n        cgl.gl.bindBuffer(cgl.gl.ARRAY_BUFFER, buffer);\n        cgl.gl.bufferData(cgl.gl.ARRAY_BUFFER, new Float32Array(points), cgl.gl.STATIC_DRAW);\n        buffer.itemSize = 3;\n        buffer.numItems = points.length / buffer.itemSize;\n    }\n\n    this.render = function (_cgl, _size)\n    {\n        _cgl.pushModelMatrix();\n\n        vec3.set(vScale, _size, _size, _size);\n        mat4.scale(_cgl.mvMatrix, _cgl.mvMatrix, vScale);\n\n        const shader = _cgl.getShader();\n\n        if (shader)\n        {\n            shader.bind();\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n\n            _cgl.gl.vertexAttribPointer(shader.getAttrVertexPos(), buffer.itemSize, _cgl.gl.FLOAT, false, 0, 0);\n            _cgl.gl.enableVertexAttribArray(shader.getAttrVertexPos());\n\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n            _cgl.gl.drawArrays(_cgl.gl.LINE_STRIP, 0, buffer.numItems);\n        }\n\n        _cgl.popModelMatrix();\n    };\n\n    bufferData();\n};\n\n\nconst WireCube = function (cgl)\n{\n    const buffer = cgl.gl.createBuffer();\n    const vScale = vec3.create();\n\n    function bufferData()\n    {\n        const points = [];\n        const tc = [];\n        const norms = [];\n        const segments = 24;\n        const radius = 0.5;\n\n        points.push(-1, -1, 1);\n        points.push(1, -1, 1);\n        points.push(1, 1, 1);\n        points.push(-1, 1, 1);\n        points.push(-1, -1, 1);\n\n        points.push(-1, -1, -1);\n        points.push(1, -1, -1);\n        points.push(1, 1, -1);\n        points.push(-1, 1, -1);\n        points.push(-1, -1, -1);\n\n        points.push(-1, -1, -1);\n        points.push(-1, 1, -1);\n        points.push(-1, 1, 1);\n        points.push(-1, -1, 1);\n        points.push(-1, -1, -1);\n\n        points.push(1, -1, -1);\n        points.push(1, 1, -1);\n        points.push(1, 1, 1);\n        points.push(1, -1, 1);\n        points.push(1, -1, -1);\n\n        cgl.gl.bindBuffer(cgl.gl.ARRAY_BUFFER, buffer);\n        cgl.gl.bufferData(cgl.gl.ARRAY_BUFFER, new Float32Array(points), cgl.gl.STATIC_DRAW);\n        buffer.itemSize = 3;\n        buffer.numItems = points.length / buffer.itemSize;\n    }\n\n    this.render = function (_cgl, sizeX, sizeY, sizeZ)\n    {\n        _cgl.pushModelMatrix();\n\n        vec3.set(vScale, sizeX || 1, sizeY || 1, sizeZ || 1);\n        mat4.scale(_cgl.mvMatrix, _cgl.mvMatrix, vScale);\n\n        const shader = _cgl.getShader();\n        if (shader)\n        {\n            shader.bind();\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n\n            _cgl.gl.vertexAttribPointer(shader.getAttrVertexPos(), buffer.itemSize, _cgl.gl.FLOAT, false, 0, 0);\n            _cgl.gl.enableVertexAttribArray(shader.getAttrVertexPos());\n\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n            _cgl.gl.drawArrays(_cgl.gl.LINE_STRIP, 0, buffer.numItems);\n        }\n\n        _cgl.popModelMatrix();\n    };\n\n    bufferData();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX21hcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX21hcmtlci5qcz84ZjJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7IHZlYzMsIG1hdDQgfSBmcm9tIFwiZ2wtbWF0cml4XCI7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCIuLi9jZy9jZ19nZW9tXCI7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSBcIi4vY2dsX21lc2hcIjtcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuL2NnbF9zaGFkZXJcIjtcbmltcG9ydCB7IERFRzJSQUQgfSBmcm9tIFwiLi9jZ2xfdXRpbHNcIjtcblxuXG5leHBvcnQgY29uc3QgTWFya2VyID0gZnVuY3Rpb24gKF9jZ2wpXG57XG4gICAgY29uc3QgZ2VvbSA9IG5ldyBHZW9tZXRyeShcIm1hcmtlclwiKTtcbiAgICBnZW9tLnNldFBvaW50VmVydGljZXMoXG4gICAgICAgIFtcbiAgICAgICAgICAgIDAuMDAwMDEsIDAsIDAsIDEsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLjAwMDAxLCAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgMC4wMDAwMSwgMCwgMCwgMSxcbiAgICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKF9jZ2wsIGdlb20sIF9jZ2wuZ2wuTElORVMpO1xuICAgIG1lc2guc2V0R2VvbShnZW9tKTtcblxuICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXIoX2NnbCwgXCJtYXJrZXJtYXRlcmlhbFwiKTtcblxuICAgIGNvbnN0IGZyYWcgPSBcIlwiXG4gICAgICAgIC5lbmRsKCkgKyBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIlxuICAgICAgICAuZW5kbCgpICsgXCJJTiB2ZWMzIGF4aXNDb2xvcjtcIlxuXG4gICAgICAgIC5lbmRsKCkgKyBcInZvaWQgbWFpbigpXCJcbiAgICAgICAgLmVuZGwoKSArIFwie1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgICB2ZWM0IGNvbD12ZWM0KGF4aXNDb2xvciwxLjApO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgICBvdXRDb2xvciA9IGNvbDtcIlxuICAgICAgICAuZW5kbCgpICsgXCJ9XCI7XG5cbiAgICBjb25zdCB2ZXJ0ID0gXCJcIlxuICAgICAgICAuZW5kbCgpICsgXCJJTiB2ZWMzIHZQb3NpdGlvbjtcIlxuICAgICAgICAuZW5kbCgpICsgXCJVTkkgbWF0NCBwcm9qTWF0cml4O1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIlVOSSBtYXQ0IG12TWF0cml4O1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIk9VVCB2ZWMzIGF4aXNDb2xvcjtcIlxuXG4gICAgICAgIC5lbmRsKCkgKyBcInZvaWQgbWFpbigpXCJcbiAgICAgICAgLmVuZGwoKSArIFwie1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgIHZlYzQgcG9zPXZlYzQodlBvc2l0aW9uLCAxLjApO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgIGlmKHBvcy54IT0wLjApYXhpc0NvbG9yPXZlYzMoMS4wLDAuMywwLjApO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgIGlmKHBvcy55IT0wLjApYXhpc0NvbG9yPXZlYzMoMC4wLDEuMCwwLjIpO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgIGlmKHBvcy56IT0wLjApYXhpc0NvbG9yPXZlYzMoMC4wLDAuNSwxLjApO1wiXG5cbiAgICAgICAgLmVuZGwoKSArIFwiICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogbXZNYXRyaXggKiBwb3M7XCJcbiAgICAgICAgLmVuZGwoKSArIFwifVwiO1xuXG4gICAgc2hhZGVyLnNldFNvdXJjZSh2ZXJ0LCBmcmFnKTtcblxuICAgIHRoaXMuX3ZTY2FsZSA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoY2dsLCBfc2l6ZSwgZGVwdGhUZXN0KVxuICAgIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IF9zaXplIHx8IDI7XG4gICAgICAgIGNnbC5wdXNoTW9kZWxNYXRyaXgoKTtcblxuICAgICAgICBjZ2wucHVzaFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIHZlYzMuc2V0KHRoaXMuX3ZTY2FsZSwgc2l6ZSwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIG1hdDQuc2NhbGUoY2dsLm12TWF0cml4LCBjZ2wubXZNYXRyaXgsIHRoaXMuX3ZTY2FsZSk7XG5cbiAgICAgICAgLy8gY2dsLmdsLmRpc2FibGUoY2dsLmdsLkRFUFRIX1RFU1QpO1xuICAgICAgICBjZ2wucHVzaERlcHRoVGVzdChkZXB0aFRlc3QgPT0gdHJ1ZSk7XG5cbiAgICAgICAgbWVzaC5yZW5kZXIoY2dsLmdldFNoYWRlcigpKTtcblxuICAgICAgICAvLyBjZ2wuZ2wuZW5hYmxlKGNnbC5nbC5ERVBUSF9URVNUKTtcbiAgICAgICAgY2dsLnBvcERlcHRoVGVzdCgpO1xuICAgICAgICBjZ2wucG9wU2hhZGVyKCk7XG5cbiAgICAgICAgY2dsLnBvcE1vZGVsTWF0cml4KCk7XG4gICAgfTtcbn07XG5cblxuZXhwb3J0IGNvbnN0IFdpcmVQb2ludCA9IGZ1bmN0aW9uIChjZ2wpXG57XG4gICAgY29uc3QgYnVmZmVyID0gY2dsLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGNvbnN0IHZTY2FsZSA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICBmdW5jdGlvbiBidWZmZXJEYXRhKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IDI0O1xuICAgICAgICBsZXQgaSA9IDAsIGRlZ0luUmFkID0gMDtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gMC41O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gTWF0aC5yb3VuZChzZWdtZW50cyk7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVnSW5SYWQgPSAoMzYwLjAgLyBNYXRoLnJvdW5kKHNlZ21lbnRzKSkgKiBpICogREVHMlJBRDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKE1hdGguY29zKGRlZ0luUmFkKSAqIHJhZGl1cyk7XG4gICAgICAgICAgICBwb2ludHMucHVzaCgwKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKE1hdGguc2luKGRlZ0luUmFkKSAqIHJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IE1hdGgucm91bmQoc2VnbWVudHMpOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlZ0luUmFkID0gKDM2MC4wIC8gTWF0aC5yb3VuZChzZWdtZW50cykpICogaSAqIERFRzJSQUQ7XG4gICAgICAgICAgICBwb2ludHMucHVzaChNYXRoLmNvcyhkZWdJblJhZCkgKiByYWRpdXMpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goTWF0aC5zaW4oZGVnSW5SYWQpICogcmFkaXVzKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBNYXRoLnJvdW5kKHNlZ21lbnRzKTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWdJblJhZCA9ICgzNjAuMCAvIE1hdGgucm91bmQoc2VnbWVudHMpKSAqIGkgKiBERUcyUkFEO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goMCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChNYXRoLmNvcyhkZWdJblJhZCkgKiByYWRpdXMpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goTWF0aC5zaW4oZGVnSW5SYWQpICogcmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNnbC5nbC5iaW5kQnVmZmVyKGNnbC5nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICAgIGNnbC5nbC5idWZmZXJEYXRhKGNnbC5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzKSwgY2dsLmdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgYnVmZmVyLml0ZW1TaXplID0gMztcbiAgICAgICAgYnVmZmVyLm51bUl0ZW1zID0gcG9pbnRzLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChfY2dsLCBfc2l6ZSlcbiAgICB7XG4gICAgICAgIF9jZ2wucHVzaE1vZGVsTWF0cml4KCk7XG5cbiAgICAgICAgdmVjMy5zZXQodlNjYWxlLCBfc2l6ZSwgX3NpemUsIF9zaXplKTtcbiAgICAgICAgbWF0NC5zY2FsZShfY2dsLm12TWF0cml4LCBfY2dsLm12TWF0cml4LCB2U2NhbGUpO1xuXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IF9jZ2wuZ2V0U2hhZGVyKCk7XG5cbiAgICAgICAgaWYgKHNoYWRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcbiAgICAgICAgICAgIF9jZ2wuZ2wuYmluZEJ1ZmZlcihfY2dsLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblxuICAgICAgICAgICAgX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5nZXRBdHRyVmVydGV4UG9zKCksIGJ1ZmZlci5pdGVtU2l6ZSwgX2NnbC5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgX2NnbC5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXIuZ2V0QXR0clZlcnRleFBvcygpKTtcblxuICAgICAgICAgICAgX2NnbC5nbC5iaW5kQnVmZmVyKF9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICAgICAgX2NnbC5nbC5kcmF3QXJyYXlzKF9jZ2wuZ2wuTElORV9TVFJJUCwgMCwgYnVmZmVyLm51bUl0ZW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgICB9O1xuXG4gICAgYnVmZmVyRGF0YSgpO1xufTtcblxuXG5leHBvcnQgY29uc3QgV2lyZUN1YmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNnbC5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBjb25zdCB2U2NhbGUgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gYnVmZmVyRGF0YSgpXG4gICAge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgdGMgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9ybXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSAyNDtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gMC41O1xuXG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAtMSwgMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKDEsIC0xLCAxKTtcbiAgICAgICAgcG9pbnRzLnB1c2goMSwgMSwgMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAxLCAxKTtcbiAgICAgICAgcG9pbnRzLnB1c2goLTEsIC0xLCAxKTtcblxuICAgICAgICBwb2ludHMucHVzaCgtMSwgLTEsIC0xKTtcbiAgICAgICAgcG9pbnRzLnB1c2goMSwgLTEsIC0xKTtcbiAgICAgICAgcG9pbnRzLnB1c2goMSwgMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgLTEsIC0xKTtcblxuICAgICAgICBwb2ludHMucHVzaCgtMSwgLTEsIC0xKTtcbiAgICAgICAgcG9pbnRzLnB1c2goLTEsIDEsIC0xKTtcbiAgICAgICAgcG9pbnRzLnB1c2goLTEsIDEsIDEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgLTEsIDEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgLTEsIC0xKTtcblxuICAgICAgICBwb2ludHMucHVzaCgxLCAtMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgxLCAxLCAtMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKDEsIDEsIDEpO1xuICAgICAgICBwb2ludHMucHVzaCgxLCAtMSwgMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKDEsIC0xLCAtMSk7XG5cbiAgICAgICAgY2dsLmdsLmJpbmRCdWZmZXIoY2dsLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgY2dsLmdsLmJ1ZmZlckRhdGEoY2dsLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShwb2ludHMpLCBjZ2wuZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBidWZmZXIuaXRlbVNpemUgPSAzO1xuICAgICAgICBidWZmZXIubnVtSXRlbXMgPSBwb2ludHMubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKF9jZ2wsIHNpemVYLCBzaXplWSwgc2l6ZVopXG4gICAge1xuICAgICAgICBfY2dsLnB1c2hNb2RlbE1hdHJpeCgpO1xuXG4gICAgICAgIHZlYzMuc2V0KHZTY2FsZSwgc2l6ZVggfHwgMSwgc2l6ZVkgfHwgMSwgc2l6ZVogfHwgMSk7XG4gICAgICAgIG1hdDQuc2NhbGUoX2NnbC5tdk1hdHJpeCwgX2NnbC5tdk1hdHJpeCwgdlNjYWxlKTtcblxuICAgICAgICBjb25zdCBzaGFkZXIgPSBfY2dsLmdldFNoYWRlcigpO1xuICAgICAgICBpZiAoc2hhZGVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xuICAgICAgICAgICAgX2NnbC5nbC5iaW5kQnVmZmVyKF9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXG4gICAgICAgICAgICBfY2dsLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmdldEF0dHJWZXJ0ZXhQb3MoKSwgYnVmZmVyLml0ZW1TaXplLCBfY2dsLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBfY2dsLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlci5nZXRBdHRyVmVydGV4UG9zKCkpO1xuXG4gICAgICAgICAgICBfY2dsLmdsLmJpbmRCdWZmZXIoX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICAgICAgICBfY2dsLmdsLmRyYXdBcnJheXMoX2NnbC5nbC5MSU5FX1NUUklQLCAwLCBidWZmZXIubnVtSXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NnbC5wb3BNb2RlbE1hdHJpeCgpO1xuICAgIH07XG5cbiAgICBidWZmZXJEYXRhKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_marker.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_mesh.js":
/*!**********************************!*\
  !*** ./src/core/cgl/cgl_mesh.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MESH\": () => (/* binding */ MESH),\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_shader_uniform */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_mesh_feedback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_mesh_feedback */ \"./src/core/cgl/cgl_mesh_feedback.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n\n\n\n\n\nconst MESH = {};\nMESH.lastMesh = null;\n\n/**\n * webgl renderable 3d object\n * @external CGL\n * @namespace Mesh\n * @hideconstructor\n * @param {Context} cgl\n * @param {Geometry} geometry\n * @param {Number} [glPrimitive]\n * @class\n * @example\n * const cgl=this._cgl\n * const mesh=new CGL.Mesh(cgl, geometry);\n *\n * function render()\n * {\n *   mesh.render(cgl.getShader());\n * }\n */\nconst Mesh = function (_cgl, __geom, _options)\n{\n    this._cgl = _cgl;\n\n    let options = _options || {};\n    if (CABLES.UTILS.isNumeric(options))options = { \"glPrimitive\": _options }; // old constructor fallback...\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"cgl_mesh\");\n    this._bufVertexAttrib = null;\n    this._bufVerticesIndizes = this._cgl.gl.createBuffer();\n    this._indexType = this._cgl.gl.UNSIGNED_SHORT;\n    this._attributes = [];\n    this._attribLocs = {};\n    this._geom = null;\n    this._lastShader = null;\n    this._numInstances = 0;\n    this._glPrimitive = options.glPrimitive;\n\n    this.opId = options.opId || \"\";\n    this._preWireframeGeom = null;\n    this.addVertexNumbers = false;\n    this._name = \"unknown\";\n\n    this.feedBackAttributes = [];\n    this.setGeom(__geom);\n\n    this._feedBacks = [];\n    this._feedBacksChanged = false;\n    this._transformFeedBackLoc = -1;\n    this._lastAttrUpdate = 0;\n\n    this.memFreed = false;\n\n    this._cgl.profileData.addHeavyEvent(\"mesh constructed\", this._name);\n\n    this._queryExt = null;\n\n    Object.defineProperty(this, \"numInstances\", {\n        get()\n        {\n            return this._numInstances;\n        },\n        set(v)\n        {\n            this.setNumInstances(v);\n        },\n    });\n};\n\nMesh.prototype.freeMem = function ()\n{\n    this.memFreed = true;\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        this._attributes[i].floatArray = null;\n    }\n};\n\n/**\n * @function updateVertices\n * @memberof Mesh\n * @instance\n * @description update vertices only from a geometry\n * @param {Geometry} geometry\n */\nMesh.prototype.updateVertices = function (geom)\n{\n    this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION, geom.vertices, 3);\n    this._numVerts = geom.vertices.length / 3;\n};\n\nMesh.prototype.setAttributePointer = function (attrName, name, stride, offset)\n{\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].name == attrName)\n        {\n            if (!this._attributes[i].pointer) this._attributes[i].pointer = [];\n\n            this._attributes[i].pointer.push(\n                {\n                    \"loc\": -1,\n                    \"name\": name,\n                    \"stride\": stride,\n                    \"offset\": offset,\n                    \"instanced\": attrName == _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX,\n                }\n            );\n        }\n    }\n};\n\nMesh.prototype.getAttribute = function (name)\n{\n    for (let i = 0; i < this._attributes.length; i++) if (this._attributes[i].name == name) return this._attributes[i];\n};\n\nMesh.prototype.setAttributeRange = function (attr, array, start, end)\n{\n    if (!attr) return;\n    if (!start && !end) return;\n\n    if (!attr.name)\n    {\n        this._log.stack(\"no attrname?!\");\n    }\n\n    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n    this._cgl.profileData.profileMeshAttributes += (end - start) || 0;\n\n    this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0;\n    this._cgl.profileData.profileSingleMeshAttribute[this._name] += (end - start) || 0;\n\n    if (attr.numItems < array.length / attr.itemSize)\n    {\n        this._resizeAttr(array, attr);\n    }\n\n    if (end >= array.length - 1)\n    {\n        this._log.log(this._cgl.canvas.id + \" \" + attr.name + \" buffersubdata out of bounds ?\", array.length, end, start, attr);\n    }\n\n    if (this._cgl.glVersion == 1) this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, array); // probably slow/ maybe create and array with only changed size ??\n    else this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, start * 4, array, start, (end - start));\n};\n\nMesh.prototype._resizeAttr = function (array, attr)\n{\n    if (attr.buffer)\n        this._cgl.gl.deleteBuffer(attr.buffer);\n\n    attr.buffer = this._cgl.gl.createBuffer();\n    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n    this._bufferArray(array, attr);\n    attr.numItems = array.length / attr.itemSize;// numItems;\n};\n\n\nMesh.prototype._bufferArray = function (array, attr)\n{\n    let floatArray = attr.floatArray || null;\n    if (!array) return;\n\n\n    if (this._cgl.debugOneFrame)\n    {\n        console.log(\"_bufferArray\", array.length, attr.name); // eslint-disable-line\n    }\n\n    if (!(array instanceof Float32Array))\n    {\n        if (attr && floatArray && floatArray.length == array.length)\n        {\n            floatArray.set(array);\n            // floatArray = floatArray;\n        }\n        else\n        {\n            floatArray = new Float32Array(array);\n\n            if (this._cgl.debugOneFrame)\n            {\n                console.log(\"_bufferArray create new float32array\", array.length, attr.name); // eslint-disable-line\n            }\n\n            if (array.length > 10000)\n            {\n                this._cgl.profileData.profileNonTypedAttrib++;\n                this._cgl.profileData.profileNonTypedAttribNames = \"(\" + this._name + \":\" + attr.name + \")\";\n            }\n        }\n    }\n    else floatArray = array;\n\n    attr.arrayLength = floatArray.length;\n    attr.floatArray = null;// floatArray;\n\n    this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);\n};\n\n/**\n * @function setAttribute\n * @description update attribute\n * @memberof Mesh\n * @instance\n * @param {String} attribute name\n * @param {Array} data\n * @param {Number} itemSize\n * @param {Object} options\n */\nMesh.prototype.addAttribute = Mesh.prototype.updateAttribute = Mesh.prototype.setAttribute = function (name, array, itemSize, options)\n{\n    if (!array)\n    {\n        this._log.error(\"mesh addAttribute - no array given! \" + name);\n        throw new Error();\n    }\n    let cb = null;\n    let instanced = false;\n    let i = 0;\n    const numItems = array.length / itemSize;\n\n    this._cgl.profileData.profileMeshAttributes += numItems || 0;\n\n    if (typeof options == \"function\")\n    {\n        cb = options;\n    }\n\n    if (typeof options == \"object\")\n    {\n        if (options.cb) cb = options.cb;\n        if (options.instanced) instanced = options.instanced;\n    }\n\n    if (name == _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX) instanced = true;\n\n\n    for (i = 0; i < this._attributes.length; i++)\n    {\n        const attr = this._attributes[i];\n        if (attr.name == name)\n        {\n            if (attr.numItems === numItems)\n            {\n            }\n            else\n            {\n                // this._log.log(\"wrong buffer size\", this._geom.name, attr.name, attr.numItems, numItems);\n                this._resizeAttr(array, attr);\n            }\n\n            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n            this._bufferArray(array, attr);\n\n            return attr;\n        }\n    }\n\n    // create new buffer...\n\n    const buffer = this._cgl.gl.createBuffer();\n\n    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, buffer);\n    // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);\n\n    let type = this._cgl.gl.FLOAT;\n    if (options && options.type) type = options.type;\n    const attr = {\n        \"buffer\": buffer,\n        \"name\": name,\n        \"cb\": cb,\n        \"itemSize\": itemSize,\n        \"numItems\": numItems,\n        \"startItem\": 0,\n        \"instanced\": instanced,\n        \"type\": type\n    };\n\n    this._bufferArray(array, attr);\n\n    if (name == _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION) this._bufVertexAttrib = attr;\n    this._attributes.push(attr);\n    this._attribLocs = {};\n\n    return attr;\n};\n\nMesh.prototype.getAttributes = function ()\n{\n    return this._attributes;\n};\n\n/**\n * @function updateTexCoords\n * @description update texture coordinates only from a geometry\n * @memberof Mesh\n * @instance\n * @param {Geometry} geometry\n */\nMesh.prototype.updateTexCoords = function (geom)\n{\n    if (geom.texCoords && geom.texCoords.length > 0)\n    {\n        this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, geom.texCoords, 2);\n    }\n    else\n    {\n        const tcBuff = new Float32Array(Math.round((geom.vertices.length / 3) * 2));\n        this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);\n    }\n};\n\n\n/**\n * @function updateNormals\n * @description update normals only from a geometry\n * @memberof Mesh\n * @instance\n * @param {Geometry} geometry\n */\nMesh.prototype.updateNormals = function (geom)\n{\n    if (geom.vertexNormals && geom.vertexNormals.length > 0)\n    {\n        this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, geom.vertexNormals, 3);\n    }\n    else\n    {\n        const tcBuff = new Float32Array(Math.round((geom.vertices.length)));\n        this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);\n    }\n};\n\n\nMesh.prototype._setVertexNumbers = function (arr)\n{\n    if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || arr)\n    {\n        if (arr) this._verticesNumbers = arr;\n        else\n        {\n            this._verticesNumbers = new Float32Array(this._numVerts);\n            for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;\n        }\n\n        this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (attr, geom, shader) =>\n        {\n            if (!shader.uniformNumVertices) shader.uniformNumVertices = new _cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_0__.Uniform(shader, \"f\", \"numVertices\", this._numVerts);\n            shader.uniformNumVertices.setValue(this._numVerts);\n\n            // console.log(\"this._numVerts\", this._numVerts, attr, shader.uniformNumVertices);\n        });\n    }\n};\n\n/**\n * @function setVertexIndices\n * @description update vertex indices / faces\n * @memberof Mesh\n * @instance\n * @param {array} vertIndices\n */\nMesh.prototype.setVertexIndices = function (vertIndices)\n{\n    if (!this._bufVerticesIndizes)\n    {\n        this._log.warn(\"no bufVerticesIndizes: \" + this._name);\n        return;\n    }\n    if (vertIndices.length > 0)\n    {\n        if (vertIndices instanceof Float32Array) this._log.warn(\"vertIndices float32Array: \" + this._name);\n\n        for (let i = 0; i < vertIndices.length; i++)\n        {\n            if (vertIndices[i] >= this._numVerts)\n            {\n                this._log.warn(\"invalid index in \" + this._name, i, vertIndices[i]);\n                return;\n            }\n        }\n\n        this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);\n\n        // todo cache this ?\n        // if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)\n\n        if (vertIndices.length > 65535)\n        {\n            this.vertIndicesTyped = new Uint32Array(vertIndices);\n            this._indexType = this._cgl.gl.UNSIGNED_INT;\n        }\n        else\n        if (vertIndices instanceof Uint32Array)\n        {\n            this.vertIndicesTyped = vertIndices;\n            this._indexType = this._cgl.gl.UNSIGNED_INT;\n        }\n        else\n        if (!(vertIndices instanceof Uint16Array))\n        {\n            this.vertIndicesTyped = new Uint16Array(vertIndices);\n            this._indexType = this._cgl.gl.UNSIGNED_SHORT;\n        }\n        else this.vertIndicesTyped = vertIndices;\n\n        this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW);\n        this._bufVerticesIndizes.itemSize = 1;\n        this._bufVerticesIndizes.numItems = vertIndices.length;\n    }\n    else this._bufVerticesIndizes.numItems = 0;\n};\n\n/**\n * @function setGeom\n * @memberof Mesh\n * @instance\n * @description set geometry for mesh\n * @param {Geometry} geometry\n */\nMesh.prototype.setGeom = function (geom, removeRef)\n{\n    this._geom = geom;\n    if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;\n    if (this._geom && this._geom.name) this._name = \"mesh \" + this._geom.name;\n\n    MESH.lastMesh = null;\n    this._cgl.profileData.profileMeshSetGeom++;\n\n    this._disposeAttributes();\n\n    this.updateVertices(this._geom);\n    this.setVertexIndices(this._geom.verticesIndices);\n\n    if (this.addVertexNumbers) this._setVertexNumbers();\n\n    const geomAttribs = this._geom.getAttributes();\n\n    const attribAssoc = {\n        \"texCoords\": _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,\n        \"vertexNormals\": _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,\n        \"vertexColors\": _constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_COLOR,\n        \"tangents\": \"attrTangent\",\n        \"biTangents\": \"attrBiTangent\",\n    };\n\n    for (const index in geomAttribs)\n        if (geomAttribs[index].data && geomAttribs[index].data.length)\n            this.setAttribute(attribAssoc[index] || index, geomAttribs[index].data, geomAttribs[index].itemSize);\n\n\n    if (removeRef)\n    {\n        this._geom = null;\n    }\n};\n\nMesh.prototype._preBind = function (shader)\n{\n    for (let i = 0; i < this._attributes.length; i++)\n        if (this._attributes[i].cb)\n            this._attributes[i].cb(this._attributes[i], this._geom, shader);\n};\n\nMesh.prototype._checkAttrLengths = function ()\n{\n    if (this.memFreed) return;\n    // check length\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].arrayLength / this._attributes[i].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize)\n        {\n            let name = \"unknown\";\n            if (this._geom)name = this._geom.name;\n            // this._log.warn(\n            //     name + \": \" + this._attributes[i].name +\n            //     \" wrong attr length. is:\", this._attributes[i].arrayLength / this._attributes[i].itemSize,\n            //     \" should be:\", this._attributes[0].arrayLength / this._attributes[0].itemSize,\n            // );\n        }\n    }\n};\n\nMesh.prototype._bind = function (shader)\n{\n    if (!shader.isValid()) return;\n\n    let attrLocs = [];\n    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];\n    else this._attribLocs[shader.id] = attrLocs;\n\n    this._lastShader = shader;\n    if (shader.lastCompile > this._lastAttrUpdate || attrLocs.length != this._attributes.length)\n    {\n        this._lastAttrUpdate = shader.lastCompile;\n        for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;\n    }\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        const attribute = this._attributes[i];\n        if (attrLocs[i] == -1)\n        {\n            if (attribute._attrLocationLastShaderTime != shader.lastCompile)\n            {\n                attribute._attrLocationLastShaderTime = shader.lastCompile;\n                attrLocs[i] = this._cgl.glGetAttribLocation(shader.getProgram(), attribute.name);\n                // this._log.log('attribloc',attribute.name,attrLocs[i]);\n                this._cgl.profileData.profileAttrLoc++;\n            }\n        }\n\n        if (attrLocs[i] != -1)\n        {\n            this._cgl.gl.enableVertexAttribArray(attrLocs[i]);\n            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attribute.buffer);\n\n            if (attribute.instanced)\n            {\n                // todo: easier way to fill mat4 attribs...\n                if (attribute.itemSize <= 4)\n                {\n                    if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn(\"instanced attrib itemsize error\", this._geom.name, attribute);\n\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);\n                }\n                else if (attribute.itemSize == 16)\n                {\n                    const stride = 16 * 4;\n\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i], 4, attribute.type, false, stride, 0);\n                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 1, 4, attribute.type, false, stride, 4 * 4 * 1);\n                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 2, 4, attribute.type, false, stride, 4 * 4 * 2);\n                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 3, 4, attribute.type, false, stride, 4 * 4 * 3);\n\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);\n                }\n                else\n                {\n                    this._log.warn(\"unknown instance attrib size\", attribute.name);\n                }\n            }\n            else\n            {\n                if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn(\"attrib itemsize error\", this._name, attribute);\n                this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);\n\n                if (attribute.pointer)\n                {\n                    for (let ip = 0; ip < attribute.pointer.length; ip++)\n                    {\n                        const pointer = attribute.pointer[ip];\n\n                        if (pointer.loc == -1)\n                            pointer.loc = this._cgl.glGetAttribLocation(shader.getProgram(), pointer.name);\n\n                        this._cgl.profileData.profileAttrLoc++;\n\n                        this._cgl.gl.enableVertexAttribArray(pointer.loc);\n                        this._cgl.gl.vertexAttribPointer(pointer.loc, attribute.itemSize, attribute.type, false, pointer.stride, pointer.offset);\n                    }\n                }\n                this.bindFeedback(attribute);\n            }\n        }\n    }\n\n    if (this._bufVerticesIndizes && this._bufVerticesIndizes.numItems !== 0) this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);\n};\n\nMesh.prototype.unBind = function ()\n{\n    const shader = this._lastShader;\n    this._lastShader = null;\n    if (!shader) return;\n\n    let attrLocs = [];\n    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];\n    else this._attribLocs[shader.id] = attrLocs;\n\n    MESH.lastMesh = null;\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].instanced)\n        {\n            // todo: easier way to fill mat4 attribs...\n            if (this._attributes[i].itemSize <= 4)\n            {\n                if (attrLocs[i] != -1) this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);\n                if (attrLocs[i] >= 0) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);\n            }\n            else\n            {\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);\n                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);\n                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);\n                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);\n            }\n        }\n\n        if (attrLocs[i] != -1) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);\n    }\n};\n\nMesh.prototype.meshChanged = function ()\n{\n    return this._cgl.lastMesh && this._cgl.lastMesh != this;\n};\n\nMesh.prototype.printDebug = function (shader)\n{\n    console.log(\"--attributes\");\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        console.log(\"attribute \" + i + \" \" + this._attributes[i].name);\n    }\n};\n\nMesh.prototype.setNumVertices = function (num)\n{\n    this._bufVertexAttrib.numItems = num;\n};\n\nMesh.prototype.getNumVertices = function ()\n{\n    return this._bufVertexAttrib.numItems;\n};\n\n\n/**\n * @function render\n * @memberof Mesh\n * @instance\n * @description draw mesh to screen\n * @param {Shader} shader\n */\nMesh.prototype.render = function (shader)\n{\n    // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh\n\n    if (!shader || !shader.isValid() || this._cgl.aborted) return;\n\n    this._checkAttrLengths();\n\n    if (this._geom)\n    {\n        if (this._preWireframeGeom && !shader.wireframe && !this._geom.isIndexed())\n        {\n            this.setGeom(this._preWireframeGeom);\n            this._preWireframeGeom = null;\n            // console.log(\"remove prewireframe geom\");\n        }\n\n        if (shader.wireframe)\n        {\n            let changed = false;\n\n            if (this._geom.isIndexed())\n            {\n                if (!this._preWireframeGeom)\n                {\n                    this._preWireframeGeom = this._geom;\n                    this._geom = this._geom.copy();\n                }\n\n                this._geom.unIndex();\n                changed = true;\n            }\n\n            if (!this._geom.getAttribute(\"attrBarycentric\"))\n            {\n                if (!this._preWireframeGeom)\n                {\n                    this._preWireframeGeom = this._geom;\n                    this._geom = this._geom.copy();\n                }\n                changed = true;\n\n                this._geom.calcBarycentric();\n            }\n            if (changed) this.setGeom(this._geom);\n        }\n        // if (shader.wireframe)\n        // console.log(shader.wireframe, this._geom.isIndexed());\n    }\n\n    let needsBind = false;\n    if (MESH.lastMesh != this)\n    {\n        if (MESH.lastMesh) MESH.lastMesh.unBind();\n        needsBind = true;\n    }\n\n\n    // var needsBind=false;\n    // {\n    //     needsBind=true;\n    // }\n    if (needsBind) this._preBind(shader);\n\n    if (!shader.bind()) return;\n\n    // if(needsBind)\n    this._bind(shader);\n    if (this.addVertexNumbers) this._setVertexNumbers();\n\n    MESH.lastMesh = this;\n\n    let prim = this._cgl.gl.TRIANGLES;\n    if (this._glPrimitive !== undefined) prim = this._glPrimitive;\n    if (shader.glPrimitive !== null) prim = shader.glPrimitive;\n\n    let elementDiv = 1;\n    let doQuery = this._cgl.profileData.doProfileGlQuery;\n    let queryStarted = false;\n    if (doQuery)\n    {\n        let id = this._name + \" - \" + shader.getName() + \" #\" + shader.id;\n        if (this._numInstances) id += \" instanced \" + this._numInstances + \"x\";\n\n        let queryProfilerData = this._cgl.profileData.glQueryData[id];\n\n        if (!queryProfilerData) queryProfilerData = { \"id\": id, \"num\": 0 };\n\n        if (shader.opId)queryProfilerData.shaderOp = shader.opId;\n        if (this.opId)queryProfilerData.meshOp = this.opId;\n\n        this._cgl.profileData.glQueryData[id] = queryProfilerData;\n\n        if (!this._queryExt && this._queryExt !== false) this._queryExt = this._cgl.enableExtension(\"EXT_disjoint_timer_query_webgl2\") || false;\n        if (this._queryExt)\n        {\n            if (queryProfilerData._drawQuery)\n            {\n                const available = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE);\n                if (available)\n                {\n                    const elapsedNanos = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT);\n                    const currentTimeGPU = elapsedNanos / 1000000;\n\n                    queryProfilerData._times = queryProfilerData._times || 0;\n                    queryProfilerData._times += currentTimeGPU;\n                    queryProfilerData._numcount++;\n                    queryProfilerData.when = performance.now();\n                    queryProfilerData._drawQuery = null;\n                    queryProfilerData.queryStarted = false;\n                }\n            }\n\n            if (!queryProfilerData.queryStarted)\n            {\n                queryProfilerData._drawQuery = this._cgl.gl.createQuery();\n                this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, queryProfilerData._drawQuery);\n                queryStarted = queryProfilerData.queryStarted = true;\n            }\n        }\n    }\n\n\n    if (this.hasFeedbacks())\n    {\n        this.drawFeedbacks(shader, prim);\n    }\n    else if (!this._bufVerticesIndizes || this._bufVerticesIndizes.numItems === 0)\n    {\n        // for (let i = 0; i < this._attributes.length; i++)\n        // {\n        //     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)\n        //     {\n        //         this._log.warn(\"attrib buffer length wrong! \", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);\n        //         // this._log.log(this);\n        //         // debugger;\n        //         return;\n        //     }\n        // }\n\n\n        if (prim == this._cgl.gl.TRIANGLES)elementDiv = 3;\n        if (this._numInstances === 0) this._cgl.gl.drawArrays(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);\n        else this._cgl.gl.drawArraysInstanced(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);\n    }\n    else\n    {\n        if (prim == this._cgl.gl.TRIANGLES)elementDiv = 3;\n        if (this._numInstances === 0)\n        {\n            // console.log(\"la\", this._bufVerticesIndizes.numItems);\n\n            this._cgl.gl.drawElements(prim, this._bufVerticesIndizes.numItems, this._indexType, 0);\n        }\n        else\n        {\n            this._cgl.gl.drawElementsInstanced(prim, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);\n        }\n    }\n\n    if (this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR)\n    {\n        this._log.error(\"mesh draw gl error\");\n        this._log.error(\"mesh\", this);\n        this._log.error(\"shader\", shader);\n\n        const attribNames = [];\n        for (let i = 0; i < this._cgl.gl.getProgramParameter(shader.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); i++)\n        {\n            const name = this._cgl.gl.getActiveAttrib(shader.getProgram(), i).name;\n            this._log.error(\"attrib \", name);\n        }\n    }\n\n    this._cgl.profileData.profileMeshNumElements += (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);\n    this._cgl.profileData.profileMeshDraw++;\n\n    if (doQuery && queryStarted)\n    {\n        this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);\n    }\n\n    this._cgl.printError(\"mesh render \" + this._name);\n\n    this.unBind();\n};\n\nMesh.prototype.setNumInstances = function (n)\n{\n    n = Math.max(0, n);\n    if (this._numInstances != n)\n    {\n        this._numInstances = n;\n        // if (n <= 0)return;\n        const indexArr = new Float32Array(n);\n        for (let i = 0; i < n; i++) indexArr[i] = i;\n        this.setAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_INSTANCE_INDEX, indexArr, 1, { \"instanced\": true });\n    }\n};\n\nMesh.prototype._disposeAttributes = function ()\n{\n    if (!this._attributes) return;\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].buffer)\n        {\n            this._cgl.gl.deleteBuffer(this._attributes[i].buffer);\n            this._attributes[i].buffer = null;\n        }\n    }\n    this._attributes.length = 0;\n};\n\nMesh.prototype.dispose = function ()\n{\n    if (this._bufVertexAttrib && this._bufVertexAttrib.buffer) this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);\n    if (this._bufVerticesIndizes) this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);\n    this._bufVerticesIndizes = null;\n\n    this._disposeAttributes();\n};\n\n(0,_cgl_mesh_feedback__WEBPACK_IMPORTED_MODULE_2__.extendMeshWithFeedback)(Mesh);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX21lc2guanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9tZXNoLmpzP2ZlM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVW5pZm9ybSB9IGZyb20gXCIuL2NnbF9zaGFkZXJfdW5pZm9ybVwiO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBleHRlbmRNZXNoV2l0aEZlZWRiYWNrIH0gZnJvbSBcIi4vY2dsX21lc2hfZmVlZGJhY2tcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5cbmNvbnN0IE1FU0ggPSB7fTtcbk1FU0gubGFzdE1lc2ggPSBudWxsO1xuXG4vKipcbiAqIHdlYmdsIHJlbmRlcmFibGUgM2Qgb2JqZWN0XG4gKiBAZXh0ZXJuYWwgQ0dMXG4gKiBAbmFtZXNwYWNlIE1lc2hcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2dsXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtnbFByaW1pdGl2ZV1cbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNnbD10aGlzLl9jZ2xcbiAqIGNvbnN0IG1lc2g9bmV3IENHTC5NZXNoKGNnbCwgZ2VvbWV0cnkpO1xuICpcbiAqIGZ1bmN0aW9uIHJlbmRlcigpXG4gKiB7XG4gKiAgIG1lc2gucmVuZGVyKGNnbC5nZXRTaGFkZXIoKSk7XG4gKiB9XG4gKi9cbmNvbnN0IE1lc2ggPSBmdW5jdGlvbiAoX2NnbCwgX19nZW9tLCBfb3B0aW9ucylcbntcbiAgICB0aGlzLl9jZ2wgPSBfY2dsO1xuXG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoQ0FCTEVTLlVUSUxTLmlzTnVtZXJpYyhvcHRpb25zKSlvcHRpb25zID0geyBcImdsUHJpbWl0aXZlXCI6IF9vcHRpb25zIH07IC8vIG9sZCBjb25zdHJ1Y3RvciBmYWxsYmFjay4uLlxuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ2xfbWVzaFwiKTtcbiAgICB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIgPSBudWxsO1xuICAgIHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcyA9IHRoaXMuX2NnbC5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLl9pbmRleFR5cGUgPSB0aGlzLl9jZ2wuZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IFtdO1xuICAgIHRoaXMuX2F0dHJpYkxvY3MgPSB7fTtcbiAgICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0U2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9udW1JbnN0YW5jZXMgPSAwO1xuICAgIHRoaXMuX2dsUHJpbWl0aXZlID0gb3B0aW9ucy5nbFByaW1pdGl2ZTtcblxuICAgIHRoaXMub3BJZCA9IG9wdGlvbnMub3BJZCB8fCBcIlwiO1xuICAgIHRoaXMuX3ByZVdpcmVmcmFtZUdlb20gPSBudWxsO1xuICAgIHRoaXMuYWRkVmVydGV4TnVtYmVycyA9IGZhbHNlO1xuICAgIHRoaXMuX25hbWUgPSBcInVua25vd25cIjtcblxuICAgIHRoaXMuZmVlZEJhY2tBdHRyaWJ1dGVzID0gW107XG4gICAgdGhpcy5zZXRHZW9tKF9fZ2VvbSk7XG5cbiAgICB0aGlzLl9mZWVkQmFja3MgPSBbXTtcbiAgICB0aGlzLl9mZWVkQmFja3NDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbnNmb3JtRmVlZEJhY2tMb2MgPSAtMTtcbiAgICB0aGlzLl9sYXN0QXR0clVwZGF0ZSA9IDA7XG5cbiAgICB0aGlzLm1lbUZyZWVkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEuYWRkSGVhdnlFdmVudChcIm1lc2ggY29uc3RydWN0ZWRcIiwgdGhpcy5fbmFtZSk7XG5cbiAgICB0aGlzLl9xdWVyeUV4dCA9IG51bGw7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJudW1JbnN0YW5jZXNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtSW5zdGFuY2VzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXROdW1JbnN0YW5jZXModik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5mcmVlTWVtID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLm1lbUZyZWVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbaV0uZmxvYXRBcnJheSA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdXBkYXRlVmVydGljZXNcbiAqIEBtZW1iZXJvZiBNZXNoXG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgdmVydGljZXMgb25seSBmcm9tIGEgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKi9cbk1lc2gucHJvdG90eXBlLnVwZGF0ZVZlcnRpY2VzID0gZnVuY3Rpb24gKGdlb20pXG57XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX1BPU0lUSU9OLCBnZW9tLnZlcnRpY2VzLCAzKTtcbiAgICB0aGlzLl9udW1WZXJ0cyA9IGdlb20udmVydGljZXMubGVuZ3RoIC8gMztcbn07XG5cbk1lc2gucHJvdG90eXBlLnNldEF0dHJpYnV0ZVBvaW50ZXIgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIG5hbWUsIHN0cmlkZSwgb2Zmc2V0KVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUgPT0gYXR0ck5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0cmlidXRlc1tpXS5wb2ludGVyKSB0aGlzLl9hdHRyaWJ1dGVzW2ldLnBvaW50ZXIgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tpXS5wb2ludGVyLnB1c2goXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImxvY1wiOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaWRlXCI6IHN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBcImluc3RhbmNlZFwiOiBhdHRyTmFtZSA9PSBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9JTlNUQU5DRV9NTUFUUklYLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NZXNoLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbaV07XG59O1xuXG5NZXNoLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVSYW5nZSA9IGZ1bmN0aW9uIChhdHRyLCBhcnJheSwgc3RhcnQsIGVuZClcbntcbiAgICBpZiAoIWF0dHIpIHJldHVybjtcbiAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHJldHVybjtcblxuICAgIGlmICghYXR0ci5uYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwibm8gYXR0cm5hbWU/IVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBhdHRyLmJ1ZmZlcik7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNZXNoQXR0cmlidXRlcyArPSAoZW5kIC0gc3RhcnQpIHx8IDA7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNpbmdsZU1lc2hBdHRyaWJ1dGVbdGhpcy5fbmFtZV0gPSB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNpbmdsZU1lc2hBdHRyaWJ1dGVbdGhpcy5fbmFtZV0gfHwgMDtcbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNpbmdsZU1lc2hBdHRyaWJ1dGVbdGhpcy5fbmFtZV0gKz0gKGVuZCAtIHN0YXJ0KSB8fCAwO1xuXG4gICAgaWYgKGF0dHIubnVtSXRlbXMgPCBhcnJheS5sZW5ndGggLyBhdHRyLml0ZW1TaXplKVxuICAgIHtcbiAgICAgICAgdGhpcy5fcmVzaXplQXR0cihhcnJheSwgYXR0cik7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+PSBhcnJheS5sZW5ndGggLSAxKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmxvZyh0aGlzLl9jZ2wuY2FudmFzLmlkICsgXCIgXCIgKyBhdHRyLm5hbWUgKyBcIiBidWZmZXJzdWJkYXRhIG91dCBvZiBib3VuZHMgP1wiLCBhcnJheS5sZW5ndGgsIGVuZCwgc3RhcnQsIGF0dHIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jZ2wuZ2xWZXJzaW9uID09IDEpIHRoaXMuX2NnbC5nbC5idWZmZXJTdWJEYXRhKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIDAsIGFycmF5KTsgLy8gcHJvYmFibHkgc2xvdy8gbWF5YmUgY3JlYXRlIGFuZCBhcnJheSB3aXRoIG9ubHkgY2hhbmdlZCBzaXplID8/XG4gICAgZWxzZSB0aGlzLl9jZ2wuZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBzdGFydCAqIDQsIGFycmF5LCBzdGFydCwgKGVuZCAtIHN0YXJ0KSk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5fcmVzaXplQXR0ciA9IGZ1bmN0aW9uIChhcnJheSwgYXR0cilcbntcbiAgICBpZiAoYXR0ci5idWZmZXIpXG4gICAgICAgIHRoaXMuX2NnbC5nbC5kZWxldGVCdWZmZXIoYXR0ci5idWZmZXIpO1xuXG4gICAgYXR0ci5idWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXIodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgYXR0ci5idWZmZXIpO1xuICAgIHRoaXMuX2J1ZmZlckFycmF5KGFycmF5LCBhdHRyKTtcbiAgICBhdHRyLm51bUl0ZW1zID0gYXJyYXkubGVuZ3RoIC8gYXR0ci5pdGVtU2l6ZTsvLyBudW1JdGVtcztcbn07XG5cblxuTWVzaC5wcm90b3R5cGUuX2J1ZmZlckFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBhdHRyKVxue1xuICAgIGxldCBmbG9hdEFycmF5ID0gYXR0ci5mbG9hdEFycmF5IHx8IG51bGw7XG4gICAgaWYgKCFhcnJheSkgcmV0dXJuO1xuXG5cbiAgICBpZiAodGhpcy5fY2dsLmRlYnVnT25lRnJhbWUpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcIl9idWZmZXJBcnJheVwiLCBhcnJheS5sZW5ndGgsIGF0dHIubmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG5cbiAgICBpZiAoIShhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpXG4gICAge1xuICAgICAgICBpZiAoYXR0ciAmJiBmbG9hdEFycmF5ICYmIGZsb2F0QXJyYXkubGVuZ3RoID09IGFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgZmxvYXRBcnJheS5zZXQoYXJyYXkpO1xuICAgICAgICAgICAgLy8gZmxvYXRBcnJheSA9IGZsb2F0QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jZ2wuZGVidWdPbmVGcmFtZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIl9idWZmZXJBcnJheSBjcmVhdGUgbmV3IGZsb2F0MzJhcnJheVwiLCBhcnJheS5sZW5ndGgsIGF0dHIubmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+IDEwMDAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTm9uVHlwZWRBdHRyaWIrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU5vblR5cGVkQXR0cmliTmFtZXMgPSBcIihcIiArIHRoaXMuX25hbWUgKyBcIjpcIiArIGF0dHIubmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgZmxvYXRBcnJheSA9IGFycmF5O1xuXG4gICAgYXR0ci5hcnJheUxlbmd0aCA9IGZsb2F0QXJyYXkubGVuZ3RoO1xuICAgIGF0dHIuZmxvYXRBcnJheSA9IG51bGw7Ly8gZmxvYXRBcnJheTtcblxuICAgIHRoaXMuX2NnbC5nbC5idWZmZXJEYXRhKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGZsb2F0QXJyYXksIHRoaXMuX2NnbC5nbC5EWU5BTUlDX0RSQVcpO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0QXR0cmlidXRlXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIGF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIE1lc2hcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gaXRlbVNpemVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbk1lc2gucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IE1lc2gucHJvdG90eXBlLnVwZGF0ZUF0dHJpYnV0ZSA9IE1lc2gucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCBhcnJheSwgaXRlbVNpemUsIG9wdGlvbnMpXG57XG4gICAgaWYgKCFhcnJheSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIm1lc2ggYWRkQXR0cmlidXRlIC0gbm8gYXJyYXkgZ2l2ZW4hIFwiICsgbmFtZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICBsZXQgY2IgPSBudWxsO1xuICAgIGxldCBpbnN0YW5jZWQgPSBmYWxzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbnVtSXRlbXMgPSBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZTtcblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTWVzaEF0dHJpYnV0ZXMgKz0gbnVtSXRlbXMgfHwgMDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcImZ1bmN0aW9uXCIpXG4gICAge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIpXG4gICAge1xuICAgICAgICBpZiAob3B0aW9ucy5jYikgY2IgPSBvcHRpb25zLmNiO1xuICAgICAgICBpZiAob3B0aW9ucy5pbnN0YW5jZWQpIGluc3RhbmNlZCA9IG9wdGlvbnMuaW5zdGFuY2VkO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09IENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX0lOU1RBTkNFX01NQVRSSVgpIGluc3RhbmNlZCA9IHRydWU7XG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuX2F0dHJpYnV0ZXNbaV07XG4gICAgICAgIGlmIChhdHRyLm5hbWUgPT0gbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGF0dHIubnVtSXRlbXMgPT09IG51bUl0ZW1zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2xvZy5sb2coXCJ3cm9uZyBidWZmZXIgc2l6ZVwiLCB0aGlzLl9nZW9tLm5hbWUsIGF0dHIubmFtZSwgYXR0ci5udW1JdGVtcywgbnVtSXRlbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUF0dHIoYXJyYXksIGF0dHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBhdHRyLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJBcnJheShhcnJheSwgYXR0cik7XG5cbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG5ldyBidWZmZXIuLi5cblxuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2NnbC5nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgLy8gdGhpcy5fY2dsLmdsLmJ1ZmZlckRhdGEodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgZmxvYXRBcnJheSwgdGhpcy5fY2dsLmdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICBsZXQgdHlwZSA9IHRoaXMuX2NnbC5nbC5GTE9BVDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgY29uc3QgYXR0ciA9IHtcbiAgICAgICAgXCJidWZmZXJcIjogYnVmZmVyLFxuICAgICAgICBcIm5hbWVcIjogbmFtZSxcbiAgICAgICAgXCJjYlwiOiBjYixcbiAgICAgICAgXCJpdGVtU2l6ZVwiOiBpdGVtU2l6ZSxcbiAgICAgICAgXCJudW1JdGVtc1wiOiBudW1JdGVtcyxcbiAgICAgICAgXCJzdGFydEl0ZW1cIjogMCxcbiAgICAgICAgXCJpbnN0YW5jZWRcIjogaW5zdGFuY2VkLFxuICAgICAgICBcInR5cGVcIjogdHlwZVxuICAgIH07XG5cbiAgICB0aGlzLl9idWZmZXJBcnJheShhcnJheSwgYXR0cik7XG5cbiAgICBpZiAobmFtZSA9PSBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfUE9TSVRJT04pIHRoaXMuX2J1ZlZlcnRleEF0dHJpYiA9IGF0dHI7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgIHRoaXMuX2F0dHJpYkxvY3MgPSB7fTtcblxuICAgIHJldHVybiBhdHRyO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiB1cGRhdGVUZXhDb29yZHNcbiAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgdGV4dHVyZSBjb29yZGluYXRlcyBvbmx5IGZyb20gYSBnZW9tZXRyeVxuICogQG1lbWJlcm9mIE1lc2hcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqL1xuTWVzaC5wcm90b3R5cGUudXBkYXRlVGV4Q29vcmRzID0gZnVuY3Rpb24gKGdlb20pXG57XG4gICAgaWYgKGdlb20udGV4Q29vcmRzICYmIGdlb20udGV4Q29vcmRzLmxlbmd0aCA+IDApXG4gICAge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfVEVYQ09PUkQsIGdlb20udGV4Q29vcmRzLCAyKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc3QgdGNCdWZmID0gbmV3IEZsb2F0MzJBcnJheShNYXRoLnJvdW5kKChnZW9tLnZlcnRpY2VzLmxlbmd0aCAvIDMpICogMikpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfVEVYQ09PUkQsIHRjQnVmZiwgMik7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvbiB1cGRhdGVOb3JtYWxzXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIG5vcm1hbHMgb25seSBmcm9tIGEgZ2VvbWV0cnlcbiAqIEBtZW1iZXJvZiBNZXNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKi9cbk1lc2gucHJvdG90eXBlLnVwZGF0ZU5vcm1hbHMgPSBmdW5jdGlvbiAoZ2VvbSlcbntcbiAgICBpZiAoZ2VvbS52ZXJ0ZXhOb3JtYWxzICYmIGdlb20udmVydGV4Tm9ybWFscy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX05PUk1BTCwgZ2VvbS52ZXJ0ZXhOb3JtYWxzLCAzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc3QgdGNCdWZmID0gbmV3IEZsb2F0MzJBcnJheShNYXRoLnJvdW5kKChnZW9tLnZlcnRpY2VzLmxlbmd0aCkpKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX05PUk1BTCwgdGNCdWZmLCAzKTtcbiAgICB9XG59O1xuXG5cbk1lc2gucHJvdG90eXBlLl9zZXRWZXJ0ZXhOdW1iZXJzID0gZnVuY3Rpb24gKGFycilcbntcbiAgICBpZiAoIXRoaXMuX3ZlcnRpY2VzTnVtYmVycyB8fCB0aGlzLl92ZXJ0aWNlc051bWJlcnMubGVuZ3RoICE9IHRoaXMuX251bVZlcnRzIHx8IGFycilcbiAgICB7XG4gICAgICAgIGlmIChhcnIpIHRoaXMuX3ZlcnRpY2VzTnVtYmVycyA9IGFycjtcbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNlc051bWJlcnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX251bVZlcnRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtVmVydHM7IGkrKykgdGhpcy5fdmVydGljZXNOdW1iZXJzW2ldID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1ZFUlRFWF9OVU1CRVIsIHRoaXMuX3ZlcnRpY2VzTnVtYmVycywgMSwgKGF0dHIsIGdlb20sIHNoYWRlcikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzaGFkZXIudW5pZm9ybU51bVZlcnRpY2VzKSBzaGFkZXIudW5pZm9ybU51bVZlcnRpY2VzID0gbmV3IFVuaWZvcm0oc2hhZGVyLCBcImZcIiwgXCJudW1WZXJ0aWNlc1wiLCB0aGlzLl9udW1WZXJ0cyk7XG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybU51bVZlcnRpY2VzLnNldFZhbHVlKHRoaXMuX251bVZlcnRzKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLl9udW1WZXJ0c1wiLCB0aGlzLl9udW1WZXJ0cywgYXR0ciwgc2hhZGVyLnVuaWZvcm1OdW1WZXJ0aWNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHNldFZlcnRleEluZGljZXNcbiAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgdmVydGV4IGluZGljZXMgLyBmYWNlc1xuICogQG1lbWJlcm9mIE1lc2hcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHthcnJheX0gdmVydEluZGljZXNcbiAqL1xuTWVzaC5wcm90b3R5cGUuc2V0VmVydGV4SW5kaWNlcyA9IGZ1bmN0aW9uICh2ZXJ0SW5kaWNlcylcbntcbiAgICBpZiAoIXRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcylcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwibm8gYnVmVmVydGljZXNJbmRpemVzOiBcIiArIHRoaXMuX25hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2ZXJ0SW5kaWNlcy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgaWYgKHZlcnRJbmRpY2VzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB0aGlzLl9sb2cud2FybihcInZlcnRJbmRpY2VzIGZsb2F0MzJBcnJheTogXCIgKyB0aGlzLl9uYW1lKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRJbmRpY2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmVydEluZGljZXNbaV0gPj0gdGhpcy5fbnVtVmVydHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJpbnZhbGlkIGluZGV4IGluIFwiICsgdGhpcy5fbmFtZSwgaSwgdmVydEluZGljZXNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzKTtcblxuICAgICAgICAvLyB0b2RvIGNhY2hlIHRoaXMgP1xuICAgICAgICAvLyBpZighdGhpcy52ZXJ0SW5kaWNlc1R5cGVkIHx8IHRoaXMudmVydEluZGljZXNUeXBlZC5sZW5ndGghPXRoaXMuX2dlb20udmVydGljZXNJbmRpY2VzLmxlbmd0aClcblxuICAgICAgICBpZiAodmVydEluZGljZXMubGVuZ3RoID4gNjU1MzUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudmVydEluZGljZXNUeXBlZCA9IG5ldyBVaW50MzJBcnJheSh2ZXJ0SW5kaWNlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbmRleFR5cGUgPSB0aGlzLl9jZ2wuZ2wuVU5TSUdORURfSU5UO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgaWYgKHZlcnRJbmRpY2VzIGluc3RhbmNlb2YgVWludDMyQXJyYXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudmVydEluZGljZXNUeXBlZCA9IHZlcnRJbmRpY2VzO1xuICAgICAgICAgICAgdGhpcy5faW5kZXhUeXBlID0gdGhpcy5fY2dsLmdsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIGlmICghKHZlcnRJbmRpY2VzIGluc3RhbmNlb2YgVWludDE2QXJyYXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnZlcnRJbmRpY2VzVHlwZWQgPSBuZXcgVWludDE2QXJyYXkodmVydEluZGljZXMpO1xuICAgICAgICAgICAgdGhpcy5faW5kZXhUeXBlID0gdGhpcy5fY2dsLmdsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy52ZXJ0SW5kaWNlc1R5cGVkID0gdmVydEluZGljZXM7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJ1ZmZlckRhdGEodGhpcy5fY2dsLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRJbmRpY2VzVHlwZWQsIHRoaXMuX2NnbC5nbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgICB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMuaXRlbVNpemUgPSAxO1xuICAgICAgICB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMubnVtSXRlbXMgPSB2ZXJ0SW5kaWNlcy5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLm51bUl0ZW1zID0gMDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHNldEdlb21cbiAqIEBtZW1iZXJvZiBNZXNoXG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiBzZXQgZ2VvbWV0cnkgZm9yIG1lc2hcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKi9cbk1lc2gucHJvdG90eXBlLnNldEdlb20gPSBmdW5jdGlvbiAoZ2VvbSwgcmVtb3ZlUmVmKVxue1xuICAgIHRoaXMuX2dlb20gPSBnZW9tO1xuICAgIGlmIChnZW9tLmdsUHJpbWl0aXZlICE9IG51bGwpIHRoaXMuX2dsUHJpbWl0aXZlID0gZ2VvbS5nbFByaW1pdGl2ZTtcbiAgICBpZiAodGhpcy5fZ2VvbSAmJiB0aGlzLl9nZW9tLm5hbWUpIHRoaXMuX25hbWUgPSBcIm1lc2ggXCIgKyB0aGlzLl9nZW9tLm5hbWU7XG5cbiAgICBNRVNILmxhc3RNZXNoID0gbnVsbDtcbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1lc2hTZXRHZW9tKys7XG5cbiAgICB0aGlzLl9kaXNwb3NlQXR0cmlidXRlcygpO1xuXG4gICAgdGhpcy51cGRhdGVWZXJ0aWNlcyh0aGlzLl9nZW9tKTtcbiAgICB0aGlzLnNldFZlcnRleEluZGljZXModGhpcy5fZ2VvbS52ZXJ0aWNlc0luZGljZXMpO1xuXG4gICAgaWYgKHRoaXMuYWRkVmVydGV4TnVtYmVycykgdGhpcy5fc2V0VmVydGV4TnVtYmVycygpO1xuXG4gICAgY29uc3QgZ2VvbUF0dHJpYnMgPSB0aGlzLl9nZW9tLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIGNvbnN0IGF0dHJpYkFzc29jID0ge1xuICAgICAgICBcInRleENvb3Jkc1wiOiBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfVEVYQ09PUkQsXG4gICAgICAgIFwidmVydGV4Tm9ybWFsc1wiOiBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfTk9STUFMLFxuICAgICAgICBcInZlcnRleENvbG9yc1wiOiBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfQ09MT1IsXG4gICAgICAgIFwidGFuZ2VudHNcIjogXCJhdHRyVGFuZ2VudFwiLFxuICAgICAgICBcImJpVGFuZ2VudHNcIjogXCJhdHRyQmlUYW5nZW50XCIsXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gZ2VvbUF0dHJpYnMpXG4gICAgICAgIGlmIChnZW9tQXR0cmlic1tpbmRleF0uZGF0YSAmJiBnZW9tQXR0cmlic1tpbmRleF0uZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyaWJBc3NvY1tpbmRleF0gfHwgaW5kZXgsIGdlb21BdHRyaWJzW2luZGV4XS5kYXRhLCBnZW9tQXR0cmlic1tpbmRleF0uaXRlbVNpemUpO1xuXG5cbiAgICBpZiAocmVtb3ZlUmVmKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuX3ByZUJpbmQgPSBmdW5jdGlvbiAoc2hhZGVyKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbaV0uY2IpXG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW2ldLmNiKHRoaXMuX2F0dHJpYnV0ZXNbaV0sIHRoaXMuX2dlb20sIHNoYWRlcik7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5fY2hlY2tBdHRyTGVuZ3RocyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMubWVtRnJlZWQpIHJldHVybjtcbiAgICAvLyBjaGVjayBsZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1tpXS5hcnJheUxlbmd0aCAvIHRoaXMuX2F0dHJpYnV0ZXNbaV0uaXRlbVNpemUgPCB0aGlzLl9hdHRyaWJ1dGVzWzBdLmFycmF5TGVuZ3RoIC8gdGhpcy5fYXR0cmlidXRlc1swXS5pdGVtU2l6ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBcInVua25vd25cIjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZW9tKW5hbWUgPSB0aGlzLl9nZW9tLm5hbWU7XG4gICAgICAgICAgICAvLyB0aGlzLl9sb2cud2FybihcbiAgICAgICAgICAgIC8vICAgICBuYW1lICsgXCI6IFwiICsgdGhpcy5fYXR0cmlidXRlc1tpXS5uYW1lICtcbiAgICAgICAgICAgIC8vICAgICBcIiB3cm9uZyBhdHRyIGxlbmd0aC4gaXM6XCIsIHRoaXMuX2F0dHJpYnV0ZXNbaV0uYXJyYXlMZW5ndGggLyB0aGlzLl9hdHRyaWJ1dGVzW2ldLml0ZW1TaXplLFxuICAgICAgICAgICAgLy8gICAgIFwiIHNob3VsZCBiZTpcIiwgdGhpcy5fYXR0cmlidXRlc1swXS5hcnJheUxlbmd0aCAvIHRoaXMuX2F0dHJpYnV0ZXNbMF0uaXRlbVNpemUsXG4gICAgICAgICAgICAvLyApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoc2hhZGVyKVxue1xuICAgIGlmICghc2hhZGVyLmlzVmFsaWQoKSkgcmV0dXJuO1xuXG4gICAgbGV0IGF0dHJMb2NzID0gW107XG4gICAgaWYgKHRoaXMuX2F0dHJpYkxvY3Nbc2hhZGVyLmlkXSkgYXR0ckxvY3MgPSB0aGlzLl9hdHRyaWJMb2NzW3NoYWRlci5pZF07XG4gICAgZWxzZSB0aGlzLl9hdHRyaWJMb2NzW3NoYWRlci5pZF0gPSBhdHRyTG9jcztcblxuICAgIHRoaXMuX2xhc3RTaGFkZXIgPSBzaGFkZXI7XG4gICAgaWYgKHNoYWRlci5sYXN0Q29tcGlsZSA+IHRoaXMuX2xhc3RBdHRyVXBkYXRlIHx8IGF0dHJMb2NzLmxlbmd0aCAhPSB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xhc3RBdHRyVXBkYXRlID0gc2hhZGVyLmxhc3RDb21waWxlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIGF0dHJMb2NzW2ldID0gLTE7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5fYXR0cmlidXRlc1tpXTtcbiAgICAgICAgaWYgKGF0dHJMb2NzW2ldID09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLl9hdHRyTG9jYXRpb25MYXN0U2hhZGVyVGltZSAhPSBzaGFkZXIubGFzdENvbXBpbGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLl9hdHRyTG9jYXRpb25MYXN0U2hhZGVyVGltZSA9IHNoYWRlci5sYXN0Q29tcGlsZTtcbiAgICAgICAgICAgICAgICBhdHRyTG9jc1tpXSA9IHRoaXMuX2NnbC5nbEdldEF0dHJpYkxvY2F0aW9uKHNoYWRlci5nZXRQcm9ncmFtKCksIGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9sb2cubG9nKCdhdHRyaWJsb2MnLGF0dHJpYnV0ZS5uYW1lLGF0dHJMb2NzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZUF0dHJMb2MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyTG9jc1tpXSAhPSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIpO1xuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmluc3RhbmNlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBlYXNpZXIgd2F5IHRvIGZpbGwgbWF0NCBhdHRyaWJzLi4uXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pdGVtU2l6ZSA8PSA0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGUuaXRlbVNpemUgfHwgYXR0cmlidXRlLml0ZW1TaXplID09IDApIHRoaXMuX2xvZy53YXJuKFwiaW5zdGFuY2VkIGF0dHJpYiBpdGVtc2l6ZSBlcnJvclwiLCB0aGlzLl9nZW9tLm5hbWUsIGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ckxvY3NbaV0sIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLnR5cGUsIGZhbHNlLCBhdHRyaWJ1dGUuaXRlbVNpemUgKiA0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckxvY3NbaV0sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUuaXRlbVNpemUgPT0gMTYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpZGUgPSAxNiAqIDQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ckxvY3NbaV0sIDQsIGF0dHJpYnV0ZS50eXBlLCBmYWxzZSwgc3RyaWRlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJMb2NzW2ldICsgMSwgNCwgYXR0cmlidXRlLnR5cGUsIGZhbHNlLCBzdHJpZGUsIDQgKiA0ICogMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyTG9jc1tpXSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyTG9jc1tpXSArIDIsIDQsIGF0dHJpYnV0ZS50eXBlLCBmYWxzZSwgc3RyaWRlLCA0ICogNCAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ckxvY3NbaV0gKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ckxvY3NbaV0gKyAzLCA0LCBhdHRyaWJ1dGUudHlwZSwgZmFsc2UsIHN0cmlkZSwgNCAqIDQgKiAzKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldICsgMiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldICsgMywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwidW5rbm93biBpbnN0YW5jZSBhdHRyaWIgc2l6ZVwiLCBhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlLml0ZW1TaXplIHx8IGF0dHJpYnV0ZS5pdGVtU2l6ZSA9PSAwKSB0aGlzLl9sb2cud2FybihcImF0dHJpYiBpdGVtc2l6ZSBlcnJvclwiLCB0aGlzLl9uYW1lLCBhdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJMb2NzW2ldLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS50eXBlLCBmYWxzZSwgYXR0cmlidXRlLml0ZW1TaXplICogNCwgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlLnBvaW50ZXIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpcCA9IDA7IGlwIDwgYXR0cmlidXRlLnBvaW50ZXIubGVuZ3RoOyBpcCsrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyID0gYXR0cmlidXRlLnBvaW50ZXJbaXBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRlci5sb2MgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5sb2MgPSB0aGlzLl9jZ2wuZ2xHZXRBdHRyaWJMb2NhdGlvbihzaGFkZXIuZ2V0UHJvZ3JhbSgpLCBwb2ludGVyLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZUF0dHJMb2MrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvaW50ZXIubG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvaW50ZXIubG9jLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS50eXBlLCBmYWxzZSwgcG9pbnRlci5zdHJpZGUsIHBvaW50ZXIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRGZWVkYmFjayhhdHRyaWJ1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcyAmJiB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMubnVtSXRlbXMgIT09IDApIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzKTtcbn07XG5cbk1lc2gucHJvdG90eXBlLnVuQmluZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fbGFzdFNoYWRlcjtcbiAgICB0aGlzLl9sYXN0U2hhZGVyID0gbnVsbDtcbiAgICBpZiAoIXNoYWRlcikgcmV0dXJuO1xuXG4gICAgbGV0IGF0dHJMb2NzID0gW107XG4gICAgaWYgKHRoaXMuX2F0dHJpYkxvY3Nbc2hhZGVyLmlkXSkgYXR0ckxvY3MgPSB0aGlzLl9hdHRyaWJMb2NzW3NoYWRlci5pZF07XG4gICAgZWxzZSB0aGlzLl9hdHRyaWJMb2NzW3NoYWRlci5pZF0gPSBhdHRyTG9jcztcblxuICAgIE1FU0gubGFzdE1lc2ggPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbaV0uaW5zdGFuY2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0b2RvOiBlYXNpZXIgd2F5IHRvIGZpbGwgbWF0NCBhdHRyaWJzLi4uXG4gICAgICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1tpXS5pdGVtU2l6ZSA8PSA0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyTG9jc1tpXSAhPSAtMSkgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckxvY3NbaV0sIDApO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyTG9jc1tpXSA+PSAwKSB0aGlzLl9jZ2wuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckxvY3NbaV0gKyAxLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSArIDIsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldICsgMywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyTG9jc1tpXSArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ckxvY3NbaV0gKyAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ckxvY3NbaV0gIT0gLTEpIHRoaXMuX2NnbC5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ckxvY3NbaV0pO1xuICAgIH1cbn07XG5cbk1lc2gucHJvdG90eXBlLm1lc2hDaGFuZ2VkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fY2dsLmxhc3RNZXNoICYmIHRoaXMuX2NnbC5sYXN0TWVzaCAhPSB0aGlzO1xufTtcblxuTWVzaC5wcm90b3R5cGUucHJpbnREZWJ1ZyA9IGZ1bmN0aW9uIChzaGFkZXIpXG57XG4gICAgY29uc29sZS5sb2coXCItLWF0dHJpYnV0ZXNcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJhdHRyaWJ1dGUgXCIgKyBpICsgXCIgXCIgKyB0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbn07XG5cbk1lc2gucHJvdG90eXBlLnNldE51bVZlcnRpY2VzID0gZnVuY3Rpb24gKG51bSlcbntcbiAgICB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIubnVtSXRlbXMgPSBudW07XG59O1xuXG5NZXNoLnByb3RvdHlwZS5nZXROdW1WZXJ0aWNlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5udW1JdGVtcztcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gcmVuZGVyXG4gKiBAbWVtYmVyb2YgTWVzaFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gZHJhdyBtZXNoIHRvIHNjcmVlblxuICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlclxuICovXG5NZXNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2hhZGVyKVxue1xuICAgIC8vIFRPRE86IGVuYWJsZS9kaXNhYmxldmVydGV4IG9ubHkgaWYgdGhlIG1lc2ggaGFzIGNoYW5nZWQuLi4gdGhpbmsgZHJhd2luZyAxMDAwMHggdGhlIHNhbWUgbWVzaFxuXG4gICAgaWYgKCFzaGFkZXIgfHwgIXNoYWRlci5pc1ZhbGlkKCkgfHwgdGhpcy5fY2dsLmFib3J0ZWQpIHJldHVybjtcblxuICAgIHRoaXMuX2NoZWNrQXR0ckxlbmd0aHMoKTtcblxuICAgIGlmICh0aGlzLl9nZW9tKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZVdpcmVmcmFtZUdlb20gJiYgIXNoYWRlci53aXJlZnJhbWUgJiYgIXRoaXMuX2dlb20uaXNJbmRleGVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0R2VvbSh0aGlzLl9wcmVXaXJlZnJhbWVHZW9tKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZVdpcmVmcmFtZUdlb20gPSBudWxsO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJyZW1vdmUgcHJld2lyZWZyYW1lIGdlb21cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhZGVyLndpcmVmcmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2dlb20uaXNJbmRleGVkKCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmVXaXJlZnJhbWVHZW9tKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlV2lyZWZyYW1lR2VvbSA9IHRoaXMuX2dlb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlb20gPSB0aGlzLl9nZW9tLmNvcHkoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9tLnVuSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9nZW9tLmdldEF0dHJpYnV0ZShcImF0dHJCYXJ5Y2VudHJpY1wiKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ByZVdpcmVmcmFtZUdlb20pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVXaXJlZnJhbWVHZW9tID0gdGhpcy5fZ2VvbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VvbSA9IHRoaXMuX2dlb20uY29weSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2dlb20uY2FsY0JhcnljZW50cmljKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkgdGhpcy5zZXRHZW9tKHRoaXMuX2dlb20pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIChzaGFkZXIud2lyZWZyYW1lKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzaGFkZXIud2lyZWZyYW1lLCB0aGlzLl9nZW9tLmlzSW5kZXhlZCgpKTtcbiAgICB9XG5cbiAgICBsZXQgbmVlZHNCaW5kID0gZmFsc2U7XG4gICAgaWYgKE1FU0gubGFzdE1lc2ggIT0gdGhpcylcbiAgICB7XG4gICAgICAgIGlmIChNRVNILmxhc3RNZXNoKSBNRVNILmxhc3RNZXNoLnVuQmluZCgpO1xuICAgICAgICBuZWVkc0JpbmQgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgLy8gdmFyIG5lZWRzQmluZD1mYWxzZTtcbiAgICAvLyB7XG4gICAgLy8gICAgIG5lZWRzQmluZD10cnVlO1xuICAgIC8vIH1cbiAgICBpZiAobmVlZHNCaW5kKSB0aGlzLl9wcmVCaW5kKHNoYWRlcik7XG5cbiAgICBpZiAoIXNoYWRlci5iaW5kKCkpIHJldHVybjtcblxuICAgIC8vIGlmKG5lZWRzQmluZClcbiAgICB0aGlzLl9iaW5kKHNoYWRlcik7XG4gICAgaWYgKHRoaXMuYWRkVmVydGV4TnVtYmVycykgdGhpcy5fc2V0VmVydGV4TnVtYmVycygpO1xuXG4gICAgTUVTSC5sYXN0TWVzaCA9IHRoaXM7XG5cbiAgICBsZXQgcHJpbSA9IHRoaXMuX2NnbC5nbC5UUklBTkdMRVM7XG4gICAgaWYgKHRoaXMuX2dsUHJpbWl0aXZlICE9PSB1bmRlZmluZWQpIHByaW0gPSB0aGlzLl9nbFByaW1pdGl2ZTtcbiAgICBpZiAoc2hhZGVyLmdsUHJpbWl0aXZlICE9PSBudWxsKSBwcmltID0gc2hhZGVyLmdsUHJpbWl0aXZlO1xuXG4gICAgbGV0IGVsZW1lbnREaXYgPSAxO1xuICAgIGxldCBkb1F1ZXJ5ID0gdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmRvUHJvZmlsZUdsUXVlcnk7XG4gICAgbGV0IHF1ZXJ5U3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmIChkb1F1ZXJ5KVxuICAgIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5fbmFtZSArIFwiIC0gXCIgKyBzaGFkZXIuZ2V0TmFtZSgpICsgXCIgI1wiICsgc2hhZGVyLmlkO1xuICAgICAgICBpZiAodGhpcy5fbnVtSW5zdGFuY2VzKSBpZCArPSBcIiBpbnN0YW5jZWQgXCIgKyB0aGlzLl9udW1JbnN0YW5jZXMgKyBcInhcIjtcblxuICAgICAgICBsZXQgcXVlcnlQcm9maWxlckRhdGEgPSB0aGlzLl9jZ2wucHJvZmlsZURhdGEuZ2xRdWVyeURhdGFbaWRdO1xuXG4gICAgICAgIGlmICghcXVlcnlQcm9maWxlckRhdGEpIHF1ZXJ5UHJvZmlsZXJEYXRhID0geyBcImlkXCI6IGlkLCBcIm51bVwiOiAwIH07XG5cbiAgICAgICAgaWYgKHNoYWRlci5vcElkKXF1ZXJ5UHJvZmlsZXJEYXRhLnNoYWRlck9wID0gc2hhZGVyLm9wSWQ7XG4gICAgICAgIGlmICh0aGlzLm9wSWQpcXVlcnlQcm9maWxlckRhdGEubWVzaE9wID0gdGhpcy5vcElkO1xuXG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5nbFF1ZXJ5RGF0YVtpZF0gPSBxdWVyeVByb2ZpbGVyRGF0YTtcblxuICAgICAgICBpZiAoIXRoaXMuX3F1ZXJ5RXh0ICYmIHRoaXMuX3F1ZXJ5RXh0ICE9PSBmYWxzZSkgdGhpcy5fcXVlcnlFeHQgPSB0aGlzLl9jZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXJ5RXh0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocXVlcnlQcm9maWxlckRhdGEuX2RyYXdRdWVyeSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLl9jZ2wuZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnlQcm9maWxlckRhdGEuX2RyYXdRdWVyeSwgdGhpcy5fY2dsLmdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkTmFub3MgPSB0aGlzLl9jZ2wuZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnlQcm9maWxlckRhdGEuX2RyYXdRdWVyeSwgdGhpcy5fY2dsLmdsLlFVRVJZX1JFU1VMVCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lR1BVID0gZWxhcHNlZE5hbm9zIC8gMTAwMDAwMDtcblxuICAgICAgICAgICAgICAgICAgICBxdWVyeVByb2ZpbGVyRGF0YS5fdGltZXMgPSBxdWVyeVByb2ZpbGVyRGF0YS5fdGltZXMgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEuX3RpbWVzICs9IGN1cnJlbnRUaW1lR1BVO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVByb2ZpbGVyRGF0YS5fbnVtY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEud2hlbiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVByb2ZpbGVyRGF0YS5fZHJhd1F1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEucXVlcnlTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXF1ZXJ5UHJvZmlsZXJEYXRhLnF1ZXJ5U3RhcnRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBxdWVyeVByb2ZpbGVyRGF0YS5fZHJhd1F1ZXJ5ID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJlZ2luUXVlcnkodGhpcy5fcXVlcnlFeHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnlQcm9maWxlckRhdGEuX2RyYXdRdWVyeSk7XG4gICAgICAgICAgICAgICAgcXVlcnlTdGFydGVkID0gcXVlcnlQcm9maWxlckRhdGEucXVlcnlTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuaGFzRmVlZGJhY2tzKCkpXG4gICAge1xuICAgICAgICB0aGlzLmRyYXdGZWVkYmFja3Moc2hhZGVyLCBwcmltKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcyB8fCB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMubnVtSXRlbXMgPT09IDApXG4gICAge1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLmFycmF5TGVuZ3RoIC8gdGhpcy5fYXR0cmlidXRlc1tpXS5pdGVtU2l6ZSAhPSB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIuZmxvYXRBcnJheS5sZW5ndGggLyAzKVxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiYXR0cmliIGJ1ZmZlciBsZW5ndGggd3JvbmchIFwiLCB0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUsIHRoaXMuX2F0dHJpYnV0ZXNbaV0uYXJyYXlMZW5ndGggLyB0aGlzLl9hdHRyaWJ1dGVzW2ldLml0ZW1TaXplLCB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIuZmxvYXRBcnJheS5sZW5ndGggLyAzLCB0aGlzLl9hdHRyaWJ1dGVzW2ldLml0ZW1TaXplKTtcbiAgICAgICAgLy8gICAgICAgICAvLyB0aGlzLl9sb2cubG9nKHRoaXMpO1xuICAgICAgICAvLyAgICAgICAgIC8vIGRlYnVnZ2VyO1xuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG5cbiAgICAgICAgaWYgKHByaW0gPT0gdGhpcy5fY2dsLmdsLlRSSUFOR0xFUyllbGVtZW50RGl2ID0gMztcbiAgICAgICAgaWYgKHRoaXMuX251bUluc3RhbmNlcyA9PT0gMCkgdGhpcy5fY2dsLmdsLmRyYXdBcnJheXMocHJpbSwgdGhpcy5fYnVmVmVydGV4QXR0cmliLnN0YXJ0SXRlbSwgdGhpcy5fYnVmVmVydGV4QXR0cmliLm51bUl0ZW1zIC0gdGhpcy5fYnVmVmVydGV4QXR0cmliLnN0YXJ0SXRlbSk7XG4gICAgICAgIGVsc2UgdGhpcy5fY2dsLmdsLmRyYXdBcnJheXNJbnN0YW5jZWQocHJpbSwgdGhpcy5fYnVmVmVydGV4QXR0cmliLnN0YXJ0SXRlbSwgdGhpcy5fYnVmVmVydGV4QXR0cmliLm51bUl0ZW1zLCB0aGlzLl9udW1JbnN0YW5jZXMpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAocHJpbSA9PSB0aGlzLl9jZ2wuZ2wuVFJJQU5HTEVTKWVsZW1lbnREaXYgPSAzO1xuICAgICAgICBpZiAodGhpcy5fbnVtSW5zdGFuY2VzID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImxhXCIsIHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcy5udW1JdGVtcyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5kcmF3RWxlbWVudHMocHJpbSwgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLm51bUl0ZW1zLCB0aGlzLl9pbmRleFR5cGUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmRyYXdFbGVtZW50c0luc3RhbmNlZChwcmltLCB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMubnVtSXRlbXMsIHRoaXMuX2luZGV4VHlwZSwgMCwgdGhpcy5fbnVtSW5zdGFuY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jZ2wuZGVidWdPbmVGcmFtZSAmJiB0aGlzLl9jZ2wuZ2wuZ2V0RXJyb3IoKSAhPSB0aGlzLl9jZ2wuZ2wuTk9fRVJST1IpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJtZXNoIGRyYXcgZ2wgZXJyb3JcIik7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIm1lc2hcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcInNoYWRlclwiLCBzaGFkZXIpO1xuXG4gICAgICAgIGNvbnN0IGF0dHJpYk5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY2dsLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fY2dsLmdsLkFDVElWRV9BVFRSSUJVVEVTKTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fY2dsLmdsLmdldEFjdGl2ZUF0dHJpYihzaGFkZXIuZ2V0UHJvZ3JhbSgpLCBpKS5uYW1lO1xuICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiYXR0cmliIFwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTWVzaE51bUVsZW1lbnRzICs9ICh0aGlzLl9idWZWZXJ0ZXhBdHRyaWIubnVtSXRlbXMgLyBlbGVtZW50RGl2KSAqICh0aGlzLl9udW1JbnN0YW5jZXMgfHwgMSk7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNZXNoRHJhdysrO1xuXG4gICAgaWYgKGRvUXVlcnkgJiYgcXVlcnlTdGFydGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmVuZFF1ZXJ5KHRoaXMuX3F1ZXJ5RXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgIH1cblxuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwibWVzaCByZW5kZXIgXCIgKyB0aGlzLl9uYW1lKTtcblxuICAgIHRoaXMudW5CaW5kKCk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5zZXROdW1JbnN0YW5jZXMgPSBmdW5jdGlvbiAobilcbntcbiAgICBuID0gTWF0aC5tYXgoMCwgbik7XG4gICAgaWYgKHRoaXMuX251bUluc3RhbmNlcyAhPSBuKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbnVtSW5zdGFuY2VzID0gbjtcbiAgICAgICAgLy8gaWYgKG4gPD0gMClyZXR1cm47XG4gICAgICAgIGNvbnN0IGluZGV4QXJyID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIGluZGV4QXJyW2ldID0gaTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfSU5TVEFOQ0VfSU5ERVgsIGluZGV4QXJyLCAxLCB7IFwiaW5zdGFuY2VkXCI6IHRydWUgfSk7XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuX2Rpc3Bvc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZXMpIHJldHVybjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLmJ1ZmZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9hdHRyaWJ1dGVzW2ldLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW2ldLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGggPSAwO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2J1ZlZlcnRleEF0dHJpYiAmJiB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIuYnVmZmVyKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5idWZmZXIpO1xuICAgIGlmICh0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMpIHRoaXMuX2NnbC5nbC5kZWxldGVCdWZmZXIodGhpcy5fYnVmVmVydGljZXNJbmRpemVzKTtcbiAgICB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMgPSBudWxsO1xuXG4gICAgdGhpcy5fZGlzcG9zZUF0dHJpYnV0ZXMoKTtcbn07XG5cbmV4dGVuZE1lc2hXaXRoRmVlZGJhY2soTWVzaCk7XG5cbmV4cG9ydCB7IE1lc2gsIE1FU0ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_mesh.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_mesh_feedback.js":
/*!*******************************************!*\
  !*** ./src/core/cgl/cgl_mesh_feedback.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extendMeshWithFeedback\": () => (/* binding */ extendMeshWithFeedback)\n/* harmony export */ });\n// view-source:http://toji.github.io/webgl2-particles-2/\n\nfunction extendMeshWithFeedback(Mesh)\n{\n    Mesh.prototype.hasFeedbacks = function ()\n    {\n        return this._feedBacks.length > 0;\n    };\n\n    Mesh.prototype.removeFeedbacks = function (shader)\n    {\n        if (!this._feedbacks) return;\n        this._feedbacks.length = 0;\n        this._feedBacksChanged = true;\n    };\n\n    Mesh.prototype.setAttributeFeedback = function () {};\n\n    Mesh.prototype.setFeedback = function (attrib, nameOut, initialArr)\n    {\n        let fb = { nameOut, };\n        let found = false;\n        this.unBindFeedbacks();\n\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            if (this._feedBacks[i].nameOut == nameOut)\n            {\n                fb = this._feedBacks[i];\n\n                found = true;\n            }\n        }\n\n        if (!found) this._feedBacksChanged = true;\n\n        fb.initialArr = initialArr;\n        fb.attrib = attrib;\n\n        // console.log(\"setfeedback\");\n\n        if (fb.outBuffer) this._cgl.gl.deleteBuffer(fb.outBuffer);\n        // if(fb.attrib.buffer)this._cgl.gl.deleteBuffer(fb.attrib.buffer);\n        fb.outBuffer = this._cgl.gl.createBuffer();\n        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.outBuffer);\n        this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, fb.initialArr, this._cgl.gl.STATIC_DRAW);\n\n        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.attrib.buffer);\n        this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, fb.initialArr, this._cgl.gl.STATIC_DRAW);\n\n        if (!found) this._feedBacks.push(fb);\n\n        // console.log('initialArr',initialArr.length/3);\n        // console.log('vertices',fb.attrib.numItems);\n        // console.log('vertices',this._bufVertexAttrib.numItems);\n\n        return fb;\n    };\n\n    Mesh.prototype.bindFeedback = function (attrib)\n    {\n        if (!this._feedBacks || this._feedBacks.length === 0) return;\n        if (this._transformFeedBackLoc == -1) this._transformFeedBackLoc = this._cgl.gl.createTransformFeedback();\n\n        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);\n\n        let found = false;\n\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            const fb = this._feedBacks[i];\n\n            if (fb.attrib == attrib)\n            {\n                found = true;\n                // this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.attrib.buffer);\n                //\n                // this._cgl.gl.vertexAttribPointer(\n                //     fb.attrib.loc,\n                //     fb.attrib.itemSize,\n                //     fb.attrib.type,\n                //     false,\n                //     fb.attrib.itemSize*4, 0);\n\n                this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, fb.outBuffer);\n            }\n        }\n\n        if (!found)\n        {\n            // console.log(\"ARTTRIB NOT FOUND\",attrib.name);\n        }\n    };\n\n    Mesh.prototype.drawFeedbacks = function (shader, prim)\n    {\n        let i = 0;\n\n        if (this._feedBacksChanged)\n        {\n            const names = [];\n            this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);\n\n            for (i = 0; i < this._feedBacks.length; i++) names.push(this._feedBacks[i].nameOut);\n            shader.setFeedbackNames(names);\n\n            console.log(\"feedbacknames\", names);\n\n            shader.compile();\n            this._feedBacksChanged = false;\n            this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);\n            console.log(\"changed finished\");\n            return;\n        }\n\n        //\n        // for( i=0;i<this._feedBacks.length;i++)\n        // {\n        //     var fb=this._feedBacks[i];\n        //\n        //     this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, fb.outBuffer);\n        // }\n\n        // draw\n        this._cgl.gl.beginTransformFeedback(this.glPrimitive);\n        this._cgl.gl.drawArrays(prim, 0, this._feedBacks[0].attrib.numItems);\n\n        // unbind\n        this._cgl.gl.endTransformFeedback();\n\n        this.unBindFeedbacks();\n\n        this.feedBacksSwapBuffers();\n    };\n\n    Mesh.prototype.unBindFeedbacks = function ()\n    {\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            // this._cgl.gl.disableVertexAttribArray(this._feedBacks[i].attrib.loc);\n            this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, null);\n        }\n\n        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);\n    };\n\n    Mesh.prototype.feedBacksSwapBuffers = function ()\n    {\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            const t = this._feedBacks[i].attrib.buffer;\n            this._feedBacks[i].attrib.buffer = this._feedBacks[i].outBuffer;\n            this._feedBacks[i].outBuffer = t;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX21lc2hfZmVlZGJhY2suanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfbWVzaF9mZWVkYmFjay5qcz9mOGNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpZXctc291cmNlOmh0dHA6Ly90b2ppLmdpdGh1Yi5pby93ZWJnbDItcGFydGljbGVzLTIvXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRNZXNoV2l0aEZlZWRiYWNrKE1lc2gpXG57XG4gICAgTWVzaC5wcm90b3R5cGUuaGFzRmVlZGJhY2tzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZWVkQmFja3MubGVuZ3RoID4gMDtcbiAgICB9O1xuXG4gICAgTWVzaC5wcm90b3R5cGUucmVtb3ZlRmVlZGJhY2tzID0gZnVuY3Rpb24gKHNoYWRlcilcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fZmVlZGJhY2tzKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2ZlZWRiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9mZWVkQmFja3NDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTWVzaC5wcm90b3R5cGUuc2V0QXR0cmlidXRlRmVlZGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIE1lc2gucHJvdG90eXBlLnNldEZlZWRiYWNrID0gZnVuY3Rpb24gKGF0dHJpYiwgbmFtZU91dCwgaW5pdGlhbEFycilcbiAgICB7XG4gICAgICAgIGxldCBmYiA9IHsgbmFtZU91dCwgfTtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5CaW5kRmVlZGJhY2tzKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mZWVkQmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mZWVkQmFja3NbaV0ubmFtZU91dCA9PSBuYW1lT3V0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZiID0gdGhpcy5fZmVlZEJhY2tzW2ldO1xuXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3VuZCkgdGhpcy5fZmVlZEJhY2tzQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgZmIuaW5pdGlhbEFyciA9IGluaXRpYWxBcnI7XG4gICAgICAgIGZiLmF0dHJpYiA9IGF0dHJpYjtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNldGZlZWRiYWNrXCIpO1xuXG4gICAgICAgIGlmIChmYi5vdXRCdWZmZXIpIHRoaXMuX2NnbC5nbC5kZWxldGVCdWZmZXIoZmIub3V0QnVmZmVyKTtcbiAgICAgICAgLy8gaWYoZmIuYXR0cmliLmJ1ZmZlcil0aGlzLl9jZ2wuZ2wuZGVsZXRlQnVmZmVyKGZiLmF0dHJpYi5idWZmZXIpO1xuICAgICAgICBmYi5vdXRCdWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGZiLm91dEJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5idWZmZXJEYXRhKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGZiLmluaXRpYWxBcnIsIHRoaXMuX2NnbC5nbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXIodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgZmIuYXR0cmliLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5idWZmZXJEYXRhKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGZiLmluaXRpYWxBcnIsIHRoaXMuX2NnbC5nbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgaWYgKCFmb3VuZCkgdGhpcy5fZmVlZEJhY2tzLnB1c2goZmIpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbml0aWFsQXJyJyxpbml0aWFsQXJyLmxlbmd0aC8zKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZlcnRpY2VzJyxmYi5hdHRyaWIubnVtSXRlbXMpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndmVydGljZXMnLHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5udW1JdGVtcyk7XG5cbiAgICAgICAgcmV0dXJuIGZiO1xuICAgIH07XG5cbiAgICBNZXNoLnByb3RvdHlwZS5iaW5kRmVlZGJhY2sgPSBmdW5jdGlvbiAoYXR0cmliKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mZWVkQmFja3MgfHwgdGhpcy5fZmVlZEJhY2tzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtRmVlZEJhY2tMb2MgPT0gLTEpIHRoaXMuX3RyYW5zZm9ybUZlZWRCYWNrTG9jID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayh0aGlzLl9jZ2wuZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCB0aGlzLl90cmFuc2Zvcm1GZWVkQmFja0xvYyk7XG5cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mZWVkQmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGZiID0gdGhpcy5fZmVlZEJhY2tzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZmIuYXR0cmliID09IGF0dHJpYilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXIodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgZmIuYXR0cmliLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgICAvLyAgICAgZmIuYXR0cmliLmxvYyxcbiAgICAgICAgICAgICAgICAvLyAgICAgZmIuYXR0cmliLml0ZW1TaXplLFxuICAgICAgICAgICAgICAgIC8vICAgICBmYi5hdHRyaWIudHlwZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gICAgIGZiLmF0dHJpYi5pdGVtU2l6ZSo0LCAwKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyQmFzZSh0aGlzLl9jZ2wuZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgZmIub3V0QnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQVJUVFJJQiBOT1QgRk9VTkRcIixhdHRyaWIubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWVzaC5wcm90b3R5cGUuZHJhd0ZlZWRiYWNrcyA9IGZ1bmN0aW9uIChzaGFkZXIsIHByaW0pXG4gICAge1xuICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZlZWRCYWNrc0NoYW5nZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIHRoaXMuX3RyYW5zZm9ybUZlZWRCYWNrTG9jKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2ZlZWRCYWNrcy5sZW5ndGg7IGkrKykgbmFtZXMucHVzaCh0aGlzLl9mZWVkQmFja3NbaV0ubmFtZU91dCk7XG4gICAgICAgICAgICBzaGFkZXIuc2V0RmVlZGJhY2tOYW1lcyhuYW1lcyk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmVlZGJhY2tuYW1lc1wiLCBuYW1lcyk7XG5cbiAgICAgICAgICAgIHNoYWRlci5jb21waWxlKCk7XG4gICAgICAgICAgICB0aGlzLl9mZWVkQmFja3NDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjaGFuZ2VkIGZpbmlzaGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZm9yKCBpPTA7aTx0aGlzLl9mZWVkQmFja3MubGVuZ3RoO2krKylcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdmFyIGZiPXRoaXMuX2ZlZWRCYWNrc1tpXTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyQmFzZSh0aGlzLl9jZ2wuZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgZmIub3V0QnVmZmVyKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGRyYXdcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2sodGhpcy5nbFByaW1pdGl2ZSk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5kcmF3QXJyYXlzKHByaW0sIDAsIHRoaXMuX2ZlZWRCYWNrc1swXS5hdHRyaWIubnVtSXRlbXMpO1xuXG4gICAgICAgIC8vIHVuYmluZFxuICAgICAgICB0aGlzLl9jZ2wuZ2wuZW5kVHJhbnNmb3JtRmVlZGJhY2soKTtcblxuICAgICAgICB0aGlzLnVuQmluZEZlZWRiYWNrcygpO1xuXG4gICAgICAgIHRoaXMuZmVlZEJhY2tzU3dhcEJ1ZmZlcnMoKTtcbiAgICB9O1xuXG4gICAgTWVzaC5wcm90b3R5cGUudW5CaW5kRmVlZGJhY2tzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZmVlZEJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2ZlZWRCYWNrc1tpXS5hdHRyaWIubG9jKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyQmFzZSh0aGlzLl9jZ2wuZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpO1xuICAgIH07XG5cbiAgICBNZXNoLnByb3RvdHlwZS5mZWVkQmFja3NTd2FwQnVmZmVycyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZlZWRCYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX2ZlZWRCYWNrc1tpXS5hdHRyaWIuYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5fZmVlZEJhY2tzW2ldLmF0dHJpYi5idWZmZXIgPSB0aGlzLl9mZWVkQmFja3NbaV0ub3V0QnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5fZmVlZEJhY2tzW2ldLm91dEJ1ZmZlciA9IHQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_mesh_feedback.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_profiledata.js":
/*!*****************************************!*\
  !*** ./src/core/cgl/cgl_profiledata.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProfileData\": () => (/* binding */ ProfileData)\n/* harmony export */ });\nclass ProfileData\n{\n    constructor(cgl)\n    {\n        this._cgl = cgl;\n        this._lastTime = 0;\n        this.pause = false;\n        this.profileUniformCount = 0;\n        this.profileShaderBinds = 0;\n        this.profileUniformCount = 0;\n        this.profileShaderCompiles = 0;\n        this.profileVideosPlaying = 0;\n        this.profileMVPMatrixCount = 0;\n        this.profileEffectBuffercreate = 0;\n        this.profileShaderGetUniform = 0;\n        this.profileFrameBuffercreate = 0;\n        this.profileMeshSetGeom = 0;\n        this.profileTextureNew = 0;\n        this.profileGenMipMap = 0;\n        this.profileOnAnimFrameOps = 0;\n\n        this.profileFencedPixelRead = 0;\n        this.profileMainloopMs = 0;\n        this.profileMeshDraw = 0;\n        this.profileTextureEffect = 0;\n        this.profileTexPreviews = 0;\n        this.shaderCompileTime = 0;\n        this.profileMeshNumElements = 0;\n        this.profileMeshAttributes = 0;\n        this.profileSingleMeshAttribute = [];\n        this.heavyEvents = [];\n\n        this.doProfileGlQuery = false;\n        this.glQueryData = {};\n    }\n\n    clear()\n    {\n        this.profileSingleMeshAttribute = {};\n        this.profileMeshAttributes = 0;\n        this.profileUniformCount = 0;\n        this.profileShaderGetUniform = 0;\n        this.profileShaderCompiles = 0;\n        this.profileShaderBinds = 0;\n        this.profileTextureResize = 0;\n        this.profileFrameBuffercreate = 0;\n        this.profileEffectBuffercreate = 0;\n        this.profileTextureDelete = 0;\n        this.profileMeshSetGeom = 0;\n        this.profileVideosPlaying = 0;\n        this.profileMVPMatrixCount = 0;\n        this.profileNonTypedAttrib = 0;\n        this.profileNonTypedAttribNames = \"\";\n        this.profileTextureNew = 0;\n        this.profileGenMipMap = 0;\n        this.profileFramebuffer = 0;\n        this.profileMeshDraw = 0;\n        this.profileTextureEffect = 0;\n        this.profileTexPreviews = 0;\n        this.profileMeshNumElements = 0;\n        this.profileFencedPixelRead = 0;\n    }\n\n    clearGlQuery()\n    {\n        for (let i in this.glQueryData)\n        {\n            if (!this.glQueryData[i].lastClear || performance.now() - this.glQueryData[i].lastClear > 1000)\n            {\n                this.glQueryData[i].time = this.glQueryData[i]._times / this.glQueryData[i]._numcount;\n                this.glQueryData[i].num = this.glQueryData[i]._numcount;\n\n                this.glQueryData[i]._times = 0;\n                this.glQueryData[i]._numcount = 0;\n                this.glQueryData[i].lastClear = performance.now();\n            }\n        }\n    }\n\n    addHeavyEvent(event, name, info)\n    {\n        const e = { \"event\": event, \"name\": name, \"info\": info, \"date\": performance.now() };\n        this.heavyEvents.push(e);\n        this._cgl.emitEvent(\"heavyEvent\", e);\n    }\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3Byb2ZpbGVkYXRhLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9wcm9maWxlZGF0YS5qcz85NzcyIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFByb2ZpbGVEYXRhXG57XG4gICAgY29uc3RydWN0b3IoY2dsKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsID0gY2dsO1xuICAgICAgICB0aGlzLl9sYXN0VGltZSA9IDA7XG4gICAgICAgIHRoaXMucGF1c2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9maWxlVW5pZm9ybUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlU2hhZGVyQmluZHMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVVbmlmb3JtQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVTaGFkZXJDb21waWxlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVZpZGVvc1BsYXlpbmcgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNVlBNYXRyaXhDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUVmZmVjdEJ1ZmZlcmNyZWF0ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVNoYWRlckdldFVuaWZvcm0gPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVGcmFtZUJ1ZmZlcmNyZWF0ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU1lc2hTZXRHZW9tID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4dHVyZU5ldyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUdlbk1pcE1hcCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU9uQW5pbUZyYW1lT3BzID0gMDtcblxuICAgICAgICB0aGlzLnByb2ZpbGVGZW5jZWRQaXhlbFJlYWQgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNYWlubG9vcE1zID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaERyYXcgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVUZXh0dXJlRWZmZWN0ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4UHJldmlld3MgPSAwO1xuICAgICAgICB0aGlzLnNoYWRlckNvbXBpbGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaE51bUVsZW1lbnRzID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaEF0dHJpYnV0ZXMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVTaW5nbGVNZXNoQXR0cmlidXRlID0gW107XG4gICAgICAgIHRoaXMuaGVhdnlFdmVudHMgPSBbXTtcblxuICAgICAgICB0aGlzLmRvUHJvZmlsZUdsUXVlcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nbFF1ZXJ5RGF0YSA9IHt9O1xuICAgIH1cblxuICAgIGNsZWFyKClcbiAgICB7XG4gICAgICAgIHRoaXMucHJvZmlsZVNpbmdsZU1lc2hBdHRyaWJ1dGUgPSB7fTtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaEF0dHJpYnV0ZXMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVVbmlmb3JtQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlU2hhZGVyQ29tcGlsZXMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVTaGFkZXJCaW5kcyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVRleHR1cmVSZXNpemUgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVGcmFtZUJ1ZmZlcmNyZWF0ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUVmZmVjdEJ1ZmZlcmNyZWF0ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVRleHR1cmVEZWxldGUgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNZXNoU2V0R2VvbSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVZpZGVvc1BsYXlpbmcgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNVlBNYXRyaXhDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU5vblR5cGVkQXR0cmliID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTm9uVHlwZWRBdHRyaWJOYW1lcyA9IFwiXCI7XG4gICAgICAgIHRoaXMucHJvZmlsZVRleHR1cmVOZXcgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVHZW5NaXBNYXAgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVGcmFtZWJ1ZmZlciA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU1lc2hEcmF3ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4dHVyZUVmZmVjdCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVRleFByZXZpZXdzID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaE51bUVsZW1lbnRzID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlRmVuY2VkUGl4ZWxSZWFkID0gMDtcbiAgICB9XG5cbiAgICBjbGVhckdsUXVlcnkoKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmdsUXVlcnlEYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2xRdWVyeURhdGFbaV0ubGFzdENsZWFyIHx8IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5nbFF1ZXJ5RGF0YVtpXS5sYXN0Q2xlYXIgPiAxMDAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xRdWVyeURhdGFbaV0udGltZSA9IHRoaXMuZ2xRdWVyeURhdGFbaV0uX3RpbWVzIC8gdGhpcy5nbFF1ZXJ5RGF0YVtpXS5fbnVtY291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5nbFF1ZXJ5RGF0YVtpXS5udW0gPSB0aGlzLmdsUXVlcnlEYXRhW2ldLl9udW1jb3VudDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2xRdWVyeURhdGFbaV0uX3RpbWVzID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmdsUXVlcnlEYXRhW2ldLl9udW1jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5nbFF1ZXJ5RGF0YVtpXS5sYXN0Q2xlYXIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZEhlYXZ5RXZlbnQoZXZlbnQsIG5hbWUsIGluZm8pXG4gICAge1xuICAgICAgICBjb25zdCBlID0geyBcImV2ZW50XCI6IGV2ZW50LCBcIm5hbWVcIjogbmFtZSwgXCJpbmZvXCI6IGluZm8sIFwiZGF0ZVwiOiBwZXJmb3JtYW5jZS5ub3coKSB9O1xuICAgICAgICB0aGlzLmhlYXZ5RXZlbnRzLnB1c2goZSk7XG4gICAgICAgIHRoaXMuX2NnbC5lbWl0RXZlbnQoXCJoZWF2eUV2ZW50XCIsIGUpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgeyBQcm9maWxlRGF0YSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_profiledata.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_shader.js":
/*!************************************!*\
  !*** ./src/core/cgl/cgl_shader.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shader\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var _cgl_shader_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_shader_lib */ \"./src/core/cgl/cgl_shader_lib.js\");\n/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../timer */ \"./src/core/timer.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n/* harmony import */ var _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_mesh */ \"./src/core/cgl/cgl_mesh.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cgl_utils */ \"./src/core/cgl/cgl_utils.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _cgl_shader_default_glsl_vert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cgl_shader_default_glsl.vert */ \"./src/core/cgl/cgl_shader_default_glsl.vert\");\n\n\n\n\n// import { CGL } from \"./index\";\n\n\n\n\n// ---------------------------------------------------------------------------\n\n\n/*\n\nproposal default shader variable names:\n\nattrVertex - currently: vPosition\nattrVertexIndex - currently: attrVertIndex\nattrTexCoord\nattrInstMat - currently: instMat\nattrVertColor\nattrTangent\nattrBiTangent\n\nuProjMatrix - currently: projMatrix\nuModelMatrix - currently: modelMatrix\nuNormalMatrix - currently: normalMatrix\nuCamPosition - currently: camPos\n\n*/\n\n\n// ---------------------------------------------------------------------------\n\nlet materialIdCounter = 0;\n\n/**\n * @class\n * @external CGL\n * @namespace Shader\n * @hideconstructor\n * @example\n * var shader=new CGL.Shader(cgl,'MinimalMaterial');\n * shader.setSource(attachments.shader_vert,attachments.shader_frag);\n */\nconst Shader = function (_cgl, _name, _op)\n{\n    if (!_cgl) throw new Error(\"shader constructed without cgl \" + _name);\n\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\"cgl_shader\");\n    this._cgl = _cgl;\n\n    if (!_name) this._log.stack(\"no shader name given\");\n    this._name = _name || \"unknown\";\n\n    if (_op) this.opId = _op.id;\n    this.glslVersion = 0;\n    if (_cgl.glVersion > 1) this.glslVersion = 300;\n\n    this._materialId = ++materialIdCounter;\n\n    this.id = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.simpleId)();\n    this._isValid = true;\n    this._program = null;\n    this._uniforms = [];\n    this._drawBuffers = [true];\n    this._defines = [];\n    this._needsRecompile = true;\n    this._compileReason = \"initial\";\n\n    this.ignoreMissingUniforms = false;\n    this._projMatrixUniform = null;\n    this._mvMatrixUniform = null;\n    this._mMatrixUniform = null;\n    this._vMatrixUniform = null;\n    this._camPosUniform = null;\n    this._normalMatrixUniform = null;\n    this._inverseViewMatrixUniform = null;\n\n    this._attrVertexPos = -1;\n    this.precision = _cgl.patch.config.glslPrecision || \"highp\";\n\n    this._pMatrixState = -1;\n    this._vMatrixState = -1;\n\n    this._countMissingUniforms = 0;\n    this._modGroupCount = 0; // not needed anymore...\n    this._feedBackNames = [];\n    this._attributes = [];\n\n    this.glPrimitive = null;\n    this.offScreenPass = false;\n    this._extensions = [];\n    this.srcVert = this.getDefaultVertexShader();\n    this.srcFrag = this.getDefaultFragmentShader();\n    this.lastCompile = 0;\n\n    this._moduleNames = [];\n    this._modules = [];\n    this._moduleNumId = 0;\n\n    this._libs = [];\n    this._structNames = [];\n    this._structUniformNames = [];\n    this._textureStackUni = [];\n    this._textureStackTex = [];\n    this._textureStackType = [];\n    this._textureStackTexCgl = [];\n\n    this._tempNormalMatrix = mat4.create();\n    this._tempCamPosMatrix = mat4.create();\n    this._tempInverseViewMatrix = mat4.create();\n    this._tempInverseProjMatrix = mat4.create();\n\n    this.setModules([\"MODULE_VERTEX_POSITION\", \"MODULE_COLOR\", \"MODULE_BEGIN_FRAG\"]);\n};\n\nShader.prototype.isValid = function ()\n{\n    return this._isValid;\n};\n\nShader.prototype.getCgl = function ()\n{\n    return this._cgl;\n};\n\nShader.prototype.getName = function ()\n{\n    return this._name;\n};\n\n/**\n * enable an extension for the shader\n * @function enableExtension\n * @memberof Shader\n * @instance\n * @param name extension name\n */\nShader.prototype.enableExtension = function (name)\n{\n    this.setWhyCompile(\"enable extension \" + name);\n    this._needsRecompile = true;\n    this._extensions.push(name);\n};\n\nShader.prototype.getAttrVertexPos = function ()\n{\n    return this._attrVertexPos;\n};\n\nShader.prototype.hasTextureUniforms = function ()\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n        if (this._uniforms[i].getType() == \"t\") return true;\n    return false;\n};\n\nShader.prototype.setWhyCompile = function (why)\n{\n    this._compileReason = why;\n};\n\n/**\n * copy all uniform values from another shader\n * @function copyUniforms\n * @memberof Shader\n * @instance\n * @param shader uniform values will be copied from this shader\n */\nShader.prototype.copyUniformValues = function (origShader)\n{\n    // console.log(origShader._uniforms);\n    for (let i = 0; i < origShader._uniforms.length; i++)\n    {\n        if (!this._uniforms[i])\n        {\n            this._log.log(\"unknown uniform?!\");\n            continue;\n        }\n\n        // this._log.log(origShader._uniforms[i].getName());\n        // this.getUniform(origShader._uniforms[i].)\n        // this._uniforms[i].set(origShader._uniforms[i].getValue());\n\n\n        if (origShader._uniforms[i].getName().indexOf(\"pathPoints\") != -1)\n            console.log(\"copyUniformValues\", origShader._uniforms[i].getName(), origShader._uniforms[i].getValue());\n\n        this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());\n    }\n\n    this.popTextures();\n    for (let i = 0; i < origShader._textureStackUni.length; i++)\n    {\n        this._textureStackUni[i] = origShader._textureStackUni[i];\n        this._textureStackTex[i] = origShader._textureStackTex[i];\n        this._textureStackType[i] = origShader._textureStackType[i];\n        this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];\n    }\n\n    // this._textureStackUni = [];\n    // this._textureStackTex = [];\n    // this._textureStackType = [];\n    // this._textureStackTexCgl = [];\n};\n\n/**\n * copy current shader\n * @function copy\n * @memberof Shader\n * @instance\n * @returns newShader\n */\nShader.prototype.copy = function ()\n{\n    const shader = new Shader(this._cgl, this._name + \" copy\");\n    shader.setSource(this.srcVert, this.srcFrag);\n\n    shader._modules = JSON.parse(JSON.stringify(this._modules));\n    shader._defines = JSON.parse(JSON.stringify(this._defines));\n\n    shader._modGroupCount = this._modGroupCount;\n    shader._moduleNames = this._moduleNames;\n    shader.glPrimitive = this.glPrimitive;\n    shader.offScreenPass = this.offScreenPass;\n    shader._extensions = this._extensions;\n    shader.wireframe = this.wireframe;\n    shader._attributes = this._attributes;\n\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        const u = this._uniforms[i].copy(shader);\n        u.resetLoc();\n    }\n\n    this.setWhyCompile(\"copy\");\n    shader._needsRecompile = true;\n    return shader;\n};\n\n\n/**\n * set shader source code\n * @function setSource\n * @memberof Shader\n * @instance\n * @param {String} srcVert\n * @param {String} srcFrag\n */\nShader.prototype.setSource = function (srcVert, srcFrag)\n{\n    this.srcVert = srcVert;\n    this.srcFrag = srcFrag;\n    this.setWhyCompile(\"Source changed\");\n    this._needsRecompile = true;\n    this._isValid = true;\n};\n\nShader.prototype._addLibs = function (src)\n{\n    for (const id in _cgl_shader_lib__WEBPACK_IMPORTED_MODULE_0__.ShaderLibMods)\n    {\n        if (src.indexOf(id) > -1)\n        {\n            const lib = new _cgl_shader_lib__WEBPACK_IMPORTED_MODULE_0__.ShaderLibMods[id]();\n            src = src.replace(\"{{\" + id + \"}}\", lib.srcHeadFrag);\n            this._libs.push(lib);\n            if (lib.initUniforms)lib.initUniforms(this);\n        }\n    }\n\n    return src;\n};\n\nShader.prototype.createStructUniforms = function ()\n{\n    // * create structs\n    let structStrFrag = \"\";\n    let structStrVert = \"\"; // TODO: not used yet\n\n    this._structNames = [];\n    // * reset the arrays holding the value each recompile so we don't skip structs\n    // * key value mapping so the same struct can be added twice (two times the same modifier)\n    this._injectedStringsFrag = {};\n    this._injectedStringsVert = {};\n\n    this._structUniformNamesIndicesFrag = [];\n    this._structUniformNamesIndicesVert = [];\n\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        // * only add uniforms to struct that are a member of a struct\n        if (this._uniforms[i].isStructMember())\n        {\n            const injectionString = \"{{INJECTION_POINT_STRUCT_\" + this._uniforms[i]._structName + \"}}\";\n\n            // * check if struct is not already part of shader\n            if (this._structNames.indexOf(this._uniforms[i]._structName) === -1)\n            {\n                // * create struct definition with placeholder string to inject\n                const structDefinition = \"struct \"\n                    + this._uniforms[i]._structName + \" {\".endl()\n                    + injectionString\n                    + \"};\".endl().endl();\n\n                if (this._uniforms[i].getShaderType() === \"both\" || this._uniforms[i].getShaderType() === \"frag\")\n                    structStrFrag = structStrFrag.concat(structDefinition);\n\n                if (this._uniforms[i].getShaderType() === \"both\" || this._uniforms[i].getShaderType() === \"vert\")\n                    structStrVert = structStrVert.concat(structDefinition);\n\n                this._structNames.push(this._uniforms[i]._structName);\n                this._injectedStringsFrag[this._uniforms[i]._structName] = [];\n                this._injectedStringsVert[this._uniforms[i]._structName] = [];\n            }\n\n            // * create member & comment\n            let comment = \"\";\n            if (this._uniforms[i].comment) comment = \" // \" + this._uniforms[i].comment;\n\n            let stringToInsert = \"\";\n            if (this._uniforms[i].getGlslTypeString() == undefined)stringToInsert += \"//\";\n            stringToInsert += \"  \" + this._uniforms[i].getGlslTypeString()\n                    + \" \" + this._uniforms[i]._propertyName + \";\"\n                    + comment;\n\n            if (this._uniforms[i].getShaderType() === \"both\")\n            {\n                // * inject member before {injectionString}\n                if (\n                    this._injectedStringsFrag[this._uniforms[i]._structName].indexOf(stringToInsert) === -1\n                && this._injectedStringsVert[this._uniforms[i]._structName].indexOf(stringToInsert) === -1)\n                {\n                    const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);\n                    const insertionIndexVert = structStrVert.lastIndexOf(injectionString);\n\n                    structStrFrag =\n                        structStrFrag.slice(0, insertionIndexFrag)\n                        + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);\n\n                    structStrVert =\n                        structStrVert.slice(0, insertionIndexVert)\n                        + stringToInsert + structStrVert.slice(insertionIndexVert - 1);\n\n                    this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);\n                    this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);\n                }\n\n                if (this._structUniformNamesIndicesFrag.indexOf(i) === -1) this._structUniformNamesIndicesFrag.push(i);\n                if (this._structUniformNamesIndicesVert.indexOf(i) === -1) this._structUniformNamesIndicesVert.push(i);\n            }\n            else if (this._uniforms[i].getShaderType() === \"frag\")\n            {\n                // * inject member before {injectionString}\n                if (this._injectedStringsFrag[this._uniforms[i]._structName].indexOf(stringToInsert) === -1)\n                {\n                    const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);\n\n                    structStrFrag =\n                        structStrFrag.slice(0, insertionIndexFrag)\n                        + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);\n\n                    this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);\n                }\n\n                if (this._structUniformNamesIndicesFrag.indexOf(i) === -1) this._structUniformNamesIndicesFrag.push(i);\n            }\n            else if (this._uniforms[i].getShaderType() === \"vert\")\n            {\n                // * inject member before {injectionString}\n                if (this._injectedStringsVert[this._uniforms[i]._structName].indexOf(stringToInsert) === -1)\n                {\n                    const insertionIndexVert = structStrVert.lastIndexOf(injectionString);\n\n                    structStrVert =\n                        structStrVert.slice(0, insertionIndexVert)\n                        + stringToInsert + structStrVert.slice(insertionIndexVert - 1);\n\n                    this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);\n                }\n\n                if (this._structUniformNamesIndicesVert.indexOf(i) === -1) this._structUniformNamesIndicesVert.push(i);\n            }\n        }\n    }\n\n    // * dedupe injected uni declarations\n    this._uniDeclarationsFrag = [];\n    this._uniDeclarationsVert = [];\n\n    // * remove struct injection points and add uniform in fragment\n    for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1)\n    {\n        const index = this._structUniformNamesIndicesFrag[i];\n        const uniDeclarationString = \"UNI \" + this._uniforms[index]._structName + \" \" + this._uniforms[index]._structUniformName + \";\".endl();\n\n        if (this._uniDeclarationsFrag.indexOf(uniDeclarationString) === -1)\n        {\n            const injectionString = \"{{INJECTION_POINT_STRUCT_\" + this._uniforms[index]._structName + \"}}\";\n\n            structStrFrag = structStrFrag.replace(injectionString, \"\");\n            structStrFrag += uniDeclarationString;\n\n            this._uniDeclarationsFrag.push(uniDeclarationString);\n        }\n    }\n\n    // * remove struct injection points and add uniform in vertex\n    for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1)\n    {\n        const index = this._structUniformNamesIndicesVert[i];\n        const uniDeclarationString = \"UNI \" + this._uniforms[index]._structName + \" \" + this._uniforms[index]._structUniformName + \";\".endl();\n\n        if (this._uniDeclarationsVert.indexOf(uniDeclarationString) === -1)\n        {\n            const injectionString = \"{{INJECTION_POINT_STRUCT_\" + this._uniforms[index]._structName + \"}}\";\n\n            structStrVert = structStrVert.replace(injectionString, \"\");\n            structStrVert += uniDeclarationString;\n            this._uniDeclarationsVert.push(uniDeclarationString);\n        }\n    }\n\n    return [structStrVert, structStrFrag];\n};\n\nShader.prototype._getAttrSrc = function (attr, firstLevel)\n{\n    const r = {};\n    if (attr.name && attr.type)\n    {\n        r.srcHeadVert = \"\";\n        if (!firstLevel) r.srcHeadVert += \"#ifndef ATTRIB_\" + attr.name.endl();\n        r.srcHeadVert += \"#define ATTRIB_\" + attr.name.endl();\n        r.srcHeadVert += \"IN \" + attr.type + \" \" + attr.name + \";\".endl();\n        if (!firstLevel) r.srcHeadVert += \"#endif\".endl();\n\n        if (attr.nameFrag)\n        {\n            r.srcHeadVert += \"\";\n            if (!firstLevel) r.srcHeadVert += \"#ifndef ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadVert += \"#define ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadVert += \"OUT \" + attr.type + \" \" + attr.nameFrag + \";\".endl();\n            if (!firstLevel) r.srcHeadVert += \"#endif\".endl();\n\n            r.srcVert = \"\".endl() + attr.nameFrag + \"=\" + attr.name + \";\";\n\n            r.srcHeadFrag = \"\";\n            if (!firstLevel) r.srcHeadFrag += \"#ifndef ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadFrag += \"#define ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadFrag += \"IN \" + attr.type + \" \" + attr.nameFrag + \";\".endl();\n            if (!firstLevel) r.srcHeadFrag += \"#endif\".endl();\n        }\n    }\n    return r;\n};\n\nShader.prototype.compile = function ()\n{\n    if (this._cgl.aborted) return;\n    const startTime = performance.now();\n\n\n\n    this._cgl.profileData.profileShaderCompiles++;\n    this._cgl.profileData.profileShaderCompileName = this._name + \" [\" + this._compileReason + \"]\";\n\n    let extensionString = \"\";\n    if (this._extensions)\n        for (let i = 0; i < this._extensions.length; i++)\n            extensionString += \"#extension \" + this._extensions[i] + \" : enable\".endl();\n\n    let definesStr = \"\";\n    if (this._defines.length) definesStr = \"\\n// cgl generated\".endl();\n    for (let i = 0; i < this._defines.length; i++)\n        definesStr += \"#define \" + this._defines[i][0] + \" \" + this._defines[i][1] + \"\".endl();\n\n    const structStrings = this.createStructUniforms();\n    this._cgl.profileData.addHeavyEvent(\"shader compile\", this._name + \" [\" + this._compileReason + \"]\");\n    this._compileReason = \"\";\n\n\n\n    if (this._uniforms)\n    {\n        // * we create an array of the uniform names to check our indices & an array to save them\n        const uniNames = this._uniforms.map((uni) => { return uni._name; });\n        const indicesToRemove = [];\n\n        // * we go through our uniforms and check if the same name is contained somewhere further in the array\n        // * if so, we add the current index to be removed later\n        for (let i = 0; i < this._uniforms.length; i++)\n        {\n            const uni = this._uniforms[i];\n            const nextIndex = uniNames.indexOf(uni._name, i + 1);\n            if (nextIndex > -1) indicesToRemove.push(i);\n        }\n\n        // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices\n        // * also, we reset the locations of all the other valid uniforms\n        for (let j = this._uniforms.length - 1; j >= 0; j -= 1)\n        {\n            if (indicesToRemove.indexOf(j) > -1) this._uniforms.splice(j, 1);\n            else this._uniforms[j].resetLoc();\n        }\n    }\n\n    this._cgl.printError(\"uniform resets\");\n\n    if (this.hasTextureUniforms()) definesStr += \"#define HAS_TEXTURES\".endl();\n\n    let vs = \"\";\n    let fs = \"\";\n\n    if (!this.srcFrag)\n    {\n        this._log.error(\"[cgl shader] has no fragment source!\", this);\n        this.srcVert = this.getDefaultVertexShader();\n        this.srcFrag = this.getDefaultFragmentShader();\n        // return;\n    }\n\n    if (this.glslVersion == 300)\n    {\n        vs = \"#version 300 es\"\n            .endl() + \"// \"\n            .endl() + \"// vertex shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"precision \" + this.precision + \" float;\"\n            .endl() + \"precision \" + this.precision + \" sampler2D;\"\n            .endl() + \"\"\n            .endl() + \"#define WEBGL2\"\n            .endl() + \"#define texture2D texture\"\n            .endl() + \"#define UNI uniform\"\n            .endl() + \"#define IN in\"\n            .endl() + \"#define OUT out\"\n            .endl();\n\n        fs = \"#version 300 es\"\n            .endl() + \"// \"\n            .endl() + \"// fragment shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"precision \" + this.precision + \" float;\"\n            .endl() + \"precision \" + this.precision + \" sampler2D;\"\n            .endl() + \"\"\n            .endl() + \"#define WEBGL2\"\n            .endl() + \"#define texture2D texture\"\n            .endl() + \"#define IN in\"\n            .endl() + \"#define OUT out\"\n            .endl() + \"#define UNI uniform\"\n            .endl() + \"{{DRAWBUFFER}}\"\n\n            .endl();\n    }\n    else\n    {\n        fs = \"\"\n            .endl() + \"// \"\n            .endl() + \"// fragment shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"#define WEBGL1\"\n            .endl() + \"#define texture texture2D\"\n            .endl() + \"#define outColor gl_FragColor\"\n            .endl() + \"#define IN varying\"\n            .endl() + \"#define UNI uniform\"\n            .endl();\n\n        vs = \"\"\n            .endl() + \"// \"\n            .endl() + \"// vertex shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"#define WEBGL1\"\n            .endl() + \"#define texture texture2D\"\n            .endl() + \"#define OUT varying\"\n            .endl() + \"#define IN attribute\"\n            .endl() + \"#define UNI uniform\"\n            .endl();\n    }\n\n    let uniformsStrVert = \"\\n// cgl generated\".endl();\n    let uniformsStrFrag = \"\\n// cgl generated\".endl();\n\n\n    fs += \"\\n// active mods: --------------- \";\n    vs += \"\\n// active mods: --------------- \";\n\n    let foundModsFrag = false;\n    let foundModsVert = false;\n    for (let i = 0; i < this._moduleNames.length; i++)\n    {\n        for (let j = 0; j < this._modules.length; j++)\n        {\n            if (this._modules[j].name == this._moduleNames[i])\n            {\n                if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag)\n                {\n                    foundModsFrag = true;\n                    fs += \"\\n// \" + i + \".\" + j + \". \" + this._modules[j].title + \" (\" + this._modules[j].name + \")\";\n                }\n                if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert)\n                {\n                    vs += \"\\n// \" + i + \".\" + j + \". \" + this._modules[j].title + \" (\" + this._modules[j].name + \")\";\n                    foundModsVert = true;\n                }\n            }\n        }\n    }\n    if (!foundModsVert)fs += \"\\n// no mods used...\";\n    if (!foundModsFrag)fs += \"\\n// no mods used...\";\n    fs += \"\\n\";\n    vs += \"\\n\";\n\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())\n        {\n            let uniStr = \"\";\n            if (!this._uniforms[i].getGlslTypeString())uniStr += \"// \";\n            uniStr += \"UNI \" + this._uniforms[i].getGlslTypeString() + \" \" + this._uniforms[i].getName();\n            let comment = \"\";\n            if (this._uniforms[i].comment) comment = \" // \" + this._uniforms[i].comment;\n\n            if (this._uniforms[i].shaderType == \"vert\" || this._uniforms[i].shaderType == \"both\")\n                if (this.srcVert.indexOf(uniStr) == -1 && this.srcVert.indexOf(\"uniform \" + this._uniforms[i].getGlslTypeString() + \" \" + this._uniforms[i].getName()) == -1)\n                    uniformsStrVert += uniStr + \";\" + comment.endl();\n\n            if (this._uniforms[i].shaderType == \"frag\" || this._uniforms[i].shaderType == \"both\")\n                if (this.srcFrag.indexOf(uniStr) == -1 && this.srcFrag.indexOf(\"uniform \" + this._uniforms[i].getGlslTypeString() + \" \" + this._uniforms[i].getName()) == -1)\n                    uniformsStrFrag += uniStr + \";\" + comment.endl();\n        }\n    }\n\n\n    let countUniFrag = 0;\n    let countUniVert = 0;\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())\n        {\n            if (this._uniforms[i].shaderType == \"vert\" || this._uniforms[i].shaderType == \"both\") countUniVert++;\n            if (this._uniforms[i].shaderType == \"frag\" || this._uniforms[i].shaderType == \"both\") countUniFrag++;\n        }\n    }\n    if (countUniFrag >= this._cgl.maxUniformsFrag) this._log.warn(\"[cgl_shader] num uniforms frag: \" + countUniFrag + \" / \" + this._cgl.maxUniformsFrag);\n    if (countUniVert >= this._cgl.maxUniformsVert) this._log.warn(\"[cgl_shader] num uniforms vert: \" + countUniVert + \" / \" + this._cgl.maxUniformsVert);\n\n\n    if (fs.indexOf(\"precision\") == -1) fs = \"precision \" + this.precision + \" float;\".endl() + fs;\n    if (vs.indexOf(\"precision\") == -1) vs = \"precision \" + this.precision + \" float;\".endl() + vs;\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))\n    {\n        fs += \"#define MOBILE\".endl();\n        vs += \"#define MOBILE\".endl();\n    }\n    vs = extensionString + vs + definesStr + structStrings[0] + uniformsStrVert + \"\\n// -- \\n\" + this.srcVert;\n    fs = extensionString + fs + definesStr + structStrings[1] + uniformsStrFrag + \"\\n// -- \\n\" + this.srcFrag;\n\n\n    let srcHeadVert = \"\";\n    let srcHeadFrag = \"\";\n\n    this._modules.sort(function (a, b)\n    {\n        return a.group - b.group;\n    });\n\n    this._modules.sort(function (a, b)\n    {\n        return a.priority || 0 - b.priority || 0;\n    });\n\n\n    let addedAttribs = false;\n\n    for (let i = 0; i < this._moduleNames.length; i++)\n    {\n        let srcVert = \"\";\n        let srcFrag = \"\";\n\n        if (!addedAttribs)\n        {\n            addedAttribs = true;\n\n            for (let k = 0; k < this._attributes.length; k++)\n            {\n                const r = this._getAttrSrc(this._attributes[k], true);\n                if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;\n                if (r.srcVert)srcVert += r.srcVert;\n                if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;\n            }\n        }\n\n        for (let j = 0; j < this._modules.length; j++)\n        {\n            const mod = this._modules[j];\n            if (mod.name == this._moduleNames[i])\n            {\n                srcHeadVert += \"\\n//---- MOD: group:\" + mod.group + \": idx:\" + j + \" - prfx:\" + mod.prefix + \" - \" + mod.title + \" ------\\n\";\n                srcHeadFrag += \"\\n//---- MOD: group:\" + mod.group + \": idx:\" + j + \" - prfx:\" + mod.prefix + \" - \" + mod.title + \" ------\\n\";\n\n                srcVert += \"\\n\\n//---- MOD: \" + mod.title + \" / \" + mod.priority + \" ------\\n\";\n                srcFrag += \"\\n\\n//---- MOD: \" + mod.title + \" / \" + mod.priority + \" ------\\n\";\n\n                if (mod.attributes)\n                    for (let k = 0; k < mod.attributes.length; k++)\n                    {\n                        const r = this._getAttrSrc(mod.attributes[k], false);\n                        if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;\n                        if (r.srcVert)srcVert += r.srcVert;\n                        if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;\n                    }\n\n                srcHeadVert += mod.srcHeadVert || \"\";\n                srcHeadFrag += mod.srcHeadFrag || \"\";\n                srcVert += mod.srcBodyVert || \"\";\n                srcFrag += mod.srcBodyFrag || \"\";\n\n                srcHeadVert += \"\\n//---- end mod ------\\n\";\n                srcHeadFrag += \"\\n//---- end mod ------\\n\";\n\n                srcVert += \"\\n//---- end mod ------\\n\";\n                srcFrag += \"\\n//---- end mod ------\\n\";\n\n                srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);\n                srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);\n                srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);\n                srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);\n\n                srcVert = srcVert.replace(/MOD_/g, mod.prefix);\n                srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);\n                srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);\n                srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);\n            }\n        }\n\n\n        vs = vs.replace(\"{{\" + this._moduleNames[i] + \"}}\", srcVert);\n        fs = fs.replace(\"{{\" + this._moduleNames[i] + \"}}\", srcFrag);\n    }\n    vs = vs.replace(\"{{MODULES_HEAD}}\", srcHeadVert);\n    fs = fs.replace(\"{{MODULES_HEAD}}\", srcHeadFrag);\n\n\n    vs = this._addLibs(vs);\n    fs = this._addLibs(fs);\n\n\n    // SETUP draw buffers / multi texture render targets\n\n    let drawBufferStr = \"\";\n    for (let i = 0; i < 16; i++)\n        if (fs.indexOf(\"outColor\" + i) > -1) this._drawBuffers[i] = true;\n\n    if (this._drawBuffers.length == 1)\n    {\n        drawBufferStr = \"out vec4 outColor;\".endl();\n        drawBufferStr += \"#define gl_FragColor outColor\".endl();\n    }\n    else\n    {\n        drawBufferStr += \"#define MULTI_COLORTARGETS\".endl();\n        drawBufferStr += \"vec4 outColor;\".endl();\n\n        let count = 0;\n        for (let i = 0; i < this._drawBuffers.length; i++)\n        {\n            if (count == 0) drawBufferStr += \"#define gl_FragColor outColor\" + i + \"\".endl();\n            drawBufferStr += \"layout(location = \" + i + \") out vec4 outColor\" + i + \";\".endl();\n            count++;\n        }\n    }\n\n    fs = fs.replace(\"{{DRAWBUFFER}}\", drawBufferStr);\n    // //////\n\n\n    if (!this._program)\n    {\n        this._program = this._createProgram(vs, fs);\n    }\n    else\n    {\n        // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );\n        // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );\n        // linkProgram(program);\n        this._program = this._createProgram(vs, fs);\n\n        this._projMatrixUniform = null;\n\n        for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].resetLoc();\n    }\n\n    this.finalShaderFrag = fs;\n    this.finalShaderVert = vs;\n\n\n    _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__.MESH.lastMesh = null;\n    _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__.MESH.lastShader = null;\n\n    this._countMissingUniforms = 0;\n    this._needsRecompile = false;\n    this.lastCompile = (0,_timer__WEBPACK_IMPORTED_MODULE_1__.now)();\n\n    // this._cgl.printError(\"shader compile\");\n\n    this._cgl.profileData.shaderCompileTime += performance.now() - startTime;\n};\n\nShader.hasChanged = function ()\n{\n    return this._needsRecompile;\n};\n\n\nShader.prototype.bind = function ()\n{\n    if (!this._isValid || this._cgl.aborted) return;\n\n    _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__.MESH.lastShader = this;\n\n    if (!this._program || this._needsRecompile) this.compile();\n    if (!this._isValid) return;\n\n    if (!this._projMatrixUniform && !this.ignoreMissingUniforms)\n    {\n        this._countMissingUniforms++;\n        // if (this._countMissingUniforms == 10)console.log(\"stopping getlocation of missing uniforms...\", this._name);\n        if (this._countMissingUniforms < 10)\n        {\n            this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_PROJMAT);\n            this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION);\n            this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, \"mvMatrix\");\n            this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_VIEWMAT);\n            this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_MODELMAT);\n            this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_VIEWPOS);\n            this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_NORMALMAT);\n            this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_INVVIEWMAT);\n            this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_INVPROJMAT);\n            this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_MATERIALID);\n            this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, _constants__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS.SHADER.SHADERVAR_UNI_OBJECTID);\n\n            for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].needsUpdate = true;\n        }\n    }\n\n\n    if (this._cgl.currentProgram != this._program)\n    {\n        this._cgl.profileData.profileShaderBinds++;\n        this._cgl.gl.useProgram(this._program);\n        this._cgl.currentProgram = this._program;\n    }\n\n    for (let i = 0; i < this._uniforms.length; i++)\n        if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();\n\n    if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount())\n    {\n        this._pMatrixState = this._cgl.getProjectionMatrixStateCount();\n        this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, false, this._cgl.pMatrix);\n        this._cgl.profileData.profileMVPMatrixCount++;\n    }\n\n    if (this._objectIdUniform)\n        this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.frameStore.objectIdCounter);\n\n    if (this._materialIdUniform)\n        this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);\n\n    if (this._vMatrixUniform)\n    {\n        if (this._vMatrixState != this._cgl.getViewMatrixStateCount())\n        {\n            this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, false, this._cgl.vMatrix);\n            this._cgl.profileData.profileMVPMatrixCount++;\n            this._vMatrixState = this._cgl.getViewMatrixStateCount();\n\n            if (this._inverseViewMatrixUniform)\n            {\n                mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);\n                this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, false, this._tempInverseViewMatrix);\n                this._cgl.profileData.profileMVPMatrixCount++;\n            }\n            if (this._inverseProjMatrixUniform)\n            {\n                mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);\n                this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, false, this._tempInverseProjMatrix);\n                this._cgl.profileData.profileMVPMatrixCount++;\n            }\n        }\n        this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, false, this._cgl.mMatrix);\n        this._cgl.profileData.profileMVPMatrixCount++;\n\n        if (this._camPosUniform)\n        {\n            mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix);\n            this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]);\n            this._cgl.profileData.profileMVPMatrixCount++;\n        }\n    }\n    else\n    {\n        // mvmatrix deprecated....\n        const tempmv = mat4.create();\n\n        mat4.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);\n        this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);\n        this._cgl.profileData.profileMVPMatrixCount++;\n    }\n\n    if (this._normalMatrixUniform)\n    {\n        // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);\n        mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix);\n        mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);\n\n        this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, false, this._tempNormalMatrix);\n        this._cgl.profileData.profileMVPMatrixCount++;\n    }\n\n    for (let i = 0; i < this._libs.length; i++)\n    {\n        if (this._libs[i].onBind) this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);\n    }\n\n    this._bindTextures();\n\n    return this._isValid;\n};\n\nShader.prototype.unBind = function ()\n{\n};\n\n/**\n * easily enable/disable a define without a value\n * @function toggleDefine\n * @memberof Shader\n * @instance\n * @param {name} name\n * @param {any} value or port\n */\nShader.prototype.toggleDefine = function (name, enabled)\n{\n    if (enabled && typeof (enabled) == \"object\" && enabled.addEventListener) // port\n    {\n        if (enabled.changeListener)enabled.removeEventListener(enabled.changeListener);\n\n        enabled.onToggleDefine = (v) =>\n        {\n            this.toggleDefine(name, v);\n        };\n\n        enabled.changeListener = enabled.on(\"change\", enabled.onToggleDefine);\n        enabled = enabled.get();\n    }\n\n    if (enabled) this.define(name);\n    else this.removeDefine(name);\n};\n\n/**\n * add a define to a shader, e.g.  #define DO_THIS_THAT 1\n * @function define\n * @memberof Shader\n * @instance\n * @param {String} name\n * @param {Any} value (can be empty)\n */\nShader.prototype.define = function (name, value)\n{\n    if (value === null || value === undefined) value = \"\";\n\n    if (typeof (value) == \"object\") // port\n    {\n        value.removeEventListener(\"change\", value.onDefineChange);\n        value.onDefineChange = (v) =>\n        {\n            this.define(name, v);\n        };\n        value.on(\"change\", value.onDefineChange);\n\n        value = value.get();\n    }\n\n\n    for (let i = 0; i < this._defines.length; i++)\n    {\n        if (this._defines[i][0] == name && this._defines[i][1] == value) return;\n        if (this._defines[i][0] == name)\n        {\n            this._defines[i][1] = value;\n            this.setWhyCompile(\"define \" + name + \" \" + value);\n\n            this._needsRecompile = true;\n            return;\n        }\n    }\n    this.setWhyCompile(\"define \" + name + \" \" + value);\n    this._needsRecompile = true;\n    this._defines.push([name, value]);\n};\n\nShader.prototype.getDefines = function ()\n{\n    return this._defines;\n};\n\nShader.prototype.getDefine = function (name)\n{\n    for (let i = 0; i < this._defines.length; i++)\n        if (this._defines[i][0] == name) return this._defines[i][1];\n    return null;\n};\n\n/**\n * return true if shader has define\n * @function hasDefine\n * @memberof Shader\n * @instance\n * @param {String} name\n * @return {Boolean}\n */\nShader.prototype.hasDefine = function (name)\n{\n    for (let i = 0; i < this._defines.length; i++)\n        if (this._defines[i][0] == name) return true;\n};\n\n/**\n * remove a define from a shader\n * @param {name} name\n * @function removeDefine\n * @memberof Shader\n * @instance\n */\nShader.prototype.removeDefine = function (name)\n{\n    for (let i = 0; i < this._defines.length; i++)\n    {\n        if (this._defines[i][0] == name)\n        {\n            this._defines.splice(i, 1);\n            this._needsRecompile = true;\n\n            this.setWhyCompile(\"define removed:\" + name);\n\n            return;\n        }\n    }\n};\n\n/**\n * remove a module from shader\n * @function removeModule\n * @memberof Shader\n * @instance\n * @param {shaderModule} module the module to be removed\n */\nShader.prototype.removeModule = function (mod)\n{\n    for (let i = 0; i < this._modules.length; i++)\n    {\n        if (mod && mod.id)\n        {\n            if (this._modules[i].id == mod.id || !this._modules[i])\n            {\n                let found = true;\n                while (found)\n                {\n                    found = false;\n                    for (let j = 0; j < this._uniforms.length; j++)\n                    {\n                        if (this._uniforms[j].getName().indexOf(mod.prefix) == 0)\n                        {\n                            this._uniforms.splice(j, 1);\n                            found = true;\n                            continue;\n                        }\n                    }\n                }\n\n                this._needsRecompile = true;\n                this.setWhyCompile(\"remove module \" + mod.title);\n                this._modules.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\n\nShader.prototype.getNumModules = function ()\n{\n    return this._modules.length;\n};\n\n\nShader.prototype.getCurrentModules = function () { return this._modules; };\n\n\n/**\n * add a module\n * @function addModule\n * @memberof Shader\n * @instance\n * @param {shaderModule} module the module to be added\n * @param {shaderModule} [sibling] sibling module, new module will share the same group\n */\nShader.prototype.addModule = function (mod, sibling)\n{\n    if (this.hasModule(mod.id)) return;\n    if (!mod.id) mod.id = CABLES.simpleId();\n    if (!mod.numId) mod.numId = this._moduleNumId;\n    if (!mod.num)mod.num = this._modules.length;\n    if (sibling && !sibling.group) sibling.group = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.simpleId)();\n\n    if (!mod.group)\n        if (sibling) mod.group = sibling.group;\n        else mod.group = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.simpleId)();\n\n    mod.prefix = \"mod\" + mod.group + \"_\";\n    this._modules.push(mod);\n\n    this._needsRecompile = true;\n    this.setWhyCompile(\"add module \" + mod.title);\n    this._moduleNumId++;\n\n    return mod;\n};\n\nShader.prototype.hasModule = function (modId)\n{\n    for (let i = 0; i < this._modules.length; i++)\n    {\n        if (this._modules[i].id == modId) return true;\n    }\n    return false;\n};\n\nShader.prototype.setModules = function (names)\n{\n    this._moduleNames = names;\n};\n\nShader.prototype.dispose = function ()\n{\n    this._cgl.gl.deleteProgram(this._program);\n};\n\nShader.prototype.needsRecompile = function ()\n{\n    return this._needsRecompile;\n};\n\nShader.prototype.setDrawBuffers = function (arr)\n{\n    console.log(\"useless drawbuffers...?!\");\n    // if (this._drawBuffers.length !== arr.length)\n    // {\n    //     this._drawBuffers = arr;\n    //     this._needsRecompile = true;\n    //     this.setWhyCompile(\"setDrawBuffers\");\n    //     return;\n    // }\n    // for (let i = 0; i < arr.length; i++)\n    // {\n    //     if (arr[i] !== this._drawBuffers[i])\n    //     {\n    //         this._drawBuffers = arr;\n    //         this._needsRecompile = true;\n    //         this.setWhyCompile(\"setDrawBuffers\");\n    //         return;\n    //     }\n    // }\n};\n\nShader.prototype.getUniforms = function ()\n{\n    return this._uniforms;\n};\n\nShader.prototype.getUniform = function (name)\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n        if (this._uniforms[i].getName() == name)\n            return this._uniforms[i];\n    return null;\n};\n\nShader.prototype.removeAllUniforms = function ()\n{\n    this._uniforms = [];\n    // for (let i = 0; i < this._uniforms.length; i++)\n    //     this.removeUniform(this._uniforms[i].name);\n};\n\nShader.prototype.removeUniform = function (name)\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].getName() == name)\n        {\n            this._uniforms.splice(i, 1);\n        }\n    }\n    this._needsRecompile = true;\n    this.setWhyCompile(\"remove uniform \" + name);\n};\n\n\nShader.prototype._addUniform = function (uni)\n{\n    this._uniforms.push(uni);\n    this.setWhyCompile(\"add uniform \" + name);\n    this._needsRecompile = true;\n};\n\n/**\n * add a uniform to the fragment shader\n * @param {String} type ['f','t', etc]\n * @param {String} name\n * @param {any} value or port\n * @memberof Shader\n * @instance\n * @function addUniformFrag\n * @returns {CGL.Uniform}\n */\nShader.prototype.addUniformFrag = function (type, name, valueOrPort, p2, p3, p4)\n{\n    const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);\n    uni.shaderType = \"frag\";\n    return uni;\n};\n\n/**\n * add a uniform to the vertex shader\n * @param {String} type ['f','t', etc]\n * @param {String} name\n * @param {any} value or port\n * @memberof Shader\n * @instance\n * @function addUniformVert\n * @returns {CGL.Uniform}\n */\nShader.prototype.addUniformVert = function (type, name, valueOrPort, p2, p3, p4)\n{\n    const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);\n    uni.shaderType = \"vert\";\n    return uni;\n};\n/**\n * add a uniform to both shaders\n * @param {String} type ['f','t', etc]\n * @param {String} name\n * @param {any} value or port\n * @memberof Shader\n * @instance\n * @function addUniformBoth\n * @returns {CGL.Uniform}\n */\nShader.prototype.addUniformBoth = function (type, name, valueOrPort, p2, p3, p4)\n{\n    const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);\n    uni.shaderType = \"both\";\n    return uni;\n};\n\n/**\n * add a struct & its uniforms to the fragment shader\n * @param {String} structName name of the struct, i.e.: LightStruct\n * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni\n * @param {Array} members array of objects containing the struct members. see example for structure\n\n * @memberof Shader\n * @instance\n * @function addUniformStructFrag\n * @returns {Object}\n * @example\n * const shader = new CGL.Shader(cgl, 'MinimalMaterial');\n * shader.setSource(attachments.shader_vert, attachments.shader_frag);\n * shader.addUniformStructFrag(\"Light\", \"uniformLight\", [\n * { \"type\": \"3f\", \"name\": \"position\", \"v1\": null },\n * { \"type\": \"4f\", \"name\": \"color\", \"v1\": inR, v2: inG, v3: inB, v4: inAlpha }\n * ]);\n */\nShader.prototype.addUniformStructFrag = function (structName, uniformName, members)\n{\n    const uniforms = {};\n\n    if (!members) return uniforms;\n\n    for (let i = 0; i < members.length; i += 1)\n    {\n        const member = members[i];\n        if (!this.hasUniform(uniformName + \".\" + member.name))\n        {\n            const uni = new CGL.Uniform(this, member.type, uniformName + \".\" + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);\n            uni.shaderType = \"frag\";\n            uniforms[uniformName + \".\" + member.name] = uni;\n        }\n    }\n\n    return uniforms;\n};\n\n/**\n * add a struct & its uniforms to the vertex shader\n * @param {String} structName name of the struct, i.e.: LightStruct\n * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni\n * @param {Array} members array of objects containing the struct members. see example for structure\n\n * @memberof Shader\n * @instance\n * @function addUniformStructVert\n * @returns {CGL.Uniform}\n * @example\n * const shader = new CGL.Shader(cgl, 'MinimalMaterial');\n * shader.setSource(attachments.shader_vert, attachments.shader_frag);\n * shader.addUniformStructVert(\"Light\", \"uniformLight\", [\n * { \"type\": \"3f\", \"name\": \"position\", \"v1\": null },\n * { \"type\": \"4f\", \"name\": \"color\", \"v1\": inR, v2: inG, v3: inB, v4: inAlpha }\n * ]);\n */\nShader.prototype.addUniformStructVert = function (structName, uniformName, members)\n{\n    const uniforms = {};\n\n    if (!members) return uniforms;\n\n    for (let i = 0; i < members.length; i += 1)\n    {\n        const member = members[i];\n        if (!this.hasUniform(uniformName + \".\" + member.name))\n        {\n            const uni = new CGL.Uniform(this, member.type, uniformName + \".\" + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);\n            uni.shaderType = \"vert\";\n            uniforms[uniformName + \".\" + member.name] = uni;\n        }\n    }\n\n    return uniforms;\n};\n\n/**\n * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.\n * @param {String} structName name of the struct, i.e.: LightStruct\n * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni\n * @param {Array} members array of objects containing the struct members. see example for structure\n\n * @memberof Shader\n * @instance\n * @function addUniformStructBoth\n * @returns {Object}\n * @example\n * const shader = new CGL.Shader(cgl, 'MinimalMaterial');\n * shader.setSource(attachments.shader_vert, attachments.shader_frag);\n * shader.addUniformStructBoth(\"Light\", \"uniformLight\", [\n * { \"type\": \"3f\", \"name\": \"position\", \"v1\": null },\n * { \"type\": \"4f\", \"name\": \"color\", \"v1\": inR, v2: inG, v3: inB, v4: inAlpha }\n * ]);\n */\nShader.prototype.addUniformStructBoth = function (structName, uniformName, members)\n{\n    const uniforms = {};\n\n    if (!members) return uniforms;\n\n    for (let i = 0; i < members.length; i += 1)\n    {\n        const member = members[i];\n        if ((member.type === \"2i\" || member.type === \"i\" || member.type === \"3i\"))\n            this._log.error(\"Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:\", structName, \" with member:\", member.name, \" of type:\", member.type, \".\");\n        if (!this.hasUniform(uniformName + \".\" + member.name))\n        {\n            const uni = new CGL.Uniform(this, member.type, uniformName + \".\" + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);\n            uni.shaderType = \"both\";\n            uniforms[uniformName + \".\" + member.name] = uni;\n        }\n    }\n\n    return uniforms;\n};\n\nShader.prototype.hasUniform = function (name)\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].getName() == name) return true;\n    }\n    return false;\n};\n\nShader.prototype._createProgram = function (vstr, fstr)\n{\n    this._cgl.printError(\"before _createprogram\");\n\n    const program = this._cgl.gl.createProgram();\n\n    this.vshader = Shader.createShader(this._cgl, vstr, this._cgl.gl.VERTEX_SHADER, this);\n    this.fshader = Shader.createShader(this._cgl, fstr, this._cgl.gl.FRAGMENT_SHADER, this);\n\n\n    if (this.vshader && this.fshader)\n    {\n        this._cgl.gl.attachShader(program, this.vshader);\n        this._cgl.gl.attachShader(program, this.fshader);\n\n        this._linkProgram(program, vstr, fstr);\n    }\n    else\n    {\n        this._isValid = false;\n        this._cgl.printError(\"shader _createProgram\");\n        console.log(\"could not link shaderprogram\");\n        return null;\n    }\n\n    this._cgl.printError(\"shader _createProgram\");\n    return program;\n};\n\nShader.prototype.hasErrors = function ()\n{\n    return this._hasErrors;\n};\n\nShader.prototype._linkProgram = function (program, vstr, fstr)\n{\n    this._cgl.printError(\"before _linkprogram\");\n\n    if (this._feedBackNames.length > 0)\n    {\n        this._cgl.gl.transformFeedbackVaryings(program, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS);\n        // INTERLEAVED_ATTRIBS\n        // SEPARATE_ATTRIBS\n    }\n\n    this._cgl.gl.linkProgram(program);\n    this._cgl.printError(\"gl.linkprogram\");\n    this._isValid = true;\n\n    this._hasErrors = false;\n\n    if (this._cgl.patch.config.glValidateShader !== false)\n    {\n        this._cgl.gl.validateProgram(program);\n\n        if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS))\n        {\n            // validation failed\n            console.log(\"shaderprogram validation failed...\");\n            console.log(this._name + \" programinfo: \", this._cgl.gl.getProgramInfoLog(program));\n        }\n\n        if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS))\n        {\n            this._hasErrors = true;\n            this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader) || \"empty shader infolog\");\n            this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader) || \"empty shader infolog\");\n            this._log.error(this._name + \" shader linking fail...\");\n\n            // console.log(\"srcFrag\", fstr);\n            // console.log(\"srcVert\", vstr);\n            console.log(this._name + \" programinfo: \", this._cgl.gl.getProgramInfoLog(program));\n\n            console.log(\"--------------------------------------\");\n            console.log(this);\n            console.log(\"--------------------------------------\");\n            this._isValid = false;\n\n            this._name = \"errorshader\";\n            this.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());\n            this._cgl.printError(\"shader link err\");\n        }\n    }\n};\n\nShader.prototype.getProgram = function ()\n{\n    return this._program;\n};\n\nShader.prototype.setFeedbackNames = function (names)\n{\n    this.setWhyCompile(\"setFeedbackNames\");\n    this._needsRecompile = true;\n    this._feedBackNames = names;\n};\n\nShader.prototype.getDefaultVertexShader = Shader.getDefaultVertexShader = function ()\n{\n    return _cgl_shader_default_glsl_vert__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n};\n\nShader.prototype.getDefaultFragmentShader = Shader.getDefaultFragmentShader = function (r, g, b)\n{\n    if (r == undefined)\n    {\n        r = 0.5;\n        g = 0.5;\n        b = 0.5;\n    }\n    return \"\"\n        .endl() + \"IN vec2 texCoord;\"\n        .endl() + \"{{MODULES_HEAD}}\"\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"    vec4 col=vec4(\" + r + \",\" + g + \",\" + b + \",1.0);\"\n        .endl() + \"    {{MODULE_COLOR}}\"\n        .endl() + \"    outColor = col;\"\n        .endl() + \"}\";\n};\n\n/**\n  * adds attribute definition to shader header without colliding with other shader modules...\n * when attrFrag is defined, vertex shader will output this attribute to the fragment shader\n * @function\n * @memberof Shader\n * @instance\n * @param {Object} attribObject {type:x,name:x,[nameFrag:x]}\n * @return {Object}\n */\nShader.prototype.addAttribute = function (attr)\n{\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag) return;\n    }\n    this._attributes.push(attr);\n    this._needsRecompile = true;\n    this.setWhyCompile(\"addAttribute\");\n};\n\nShader.prototype.bindTextures =\nShader.prototype._bindTextures = function ()\n{\n    if (this._textureStackTex.length > this._cgl.maxTextureUnits)\n    {\n        this._log.warn(\"[shader._bindTextures] too many textures bound\", this._textureStackTex.length + \"/\" + this._cgl.maxTextureUnits);\n    }\n\n    // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);\n\n    for (let i = 0; i < this._textureStackTex.length; i++)\n    {\n        // console.log(this._textureStackTex.length, i);\n        if (!this._textureStackTex[i] && !this._textureStackTexCgl[i])\n        {\n            this._log.warn(\"no texture for pushtexture\", this._name);\n        }\n        else\n        {\n            let t = this._textureStackTex[i];\n            if (this._textureStackTexCgl[i])\n            {\n                t = this._textureStackTexCgl[i].tex || CGL.Texture.getEmptyTexture(this._cgl).tex;\n            }\n\n            let bindOk = true;\n\n            if (!this._textureStackUni[i])\n            {\n                // throw(new Error('no uniform given to texturestack'));\n                this._log.warn(\"no uniform for pushtexture\", this._name);\n                bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);\n            }\n            else\n            {\n                this._textureStackUni[i].setValue(i);\n                bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);\n\n                // console.log(bindOk, i, t, this._textureStackType[i]);\n            }\n            if (!bindOk) console.warn(\"tex bind failed\", this.getName(), this._textureStackUni[i]);\n        }\n    }\n};\n\nShader.prototype.setUniformTexture = function (uni, tex)\n{\n    tex = tex || CGL.Texture.getTempTexture(this._cgl);\n    for (let i = 0; i < this._textureStackUni.length; i++)\n        if (this._textureStackUni[i] == uni)\n        {\n            const old = this._textureStackTex[i] || this._textureStackTexCgl[i];\n            if (tex.hasOwnProperty(\"tex\"))\n            {\n                this._textureStackTexCgl[i] = tex;\n                this._textureStackTex[i] = null;\n            }\n            else\n            {\n                this._textureStackTexCgl[i] = null;\n                this._textureStackTex[i] = tex;\n            }\n\n            // this._textureStackTex[i] = tex;\n            // this._cgl.setTexture(i, tex, this._textureStackType[i]);\n            return old;\n        }\n    return null;\n};\n\n/**\n * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set\n * @param {uniform} texture uniform\n * @param {texture} texture\n * @param {type} texture type, can be ignored when TEXTURE_2D\n * @function pushTexture\n * @memberof Shader\n * @instance\n */\nShader.prototype.pushTexture = function (uniform, t, type)\n{\n    if (!uniform)\n    {\n        console.log(\"no uniform given to texturestack\", uniform);\n        return;\n    }\n    if (!t)\n    {\n        return;\n    }\n    if (!t.hasOwnProperty(\"tex\") && !(t instanceof WebGLTexture))\n    {\n        this._log.warn(new Error(\"invalid texture\").stack);\n\n        this._log.warn(\"[cgl_shader] invalid texture...\", t);\n        return;\n    }\n\n    this._textureStackUni.push(uniform);\n\n    if (t.hasOwnProperty(\"tex\"))\n    {\n        this._textureStackTexCgl.push(t);\n        this._textureStackTex.push(null);\n    }\n    else\n    {\n        this._textureStackTexCgl.push(null);\n        this._textureStackTex.push(t);\n    }\n\n    this._textureStackType.push(type);\n};\n\n/**\n * pop last texture\n * @function popTexture\n * @memberof Shader\n * @instance\n */\nShader.prototype.popTexture = function ()\n{\n    this._textureStackUni.pop();\n    this._textureStackTex.pop();\n    this._textureStackTexCgl.pop();\n    this._textureStackType.pop();\n};\n\n/**\n * pop all textures\n * @function popTextures\n * @memberof Shader\n * @instance\n */\nShader.prototype.popTextures = function ()\n{\n    this._textureStackTex.length =\n    this._textureStackTexCgl.length =\n    this._textureStackType.length =\n    this._textureStackUni.length = 0;\n};\n\nShader.prototype.getMaterialId = function ()\n{\n    return this._materialId;\n};\n\nShader.prototype.getInfo = function ()\n{\n    const info = {};\n    info.name = this._name;\n    // info.modules = JSON.parse(JSON.stringify(this._modules));\n    // info.defines = JSON.parse(JSON.stringify(this._defines));\n    info.defines = this.getDefines();\n    info.hasErrors = this.hasErrors();\n\n    return info;\n};\n\n// --------------------------\n\nShader.getErrorFragmentShader = function ()\n{\n    return \"\"\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;\"\n        .endl() + \"   g= step(0.1,g);\"\n        .endl() + \"   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);\"\n        .endl() + \"}\";\n};\n\nShader.createShader = function (cgl, str, type, cglShader)\n{\n    if (cgl.aborted) return;\n\n    // cgl.printError(\"[Shader.createShader] \", cglShader._name);\n\n    function getBadLines(infoLog)\n    {\n        const basLines = [];\n        const lines = infoLog.split(\"\\n\");\n        for (const i in lines)\n        {\n            const divide = lines[i].split(\":\");\n            if (parseInt(divide[2], 10)) basLines.push(parseInt(divide[2], 10));\n        }\n        return basLines;\n    }\n\n\n    const shader = cgl.gl.createShader(type);\n    cgl.gl.shaderSource(shader, str);\n    cgl.gl.compileShader(shader);\n\n    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS))\n    {\n        let infoLog = cgl.gl.getShaderInfoLog(shader);\n        if (!infoLog)\n        {\n            console.warn(\"empty shader info log\", this._name);\n            return;\n        }\n\n        console.log(\"compile status: \");\n\n        const badLines = getBadLines(infoLog);\n        let htmlWarning = \"<pre style=\\\"margin-bottom:0px;\\\"><code class=\\\"shaderErrorCode language-glsl\\\" style=\\\"padding-bottom:0px;max-height: initial;max-width: initial;\\\">\";\n        const lines = str.match(/^.*((\\r\\n|\\n|\\r)|$)/gm);\n\n        if (!cgl.aborted && infoLog)\n        {\n            if (type == cgl.gl.VERTEX_SHADER) console.log(\"VERTEX_SHADER\");\n            if (type == cgl.gl.FRAGMENT_SHADER) console.log(\"FRAGMENT_SHADER\");\n\n            for (const i in lines)\n            {\n                const j = parseInt(i, 10) + 1;\n                const line = j + \": \" + lines[i];\n                console.log(line);\n\n                let isBadLine = false;\n                for (const bj in badLines)\n                    if (badLines[bj] == j) isBadLine = true;\n\n                if (isBadLine)\n                {\n                    htmlWarning += \"</code></pre>\";\n                    // htmlWarning += \"<span class=\\\"shaderErrorCode error\\\">\";\n                    htmlWarning += \"<pre style=\\\"margin:0\\\"><code class=\\\"language-glsl\\\" style=\\\"background-color:#660000;padding-top:0px;padding-bottom:0px\\\">\";\n                }\n                htmlWarning += (0,_cgl_utils__WEBPACK_IMPORTED_MODULE_5__.escapeHTML)(line);\n\n                if (isBadLine)\n                {\n                    htmlWarning += \"</code></pre>\";\n                    htmlWarning += \"<pre style=\\\"margin:0\\\"><code class=\\\"language-glsl\\\" style=\\\";padding-top:0px;padding-bottom:0px\\\">\";\n                }\n            }\n        }\n\n        console.warn(infoLog);\n\n        infoLog = infoLog.replace(/\\n/g, \"<br/>\");\n        if (cgl.patch.isEditorMode())console.log(\"Shader error \", cglShader._name, infoLog, this);\n\n        htmlWarning = infoLog + \"<br/>\" + htmlWarning + \"<br/><br/>\";\n        htmlWarning += \"</code></pre>\";\n\n        cgl.patch.emitEvent(\"criticalError\", { \"title\": \"Shader error \" + cglShader._name, \"text\": htmlWarning, \"exception\": { \"message\": infoLog } });\n\n        // this._name = \"errorshader\";\n        cglShader.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());\n    }\n    else\n    {\n        // console.log(name+' shader compiled...');\n    }\n    // cgl.printError(\"shader create2\");\n    return shader;\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9zaGFkZXIuanM/ZWM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGFkZXJMaWJNb2RzIH0gZnJvbSBcIi4vY2dsX3NoYWRlcl9saWJcIjtcbmltcG9ydCB7IG5vdyB9IGZyb20gXCIuLi90aW1lclwiO1xuaW1wb3J0IHsgc2ltcGxlSWQgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB7IE1FU0ggfSBmcm9tIFwiLi9jZ2xfbWVzaFwiO1xuLy8gaW1wb3J0IHsgQ0dMIH0gZnJvbSBcIi4vaW5kZXhcIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZXNjYXBlSFRNTCB9IGZyb20gXCIuL2NnbF91dGlsc1wiO1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vY29yZV9sb2dnZXJcIjtcbmltcG9ydCBkZWZhdWx0U2hhZGVyU3JjVmVydCBmcm9tIFwiLi9jZ2xfc2hhZGVyX2RlZmF1bHRfZ2xzbC52ZXJ0XCI7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vKlxuXG5wcm9wb3NhbCBkZWZhdWx0IHNoYWRlciB2YXJpYWJsZSBuYW1lczpcblxuYXR0clZlcnRleCAtIGN1cnJlbnRseTogdlBvc2l0aW9uXG5hdHRyVmVydGV4SW5kZXggLSBjdXJyZW50bHk6IGF0dHJWZXJ0SW5kZXhcbmF0dHJUZXhDb29yZFxuYXR0ckluc3RNYXQgLSBjdXJyZW50bHk6IGluc3RNYXRcbmF0dHJWZXJ0Q29sb3JcbmF0dHJUYW5nZW50XG5hdHRyQmlUYW5nZW50XG5cbnVQcm9qTWF0cml4IC0gY3VycmVudGx5OiBwcm9qTWF0cml4XG51TW9kZWxNYXRyaXggLSBjdXJyZW50bHk6IG1vZGVsTWF0cml4XG51Tm9ybWFsTWF0cml4IC0gY3VycmVudGx5OiBub3JtYWxNYXRyaXhcbnVDYW1Qb3NpdGlvbiAtIGN1cnJlbnRseTogY2FtUG9zXG5cbiovXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBtYXRlcmlhbElkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZXJuYWwgQ0dMXG4gKiBAbmFtZXNwYWNlIFNoYWRlclxuICogQGhpZGVjb25zdHJ1Y3RvclxuICogQGV4YW1wbGVcbiAqIHZhciBzaGFkZXI9bmV3IENHTC5TaGFkZXIoY2dsLCdNaW5pbWFsTWF0ZXJpYWwnKTtcbiAqIHNoYWRlci5zZXRTb3VyY2UoYXR0YWNobWVudHMuc2hhZGVyX3ZlcnQsYXR0YWNobWVudHMuc2hhZGVyX2ZyYWcpO1xuICovXG5jb25zdCBTaGFkZXIgPSBmdW5jdGlvbiAoX2NnbCwgX25hbWUsIF9vcClcbntcbiAgICBpZiAoIV9jZ2wpIHRocm93IG5ldyBFcnJvcihcInNoYWRlciBjb25zdHJ1Y3RlZCB3aXRob3V0IGNnbCBcIiArIF9uYW1lKTtcblxuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ2xfc2hhZGVyXCIpO1xuICAgIHRoaXMuX2NnbCA9IF9jZ2w7XG5cbiAgICBpZiAoIV9uYW1lKSB0aGlzLl9sb2cuc3RhY2soXCJubyBzaGFkZXIgbmFtZSBnaXZlblwiKTtcbiAgICB0aGlzLl9uYW1lID0gX25hbWUgfHwgXCJ1bmtub3duXCI7XG5cbiAgICBpZiAoX29wKSB0aGlzLm9wSWQgPSBfb3AuaWQ7XG4gICAgdGhpcy5nbHNsVmVyc2lvbiA9IDA7XG4gICAgaWYgKF9jZ2wuZ2xWZXJzaW9uID4gMSkgdGhpcy5nbHNsVmVyc2lvbiA9IDMwMDtcblxuICAgIHRoaXMuX21hdGVyaWFsSWQgPSArK21hdGVyaWFsSWRDb3VudGVyO1xuXG4gICAgdGhpcy5pZCA9IHNpbXBsZUlkKCk7XG4gICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5fdW5pZm9ybXMgPSBbXTtcbiAgICB0aGlzLl9kcmF3QnVmZmVycyA9IFt0cnVlXTtcbiAgICB0aGlzLl9kZWZpbmVzID0gW107XG4gICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXBpbGVSZWFzb24gPSBcImluaXRpYWxcIjtcblxuICAgIHRoaXMuaWdub3JlTWlzc2luZ1VuaWZvcm1zID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvak1hdHJpeFVuaWZvcm0gPSBudWxsO1xuICAgIHRoaXMuX212TWF0cml4VW5pZm9ybSA9IG51bGw7XG4gICAgdGhpcy5fbU1hdHJpeFVuaWZvcm0gPSBudWxsO1xuICAgIHRoaXMuX3ZNYXRyaXhVbmlmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9jYW1Qb3NVbmlmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9ub3JtYWxNYXRyaXhVbmlmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9pbnZlcnNlVmlld01hdHJpeFVuaWZvcm0gPSBudWxsO1xuXG4gICAgdGhpcy5fYXR0clZlcnRleFBvcyA9IC0xO1xuICAgIHRoaXMucHJlY2lzaW9uID0gX2NnbC5wYXRjaC5jb25maWcuZ2xzbFByZWNpc2lvbiB8fCBcImhpZ2hwXCI7XG5cbiAgICB0aGlzLl9wTWF0cml4U3RhdGUgPSAtMTtcbiAgICB0aGlzLl92TWF0cml4U3RhdGUgPSAtMTtcblxuICAgIHRoaXMuX2NvdW50TWlzc2luZ1VuaWZvcm1zID0gMDtcbiAgICB0aGlzLl9tb2RHcm91cENvdW50ID0gMDsgLy8gbm90IG5lZWRlZCBhbnltb3JlLi4uXG4gICAgdGhpcy5fZmVlZEJhY2tOYW1lcyA9IFtdO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBbXTtcblxuICAgIHRoaXMuZ2xQcmltaXRpdmUgPSBudWxsO1xuICAgIHRoaXMub2ZmU2NyZWVuUGFzcyA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBbXTtcbiAgICB0aGlzLnNyY1ZlcnQgPSB0aGlzLmdldERlZmF1bHRWZXJ0ZXhTaGFkZXIoKTtcbiAgICB0aGlzLnNyY0ZyYWcgPSB0aGlzLmdldERlZmF1bHRGcmFnbWVudFNoYWRlcigpO1xuICAgIHRoaXMubGFzdENvbXBpbGUgPSAwO1xuXG4gICAgdGhpcy5fbW9kdWxlTmFtZXMgPSBbXTtcbiAgICB0aGlzLl9tb2R1bGVzID0gW107XG4gICAgdGhpcy5fbW9kdWxlTnVtSWQgPSAwO1xuXG4gICAgdGhpcy5fbGlicyA9IFtdO1xuICAgIHRoaXMuX3N0cnVjdE5hbWVzID0gW107XG4gICAgdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzID0gW107XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVW5pID0gW107XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4ID0gW107XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVHlwZSA9IFtdO1xuICAgIHRoaXMuX3RleHR1cmVTdGFja1RleENnbCA9IFtdO1xuXG4gICAgdGhpcy5fdGVtcE5vcm1hbE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgdGhpcy5fdGVtcENhbVBvc01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgdGhpcy5fdGVtcEludmVyc2VWaWV3TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICB0aGlzLl90ZW1wSW52ZXJzZVByb2pNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzKFtcIk1PRFVMRV9WRVJURVhfUE9TSVRJT05cIiwgXCJNT0RVTEVfQ09MT1JcIiwgXCJNT0RVTEVfQkVHSU5fRlJBR1wiXSk7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXRDZ2wgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9jZ2w7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xufTtcblxuLyoqXG4gKiBlbmFibGUgYW4gZXh0ZW5zaW9uIGZvciB0aGUgc2hhZGVyXG4gKiBAZnVuY3Rpb24gZW5hYmxlRXh0ZW5zaW9uXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIGV4dGVuc2lvbiBuYW1lXG4gKi9cblNoYWRlci5wcm90b3R5cGUuZW5hYmxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgdGhpcy5zZXRXaHlDb21waWxlKFwiZW5hYmxlIGV4dGVuc2lvbiBcIiArIG5hbWUpO1xuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLl9leHRlbnNpb25zLnB1c2gobmFtZSk7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldEF0dHJWZXJ0ZXhQb3MgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9hdHRyVmVydGV4UG9zO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5oYXNUZXh0dXJlVW5pZm9ybXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRUeXBlKCkgPT0gXCJ0XCIpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuc2V0V2h5Q29tcGlsZSA9IGZ1bmN0aW9uICh3aHkpXG57XG4gICAgdGhpcy5fY29tcGlsZVJlYXNvbiA9IHdoeTtcbn07XG5cbi8qKlxuICogY29weSBhbGwgdW5pZm9ybSB2YWx1ZXMgZnJvbSBhbm90aGVyIHNoYWRlclxuICogQGZ1bmN0aW9uIGNvcHlVbmlmb3Jtc1xuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0gc2hhZGVyIHVuaWZvcm0gdmFsdWVzIHdpbGwgYmUgY29waWVkIGZyb20gdGhpcyBzaGFkZXJcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5jb3B5VW5pZm9ybVZhbHVlcyA9IGZ1bmN0aW9uIChvcmlnU2hhZGVyKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKG9yaWdTaGFkZXIuX3VuaWZvcm1zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdTaGFkZXIuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl91bmlmb3Jtc1tpXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmxvZyhcInVua25vd24gdW5pZm9ybT8hXCIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLl9sb2cubG9nKG9yaWdTaGFkZXIuX3VuaWZvcm1zW2ldLmdldE5hbWUoKSk7XG4gICAgICAgIC8vIHRoaXMuZ2V0VW5pZm9ybShvcmlnU2hhZGVyLl91bmlmb3Jtc1tpXS4pXG4gICAgICAgIC8vIHRoaXMuX3VuaWZvcm1zW2ldLnNldChvcmlnU2hhZGVyLl91bmlmb3Jtc1tpXS5nZXRWYWx1ZSgpKTtcblxuXG4gICAgICAgIGlmIChvcmlnU2hhZGVyLl91bmlmb3Jtc1tpXS5nZXROYW1lKCkuaW5kZXhPZihcInBhdGhQb2ludHNcIikgIT0gLTEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvcHlVbmlmb3JtVmFsdWVzXCIsIG9yaWdTaGFkZXIuX3VuaWZvcm1zW2ldLmdldE5hbWUoKSwgb3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgdGhpcy5nZXRVbmlmb3JtKG9yaWdTaGFkZXIuX3VuaWZvcm1zW2ldLmdldE5hbWUoKSkuc2V0KG9yaWdTaGFkZXIuX3VuaWZvcm1zW2ldLmdldFZhbHVlKCkpO1xuICAgIH1cblxuICAgIHRoaXMucG9wVGV4dHVyZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdTaGFkZXIuX3RleHR1cmVTdGFja1VuaS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1VuaVtpXSA9IG9yaWdTaGFkZXIuX3RleHR1cmVTdGFja1VuaVtpXTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4W2ldID0gb3JpZ1NoYWRlci5fdGV4dHVyZVN0YWNrVGV4W2ldO1xuICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlW2ldID0gb3JpZ1NoYWRlci5fdGV4dHVyZVN0YWNrVHlwZVtpXTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldID0gb3JpZ1NoYWRlci5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldO1xuICAgIH1cblxuICAgIC8vIHRoaXMuX3RleHR1cmVTdGFja1VuaSA9IFtdO1xuICAgIC8vIHRoaXMuX3RleHR1cmVTdGFja1RleCA9IFtdO1xuICAgIC8vIHRoaXMuX3RleHR1cmVTdGFja1R5cGUgPSBbXTtcbiAgICAvLyB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2wgPSBbXTtcbn07XG5cbi8qKlxuICogY29weSBjdXJyZW50IHNoYWRlclxuICogQGZ1bmN0aW9uIGNvcHlcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybnMgbmV3U2hhZGVyXG4gKi9cblNoYWRlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcih0aGlzLl9jZ2wsIHRoaXMuX25hbWUgKyBcIiBjb3B5XCIpO1xuICAgIHNoYWRlci5zZXRTb3VyY2UodGhpcy5zcmNWZXJ0LCB0aGlzLnNyY0ZyYWcpO1xuXG4gICAgc2hhZGVyLl9tb2R1bGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLl9tb2R1bGVzKSk7XG4gICAgc2hhZGVyLl9kZWZpbmVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLl9kZWZpbmVzKSk7XG5cbiAgICBzaGFkZXIuX21vZEdyb3VwQ291bnQgPSB0aGlzLl9tb2RHcm91cENvdW50O1xuICAgIHNoYWRlci5fbW9kdWxlTmFtZXMgPSB0aGlzLl9tb2R1bGVOYW1lcztcbiAgICBzaGFkZXIuZ2xQcmltaXRpdmUgPSB0aGlzLmdsUHJpbWl0aXZlO1xuICAgIHNoYWRlci5vZmZTY3JlZW5QYXNzID0gdGhpcy5vZmZTY3JlZW5QYXNzO1xuICAgIHNoYWRlci5fZXh0ZW5zaW9ucyA9IHRoaXMuX2V4dGVuc2lvbnM7XG4gICAgc2hhZGVyLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICAgIHNoYWRlci5fYXR0cmlidXRlcyA9IHRoaXMuX2F0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgY29uc3QgdSA9IHRoaXMuX3VuaWZvcm1zW2ldLmNvcHkoc2hhZGVyKTtcbiAgICAgICAgdS5yZXNldExvYygpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImNvcHlcIik7XG4gICAgc2hhZGVyLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cblxuLyoqXG4gKiBzZXQgc2hhZGVyIHNvdXJjZSBjb2RlXG4gKiBAZnVuY3Rpb24gc2V0U291cmNlXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmNWZXJ0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjRnJhZ1xuICovXG5TaGFkZXIucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uIChzcmNWZXJ0LCBzcmNGcmFnKVxue1xuICAgIHRoaXMuc3JjVmVydCA9IHNyY1ZlcnQ7XG4gICAgdGhpcy5zcmNGcmFnID0gc3JjRnJhZztcbiAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJTb3VyY2UgY2hhbmdlZFwiKTtcbiAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLl9hZGRMaWJzID0gZnVuY3Rpb24gKHNyYylcbntcbiAgICBmb3IgKGNvbnN0IGlkIGluIFNoYWRlckxpYk1vZHMpXG4gICAge1xuICAgICAgICBpZiAoc3JjLmluZGV4T2YoaWQpID4gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxpYiA9IG5ldyBTaGFkZXJMaWJNb2RzW2lkXSgpO1xuICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoXCJ7e1wiICsgaWQgKyBcIn19XCIsIGxpYi5zcmNIZWFkRnJhZyk7XG4gICAgICAgICAgICB0aGlzLl9saWJzLnB1c2gobGliKTtcbiAgICAgICAgICAgIGlmIChsaWIuaW5pdFVuaWZvcm1zKWxpYi5pbml0VW5pZm9ybXModGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3JjO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJ1Y3RVbmlmb3JtcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gKiBjcmVhdGUgc3RydWN0c1xuICAgIGxldCBzdHJ1Y3RTdHJGcmFnID0gXCJcIjtcbiAgICBsZXQgc3RydWN0U3RyVmVydCA9IFwiXCI7IC8vIFRPRE86IG5vdCB1c2VkIHlldFxuXG4gICAgdGhpcy5fc3RydWN0TmFtZXMgPSBbXTtcbiAgICAvLyAqIHJlc2V0IHRoZSBhcnJheXMgaG9sZGluZyB0aGUgdmFsdWUgZWFjaCByZWNvbXBpbGUgc28gd2UgZG9uJ3Qgc2tpcCBzdHJ1Y3RzXG4gICAgLy8gKiBrZXkgdmFsdWUgbWFwcGluZyBzbyB0aGUgc2FtZSBzdHJ1Y3QgY2FuIGJlIGFkZGVkIHR3aWNlICh0d28gdGltZXMgdGhlIHNhbWUgbW9kaWZpZXIpXG4gICAgdGhpcy5faW5qZWN0ZWRTdHJpbmdzRnJhZyA9IHt9O1xuICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc1ZlcnQgPSB7fTtcblxuICAgIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNGcmFnID0gW107XG4gICAgdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc1ZlcnQgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICAvLyAqIG9ubHkgYWRkIHVuaWZvcm1zIHRvIHN0cnVjdCB0aGF0IGFyZSBhIG1lbWJlciBvZiBhIHN0cnVjdFxuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uaXNTdHJ1Y3RNZW1iZXIoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0aW9uU3RyaW5nID0gXCJ7e0lOSkVDVElPTl9QT0lOVF9TVFJVQ1RfXCIgKyB0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZSArIFwifX1cIjtcblxuICAgICAgICAgICAgLy8gKiBjaGVjayBpZiBzdHJ1Y3QgaXMgbm90IGFscmVhZHkgcGFydCBvZiBzaGFkZXJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJ1Y3ROYW1lcy5pbmRleE9mKHRoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gKiBjcmVhdGUgc3RydWN0IGRlZmluaXRpb24gd2l0aCBwbGFjZWhvbGRlciBzdHJpbmcgdG8gaW5qZWN0XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0RGVmaW5pdGlvbiA9IFwic3RydWN0IFwiXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWUgKyBcIiB7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgICAgICsgaW5qZWN0aW9uU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICsgXCJ9O1wiLmVuZGwoKS5lbmRsKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0U2hhZGVyVHlwZSgpID09PSBcImJvdGhcIiB8fCB0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwiZnJhZ1wiKVxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RTdHJGcmFnID0gc3RydWN0U3RyRnJhZy5jb25jYXQoc3RydWN0RGVmaW5pdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0U2hhZGVyVHlwZSgpID09PSBcImJvdGhcIiB8fCB0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwidmVydFwiKVxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RTdHJWZXJ0ID0gc3RydWN0U3RyVmVydC5jb25jYXQoc3RydWN0RGVmaW5pdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJ1Y3ROYW1lcy5wdXNoKHRoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmplY3RlZFN0cmluZ3NGcmFnW3RoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc1ZlcnRbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICogY3JlYXRlIG1lbWJlciAmIGNvbW1lbnRcbiAgICAgICAgICAgIGxldCBjb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5jb21tZW50KSBjb21tZW50ID0gXCIgLy8gXCIgKyB0aGlzLl91bmlmb3Jtc1tpXS5jb21tZW50O1xuXG4gICAgICAgICAgICBsZXQgc3RyaW5nVG9JbnNlcnQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLmdldEdsc2xUeXBlU3RyaW5nKCkgPT0gdW5kZWZpbmVkKXN0cmluZ1RvSW5zZXJ0ICs9IFwiLy9cIjtcbiAgICAgICAgICAgIHN0cmluZ1RvSW5zZXJ0ICs9IFwiICBcIiArIHRoaXMuX3VuaWZvcm1zW2ldLmdldEdsc2xUeXBlU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgKyBcIiBcIiArIHRoaXMuX3VuaWZvcm1zW2ldLl9wcm9wZXJ0eU5hbWUgKyBcIjtcIlxuICAgICAgICAgICAgICAgICAgICArIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwiYm90aFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICogaW5qZWN0IG1lbWJlciBiZWZvcmUge2luamVjdGlvblN0cmluZ31cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc0ZyYWdbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdLmluZGV4T2Yoc3RyaW5nVG9JbnNlcnQpID09PSAtMVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2luamVjdGVkU3RyaW5nc1ZlcnRbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdLmluZGV4T2Yoc3RyaW5nVG9JbnNlcnQpID09PSAtMSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydGlvbkluZGV4RnJhZyA9IHN0cnVjdFN0ckZyYWcubGFzdEluZGV4T2YoaW5qZWN0aW9uU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uSW5kZXhWZXJ0ID0gc3RydWN0U3RyVmVydC5sYXN0SW5kZXhPZihpbmplY3Rpb25TdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0U3RyRnJhZy5zbGljZSgwLCBpbnNlcnRpb25JbmRleEZyYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHN0cmluZ1RvSW5zZXJ0ICsgc3RydWN0U3RyRnJhZy5zbGljZShpbnNlcnRpb25JbmRleEZyYWcgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RTdHJWZXJ0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0clZlcnQuc2xpY2UoMCwgaW5zZXJ0aW9uSW5kZXhWZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBzdHJpbmdUb0luc2VydCArIHN0cnVjdFN0clZlcnQuc2xpY2UoaW5zZXJ0aW9uSW5kZXhWZXJ0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5qZWN0ZWRTdHJpbmdzRnJhZ1t0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZV0ucHVzaChzdHJpbmdUb0luc2VydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc1ZlcnRbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdLnB1c2goc3RyaW5nVG9JbnNlcnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzRnJhZy5pbmRleE9mKGkpID09PSAtMSkgdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc0ZyYWcucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc1ZlcnQuaW5kZXhPZihpKSA9PT0gLTEpIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNWZXJ0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwiZnJhZ1wiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICogaW5qZWN0IG1lbWJlciBiZWZvcmUge2luamVjdGlvblN0cmluZ31cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5qZWN0ZWRTdHJpbmdzRnJhZ1t0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZV0uaW5kZXhPZihzdHJpbmdUb0luc2VydCkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uSW5kZXhGcmFnID0gc3RydWN0U3RyRnJhZy5sYXN0SW5kZXhPZihpbmplY3Rpb25TdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0U3RyRnJhZy5zbGljZSgwLCBpbnNlcnRpb25JbmRleEZyYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHN0cmluZ1RvSW5zZXJ0ICsgc3RydWN0U3RyRnJhZy5zbGljZShpbnNlcnRpb25JbmRleEZyYWcgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmplY3RlZFN0cmluZ3NGcmFnW3RoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lXS5wdXNoKHN0cmluZ1RvSW5zZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc0ZyYWcuaW5kZXhPZihpKSA9PT0gLTEpIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNGcmFnLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwidmVydFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICogaW5qZWN0IG1lbWJlciBiZWZvcmUge2luamVjdGlvblN0cmluZ31cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5qZWN0ZWRTdHJpbmdzVmVydFt0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZV0uaW5kZXhPZihzdHJpbmdUb0luc2VydCkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uSW5kZXhWZXJ0ID0gc3RydWN0U3RyVmVydC5sYXN0SW5kZXhPZihpbmplY3Rpb25TdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0clZlcnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0U3RyVmVydC5zbGljZSgwLCBpbnNlcnRpb25JbmRleFZlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHN0cmluZ1RvSW5zZXJ0ICsgc3RydWN0U3RyVmVydC5zbGljZShpbnNlcnRpb25JbmRleFZlcnQgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmplY3RlZFN0cmluZ3NWZXJ0W3RoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lXS5wdXNoKHN0cmluZ1RvSW5zZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc1ZlcnQuaW5kZXhPZihpKSA9PT0gLTEpIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNWZXJ0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAqIGRlZHVwZSBpbmplY3RlZCB1bmkgZGVjbGFyYXRpb25zXG4gICAgdGhpcy5fdW5pRGVjbGFyYXRpb25zRnJhZyA9IFtdO1xuICAgIHRoaXMuX3VuaURlY2xhcmF0aW9uc1ZlcnQgPSBbXTtcblxuICAgIC8vICogcmVtb3ZlIHN0cnVjdCBpbmplY3Rpb24gcG9pbnRzIGFuZCBhZGQgdW5pZm9ybSBpbiBmcmFnbWVudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc0ZyYWcubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNGcmFnW2ldO1xuICAgICAgICBjb25zdCB1bmlEZWNsYXJhdGlvblN0cmluZyA9IFwiVU5JIFwiICsgdGhpcy5fdW5pZm9ybXNbaW5kZXhdLl9zdHJ1Y3ROYW1lICsgXCIgXCIgKyB0aGlzLl91bmlmb3Jtc1tpbmRleF0uX3N0cnVjdFVuaWZvcm1OYW1lICsgXCI7XCIuZW5kbCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl91bmlEZWNsYXJhdGlvbnNGcmFnLmluZGV4T2YodW5pRGVjbGFyYXRpb25TdHJpbmcpID09PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0aW9uU3RyaW5nID0gXCJ7e0lOSkVDVElPTl9QT0lOVF9TVFJVQ1RfXCIgKyB0aGlzLl91bmlmb3Jtc1tpbmRleF0uX3N0cnVjdE5hbWUgKyBcIn19XCI7XG5cbiAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcgPSBzdHJ1Y3RTdHJGcmFnLnJlcGxhY2UoaW5qZWN0aW9uU3RyaW5nLCBcIlwiKTtcbiAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcgKz0gdW5pRGVjbGFyYXRpb25TdHJpbmc7XG5cbiAgICAgICAgICAgIHRoaXMuX3VuaURlY2xhcmF0aW9uc0ZyYWcucHVzaCh1bmlEZWNsYXJhdGlvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAqIHJlbW92ZSBzdHJ1Y3QgaW5qZWN0aW9uIHBvaW50cyBhbmQgYWRkIHVuaWZvcm0gaW4gdmVydGV4XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzVmVydC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc1ZlcnRbaV07XG4gICAgICAgIGNvbnN0IHVuaURlY2xhcmF0aW9uU3RyaW5nID0gXCJVTkkgXCIgKyB0aGlzLl91bmlmb3Jtc1tpbmRleF0uX3N0cnVjdE5hbWUgKyBcIiBcIiArIHRoaXMuX3VuaWZvcm1zW2luZGV4XS5fc3RydWN0VW5pZm9ybU5hbWUgKyBcIjtcIi5lbmRsKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VuaURlY2xhcmF0aW9uc1ZlcnQuaW5kZXhPZih1bmlEZWNsYXJhdGlvblN0cmluZykgPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbmplY3Rpb25TdHJpbmcgPSBcInt7SU5KRUNUSU9OX1BPSU5UX1NUUlVDVF9cIiArIHRoaXMuX3VuaWZvcm1zW2luZGV4XS5fc3RydWN0TmFtZSArIFwifX1cIjtcblxuICAgICAgICAgICAgc3RydWN0U3RyVmVydCA9IHN0cnVjdFN0clZlcnQucmVwbGFjZShpbmplY3Rpb25TdHJpbmcsIFwiXCIpO1xuICAgICAgICAgICAgc3RydWN0U3RyVmVydCArPSB1bmlEZWNsYXJhdGlvblN0cmluZztcbiAgICAgICAgICAgIHRoaXMuX3VuaURlY2xhcmF0aW9uc1ZlcnQucHVzaCh1bmlEZWNsYXJhdGlvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3N0cnVjdFN0clZlcnQsIHN0cnVjdFN0ckZyYWddO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5fZ2V0QXR0clNyYyA9IGZ1bmN0aW9uIChhdHRyLCBmaXJzdExldmVsKVxue1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICBpZiAoYXR0ci5uYW1lICYmIGF0dHIudHlwZSlcbiAgICB7XG4gICAgICAgIHIuc3JjSGVhZFZlcnQgPSBcIlwiO1xuICAgICAgICBpZiAoIWZpcnN0TGV2ZWwpIHIuc3JjSGVhZFZlcnQgKz0gXCIjaWZuZGVmIEFUVFJJQl9cIiArIGF0dHIubmFtZS5lbmRsKCk7XG4gICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCIjZGVmaW5lIEFUVFJJQl9cIiArIGF0dHIubmFtZS5lbmRsKCk7XG4gICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCJJTiBcIiArIGF0dHIudHlwZSArIFwiIFwiICsgYXR0ci5uYW1lICsgXCI7XCIuZW5kbCgpO1xuICAgICAgICBpZiAoIWZpcnN0TGV2ZWwpIHIuc3JjSGVhZFZlcnQgKz0gXCIjZW5kaWZcIi5lbmRsKCk7XG5cbiAgICAgICAgaWYgKGF0dHIubmFtZUZyYWcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCJcIjtcbiAgICAgICAgICAgIGlmICghZmlyc3RMZXZlbCkgci5zcmNIZWFkVmVydCArPSBcIiNpZm5kZWYgQVRUUklCX1wiICsgYXR0ci5uYW1lRnJhZy5lbmRsKCk7XG4gICAgICAgICAgICByLnNyY0hlYWRWZXJ0ICs9IFwiI2RlZmluZSBBVFRSSUJfXCIgKyBhdHRyLm5hbWVGcmFnLmVuZGwoKTtcbiAgICAgICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCJPVVQgXCIgKyBhdHRyLnR5cGUgKyBcIiBcIiArIGF0dHIubmFtZUZyYWcgKyBcIjtcIi5lbmRsKCk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0TGV2ZWwpIHIuc3JjSGVhZFZlcnQgKz0gXCIjZW5kaWZcIi5lbmRsKCk7XG5cbiAgICAgICAgICAgIHIuc3JjVmVydCA9IFwiXCIuZW5kbCgpICsgYXR0ci5uYW1lRnJhZyArIFwiPVwiICsgYXR0ci5uYW1lICsgXCI7XCI7XG5cbiAgICAgICAgICAgIHIuc3JjSGVhZEZyYWcgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCFmaXJzdExldmVsKSByLnNyY0hlYWRGcmFnICs9IFwiI2lmbmRlZiBBVFRSSUJfXCIgKyBhdHRyLm5hbWVGcmFnLmVuZGwoKTtcbiAgICAgICAgICAgIHIuc3JjSGVhZEZyYWcgKz0gXCIjZGVmaW5lIEFUVFJJQl9cIiArIGF0dHIubmFtZUZyYWcuZW5kbCgpO1xuICAgICAgICAgICAgci5zcmNIZWFkRnJhZyArPSBcIklOIFwiICsgYXR0ci50eXBlICsgXCIgXCIgKyBhdHRyLm5hbWVGcmFnICsgXCI7XCIuZW5kbCgpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdExldmVsKSByLnNyY0hlYWRGcmFnICs9IFwiI2VuZGlmXCIuZW5kbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fY2dsLmFib3J0ZWQpIHJldHVybjtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckNvbXBpbGVzKys7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJDb21waWxlTmFtZSA9IHRoaXMuX25hbWUgKyBcIiBbXCIgKyB0aGlzLl9jb21waWxlUmVhc29uICsgXCJdXCI7XG5cbiAgICBsZXQgZXh0ZW5zaW9uU3RyaW5nID0gXCJcIjtcbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9leHRlbnNpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZXh0ZW5zaW9uU3RyaW5nICs9IFwiI2V4dGVuc2lvbiBcIiArIHRoaXMuX2V4dGVuc2lvbnNbaV0gKyBcIiA6IGVuYWJsZVwiLmVuZGwoKTtcblxuICAgIGxldCBkZWZpbmVzU3RyID0gXCJcIjtcbiAgICBpZiAodGhpcy5fZGVmaW5lcy5sZW5ndGgpIGRlZmluZXNTdHIgPSBcIlxcbi8vIGNnbCBnZW5lcmF0ZWRcIi5lbmRsKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kZWZpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBkZWZpbmVzU3RyICs9IFwiI2RlZmluZSBcIiArIHRoaXMuX2RlZmluZXNbaV1bMF0gKyBcIiBcIiArIHRoaXMuX2RlZmluZXNbaV1bMV0gKyBcIlwiLmVuZGwoKTtcblxuICAgIGNvbnN0IHN0cnVjdFN0cmluZ3MgPSB0aGlzLmNyZWF0ZVN0cnVjdFVuaWZvcm1zKCk7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJzaGFkZXIgY29tcGlsZVwiLCB0aGlzLl9uYW1lICsgXCIgW1wiICsgdGhpcy5fY29tcGlsZVJlYXNvbiArIFwiXVwiKTtcbiAgICB0aGlzLl9jb21waWxlUmVhc29uID0gXCJcIjtcblxuXG5cbiAgICBpZiAodGhpcy5fdW5pZm9ybXMpXG4gICAge1xuICAgICAgICAvLyAqIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiB0aGUgdW5pZm9ybSBuYW1lcyB0byBjaGVjayBvdXIgaW5kaWNlcyAmIGFuIGFycmF5IHRvIHNhdmUgdGhlbVxuICAgICAgICBjb25zdCB1bmlOYW1lcyA9IHRoaXMuX3VuaWZvcm1zLm1hcCgodW5pKSA9PiB7IHJldHVybiB1bmkuX25hbWU7IH0pO1xuICAgICAgICBjb25zdCBpbmRpY2VzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgICAvLyAqIHdlIGdvIHRocm91Z2ggb3VyIHVuaWZvcm1zIGFuZCBjaGVjayBpZiB0aGUgc2FtZSBuYW1lIGlzIGNvbnRhaW5lZCBzb21ld2hlcmUgZnVydGhlciBpbiB0aGUgYXJyYXlcbiAgICAgICAgLy8gKiBpZiBzbywgd2UgYWRkIHRoZSBjdXJyZW50IGluZGV4IHRvIGJlIHJlbW92ZWQgbGF0ZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gdGhpcy5fdW5pZm9ybXNbaV07XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB1bmlOYW1lcy5pbmRleE9mKHVuaS5fbmFtZSwgaSArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHRJbmRleCA+IC0xKSBpbmRpY2VzVG9SZW1vdmUucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICogYWZ0ZXIgdGhhdCwgd2UgZ28gdGhyb3VnaCB0aGUgdW5pZm9ybXMgYmFja3dhcmRzIChzbyB3ZSBrZWVwIHRoZSBvcmRlcikgYW5kIHJlbW92ZSB0aGUgaW5kaWNlc1xuICAgICAgICAvLyAqIGFsc28sIHdlIHJlc2V0IHRoZSBsb2NhdGlvbnMgb2YgYWxsIHRoZSBvdGhlciB2YWxpZCB1bmlmb3Jtc1xuICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5fdW5pZm9ybXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzVG9SZW1vdmUuaW5kZXhPZihqKSA+IC0xKSB0aGlzLl91bmlmb3Jtcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMuX3VuaWZvcm1zW2pdLnJlc2V0TG9jKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcInVuaWZvcm0gcmVzZXRzXCIpO1xuXG4gICAgaWYgKHRoaXMuaGFzVGV4dHVyZVVuaWZvcm1zKCkpIGRlZmluZXNTdHIgKz0gXCIjZGVmaW5lIEhBU19URVhUVVJFU1wiLmVuZGwoKTtcblxuICAgIGxldCB2cyA9IFwiXCI7XG4gICAgbGV0IGZzID0gXCJcIjtcblxuICAgIGlmICghdGhpcy5zcmNGcmFnKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiW2NnbCBzaGFkZXJdIGhhcyBubyBmcmFnbWVudCBzb3VyY2UhXCIsIHRoaXMpO1xuICAgICAgICB0aGlzLnNyY1ZlcnQgPSB0aGlzLmdldERlZmF1bHRWZXJ0ZXhTaGFkZXIoKTtcbiAgICAgICAgdGhpcy5zcmNGcmFnID0gdGhpcy5nZXREZWZhdWx0RnJhZ21lbnRTaGFkZXIoKTtcbiAgICAgICAgLy8gcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdsc2xWZXJzaW9uID09IDMwMClcbiAgICB7XG4gICAgICAgIHZzID0gXCIjdmVyc2lvbiAzMDAgZXNcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiLy8gXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIHZlcnRleCBzaGFkZXIgXCIgKyB0aGlzLl9uYW1lXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwicHJlY2lzaW9uIFwiICsgdGhpcy5wcmVjaXNpb24gKyBcIiBmbG9hdDtcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwicHJlY2lzaW9uIFwiICsgdGhpcy5wcmVjaXNpb24gKyBcIiBzYW1wbGVyMkQ7XCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIlwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIFdFQkdMMlwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgVU5JIHVuaWZvcm1cIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBJTiBpblwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIE9VVCBvdXRcIlxuICAgICAgICAgICAgLmVuZGwoKTtcblxuICAgICAgICBmcyA9IFwiI3ZlcnNpb24gMzAwIGVzXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBmcmFnbWVudCBzaGFkZXIgXCIgKyB0aGlzLl9uYW1lXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwicHJlY2lzaW9uIFwiICsgdGhpcy5wcmVjaXNpb24gKyBcIiBmbG9hdDtcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwicHJlY2lzaW9uIFwiICsgdGhpcy5wcmVjaXNpb24gKyBcIiBzYW1wbGVyMkQ7XCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIlwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIFdFQkdMMlwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgSU4gaW5cIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBPVVQgb3V0XCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgVU5JIHVuaWZvcm1cIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwie3tEUkFXQlVGRkVSfX1cIlxuXG4gICAgICAgICAgICAuZW5kbCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBmcyA9IFwiXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBmcmFnbWVudCBzaGFkZXIgXCIgKyB0aGlzLl9uYW1lXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBXRUJHTDFcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSB0ZXh0dXJlIHRleHR1cmUyRFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIG91dENvbG9yIGdsX0ZyYWdDb2xvclwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIElOIHZhcnlpbmdcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBVTkkgdW5pZm9ybVwiXG4gICAgICAgICAgICAuZW5kbCgpO1xuXG4gICAgICAgIHZzID0gXCJcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiLy8gXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIHZlcnRleCBzaGFkZXIgXCIgKyB0aGlzLl9uYW1lXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBXRUJHTDFcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSB0ZXh0dXJlIHRleHR1cmUyRFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIE9VVCB2YXJ5aW5nXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgSU4gYXR0cmlidXRlXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgVU5JIHVuaWZvcm1cIlxuICAgICAgICAgICAgLmVuZGwoKTtcbiAgICB9XG5cbiAgICBsZXQgdW5pZm9ybXNTdHJWZXJ0ID0gXCJcXG4vLyBjZ2wgZ2VuZXJhdGVkXCIuZW5kbCgpO1xuICAgIGxldCB1bmlmb3Jtc1N0ckZyYWcgPSBcIlxcbi8vIGNnbCBnZW5lcmF0ZWRcIi5lbmRsKCk7XG5cblxuICAgIGZzICs9IFwiXFxuLy8gYWN0aXZlIG1vZHM6IC0tLS0tLS0tLS0tLS0tLSBcIjtcbiAgICB2cyArPSBcIlxcbi8vIGFjdGl2ZSBtb2RzOiAtLS0tLS0tLS0tLS0tLS0gXCI7XG5cbiAgICBsZXQgZm91bmRNb2RzRnJhZyA9IGZhbHNlO1xuICAgIGxldCBmb3VuZE1vZHNWZXJ0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2R1bGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZHVsZXNbal0ubmFtZSA9PSB0aGlzLl9tb2R1bGVOYW1lc1tpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kdWxlc1tqXS5zcmNCb2R5RnJhZyB8fCB0aGlzLl9tb2R1bGVzW2pdLnNyY0hlYWRGcmFnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRNb2RzRnJhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZzICs9IFwiXFxuLy8gXCIgKyBpICsgXCIuXCIgKyBqICsgXCIuIFwiICsgdGhpcy5fbW9kdWxlc1tqXS50aXRsZSArIFwiIChcIiArIHRoaXMuX21vZHVsZXNbal0ubmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kdWxlc1tqXS5zcmNCb2R5VmVydCB8fCB0aGlzLl9tb2R1bGVzW2pdLnNyY0hlYWRWZXJ0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdnMgKz0gXCJcXG4vLyBcIiArIGkgKyBcIi5cIiArIGogKyBcIi4gXCIgKyB0aGlzLl9tb2R1bGVzW2pdLnRpdGxlICsgXCIgKFwiICsgdGhpcy5fbW9kdWxlc1tqXS5uYW1lICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTW9kc1ZlcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kTW9kc1ZlcnQpZnMgKz0gXCJcXG4vLyBubyBtb2RzIHVzZWQuLi5cIjtcbiAgICBpZiAoIWZvdW5kTW9kc0ZyYWcpZnMgKz0gXCJcXG4vLyBubyBtb2RzIHVzZWQuLi5cIjtcbiAgICBmcyArPSBcIlxcblwiO1xuICAgIHZzICs9IFwiXFxuXCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgJiYgIXRoaXMuX3VuaWZvcm1zW2ldLmlzU3RydWN0TWVtYmVyKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB1bmlTdHIgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl91bmlmb3Jtc1tpXS5nZXRHbHNsVHlwZVN0cmluZygpKXVuaVN0ciArPSBcIi8vIFwiO1xuICAgICAgICAgICAgdW5pU3RyICs9IFwiVU5JIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0R2xzbFR5cGVTdHJpbmcoKSArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpO1xuICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLmNvbW1lbnQpIGNvbW1lbnQgPSBcIiAvLyBcIiArIHRoaXMuX3VuaWZvcm1zW2ldLmNvbW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5zaGFkZXJUeXBlID09IFwidmVydFwiIHx8IHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJib3RoXCIpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3JjVmVydC5pbmRleE9mKHVuaVN0cikgPT0gLTEgJiYgdGhpcy5zcmNWZXJ0LmluZGV4T2YoXCJ1bmlmb3JtIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0R2xzbFR5cGVTdHJpbmcoKSArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNTdHJWZXJ0ICs9IHVuaVN0ciArIFwiO1wiICsgY29tbWVudC5lbmRsKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5zaGFkZXJUeXBlID09IFwiZnJhZ1wiIHx8IHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJib3RoXCIpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3JjRnJhZy5pbmRleE9mKHVuaVN0cikgPT0gLTEgJiYgdGhpcy5zcmNGcmFnLmluZGV4T2YoXCJ1bmlmb3JtIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0R2xzbFR5cGVTdHJpbmcoKSArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNTdHJGcmFnICs9IHVuaVN0ciArIFwiO1wiICsgY29tbWVudC5lbmRsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGxldCBjb3VudFVuaUZyYWcgPSAwO1xuICAgIGxldCBjb3VudFVuaVZlcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uc2hhZGVyVHlwZSAmJiAhdGhpcy5fdW5pZm9ybXNbaV0uaXNTdHJ1Y3RNZW1iZXIoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJ2ZXJ0XCIgfHwgdGhpcy5fdW5pZm9ybXNbaV0uc2hhZGVyVHlwZSA9PSBcImJvdGhcIikgY291bnRVbmlWZXJ0Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uc2hhZGVyVHlwZSA9PSBcImZyYWdcIiB8fCB0aGlzLl91bmlmb3Jtc1tpXS5zaGFkZXJUeXBlID09IFwiYm90aFwiKSBjb3VudFVuaUZyYWcrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY291bnRVbmlGcmFnID49IHRoaXMuX2NnbC5tYXhVbmlmb3Jtc0ZyYWcpIHRoaXMuX2xvZy53YXJuKFwiW2NnbF9zaGFkZXJdIG51bSB1bmlmb3JtcyBmcmFnOiBcIiArIGNvdW50VW5pRnJhZyArIFwiIC8gXCIgKyB0aGlzLl9jZ2wubWF4VW5pZm9ybXNGcmFnKTtcbiAgICBpZiAoY291bnRVbmlWZXJ0ID49IHRoaXMuX2NnbC5tYXhVbmlmb3Jtc1ZlcnQpIHRoaXMuX2xvZy53YXJuKFwiW2NnbF9zaGFkZXJdIG51bSB1bmlmb3JtcyB2ZXJ0OiBcIiArIGNvdW50VW5pVmVydCArIFwiIC8gXCIgKyB0aGlzLl9jZ2wubWF4VW5pZm9ybXNWZXJ0KTtcblxuXG4gICAgaWYgKGZzLmluZGV4T2YoXCJwcmVjaXNpb25cIikgPT0gLTEpIGZzID0gXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiLmVuZGwoKSArIGZzO1xuICAgIGlmICh2cy5pbmRleE9mKFwicHJlY2lzaW9uXCIpID09IC0xKSB2cyA9IFwicHJlY2lzaW9uIFwiICsgdGhpcy5wcmVjaXNpb24gKyBcIiBmbG9hdDtcIi5lbmRsKCkgKyB2cztcbiAgICBpZiAoL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuICAgIHtcbiAgICAgICAgZnMgKz0gXCIjZGVmaW5lIE1PQklMRVwiLmVuZGwoKTtcbiAgICAgICAgdnMgKz0gXCIjZGVmaW5lIE1PQklMRVwiLmVuZGwoKTtcbiAgICB9XG4gICAgdnMgPSBleHRlbnNpb25TdHJpbmcgKyB2cyArIGRlZmluZXNTdHIgKyBzdHJ1Y3RTdHJpbmdzWzBdICsgdW5pZm9ybXNTdHJWZXJ0ICsgXCJcXG4vLyAtLSBcXG5cIiArIHRoaXMuc3JjVmVydDtcbiAgICBmcyA9IGV4dGVuc2lvblN0cmluZyArIGZzICsgZGVmaW5lc1N0ciArIHN0cnVjdFN0cmluZ3NbMV0gKyB1bmlmb3Jtc1N0ckZyYWcgKyBcIlxcbi8vIC0tIFxcblwiICsgdGhpcy5zcmNGcmFnO1xuXG5cbiAgICBsZXQgc3JjSGVhZFZlcnQgPSBcIlwiO1xuICAgIGxldCBzcmNIZWFkRnJhZyA9IFwiXCI7XG5cbiAgICB0aGlzLl9tb2R1bGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpXG4gICAge1xuICAgICAgICByZXR1cm4gYS5ncm91cCAtIGIuZ3JvdXA7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9tb2R1bGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpXG4gICAge1xuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSB8fCAwIC0gYi5wcmlvcml0eSB8fCAwO1xuICAgIH0pO1xuXG5cbiAgICBsZXQgYWRkZWRBdHRyaWJzID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vZHVsZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgbGV0IHNyY1ZlcnQgPSBcIlwiO1xuICAgICAgICBsZXQgc3JjRnJhZyA9IFwiXCI7XG5cbiAgICAgICAgaWYgKCFhZGRlZEF0dHJpYnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFkZGVkQXR0cmlicyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fZ2V0QXR0clNyYyh0aGlzLl9hdHRyaWJ1dGVzW2tdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoci5zcmNIZWFkVmVydClzcmNIZWFkVmVydCArPSByLnNyY0hlYWRWZXJ0O1xuICAgICAgICAgICAgICAgIGlmIChyLnNyY1ZlcnQpc3JjVmVydCArPSByLnNyY1ZlcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHIuc3JjSGVhZEZyYWcpc3JjSGVhZEZyYWcgKz0gci5zcmNIZWFkRnJhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5fbW9kdWxlc1tqXTtcbiAgICAgICAgICAgIGlmIChtb2QubmFtZSA9PSB0aGlzLl9tb2R1bGVOYW1lc1tpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzcmNIZWFkVmVydCArPSBcIlxcbi8vLS0tLSBNT0Q6IGdyb3VwOlwiICsgbW9kLmdyb3VwICsgXCI6IGlkeDpcIiArIGogKyBcIiAtIHByZng6XCIgKyBtb2QucHJlZml4ICsgXCIgLSBcIiArIG1vZC50aXRsZSArIFwiIC0tLS0tLVxcblwiO1xuICAgICAgICAgICAgICAgIHNyY0hlYWRGcmFnICs9IFwiXFxuLy8tLS0tIE1PRDogZ3JvdXA6XCIgKyBtb2QuZ3JvdXAgKyBcIjogaWR4OlwiICsgaiArIFwiIC0gcHJmeDpcIiArIG1vZC5wcmVmaXggKyBcIiAtIFwiICsgbW9kLnRpdGxlICsgXCIgLS0tLS0tXFxuXCI7XG5cbiAgICAgICAgICAgICAgICBzcmNWZXJ0ICs9IFwiXFxuXFxuLy8tLS0tIE1PRDogXCIgKyBtb2QudGl0bGUgKyBcIiAvIFwiICsgbW9kLnByaW9yaXR5ICsgXCIgLS0tLS0tXFxuXCI7XG4gICAgICAgICAgICAgICAgc3JjRnJhZyArPSBcIlxcblxcbi8vLS0tLSBNT0Q6IFwiICsgbW9kLnRpdGxlICsgXCIgLyBcIiArIG1vZC5wcmlvcml0eSArIFwiIC0tLS0tLVxcblwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZC5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG1vZC5hdHRyaWJ1dGVzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fZ2V0QXR0clNyYyhtb2QuYXR0cmlidXRlc1trXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuc3JjSGVhZFZlcnQpc3JjSGVhZFZlcnQgKz0gci5zcmNIZWFkVmVydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnNyY1ZlcnQpc3JjVmVydCArPSByLnNyY1ZlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5zcmNIZWFkRnJhZylzcmNIZWFkRnJhZyArPSByLnNyY0hlYWRGcmFnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzcmNIZWFkVmVydCArPSBtb2Quc3JjSGVhZFZlcnQgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBzcmNIZWFkRnJhZyArPSBtb2Quc3JjSGVhZEZyYWcgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBzcmNWZXJ0ICs9IG1vZC5zcmNCb2R5VmVydCB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHNyY0ZyYWcgKz0gbW9kLnNyY0JvZHlGcmFnIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBzcmNIZWFkVmVydCArPSBcIlxcbi8vLS0tLSBlbmQgbW9kIC0tLS0tLVxcblwiO1xuICAgICAgICAgICAgICAgIHNyY0hlYWRGcmFnICs9IFwiXFxuLy8tLS0tIGVuZCBtb2QgLS0tLS0tXFxuXCI7XG5cbiAgICAgICAgICAgICAgICBzcmNWZXJ0ICs9IFwiXFxuLy8tLS0tIGVuZCBtb2QgLS0tLS0tXFxuXCI7XG4gICAgICAgICAgICAgICAgc3JjRnJhZyArPSBcIlxcbi8vLS0tLSBlbmQgbW9kIC0tLS0tLVxcblwiO1xuXG4gICAgICAgICAgICAgICAgc3JjVmVydCA9IHNyY1ZlcnQucmVwbGFjZSgve3ttb2R9fS9nLCBtb2QucHJlZml4KTtcbiAgICAgICAgICAgICAgICBzcmNGcmFnID0gc3JjRnJhZy5yZXBsYWNlKC97e21vZH19L2csIG1vZC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIHNyY0hlYWRWZXJ0ID0gc3JjSGVhZFZlcnQucmVwbGFjZSgve3ttb2R9fS9nLCBtb2QucHJlZml4KTtcbiAgICAgICAgICAgICAgICBzcmNIZWFkRnJhZyA9IHNyY0hlYWRGcmFnLnJlcGxhY2UoL3t7bW9kfX0vZywgbW9kLnByZWZpeCk7XG5cbiAgICAgICAgICAgICAgICBzcmNWZXJ0ID0gc3JjVmVydC5yZXBsYWNlKC9NT0RfL2csIG1vZC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIHNyY0ZyYWcgPSBzcmNGcmFnLnJlcGxhY2UoL01PRF8vZywgbW9kLnByZWZpeCk7XG4gICAgICAgICAgICAgICAgc3JjSGVhZFZlcnQgPSBzcmNIZWFkVmVydC5yZXBsYWNlKC9NT0RfL2csIG1vZC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIHNyY0hlYWRGcmFnID0gc3JjSGVhZEZyYWcucmVwbGFjZSgvTU9EXy9nLCBtb2QucHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdnMgPSB2cy5yZXBsYWNlKFwie3tcIiArIHRoaXMuX21vZHVsZU5hbWVzW2ldICsgXCJ9fVwiLCBzcmNWZXJ0KTtcbiAgICAgICAgZnMgPSBmcy5yZXBsYWNlKFwie3tcIiArIHRoaXMuX21vZHVsZU5hbWVzW2ldICsgXCJ9fVwiLCBzcmNGcmFnKTtcbiAgICB9XG4gICAgdnMgPSB2cy5yZXBsYWNlKFwie3tNT0RVTEVTX0hFQUR9fVwiLCBzcmNIZWFkVmVydCk7XG4gICAgZnMgPSBmcy5yZXBsYWNlKFwie3tNT0RVTEVTX0hFQUR9fVwiLCBzcmNIZWFkRnJhZyk7XG5cblxuICAgIHZzID0gdGhpcy5fYWRkTGlicyh2cyk7XG4gICAgZnMgPSB0aGlzLl9hZGRMaWJzKGZzKTtcblxuXG4gICAgLy8gU0VUVVAgZHJhdyBidWZmZXJzIC8gbXVsdGkgdGV4dHVyZSByZW5kZXIgdGFyZ2V0c1xuXG4gICAgbGV0IGRyYXdCdWZmZXJTdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgICAgaWYgKGZzLmluZGV4T2YoXCJvdXRDb2xvclwiICsgaSkgPiAtMSkgdGhpcy5fZHJhd0J1ZmZlcnNbaV0gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuX2RyYXdCdWZmZXJzLmxlbmd0aCA9PSAxKVxuICAgIHtcbiAgICAgICAgZHJhd0J1ZmZlclN0ciA9IFwib3V0IHZlYzQgb3V0Q29sb3I7XCIuZW5kbCgpO1xuICAgICAgICBkcmF3QnVmZmVyU3RyICs9IFwiI2RlZmluZSBnbF9GcmFnQ29sb3Igb3V0Q29sb3JcIi5lbmRsKCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGRyYXdCdWZmZXJTdHIgKz0gXCIjZGVmaW5lIE1VTFRJX0NPTE9SVEFSR0VUU1wiLmVuZGwoKTtcbiAgICAgICAgZHJhd0J1ZmZlclN0ciArPSBcInZlYzQgb3V0Q29sb3I7XCIuZW5kbCgpO1xuXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZHJhd0J1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAwKSBkcmF3QnVmZmVyU3RyICs9IFwiI2RlZmluZSBnbF9GcmFnQ29sb3Igb3V0Q29sb3JcIiArIGkgKyBcIlwiLmVuZGwoKTtcbiAgICAgICAgICAgIGRyYXdCdWZmZXJTdHIgKz0gXCJsYXlvdXQobG9jYXRpb24gPSBcIiArIGkgKyBcIikgb3V0IHZlYzQgb3V0Q29sb3JcIiArIGkgKyBcIjtcIi5lbmRsKCk7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnMgPSBmcy5yZXBsYWNlKFwie3tEUkFXQlVGRkVSfX1cIiwgZHJhd0J1ZmZlclN0cik7XG4gICAgLy8gLy8vLy8vXG5cblxuICAgIGlmICghdGhpcy5fcHJvZ3JhbSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSB0aGlzLl9jcmVhdGVQcm9ncmFtKHZzLCBmcyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIHRoaXMudnNoYWRlcj1jcmVhdGVTaGFkZXIodnMsIGdsLlZFUlRFWF9TSEFERVIsIHRoaXMudnNoYWRlciApO1xuICAgICAgICAvLyB0aGlzLmZzaGFkZXI9Y3JlYXRlU2hhZGVyKGZzLCBnbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZnNoYWRlciApO1xuICAgICAgICAvLyBsaW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHRoaXMuX2NyZWF0ZVByb2dyYW0odnMsIGZzKTtcblxuICAgICAgICB0aGlzLl9wcm9qTWF0cml4VW5pZm9ybSA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKykgdGhpcy5fdW5pZm9ybXNbaV0ucmVzZXRMb2MoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbmFsU2hhZGVyRnJhZyA9IGZzO1xuICAgIHRoaXMuZmluYWxTaGFkZXJWZXJ0ID0gdnM7XG5cblxuICAgIE1FU0gubGFzdE1lc2ggPSBudWxsO1xuICAgIE1FU0gubGFzdFNoYWRlciA9IG51bGw7XG5cbiAgICB0aGlzLl9jb3VudE1pc3NpbmdVbmlmb3JtcyA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RDb21waWxlID0gbm93KCk7XG5cbiAgICAvLyB0aGlzLl9jZ2wucHJpbnRFcnJvcihcInNoYWRlciBjb21waWxlXCIpO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnNoYWRlckNvbXBpbGVUaW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xufTtcblxuU2hhZGVyLmhhc0NoYW5nZWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9uZWVkc1JlY29tcGlsZTtcbn07XG5cblxuU2hhZGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWQgfHwgdGhpcy5fY2dsLmFib3J0ZWQpIHJldHVybjtcblxuICAgIE1FU0gubGFzdFNoYWRlciA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuX3Byb2dyYW0gfHwgdGhpcy5fbmVlZHNSZWNvbXBpbGUpIHRoaXMuY29tcGlsZSgpO1xuICAgIGlmICghdGhpcy5faXNWYWxpZCkgcmV0dXJuO1xuXG4gICAgaWYgKCF0aGlzLl9wcm9qTWF0cml4VW5pZm9ybSAmJiAhdGhpcy5pZ25vcmVNaXNzaW5nVW5pZm9ybXMpXG4gICAge1xuICAgICAgICB0aGlzLl9jb3VudE1pc3NpbmdVbmlmb3JtcysrO1xuICAgICAgICAvLyBpZiAodGhpcy5fY291bnRNaXNzaW5nVW5pZm9ybXMgPT0gMTApY29uc29sZS5sb2coXCJzdG9wcGluZyBnZXRsb2NhdGlvbiBvZiBtaXNzaW5nIHVuaWZvcm1zLi4uXCIsIHRoaXMuX25hbWUpO1xuICAgICAgICBpZiAodGhpcy5fY291bnRNaXNzaW5nVW5pZm9ybXMgPCAxMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcHJvak1hdHJpeFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9QUk9KTUFUKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJWZXJ0ZXhQb3MgPSB0aGlzLl9jZ2wuZ2xHZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfUE9TSVRJT04pO1xuICAgICAgICAgICAgdGhpcy5fbXZNYXRyaXhVbmlmb3JtID0gdGhpcy5fY2dsLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBcIm12TWF0cml4XCIpO1xuICAgICAgICAgICAgdGhpcy5fdk1hdHJpeFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9WSUVXTUFUKTtcbiAgICAgICAgICAgIHRoaXMuX21NYXRyaXhVbmlmb3JtID0gdGhpcy5fY2dsLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9VTklfTU9ERUxNQVQpO1xuICAgICAgICAgICAgdGhpcy5fY2FtUG9zVW5pZm9ybSA9IHRoaXMuX2NnbC5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVU5JX1ZJRVdQT1MpO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsTWF0cml4VW5pZm9ybSA9IHRoaXMuX2NnbC5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVU5JX05PUk1BTE1BVCk7XG4gICAgICAgICAgICB0aGlzLl9pbnZlcnNlVmlld01hdHJpeFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9JTlZWSUVXTUFUKTtcbiAgICAgICAgICAgIHRoaXMuX2ludmVyc2VQcm9qTWF0cml4VW5pZm9ybSA9IHRoaXMuX2NnbC5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVU5JX0lOVlBST0pNQVQpO1xuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxJZFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9NQVRFUklBTElEKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdElkVW5pZm9ybSA9IHRoaXMuX2NnbC5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVU5JX09CSkVDVElEKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKykgdGhpcy5fdW5pZm9ybXNbaV0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAodGhpcy5fY2dsLmN1cnJlbnRQcm9ncmFtICE9IHRoaXMuX3Byb2dyYW0pXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckJpbmRzKys7XG4gICAgICAgIHRoaXMuX2NnbC5nbC51c2VQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuICAgICAgICB0aGlzLl9jZ2wuY3VycmVudFByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5uZWVkc1VwZGF0ZSkgdGhpcy5fdW5pZm9ybXNbaV0udXBkYXRlVmFsdWUoKTtcblxuICAgIGlmICh0aGlzLl9wTWF0cml4U3RhdGUgIT0gdGhpcy5fY2dsLmdldFByb2plY3Rpb25NYXRyaXhTdGF0ZUNvdW50KCkpXG4gICAge1xuICAgICAgICB0aGlzLl9wTWF0cml4U3RhdGUgPSB0aGlzLl9jZ2wuZ2V0UHJvamVjdGlvbk1hdHJpeFN0YXRlQ291bnQoKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fcHJvak1hdHJpeFVuaWZvcm0sIGZhbHNlLCB0aGlzLl9jZ2wucE1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTVZQTWF0cml4Q291bnQrKztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb2JqZWN0SWRVbmlmb3JtKVxuICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybTFmKHRoaXMuX29iamVjdElkVW5pZm9ybSwgKyt0aGlzLl9jZ2wuZnJhbWVTdG9yZS5vYmplY3RJZENvdW50ZXIpO1xuXG4gICAgaWYgKHRoaXMuX21hdGVyaWFsSWRVbmlmb3JtKVxuICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybTFmKHRoaXMuX21hdGVyaWFsSWRVbmlmb3JtLCB0aGlzLl9tYXRlcmlhbElkKTtcblxuICAgIGlmICh0aGlzLl92TWF0cml4VW5pZm9ybSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl92TWF0cml4U3RhdGUgIT0gdGhpcy5fY2dsLmdldFZpZXdNYXRyaXhTdGF0ZUNvdW50KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3ZNYXRyaXhVbmlmb3JtLCBmYWxzZSwgdGhpcy5fY2dsLnZNYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNVlBNYXRyaXhDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5fdk1hdHJpeFN0YXRlID0gdGhpcy5fY2dsLmdldFZpZXdNYXRyaXhTdGF0ZUNvdW50KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnZlcnNlVmlld01hdHJpeFVuaWZvcm0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWF0NC5pbnZlcnQodGhpcy5fdGVtcEludmVyc2VWaWV3TWF0cml4LCB0aGlzLl9jZ2wudk1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5faW52ZXJzZVZpZXdNYXRyaXhVbmlmb3JtLCBmYWxzZSwgdGhpcy5fdGVtcEludmVyc2VWaWV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1WUE1hdHJpeENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faW52ZXJzZVByb2pNYXRyaXhVbmlmb3JtKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hdDQuaW52ZXJ0KHRoaXMuX3RlbXBJbnZlcnNlUHJvak1hdHJpeCwgdGhpcy5fY2dsLnBNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX2ludmVyc2VQcm9qTWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMuX3RlbXBJbnZlcnNlUHJvak1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNVlBNYXRyaXhDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX21NYXRyaXhVbmlmb3JtLCBmYWxzZSwgdGhpcy5fY2dsLm1NYXRyaXgpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1WUE1hdHJpeENvdW50Kys7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NhbVBvc1VuaWZvcm0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hdDQuaW52ZXJ0KHRoaXMuX3RlbXBDYW1Qb3NNYXRyaXgsIHRoaXMuX2NnbC52TWF0cml4KTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtM2YodGhpcy5fY2FtUG9zVW5pZm9ybSwgdGhpcy5fdGVtcENhbVBvc01hdHJpeFsxMl0sIHRoaXMuX3RlbXBDYW1Qb3NNYXRyaXhbMTNdLCB0aGlzLl90ZW1wQ2FtUG9zTWF0cml4WzE0XSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1WUE1hdHJpeENvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gbXZtYXRyaXggZGVwcmVjYXRlZC4uLi5cbiAgICAgICAgY29uc3QgdGVtcG12ID0gbWF0NC5jcmVhdGUoKTtcblxuICAgICAgICBtYXQ0Lm11bCh0ZW1wbXYsIHRoaXMuX2NnbC52TWF0cml4LCB0aGlzLl9jZ2wubU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX212TWF0cml4VW5pZm9ybSwgZmFsc2UsIHRlbXBtdik7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTVZQTWF0cml4Q291bnQrKztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbm9ybWFsTWF0cml4VW5pZm9ybSlcbiAgICB7XG4gICAgICAgIC8vIG1hdDQubXVsKHRoaXMuX3RlbXBOb3JtYWxNYXRyaXgsIHRoaXMuX2NnbC52TWF0cml4LCB0aGlzLl9jZ2wubU1hdHJpeCk7XG4gICAgICAgIG1hdDQuaW52ZXJ0KHRoaXMuX3RlbXBOb3JtYWxNYXRyaXgsIHRoaXMuX2NnbC5tTWF0cml4KTtcbiAgICAgICAgbWF0NC50cmFuc3Bvc2UodGhpcy5fdGVtcE5vcm1hbE1hdHJpeCwgdGhpcy5fdGVtcE5vcm1hbE1hdHJpeCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fbm9ybWFsTWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMuX3RlbXBOb3JtYWxNYXRyaXgpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1WUE1hdHJpeENvdW50Kys7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saWJzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpYnNbaV0ub25CaW5kKSB0aGlzLl9saWJzW2ldLm9uQmluZC5iaW5kKHRoaXMuX2xpYnNbaV0pKHRoaXMuX2NnbCwgdGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmluZFRleHR1cmVzKCk7XG5cbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn07XG5cblNoYWRlci5wcm90b3R5cGUudW5CaW5kID0gZnVuY3Rpb24gKClcbntcbn07XG5cbi8qKlxuICogZWFzaWx5IGVuYWJsZS9kaXNhYmxlIGEgZGVmaW5lIHdpdGhvdXQgYSB2YWx1ZVxuICogQGZ1bmN0aW9uIHRvZ2dsZURlZmluZVxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge25hbWV9IG5hbWVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBvciBwb3J0XG4gKi9cblNoYWRlci5wcm90b3R5cGUudG9nZ2xlRGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGVuYWJsZWQpXG57XG4gICAgaWYgKGVuYWJsZWQgJiYgdHlwZW9mIChlbmFibGVkKSA9PSBcIm9iamVjdFwiICYmIGVuYWJsZWQuYWRkRXZlbnRMaXN0ZW5lcikgLy8gcG9ydFxuICAgIHtcbiAgICAgICAgaWYgKGVuYWJsZWQuY2hhbmdlTGlzdGVuZXIpZW5hYmxlZC5yZW1vdmVFdmVudExpc3RlbmVyKGVuYWJsZWQuY2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgICAgIGVuYWJsZWQub25Ub2dnbGVEZWZpbmUgPSAodikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVEZWZpbmUobmFtZSwgdik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW5hYmxlZC5jaGFuZ2VMaXN0ZW5lciA9IGVuYWJsZWQub24oXCJjaGFuZ2VcIiwgZW5hYmxlZC5vblRvZ2dsZURlZmluZSk7XG4gICAgICAgIGVuYWJsZWQgPSBlbmFibGVkLmdldCgpO1xuICAgIH1cblxuICAgIGlmIChlbmFibGVkKSB0aGlzLmRlZmluZShuYW1lKTtcbiAgICBlbHNlIHRoaXMucmVtb3ZlRGVmaW5lKG5hbWUpO1xufTtcblxuLyoqXG4gKiBhZGQgYSBkZWZpbmUgdG8gYSBzaGFkZXIsIGUuZy4gICNkZWZpbmUgRE9fVEhJU19USEFUIDFcbiAqIEBmdW5jdGlvbiBkZWZpbmVcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSAoY2FuIGJlIGVtcHR5KVxuICovXG5TaGFkZXIucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSlcbntcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSBcIlwiO1xuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09IFwib2JqZWN0XCIpIC8vIHBvcnRcbiAgICB7XG4gICAgICAgIHZhbHVlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdmFsdWUub25EZWZpbmVDaGFuZ2UpO1xuICAgICAgICB2YWx1ZS5vbkRlZmluZUNoYW5nZSA9ICh2KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZShuYW1lLCB2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWUub24oXCJjaGFuZ2VcIiwgdmFsdWUub25EZWZpbmVDaGFuZ2UpO1xuXG4gICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0KCk7XG4gICAgfVxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RlZmluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZGVmaW5lc1tpXVswXSA9PSBuYW1lICYmIHRoaXMuX2RlZmluZXNbaV1bMV0gPT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZXNbaV1bMF0gPT0gbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5lc1tpXVsxXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwiZGVmaW5lIFwiICsgbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRXaHlDb21waWxlKFwiZGVmaW5lIFwiICsgbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLl9kZWZpbmVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldERlZmluZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9kZWZpbmVzO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXREZWZpbmUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RlZmluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbmVzW2ldWzBdID09IG5hbWUpIHJldHVybiB0aGlzLl9kZWZpbmVzW2ldWzFdO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiByZXR1cm4gdHJ1ZSBpZiBzaGFkZXIgaGFzIGRlZmluZVxuICogQGZ1bmN0aW9uIGhhc0RlZmluZVxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5oYXNEZWZpbmUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RlZmluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbmVzW2ldWzBdID09IG5hbWUpIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgYSBkZWZpbmUgZnJvbSBhIHNoYWRlclxuICogQHBhcmFtIHtuYW1lfSBuYW1lXG4gKiBAZnVuY3Rpb24gcmVtb3ZlRGVmaW5lXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5yZW1vdmVEZWZpbmUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RlZmluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZGVmaW5lc1tpXVswXSA9PSBuYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9kZWZpbmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwiZGVmaW5lIHJlbW92ZWQ6XCIgKyBuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiByZW1vdmUgYSBtb2R1bGUgZnJvbSBzaGFkZXJcbiAqIEBmdW5jdGlvbiByZW1vdmVNb2R1bGVcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtzaGFkZXJNb2R1bGV9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIGJlIHJlbW92ZWRcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5yZW1vdmVNb2R1bGUgPSBmdW5jdGlvbiAobW9kKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLmlkKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kdWxlc1tpXS5pZCA9PSBtb2QuaWQgfHwgIXRoaXMuX21vZHVsZXNbaV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZm91bmQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbal0uZ2V0TmFtZSgpLmluZGV4T2YobW9kLnByZWZpeCkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmlmb3Jtcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcInJlbW92ZSBtb2R1bGUgXCIgKyBtb2QudGl0bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5TaGFkZXIucHJvdG90eXBlLmdldE51bU1vZHVsZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9tb2R1bGVzLmxlbmd0aDtcbn07XG5cblxuU2hhZGVyLnByb3RvdHlwZS5nZXRDdXJyZW50TW9kdWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21vZHVsZXM7IH07XG5cblxuLyoqXG4gKiBhZGQgYSBtb2R1bGVcbiAqIEBmdW5jdGlvbiBhZGRNb2R1bGVcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtzaGFkZXJNb2R1bGV9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIGJlIGFkZGVkXG4gKiBAcGFyYW0ge3NoYWRlck1vZHVsZX0gW3NpYmxpbmddIHNpYmxpbmcgbW9kdWxlLCBuZXcgbW9kdWxlIHdpbGwgc2hhcmUgdGhlIHNhbWUgZ3JvdXBcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5hZGRNb2R1bGUgPSBmdW5jdGlvbiAobW9kLCBzaWJsaW5nKVxue1xuICAgIGlmICh0aGlzLmhhc01vZHVsZShtb2QuaWQpKSByZXR1cm47XG4gICAgaWYgKCFtb2QuaWQpIG1vZC5pZCA9IENBQkxFUy5zaW1wbGVJZCgpO1xuICAgIGlmICghbW9kLm51bUlkKSBtb2QubnVtSWQgPSB0aGlzLl9tb2R1bGVOdW1JZDtcbiAgICBpZiAoIW1vZC5udW0pbW9kLm51bSA9IHRoaXMuX21vZHVsZXMubGVuZ3RoO1xuICAgIGlmIChzaWJsaW5nICYmICFzaWJsaW5nLmdyb3VwKSBzaWJsaW5nLmdyb3VwID0gc2ltcGxlSWQoKTtcblxuICAgIGlmICghbW9kLmdyb3VwKVxuICAgICAgICBpZiAoc2libGluZykgbW9kLmdyb3VwID0gc2libGluZy5ncm91cDtcbiAgICAgICAgZWxzZSBtb2QuZ3JvdXAgPSBzaW1wbGVJZCgpO1xuXG4gICAgbW9kLnByZWZpeCA9IFwibW9kXCIgKyBtb2QuZ3JvdXAgKyBcIl9cIjtcbiAgICB0aGlzLl9tb2R1bGVzLnB1c2gobW9kKTtcblxuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJhZGQgbW9kdWxlIFwiICsgbW9kLnRpdGxlKTtcbiAgICB0aGlzLl9tb2R1bGVOdW1JZCsrO1xuXG4gICAgcmV0dXJuIG1vZDtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuaGFzTW9kdWxlID0gZnVuY3Rpb24gKG1vZElkKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9tb2R1bGVzW2ldLmlkID09IG1vZElkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKG5hbWVzKVxue1xuICAgIHRoaXMuX21vZHVsZU5hbWVzID0gbmFtZXM7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5uZWVkc1JlY29tcGlsZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX25lZWRzUmVjb21waWxlO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5zZXREcmF3QnVmZmVycyA9IGZ1bmN0aW9uIChhcnIpXG57XG4gICAgY29uc29sZS5sb2coXCJ1c2VsZXNzIGRyYXdidWZmZXJzLi4uPyFcIik7XG4gICAgLy8gaWYgKHRoaXMuX2RyYXdCdWZmZXJzLmxlbmd0aCAhPT0gYXJyLmxlbmd0aClcbiAgICAvLyB7XG4gICAgLy8gICAgIHRoaXMuX2RyYXdCdWZmZXJzID0gYXJyO1xuICAgIC8vICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgLy8gICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcInNldERyYXdCdWZmZXJzXCIpO1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKVxuICAgIC8vIHtcbiAgICAvLyAgICAgaWYgKGFycltpXSAhPT0gdGhpcy5fZHJhd0J1ZmZlcnNbaV0pXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgIHRoaXMuX2RyYXdCdWZmZXJzID0gYXJyO1xuICAgIC8vICAgICAgICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgIC8vICAgICAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwic2V0RHJhd0J1ZmZlcnNcIik7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fdW5pZm9ybXM7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldFVuaWZvcm0gPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpID09IG5hbWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5pZm9ybXNbaV07XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLnJlbW92ZUFsbFVuaWZvcm1zID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl91bmlmb3JtcyA9IFtdO1xuICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAgLy8gICAgIHRoaXMucmVtb3ZlVW5pZm9ybSh0aGlzLl91bmlmb3Jtc1tpXS5uYW1lKTtcbn07XG5cblNoYWRlci5wcm90b3R5cGUucmVtb3ZlVW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpID09IG5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3VuaWZvcm1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgdGhpcy5zZXRXaHlDb21waWxlKFwicmVtb3ZlIHVuaWZvcm0gXCIgKyBuYW1lKTtcbn07XG5cblxuU2hhZGVyLnByb3RvdHlwZS5fYWRkVW5pZm9ybSA9IGZ1bmN0aW9uICh1bmkpXG57XG4gICAgdGhpcy5fdW5pZm9ybXMucHVzaCh1bmkpO1xuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImFkZCB1bmlmb3JtIFwiICsgbmFtZSk7XG4gICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBhZGQgYSB1bmlmb3JtIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFsnZicsJ3QnLCBldGNdXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHthbnl9IHZhbHVlIG9yIHBvcnRcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1GcmFnXG4gKiBAcmV0dXJucyB7Q0dMLlVuaWZvcm19XG4gKi9cblNoYWRlci5wcm90b3R5cGUuYWRkVW5pZm9ybUZyYWcgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpXG57XG4gICAgY29uc3QgdW5pID0gbmV3IENHTC5Vbmlmb3JtKHRoaXMsIHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KTtcbiAgICB1bmkuc2hhZGVyVHlwZSA9IFwiZnJhZ1wiO1xuICAgIHJldHVybiB1bmk7XG59O1xuXG4vKipcbiAqIGFkZCBhIHVuaWZvcm0gdG8gdGhlIHZlcnRleCBzaGFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFsnZicsJ3QnLCBldGNdXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHthbnl9IHZhbHVlIG9yIHBvcnRcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1WZXJ0XG4gKiBAcmV0dXJucyB7Q0dMLlVuaWZvcm19XG4gKi9cblNoYWRlci5wcm90b3R5cGUuYWRkVW5pZm9ybVZlcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpXG57XG4gICAgY29uc3QgdW5pID0gbmV3IENHTC5Vbmlmb3JtKHRoaXMsIHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KTtcbiAgICB1bmkuc2hhZGVyVHlwZSA9IFwidmVydFwiO1xuICAgIHJldHVybiB1bmk7XG59O1xuLyoqXG4gKiBhZGQgYSB1bmlmb3JtIHRvIGJvdGggc2hhZGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgWydmJywndCcsIGV0Y11cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgb3IgcG9ydFxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gYWRkVW5pZm9ybUJvdGhcbiAqIEByZXR1cm5zIHtDR0wuVW5pZm9ybX1cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5hZGRVbmlmb3JtQm90aCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNClcbntcbiAgICBjb25zdCB1bmkgPSBuZXcgQ0dMLlVuaWZvcm0odGhpcywgdHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpO1xuICAgIHVuaS5zaGFkZXJUeXBlID0gXCJib3RoXCI7XG4gICAgcmV0dXJuIHVuaTtcbn07XG5cbi8qKlxuICogYWRkIGEgc3RydWN0ICYgaXRzIHVuaWZvcm1zIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJ1Y3ROYW1lIG5hbWUgb2YgdGhlIHN0cnVjdCwgaS5lLjogTGlnaHRTdHJ1Y3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bmlmb3JtTmFtZSBuYW1lIG9mIHRoZSBzdHJ1Y3QgdW5pZm9ybSBpbiB0aGUgc2hhZGVyLCBpLmUuOiBsaWdodFVuaVxuICogQHBhcmFtIHtBcnJheX0gbWVtYmVycyBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0cnVjdCBtZW1iZXJzLiBzZWUgZXhhbXBsZSBmb3Igc3RydWN0dXJlXG5cbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1TdHJ1Y3RGcmFnXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNoYWRlciA9IG5ldyBDR0wuU2hhZGVyKGNnbCwgJ01pbmltYWxNYXRlcmlhbCcpO1xuICogc2hhZGVyLnNldFNvdXJjZShhdHRhY2htZW50cy5zaGFkZXJfdmVydCwgYXR0YWNobWVudHMuc2hhZGVyX2ZyYWcpO1xuICogc2hhZGVyLmFkZFVuaWZvcm1TdHJ1Y3RGcmFnKFwiTGlnaHRcIiwgXCJ1bmlmb3JtTGlnaHRcIiwgW1xuICogeyBcInR5cGVcIjogXCIzZlwiLCBcIm5hbWVcIjogXCJwb3NpdGlvblwiLCBcInYxXCI6IG51bGwgfSxcbiAqIHsgXCJ0eXBlXCI6IFwiNGZcIiwgXCJuYW1lXCI6IFwiY29sb3JcIiwgXCJ2MVwiOiBpblIsIHYyOiBpbkcsIHYzOiBpbkIsIHY0OiBpbkFscGhhIH1cbiAqIF0pO1xuICovXG5TaGFkZXIucHJvdG90eXBlLmFkZFVuaWZvcm1TdHJ1Y3RGcmFnID0gZnVuY3Rpb24gKHN0cnVjdE5hbWUsIHVuaWZvcm1OYW1lLCBtZW1iZXJzKVxue1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge307XG5cbiAgICBpZiAoIW1lbWJlcnMpIHJldHVybiB1bmlmb3JtcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IG1lbWJlcnNbaV07XG4gICAgICAgIGlmICghdGhpcy5oYXNVbmlmb3JtKHVuaWZvcm1OYW1lICsgXCIuXCIgKyBtZW1iZXIubmFtZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaSA9IG5ldyBDR0wuVW5pZm9ybSh0aGlzLCBtZW1iZXIudHlwZSwgdW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lLCBtZW1iZXIudjEsIG1lbWJlci52MiwgbWVtYmVyLnYzLCBtZW1iZXIudjQsIHVuaWZvcm1OYW1lLCBzdHJ1Y3ROYW1lLCBtZW1iZXIubmFtZSk7XG4gICAgICAgICAgICB1bmkuc2hhZGVyVHlwZSA9IFwiZnJhZ1wiO1xuICAgICAgICAgICAgdW5pZm9ybXNbdW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lXSA9IHVuaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3Jtcztcbn07XG5cbi8qKlxuICogYWRkIGEgc3RydWN0ICYgaXRzIHVuaWZvcm1zIHRvIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RydWN0TmFtZSBuYW1lIG9mIHRoZSBzdHJ1Y3QsIGkuZS46IExpZ2h0U3RydWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pZm9ybU5hbWUgbmFtZSBvZiB0aGUgc3RydWN0IHVuaWZvcm0gaW4gdGhlIHNoYWRlciwgaS5lLjogbGlnaHRVbmlcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbWJlcnMgYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBzdHJ1Y3QgbWVtYmVycy4gc2VlIGV4YW1wbGUgZm9yIHN0cnVjdHVyZVxuXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBmdW5jdGlvbiBhZGRVbmlmb3JtU3RydWN0VmVydFxuICogQHJldHVybnMge0NHTC5Vbmlmb3JtfVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNoYWRlciA9IG5ldyBDR0wuU2hhZGVyKGNnbCwgJ01pbmltYWxNYXRlcmlhbCcpO1xuICogc2hhZGVyLnNldFNvdXJjZShhdHRhY2htZW50cy5zaGFkZXJfdmVydCwgYXR0YWNobWVudHMuc2hhZGVyX2ZyYWcpO1xuICogc2hhZGVyLmFkZFVuaWZvcm1TdHJ1Y3RWZXJ0KFwiTGlnaHRcIiwgXCJ1bmlmb3JtTGlnaHRcIiwgW1xuICogeyBcInR5cGVcIjogXCIzZlwiLCBcIm5hbWVcIjogXCJwb3NpdGlvblwiLCBcInYxXCI6IG51bGwgfSxcbiAqIHsgXCJ0eXBlXCI6IFwiNGZcIiwgXCJuYW1lXCI6IFwiY29sb3JcIiwgXCJ2MVwiOiBpblIsIHYyOiBpbkcsIHYzOiBpbkIsIHY0OiBpbkFscGhhIH1cbiAqIF0pO1xuICovXG5TaGFkZXIucHJvdG90eXBlLmFkZFVuaWZvcm1TdHJ1Y3RWZXJ0ID0gZnVuY3Rpb24gKHN0cnVjdE5hbWUsIHVuaWZvcm1OYW1lLCBtZW1iZXJzKVxue1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge307XG5cbiAgICBpZiAoIW1lbWJlcnMpIHJldHVybiB1bmlmb3JtcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IG1lbWJlcnNbaV07XG4gICAgICAgIGlmICghdGhpcy5oYXNVbmlmb3JtKHVuaWZvcm1OYW1lICsgXCIuXCIgKyBtZW1iZXIubmFtZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaSA9IG5ldyBDR0wuVW5pZm9ybSh0aGlzLCBtZW1iZXIudHlwZSwgdW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lLCBtZW1iZXIudjEsIG1lbWJlci52MiwgbWVtYmVyLnYzLCBtZW1iZXIudjQsIHVuaWZvcm1OYW1lLCBzdHJ1Y3ROYW1lLCBtZW1iZXIubmFtZSk7XG4gICAgICAgICAgICB1bmkuc2hhZGVyVHlwZSA9IFwidmVydFwiO1xuICAgICAgICAgICAgdW5pZm9ybXNbdW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lXSA9IHVuaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3Jtcztcbn07XG5cbi8qKlxuICogYWRkIGEgc3RydWN0ICYgaXRzIHVuaWZvcm1zIHRvIHRoZSBib3RoIHNoYWRlcnMuIFBMRUFTRSBOT1RFOiBpdCBpcyBub3QgcG9zc2libGUgdG8gYWRkIHRoZSBzYW1lIHN0cnVjdCB0byBib3RoIHNoYWRlcnMgd2hlbiBpdCBjb250YWlucyBBTlkgaW50ZWdlciBtZW1iZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cnVjdE5hbWUgbmFtZSBvZiB0aGUgc3RydWN0LCBpLmUuOiBMaWdodFN0cnVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1OYW1lIG5hbWUgb2YgdGhlIHN0cnVjdCB1bmlmb3JtIGluIHRoZSBzaGFkZXIsIGkuZS46IGxpZ2h0VW5pXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1iZXJzIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgc3RydWN0IG1lbWJlcnMuIHNlZSBleGFtcGxlIGZvciBzdHJ1Y3R1cmVcblxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gYWRkVW5pZm9ybVN0cnVjdEJvdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc2hhZGVyID0gbmV3IENHTC5TaGFkZXIoY2dsLCAnTWluaW1hbE1hdGVyaWFsJyk7XG4gKiBzaGFkZXIuc2V0U291cmNlKGF0dGFjaG1lbnRzLnNoYWRlcl92ZXJ0LCBhdHRhY2htZW50cy5zaGFkZXJfZnJhZyk7XG4gKiBzaGFkZXIuYWRkVW5pZm9ybVN0cnVjdEJvdGgoXCJMaWdodFwiLCBcInVuaWZvcm1MaWdodFwiLCBbXG4gKiB7IFwidHlwZVwiOiBcIjNmXCIsIFwibmFtZVwiOiBcInBvc2l0aW9uXCIsIFwidjFcIjogbnVsbCB9LFxuICogeyBcInR5cGVcIjogXCI0ZlwiLCBcIm5hbWVcIjogXCJjb2xvclwiLCBcInYxXCI6IGluUiwgdjI6IGluRywgdjM6IGluQiwgdjQ6IGluQWxwaGEgfVxuICogXSk7XG4gKi9cblNoYWRlci5wcm90b3R5cGUuYWRkVW5pZm9ybVN0cnVjdEJvdGggPSBmdW5jdGlvbiAoc3RydWN0TmFtZSwgdW5pZm9ybU5hbWUsIG1lbWJlcnMpXG57XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7fTtcblxuICAgIGlmICghbWVtYmVycykgcmV0dXJuIHVuaWZvcm1zO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gbWVtYmVyc1tpXTtcbiAgICAgICAgaWYgKChtZW1iZXIudHlwZSA9PT0gXCIyaVwiIHx8IG1lbWJlci50eXBlID09PSBcImlcIiB8fCBtZW1iZXIudHlwZSA9PT0gXCIzaVwiKSlcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIkFkZGluZyBhbiBpbnRlZ2VyIHN0cnVjdCBtZW1iZXIgdG8gYm90aCBzaGFkZXJzIGNhbiBwb3RlbnRpYWxseSBlcnJvci4gUGxlYXNlIHVzZSBkaWZmZXJlbnQgc3RydWN0cyBmb3IgZWFjaCBzaGFkZXIuIEVycm9yIG9jY3VyZWQgaW4gc3RydWN0OlwiLCBzdHJ1Y3ROYW1lLCBcIiB3aXRoIG1lbWJlcjpcIiwgbWVtYmVyLm5hbWUsIFwiIG9mIHR5cGU6XCIsIG1lbWJlci50eXBlLCBcIi5cIik7XG4gICAgICAgIGlmICghdGhpcy5oYXNVbmlmb3JtKHVuaWZvcm1OYW1lICsgXCIuXCIgKyBtZW1iZXIubmFtZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaSA9IG5ldyBDR0wuVW5pZm9ybSh0aGlzLCBtZW1iZXIudHlwZSwgdW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lLCBtZW1iZXIudjEsIG1lbWJlci52MiwgbWVtYmVyLnYzLCBtZW1iZXIudjQsIHVuaWZvcm1OYW1lLCBzdHJ1Y3ROYW1lLCBtZW1iZXIubmFtZSk7XG4gICAgICAgICAgICB1bmkuc2hhZGVyVHlwZSA9IFwiYm90aFwiO1xuICAgICAgICAgICAgdW5pZm9ybXNbdW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lXSA9IHVuaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3Jtcztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuaGFzVW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpID09IG5hbWUpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLl9jcmVhdGVQcm9ncmFtID0gZnVuY3Rpb24gKHZzdHIsIGZzdHIpXG57XG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJiZWZvcmUgX2NyZWF0ZXByb2dyYW1cIik7XG5cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIHRoaXMudnNoYWRlciA9IFNoYWRlci5jcmVhdGVTaGFkZXIodGhpcy5fY2dsLCB2c3RyLCB0aGlzLl9jZ2wuZ2wuVkVSVEVYX1NIQURFUiwgdGhpcyk7XG4gICAgdGhpcy5mc2hhZGVyID0gU2hhZGVyLmNyZWF0ZVNoYWRlcih0aGlzLl9jZ2wsIGZzdHIsIHRoaXMuX2NnbC5nbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMpO1xuXG5cbiAgICBpZiAodGhpcy52c2hhZGVyICYmIHRoaXMuZnNoYWRlcilcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdGhpcy52c2hhZGVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB0aGlzLmZzaGFkZXIpO1xuXG4gICAgICAgIHRoaXMuX2xpbmtQcm9ncmFtKHByb2dyYW0sIHZzdHIsIGZzdHIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwic2hhZGVyIF9jcmVhdGVQcm9ncmFtXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvdWxkIG5vdCBsaW5rIHNoYWRlcnByb2dyYW1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwic2hhZGVyIF9jcmVhdGVQcm9ncmFtXCIpO1xuICAgIHJldHVybiBwcm9ncmFtO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5oYXNFcnJvcnMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9oYXNFcnJvcnM7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLl9saW5rUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtLCB2c3RyLCBmc3RyKVxue1xuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwiYmVmb3JlIF9saW5rcHJvZ3JhbVwiKTtcblxuICAgIGlmICh0aGlzLl9mZWVkQmFja05hbWVzLmxlbmd0aCA+IDApXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyhwcm9ncmFtLCB0aGlzLl9mZWVkQmFja05hbWVzLCB0aGlzLl9jZ2wuZ2wuU0VQQVJBVEVfQVRUUklCUyk7XG4gICAgICAgIC8vIElOVEVSTEVBVkVEX0FUVFJJQlNcbiAgICAgICAgLy8gU0VQQVJBVEVfQVRUUklCU1xuICAgIH1cblxuICAgIHRoaXMuX2NnbC5nbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcImdsLmxpbmtwcm9ncmFtXCIpO1xuICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuXG4gICAgdGhpcy5faGFzRXJyb3JzID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fY2dsLnBhdGNoLmNvbmZpZy5nbFZhbGlkYXRlU2hhZGVyICE9PSBmYWxzZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jZ2wuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLl9jZ2wuZ2wuVkFMSURBVEVfU1RBVFVTKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdmFsaWRhdGlvbiBmYWlsZWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2hhZGVycHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC4uLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX25hbWUgKyBcIiBwcm9ncmFtaW5mbzogXCIsIHRoaXMuX2NnbC5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NnbC5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuX2NnbC5nbC5MSU5LX1NUQVRVUykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLl9jZ2wuZ2wuZ2V0U2hhZGVySW5mb0xvZyh0aGlzLmZzaGFkZXIpIHx8IFwiZW1wdHkgc2hhZGVyIGluZm9sb2dcIik7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLl9jZ2wuZ2wuZ2V0U2hhZGVySW5mb0xvZyh0aGlzLnZzaGFkZXIpIHx8IFwiZW1wdHkgc2hhZGVyIGluZm9sb2dcIik7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IodGhpcy5fbmFtZSArIFwiIHNoYWRlciBsaW5raW5nIGZhaWwuLi5cIik7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3JjRnJhZ1wiLCBmc3RyKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3JjVmVydFwiLCB2c3RyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX25hbWUgKyBcIiBwcm9ncmFtaW5mbzogXCIsIHRoaXMuX2NnbC5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgICAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSBcImVycm9yc2hhZGVyXCI7XG4gICAgICAgICAgICB0aGlzLnNldFNvdXJjZShTaGFkZXIuZ2V0RGVmYXVsdFZlcnRleFNoYWRlcigpLCBTaGFkZXIuZ2V0RXJyb3JGcmFnbWVudFNoYWRlcigpKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwic2hhZGVyIGxpbmsgZXJyXCIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXRQcm9ncmFtID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbTtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuc2V0RmVlZGJhY2tOYW1lcyA9IGZ1bmN0aW9uIChuYW1lcylcbntcbiAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJzZXRGZWVkYmFja05hbWVzXCIpO1xuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLl9mZWVkQmFja05hbWVzID0gbmFtZXM7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldERlZmF1bHRWZXJ0ZXhTaGFkZXIgPSBTaGFkZXIuZ2V0RGVmYXVsdFZlcnRleFNoYWRlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIGRlZmF1bHRTaGFkZXJTcmNWZXJ0O1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXREZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSBTaGFkZXIuZ2V0RGVmYXVsdEZyYWdtZW50U2hhZGVyID0gZnVuY3Rpb24gKHIsIGcsIGIpXG57XG4gICAgaWYgKHIgPT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgciA9IDAuNTtcbiAgICAgICAgZyA9IDAuNTtcbiAgICAgICAgYiA9IDAuNTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCJcbiAgICAgICAgLmVuZGwoKSArIFwiSU4gdmVjMiB0ZXhDb29yZDtcIlxuICAgICAgICAuZW5kbCgpICsgXCJ7e01PRFVMRVNfSEVBRH19XCJcbiAgICAgICAgLmVuZGwoKSArIFwidm9pZCBtYWluKClcIlxuICAgICAgICAuZW5kbCgpICsgXCJ7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgIHZlYzQgY29sPXZlYzQoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsMS4wKTtcIlxuICAgICAgICAuZW5kbCgpICsgXCIgICAge3tNT0RVTEVfQ09MT1J9fVwiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgICBvdXRDb2xvciA9IGNvbDtcIlxuICAgICAgICAuZW5kbCgpICsgXCJ9XCI7XG59O1xuXG4vKipcbiAgKiBhZGRzIGF0dHJpYnV0ZSBkZWZpbml0aW9uIHRvIHNoYWRlciBoZWFkZXIgd2l0aG91dCBjb2xsaWRpbmcgd2l0aCBvdGhlciBzaGFkZXIgbW9kdWxlcy4uLlxuICogd2hlbiBhdHRyRnJhZyBpcyBkZWZpbmVkLCB2ZXJ0ZXggc2hhZGVyIHdpbGwgb3V0cHV0IHRoaXMgYXR0cmlidXRlIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmliT2JqZWN0IHt0eXBlOngsbmFtZTp4LFtuYW1lRnJhZzp4XX1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cilcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1tpXS5uYW1lID09IGF0dHIubmFtZSAmJiB0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWVGcmFnID09IGF0dHIubmFtZUZyYWcpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJhZGRBdHRyaWJ1dGVcIik7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmJpbmRUZXh0dXJlcyA9XG5TaGFkZXIucHJvdG90eXBlLl9iaW5kVGV4dHVyZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl90ZXh0dXJlU3RhY2tUZXgubGVuZ3RoID4gdGhpcy5fY2dsLm1heFRleHR1cmVVbml0cylcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwiW3NoYWRlci5fYmluZFRleHR1cmVzXSB0b28gbWFueSB0ZXh0dXJlcyBib3VuZFwiLCB0aGlzLl90ZXh0dXJlU3RhY2tUZXgubGVuZ3RoICsgXCIvXCIgKyB0aGlzLl9jZ2wubWF4VGV4dHVyZVVuaXRzKTtcbiAgICB9XG5cbiAgICAvLyBmb3IgKGxldCBpID0gdGhpcy5fdGV4dHVyZVN0YWNrVGV4Lmxlbmd0aCArIDE7IGkgPCB0aGlzLl9jZ2wubWF4VGV4dHVyZVVuaXRzOyBpKyspIHRoaXMuX2NnbC5zZXRUZXh0dXJlKGksIG51bGwpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZXh0dXJlU3RhY2tUZXgubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl90ZXh0dXJlU3RhY2tUZXgubGVuZ3RoLCBpKTtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlU3RhY2tUZXhbaV0gJiYgIXRoaXMuX3RleHR1cmVTdGFja1RleENnbFtpXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJubyB0ZXh0dXJlIGZvciBwdXNodGV4dHVyZVwiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5fdGV4dHVyZVN0YWNrVGV4W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVTdGFja1RleENnbFtpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldLnRleCB8fCBDR0wuVGV4dHVyZS5nZXRFbXB0eVRleHR1cmUodGhpcy5fY2dsKS50ZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBiaW5kT2sgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmVTdGFja1VuaVtpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyhuZXcgRXJyb3IoJ25vIHVuaWZvcm0gZ2l2ZW4gdG8gdGV4dHVyZXN0YWNrJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwibm8gdW5pZm9ybSBmb3IgcHVzaHRleHR1cmVcIiwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICAgICAgYmluZE9rID0gdGhpcy5fY2dsLnNldFRleHR1cmUoaSwgdCwgdGhpcy5fdGV4dHVyZVN0YWNrVHlwZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVW5pW2ldLnNldFZhbHVlKGkpO1xuICAgICAgICAgICAgICAgIGJpbmRPayA9IHRoaXMuX2NnbC5zZXRUZXh0dXJlKGksIHQsIHRoaXMuX3RleHR1cmVTdGFja1R5cGVbaV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYmluZE9rLCBpLCB0LCB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmluZE9rKSBjb25zb2xlLndhcm4oXCJ0ZXggYmluZCBmYWlsZWRcIiwgdGhpcy5nZXROYW1lKCksIHRoaXMuX3RleHR1cmVTdGFja1VuaVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLnNldFVuaWZvcm1UZXh0dXJlID0gZnVuY3Rpb24gKHVuaSwgdGV4KVxue1xuICAgIHRleCA9IHRleCB8fCBDR0wuVGV4dHVyZS5nZXRUZW1wVGV4dHVyZSh0aGlzLl9jZ2wpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGV4dHVyZVN0YWNrVW5pLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZVN0YWNrVW5pW2ldID09IHVuaSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5fdGV4dHVyZVN0YWNrVGV4W2ldIHx8IHRoaXMuX3RleHR1cmVTdGFja1RleENnbFtpXTtcbiAgICAgICAgICAgIGlmICh0ZXguaGFzT3duUHJvcGVydHkoXCJ0ZXhcIikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldID0gdGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1RleFtpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhbaV0gPSB0ZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMuX3RleHR1cmVTdGFja1RleFtpXSA9IHRleDtcbiAgICAgICAgICAgIC8vIHRoaXMuX2NnbC5zZXRUZXh0dXJlKGksIHRleCwgdGhpcy5fdGV4dHVyZVN0YWNrVHlwZVtpXSk7XG4gICAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIHB1c2ggYSB0ZXh0dXJlIG9uIHRoZSBzdGFjay4gdGhvc2UgdGV4dHVyZXMgd2lsbCBiZSBib3VuZCB3aGVuIGJpbmRpbmcgdGhlIHNoYWRlci4gdGV4dHVyZSBzbG90cyBhcmUgYXV0b21hdGljYWxseSBzZXRcbiAqIEBwYXJhbSB7dW5pZm9ybX0gdGV4dHVyZSB1bmlmb3JtXG4gKiBAcGFyYW0ge3RleHR1cmV9IHRleHR1cmVcbiAqIEBwYXJhbSB7dHlwZX0gdGV4dHVyZSB0eXBlLCBjYW4gYmUgaWdub3JlZCB3aGVuIFRFWFRVUkVfMkRcbiAqIEBmdW5jdGlvbiBwdXNoVGV4dHVyZVxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKi9cblNoYWRlci5wcm90b3R5cGUucHVzaFRleHR1cmUgPSBmdW5jdGlvbiAodW5pZm9ybSwgdCwgdHlwZSlcbntcbiAgICBpZiAoIXVuaWZvcm0pXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5vIHVuaWZvcm0gZ2l2ZW4gdG8gdGV4dHVyZXN0YWNrXCIsIHVuaWZvcm0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0Lmhhc093blByb3BlcnR5KFwidGV4XCIpICYmICEodCBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSkpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cud2FybihuZXcgRXJyb3IoXCJpbnZhbGlkIHRleHR1cmVcIikuc3RhY2spO1xuXG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwiW2NnbF9zaGFkZXJdIGludmFsaWQgdGV4dHVyZS4uLlwiLCB0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3RleHR1cmVTdGFja1VuaS5wdXNoKHVuaWZvcm0pO1xuXG4gICAgaWYgKHQuaGFzT3duUHJvcGVydHkoXCJ0ZXhcIikpXG4gICAge1xuICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2wucHVzaCh0KTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4LnB1c2gobnVsbCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1RleENnbC5wdXNoKG51bGwpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXgucHVzaCh0KTtcbiAgICB9XG5cbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlLnB1c2godHlwZSk7XG59O1xuXG4vKipcbiAqIHBvcCBsYXN0IHRleHR1cmVcbiAqIEBmdW5jdGlvbiBwb3BUZXh0dXJlXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5wb3BUZXh0dXJlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tVbmkucG9wKCk7XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4LnBvcCgpO1xuICAgIHRoaXMuX3RleHR1cmVTdGFja1RleENnbC5wb3AoKTtcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlLnBvcCgpO1xufTtcblxuLyoqXG4gKiBwb3AgYWxsIHRleHR1cmVzXG4gKiBAZnVuY3Rpb24gcG9wVGV4dHVyZXNcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICovXG5TaGFkZXIucHJvdG90eXBlLnBvcFRleHR1cmVzID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXgubGVuZ3RoID1cbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2wubGVuZ3RoID1cbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlLmxlbmd0aCA9XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVW5pLmxlbmd0aCA9IDA7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldE1hdGVyaWFsSWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbElkO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXRJbmZvID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBpbmZvID0ge307XG4gICAgaW5mby5uYW1lID0gdGhpcy5fbmFtZTtcbiAgICAvLyBpbmZvLm1vZHVsZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZHVsZXMpKTtcbiAgICAvLyBpbmZvLmRlZmluZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX2RlZmluZXMpKTtcbiAgICBpbmZvLmRlZmluZXMgPSB0aGlzLmdldERlZmluZXMoKTtcbiAgICBpbmZvLmhhc0Vycm9ycyA9IHRoaXMuaGFzRXJyb3JzKCk7XG5cbiAgICByZXR1cm4gaW5mbztcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblNoYWRlci5nZXRFcnJvckZyYWdtZW50U2hhZGVyID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gXCJcIlxuICAgICAgICAuZW5kbCgpICsgXCJ2b2lkIG1haW4oKVwiXG4gICAgICAgIC5lbmRsKCkgKyBcIntcIlxuICAgICAgICAuZW5kbCgpICsgXCIgICBmbG9hdCBnPW1vZCgoZ2xfRnJhZ0Nvb3JkLnkrZ2xfRnJhZ0Nvb3JkLngpLDUwLjApLzUwLjA7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgZz0gc3RlcCgwLjEsZyk7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgb3V0Q29sb3IgPSB2ZWM0KCBnKzAuNSwgMC4wLCAwLjAsIDEuMCk7XCJcbiAgICAgICAgLmVuZGwoKSArIFwifVwiO1xufTtcblxuU2hhZGVyLmNyZWF0ZVNoYWRlciA9IGZ1bmN0aW9uIChjZ2wsIHN0ciwgdHlwZSwgY2dsU2hhZGVyKVxue1xuICAgIGlmIChjZ2wuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgLy8gY2dsLnByaW50RXJyb3IoXCJbU2hhZGVyLmNyZWF0ZVNoYWRlcl0gXCIsIGNnbFNoYWRlci5fbmFtZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRCYWRMaW5lcyhpbmZvTG9nKVxuICAgIHtcbiAgICAgICAgY29uc3QgYmFzTGluZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBpbmZvTG9nLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gbGluZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGRpdmlkZSA9IGxpbmVzW2ldLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIGlmIChwYXJzZUludChkaXZpZGVbMl0sIDEwKSkgYmFzTGluZXMucHVzaChwYXJzZUludChkaXZpZGVbMl0sIDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc0xpbmVzO1xuICAgIH1cblxuXG4gICAgY29uc3Qgc2hhZGVyID0gY2dsLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICBjZ2wuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3RyKTtcbiAgICBjZ2wuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgaWYgKCFjZ2wuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgY2dsLmdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGxldCBpbmZvTG9nID0gY2dsLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgaWYgKCFpbmZvTG9nKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJlbXB0eSBzaGFkZXIgaW5mbyBsb2dcIiwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcImNvbXBpbGUgc3RhdHVzOiBcIik7XG5cbiAgICAgICAgY29uc3QgYmFkTGluZXMgPSBnZXRCYWRMaW5lcyhpbmZvTG9nKTtcbiAgICAgICAgbGV0IGh0bWxXYXJuaW5nID0gXCI8cHJlIHN0eWxlPVxcXCJtYXJnaW4tYm90dG9tOjBweDtcXFwiPjxjb2RlIGNsYXNzPVxcXCJzaGFkZXJFcnJvckNvZGUgbGFuZ3VhZ2UtZ2xzbFxcXCIgc3R5bGU9XFxcInBhZGRpbmctYm90dG9tOjBweDttYXgtaGVpZ2h0OiBpbml0aWFsO21heC13aWR0aDogaW5pdGlhbDtcXFwiPlwiO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHN0ci5tYXRjaCgvXi4qKChcXHJcXG58XFxufFxccil8JCkvZ20pO1xuXG4gICAgICAgIGlmICghY2dsLmFib3J0ZWQgJiYgaW5mb0xvZylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gY2dsLmdsLlZFUlRFWF9TSEFERVIpIGNvbnNvbGUubG9nKFwiVkVSVEVYX1NIQURFUlwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IGNnbC5nbC5GUkFHTUVOVF9TSEFERVIpIGNvbnNvbGUubG9nKFwiRlJBR01FTlRfU0hBREVSXCIpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gbGluZXMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgaiA9IHBhcnNlSW50KGksIDEwKSArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyBcIjogXCIgKyBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsaW5lKTtcblxuICAgICAgICAgICAgICAgIGxldCBpc0JhZExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJqIGluIGJhZExpbmVzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFkTGluZXNbYmpdID09IGopIGlzQmFkTGluZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNCYWRMaW5lKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbFdhcm5pbmcgKz0gXCI8L2NvZGU+PC9wcmU+XCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0bWxXYXJuaW5nICs9IFwiPHNwYW4gY2xhc3M9XFxcInNoYWRlckVycm9yQ29kZSBlcnJvclxcXCI+XCI7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxXYXJuaW5nICs9IFwiPHByZSBzdHlsZT1cXFwibWFyZ2luOjBcXFwiPjxjb2RlIGNsYXNzPVxcXCJsYW5ndWFnZS1nbHNsXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjojNjYwMDAwO3BhZGRpbmctdG9wOjBweDtwYWRkaW5nLWJvdHRvbTowcHhcXFwiPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodG1sV2FybmluZyArPSBlc2NhcGVIVE1MKGxpbmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQmFkTGluZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxXYXJuaW5nICs9IFwiPC9jb2RlPjwvcHJlPlwiO1xuICAgICAgICAgICAgICAgICAgICBodG1sV2FybmluZyArPSBcIjxwcmUgc3R5bGU9XFxcIm1hcmdpbjowXFxcIj48Y29kZSBjbGFzcz1cXFwibGFuZ3VhZ2UtZ2xzbFxcXCIgc3R5bGU9XFxcIjtwYWRkaW5nLXRvcDowcHg7cGFkZGluZy1ib3R0b206MHB4XFxcIj5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4oaW5mb0xvZyk7XG5cbiAgICAgICAgaW5mb0xvZyA9IGluZm9Mb2cucmVwbGFjZSgvXFxuL2csIFwiPGJyLz5cIik7XG4gICAgICAgIGlmIChjZ2wucGF0Y2guaXNFZGl0b3JNb2RlKCkpY29uc29sZS5sb2coXCJTaGFkZXIgZXJyb3IgXCIsIGNnbFNoYWRlci5fbmFtZSwgaW5mb0xvZywgdGhpcyk7XG5cbiAgICAgICAgaHRtbFdhcm5pbmcgPSBpbmZvTG9nICsgXCI8YnIvPlwiICsgaHRtbFdhcm5pbmcgKyBcIjxici8+PGJyLz5cIjtcbiAgICAgICAgaHRtbFdhcm5pbmcgKz0gXCI8L2NvZGU+PC9wcmU+XCI7XG5cbiAgICAgICAgY2dsLnBhdGNoLmVtaXRFdmVudChcImNyaXRpY2FsRXJyb3JcIiwgeyBcInRpdGxlXCI6IFwiU2hhZGVyIGVycm9yIFwiICsgY2dsU2hhZGVyLl9uYW1lLCBcInRleHRcIjogaHRtbFdhcm5pbmcsIFwiZXhjZXB0aW9uXCI6IHsgXCJtZXNzYWdlXCI6IGluZm9Mb2cgfSB9KTtcblxuICAgICAgICAvLyB0aGlzLl9uYW1lID0gXCJlcnJvcnNoYWRlclwiO1xuICAgICAgICBjZ2xTaGFkZXIuc2V0U291cmNlKFNoYWRlci5nZXREZWZhdWx0VmVydGV4U2hhZGVyKCksIFNoYWRlci5nZXRFcnJvckZyYWdtZW50U2hhZGVyKCkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lKycgc2hhZGVyIGNvbXBpbGVkLi4uJyk7XG4gICAgfVxuICAgIC8vIGNnbC5wcmludEVycm9yKFwic2hhZGVyIGNyZWF0ZTJcIik7XG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cblxuZXhwb3J0IHsgU2hhZGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_shader_lib.js":
/*!****************************************!*\
  !*** ./src/core/cgl/cgl_shader_lib.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderLibMods\": () => (/* binding */ ShaderLibMods)\n/* harmony export */ });\n/* harmony import */ var _cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_shader_uniform */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _cgl_texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_texture */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _cgl_textureeffect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_textureeffect */ \"./src/core/cgl/cgl_textureeffect.js\");\n\n\n\n\nconst ShaderLibMods = {\n    \"CGL.BLENDMODES\": function ()\n    {\n        this.name = \"blendmodes\";\n        this.srcHeadFrag = _cgl_textureeffect__WEBPACK_IMPORTED_MODULE_2__.TextureEffect.getBlendCode();\n    },\n    \"CGL.BLENDMODES3\": function ()\n    {\n        this.name = \"blendmodes3\";\n        this.srcHeadFrag = _cgl_textureeffect__WEBPACK_IMPORTED_MODULE_2__.TextureEffect.getBlendCode(3);\n    },\n\n    \"CGL.LUMINANCE\": function ()\n    {\n        this.name = \"luminance\";\n        this.srcHeadFrag = \"\".endl()\n            + \"float cgl_luminance(vec3 c)\".endl()\n            + \"{\".endl()\n            + \"    return dot(vec3(0.2126,0.7152,0.0722),c);\".endl()\n            + \"}\".endl();\n    },\n\n\n    // quite good random numbers, but somehow don't work in ANGLE\n    \"CGL.RANDOM_OLD\": function ()\n    {\n        this.name = \"randomNumber\";\n        this.srcHeadFrag = \"\".endl()\n            + \"float cgl_random(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);\".endl()\n            + \"}\".endl()\n            + \"vec3 cgl_random3(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));\".endl()\n            + \"}\";\n    },\n\n\n    // low quality generative ranodm numbers\n    \"CGL.RANDOM_LOW\": function ()\n    {\n        this.name = \"randomNumber\";\n        this.srcHeadFrag = \"\".endl()\n            + \"float cgl_random(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);\".endl()\n            + \"}\".endl()\n            + \"vec3 cgl_random3(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));\".endl()\n            + \"}\";\n    },\n\n    // texture based random numbers\n    \"CGL.RANDOM_TEX\": function ()\n    {\n        this.name = \"randomNumbertex\";\n        this.srcHeadFrag = \"\".endl()\n            + \"UNI sampler2D CGLRNDTEX;\".endl()\n            + \"float cgl_random(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return texture(CGLRNDTEX,co*5711.0).r;\".endl()\n            + \"}\".endl()\n            + \"vec3 cgl_random3(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return texture(CGLRNDTEX,co*5711.0).rgb;\".endl()\n            + \"}\";\n\n        this.initUniforms = function (shader)\n        {\n            return [new _cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_0__.Uniform(shader, \"t\", \"CGLRNDTEX\", 7)];\n        };\n\n        this.onBind = function (cgl, shader)\n        {\n            _cgl_texture__WEBPACK_IMPORTED_MODULE_1__.Texture.getRandomTexture(cgl);\n            cgl.setTexture(7, _cgl_texture__WEBPACK_IMPORTED_MODULE_1__.Texture.getRandomTexture(cgl).tex);\n        };\n    },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl9saWIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc2hhZGVyX2xpYi5qcz9mZTk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVuaWZvcm0gfSBmcm9tIFwiLi9jZ2xfc2hhZGVyX3VuaWZvcm1cIjtcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiLi9jZ2xfdGV4dHVyZVwiO1xuaW1wb3J0IHsgVGV4dHVyZUVmZmVjdCB9IGZyb20gXCIuL2NnbF90ZXh0dXJlZWZmZWN0XCI7XG5cbmNvbnN0IFNoYWRlckxpYk1vZHMgPSB7XG4gICAgXCJDR0wuQkxFTkRNT0RFU1wiOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJibGVuZG1vZGVzXCI7XG4gICAgICAgIHRoaXMuc3JjSGVhZEZyYWcgPSBUZXh0dXJlRWZmZWN0LmdldEJsZW5kQ29kZSgpO1xuICAgIH0sXG4gICAgXCJDR0wuQkxFTkRNT0RFUzNcIjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiYmxlbmRtb2RlczNcIjtcbiAgICAgICAgdGhpcy5zcmNIZWFkRnJhZyA9IFRleHR1cmVFZmZlY3QuZ2V0QmxlbmRDb2RlKDMpO1xuICAgIH0sXG5cbiAgICBcIkNHTC5MVU1JTkFOQ0VcIjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwibHVtaW5hbmNlXCI7XG4gICAgICAgIHRoaXMuc3JjSGVhZEZyYWcgPSBcIlwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcImZsb2F0IGNnbF9sdW1pbmFuY2UodmVjMyBjKVwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIntcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCIgICAgcmV0dXJuIGRvdCh2ZWMzKDAuMjEyNiwwLjcxNTIsMC4wNzIyKSxjKTtcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ9XCIuZW5kbCgpO1xuICAgIH0sXG5cblxuICAgIC8vIHF1aXRlIGdvb2QgcmFuZG9tIG51bWJlcnMsIGJ1dCBzb21laG93IGRvbid0IHdvcmsgaW4gQU5HTEVcbiAgICBcIkNHTC5SQU5ET01fT0xEXCI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLm5hbWUgPSBcInJhbmRvbU51bWJlclwiO1xuICAgICAgICB0aGlzLnNyY0hlYWRGcmFnID0gXCJcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJmbG9hdCBjZ2xfcmFuZG9tKHZlYzIgY28pXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwie1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSAsdmVjMigxMi45ODk4LDQuMTQxNCkpKSAqIDQzMjc1OC41NDUzKTtcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ9XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwidmVjMyBjZ2xfcmFuZG9tMyh2ZWMyIGNvKVwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIntcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCIgICAgcmV0dXJuIHZlYzMoIGNnbF9yYW5kb20oY28pLGNnbF9yYW5kb20oY28rMC41NzExKSxjZ2xfcmFuZG9tKGNvKzEuNTcxMSkpO1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIn1cIjtcbiAgICB9LFxuXG5cbiAgICAvLyBsb3cgcXVhbGl0eSBnZW5lcmF0aXZlIHJhbm9kbSBudW1iZXJzXG4gICAgXCJDR0wuUkFORE9NX0xPV1wiOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJyYW5kb21OdW1iZXJcIjtcbiAgICAgICAgdGhpcy5zcmNIZWFkRnJhZyA9IFwiXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwiZmxvYXQgY2dsX3JhbmRvbSh2ZWMyIGNvKVwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIntcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCIgICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHkgLHZlYzIoMTIuOTg5OCw0LjE0MTQpKSkgKiAzNTguNTQ1Myk7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwifVwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcInZlYzMgY2dsX3JhbmRvbTModmVjMiBjbylcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwiICAgIHJldHVybiB2ZWMzKCBjZ2xfcmFuZG9tKGNvKSxjZ2xfcmFuZG9tKGNvKzAuNTcxMSksY2dsX3JhbmRvbShjbysxLjU3MTEpKTtcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ9XCI7XG4gICAgfSxcblxuICAgIC8vIHRleHR1cmUgYmFzZWQgcmFuZG9tIG51bWJlcnNcbiAgICBcIkNHTC5SQU5ET01fVEVYXCI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLm5hbWUgPSBcInJhbmRvbU51bWJlcnRleFwiO1xuICAgICAgICB0aGlzLnNyY0hlYWRGcmFnID0gXCJcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJVTkkgc2FtcGxlcjJEIENHTFJORFRFWDtcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJmbG9hdCBjZ2xfcmFuZG9tKHZlYzIgY28pXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwie1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIiAgICByZXR1cm4gdGV4dHVyZShDR0xSTkRURVgsY28qNTcxMS4wKS5yO1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIn1cIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ2ZWMzIGNnbF9yYW5kb20zKHZlYzIgY28pXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwie1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIiAgICByZXR1cm4gdGV4dHVyZShDR0xSTkRURVgsY28qNTcxMS4wKS5yZ2I7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwifVwiO1xuXG4gICAgICAgIHRoaXMuaW5pdFVuaWZvcm1zID0gZnVuY3Rpb24gKHNoYWRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVW5pZm9ybShzaGFkZXIsIFwidFwiLCBcIkNHTFJORFRFWFwiLCA3KV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbkJpbmQgPSBmdW5jdGlvbiAoY2dsLCBzaGFkZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIFRleHR1cmUuZ2V0UmFuZG9tVGV4dHVyZShjZ2wpO1xuICAgICAgICAgICAgY2dsLnNldFRleHR1cmUoNywgVGV4dHVyZS5nZXRSYW5kb21UZXh0dXJlKGNnbCkudGV4KTtcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgU2hhZGVyTGliTW9kcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader_lib.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_shader_uniform.js":
/*!********************************************!*\
  !*** ./src/core/cgl/cgl_shader_uniform.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Uniform\": () => (/* binding */ Uniform)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_uniform */ \"./src/core/cg/cg_uniform.js\");\n/* harmony import */ var _core_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core_port */ \"./src/core/core_port.js\");\n\n\n\n\n/**\n * Shader uniforms\n *\n * types:\n * <pre>\n * f    - float\n * 2f   - vec2\n * 3f   - vec3\n * 4f   - vec4\n * i    - integer\n * t    - texture\n * m4   - mat4, 4x4 float matrix\n * f[]  - array of floats\n * 2f[] - array of float vec2\n * 3f[] - array of float vec3\n * 4f[] - array of float vec4\n * </pre>\n *\n * @external CGL\n * @namespace Uniform\n * @class\n * @param {Shader} shader\n * @param {String} [type=f]\n * @param {String} name\n * @param {Number|Port} value  can be a Number,Matrix or Port\n * @example\n * // bind float uniform called myfloat and initialize with value 1.0\n * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);\n * unir.setValue(1.0);\n *\n * // bind float uniform called myfloat and automatically set it to input port value\n * const myPort=op.inFloat(\"input\");\n * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);\n *\n */\n\n\n// export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n\nclass Uniform extends _cg_cg_uniform__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n    {\n        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);\n        this._loc = -1;\n        this._cgl = __shader._cgl;\n    }\n\n    get name()\n    {\n        return this._name;\n    }\n\n    copy(newShader)\n    {\n        const uni = new Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);\n        uni.shaderType = this.shaderType;\n        return uni;\n    }\n\n    /**\n     * returns type as glsl type string. e.g. 'f' returns 'float'\n     * @function getGlslTypeString\n     * @memberof Uniform\n     * @instance\n     * @return {string} type as string\n     */\n    getGlslTypeString()\n    {\n        return Uniform.glslTypeString(this._type);\n    }\n\n    _isValidLoc()\n    {\n        return this._loc != -1;// && this._loc != null;\n    }\n\n    resetLoc()\n    {\n        this._loc = -1;\n        this.needsUpdate = true;\n    }\n\n    bindTextures() {}\n\n    getLoc()\n    {\n        return this._loc;\n    }\n\n    updateFromPort4f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this._value[3] = this._port4.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort3f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort2f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort()\n    {\n        this.setValue(this._port.get());\n    }\n\n    updateValueF()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        this._shader.getCgl().gl.uniform1f(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueF(v)\n    {\n        if (v != this._value)\n        {\n            this.needsUpdate = true;\n            this._value = v;\n        }\n    }\n\n    updateValueI()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        this._shader.getCgl().gl.uniform1i(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValue2I()\n    {\n        if (!this._value) return;\n\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);\n\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValue3I()\n    {\n        if (!this._value) return;\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValue4I()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n        this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueI(v)\n    {\n        if (v != this._value)\n        {\n            this.needsUpdate = true;\n            this._value = v;\n        }\n    }\n\n    setValue2I(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    setValue3I(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1, 2];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this._oldValue[2] = v[2];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    setValue4I(v)\n    {\n        this.needsUpdate = true;\n        this._value = v || vec4.create();\n    }\n\n    updateValueBool()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n        this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);\n\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueBool(v)\n    {\n        if (v != this._value)\n        {\n            this.needsUpdate = true;\n            this._value = v;\n        }\n    }\n\n    setValueArray4F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArray4F()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform4fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArray3F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArray3F()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform3fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArray2F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArray2F()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform2fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArrayF(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArrayF()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform1fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArrayT(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n\n    updateValue3F()\n    {\n        if (!this._value) return;\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValue3F(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1, 2];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this._oldValue[2] = v[2];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    updateValue2F()\n    {\n        if (!this._value) return;\n\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValue2F(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this.needsUpdate = true;\n        }\n        this._value = v;\n    }\n\n    updateValue4F()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        if (!this._value)\n        {\n            this._log.warn(\"no value for uniform\", this._name, this);\n            this._value = [0, 0, 0, 0];\n        }\n\n        this.needsUpdate = false;\n        this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValue4F(v)\n    {\n        if (typeof this.value == \"number\") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods\n\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1, 2, 3];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2] || v[3] != this._oldValue[3])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this._oldValue[2] = v[2];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    updateValueM4()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n        if (!this._value || this._value.length % 16 != 0) return console.log(\"this.name\", this._name, this._value);\n\n        this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueM4(v)\n    {\n        this.needsUpdate = true;\n        this._value = v || mat4.create();\n    }\n\n    updateValueArrayT()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform1iv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValueT()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._cgl.profileData.profileUniformCount++;\n        this._shader.getCgl().gl.uniform1i(this._loc, this._value);\n        this.needsUpdate = false;\n    }\n\n    setValueT(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n}\n\n\nUniform.glslTypeString = (t) =>\n{\n    if (t == \"f\") return \"float\";\n    if (t == \"b\") return \"bool\";\n    if (t == \"i\") return \"int\";\n    if (t == \"2i\") return \"ivec2\";\n    if (t == \"2f\") return \"vec2\";\n    if (t == \"3f\") return \"vec3\";\n    if (t == \"4f\") return \"vec4\";\n    if (t == \"m4\") return \"mat4\";\n\n    if (t == \"t\") return \"sampler2D\";\n    if (t == \"tc\") return \"samplerCube\";\n\n    if (t == \"3f[]\") return null; // ignore this for now...\n    if (t == \"m4[]\") return null; // ignore this for now...\n    if (t == \"f[]\") return null; // ignore this for now...\n\n    console.warn(\"[CGL UNIFORM] unknown glsl type string \", t);\n};\n\n\n/**\n * @function setValue\n * @memberof Uniform\n * @instance\n * @param {Number|Array|Matrix|Texture} value\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl91bmlmb3JtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc2hhZGVyX3VuaWZvcm0uanM/MjZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBDZ1VuaWZvcm0gZnJvbSBcIi4uL2NnL2NnX3VuaWZvcm1cIjtcbmltcG9ydCB7IFBvcnQgfSBmcm9tIFwiLi4vY29yZV9wb3J0XCI7XG5cbi8qKlxuICogU2hhZGVyIHVuaWZvcm1zXG4gKlxuICogdHlwZXM6XG4gKiA8cHJlPlxuICogZiAgICAtIGZsb2F0XG4gKiAyZiAgIC0gdmVjMlxuICogM2YgICAtIHZlYzNcbiAqIDRmICAgLSB2ZWM0XG4gKiBpICAgIC0gaW50ZWdlclxuICogdCAgICAtIHRleHR1cmVcbiAqIG00ICAgLSBtYXQ0LCA0eDQgZmxvYXQgbWF0cml4XG4gKiBmW10gIC0gYXJyYXkgb2YgZmxvYXRzXG4gKiAyZltdIC0gYXJyYXkgb2YgZmxvYXQgdmVjMlxuICogM2ZbXSAtIGFycmF5IG9mIGZsb2F0IHZlYzNcbiAqIDRmW10gLSBhcnJheSBvZiBmbG9hdCB2ZWM0XG4gKiA8L3ByZT5cbiAqXG4gKiBAZXh0ZXJuYWwgQ0dMXG4gKiBAbmFtZXNwYWNlIFVuaWZvcm1cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlclxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlPWZdXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ8UG9ydH0gdmFsdWUgIGNhbiBiZSBhIE51bWJlcixNYXRyaXggb3IgUG9ydFxuICogQGV4YW1wbGVcbiAqIC8vIGJpbmQgZmxvYXQgdW5pZm9ybSBjYWxsZWQgbXlmbG9hdCBhbmQgaW5pdGlhbGl6ZSB3aXRoIHZhbHVlIDEuMFxuICogY29uc3QgdW5pcj1uZXcgQ0dMLlVuaWZvcm0oc2hhZGVyLCdmJywnbXlmbG9hdCcsMS4wKTtcbiAqIHVuaXIuc2V0VmFsdWUoMS4wKTtcbiAqXG4gKiAvLyBiaW5kIGZsb2F0IHVuaWZvcm0gY2FsbGVkIG15ZmxvYXQgYW5kIGF1dG9tYXRpY2FsbHkgc2V0IGl0IHRvIGlucHV0IHBvcnQgdmFsdWVcbiAqIGNvbnN0IG15UG9ydD1vcC5pbkZsb2F0KFwiaW5wdXRcIik7XG4gKiBjb25zdCBwdj1uZXcgQ0dMLlVuaWZvcm0oc2hhZGVyLCdmJywnbXlmbG9hdCcsbXlQb3J0KTtcbiAqXG4gKi9cblxuXG4vLyBleHBvcnQgY29uc3QgVW5pZm9ybShfX3NoYWRlciwgX190eXBlLCBfX25hbWUsIF92YWx1ZSwgX3BvcnQyLCBfcG9ydDMsIF9wb3J0NCwgX3N0cnVjdFVuaWZvcm1OYW1lLCBfc3RydWN0TmFtZSwgX3Byb3BlcnR5TmFtZSlcblxuY2xhc3MgVW5pZm9ybSBleHRlbmRzIENnVW5pZm9ybVxue1xuICAgIGNvbnN0cnVjdG9yKF9fc2hhZGVyLCBfX3R5cGUsIF9fbmFtZSwgX3ZhbHVlLCBfcG9ydDIsIF9wb3J0MywgX3BvcnQ0LCBfc3RydWN0VW5pZm9ybU5hbWUsIF9zdHJ1Y3ROYW1lLCBfcHJvcGVydHlOYW1lKVxuICAgIHtcbiAgICAgICAgc3VwZXIoX19zaGFkZXIsIF9fdHlwZSwgX19uYW1lLCBfdmFsdWUsIF9wb3J0MiwgX3BvcnQzLCBfcG9ydDQsIF9zdHJ1Y3RVbmlmb3JtTmFtZSwgX3N0cnVjdE5hbWUsIF9wcm9wZXJ0eU5hbWUpO1xuICAgICAgICB0aGlzLl9sb2MgPSAtMTtcbiAgICAgICAgdGhpcy5fY2dsID0gX19zaGFkZXIuX2NnbDtcbiAgICB9XG5cbiAgICBnZXQgbmFtZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG5cbiAgICBjb3B5KG5ld1NoYWRlcilcbiAgICB7XG4gICAgICAgIGNvbnN0IHVuaSA9IG5ldyBVbmlmb3JtKG5ld1NoYWRlciwgdGhpcy5fdHlwZSwgdGhpcy5fbmFtZSwgdGhpcy5fdmFsdWUsIHRoaXMuX3BvcnQyLCB0aGlzLl9wb3J0MywgdGhpcy5fcG9ydDQsIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lLCB0aGlzLl9zdHJ1Y3ROYW1lLCB0aGlzLl9wcm9wZXJ0eU5hbWUpO1xuICAgICAgICB1bmkuc2hhZGVyVHlwZSA9IHRoaXMuc2hhZGVyVHlwZTtcbiAgICAgICAgcmV0dXJuIHVuaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHR5cGUgYXMgZ2xzbCB0eXBlIHN0cmluZy4gZS5nLiAnZicgcmV0dXJucyAnZmxvYXQnXG4gICAgICogQGZ1bmN0aW9uIGdldEdsc2xUeXBlU3RyaW5nXG4gICAgICogQG1lbWJlcm9mIFVuaWZvcm1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHR5cGUgYXMgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0R2xzbFR5cGVTdHJpbmcoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFVuaWZvcm0uZ2xzbFR5cGVTdHJpbmcodGhpcy5fdHlwZSk7XG4gICAgfVxuXG4gICAgX2lzVmFsaWRMb2MoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYyAhPSAtMTsvLyAmJiB0aGlzLl9sb2MgIT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXNldExvYygpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2MgPSAtMTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgYmluZFRleHR1cmVzKCkge31cblxuICAgIGdldExvYygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jO1xuICAgIH1cblxuICAgIHVwZGF0ZUZyb21Qb3J0NGYoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWVbMF0gPSB0aGlzLl9wb3J0LmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsxXSA9IHRoaXMuX3BvcnQyLmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsyXSA9IHRoaXMuX3BvcnQzLmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVszXSA9IHRoaXMuX3BvcnQ0LmdldCgpO1xuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tUG9ydDNmKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzBdID0gdGhpcy5fcG9ydC5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMV0gPSB0aGlzLl9wb3J0Mi5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMl0gPSB0aGlzLl9wb3J0My5nZXQoKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRnJvbVBvcnQyZigpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZVswXSA9IHRoaXMuX3BvcnQuZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzFdID0gdGhpcy5fcG9ydDIuZ2V0KCk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZUZyb21Qb3J0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fcG9ydC5nZXQoKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKSB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICBlbHNlIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTFmKHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlRih2KVxuICAgIHtcbiAgICAgICAgaWYgKHYgIT0gdGhpcy5fdmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVJKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKSB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICBlbHNlIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTFpKHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlMkkoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtKys7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm1OYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtMmkodGhpcy5fbG9jLCB0aGlzLl92YWx1ZVswXSwgdGhpcy5fdmFsdWVbMV0pO1xuXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZTNJKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm0rKztcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybU5hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0zaSh0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlWzBdLCB0aGlzLl92YWx1ZVsxXSwgdGhpcy5fdmFsdWVbMl0pO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWU0SSgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSsrO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm00aSh0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlWzBdLCB0aGlzLl92YWx1ZVsxXSwgdGhpcy5fdmFsdWVbMl0sIHRoaXMuX3ZhbHVlWzNdKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZUkodilcbiAgICB7XG4gICAgICAgIGlmICh2ICE9IHRoaXMuX3ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFZhbHVlMkkodilcbiAgICB7XG4gICAgICAgIGlmICghdikgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX29sZFZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IFt2WzBdIC0gMSwgMV07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2WzBdICE9IHRoaXMuX29sZFZhbHVlWzBdIHx8IHZbMV0gIT0gdGhpcy5fb2xkVmFsdWVbMV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzBdID0gdlswXTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzFdID0gdlsxXTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHNldFZhbHVlM0kodilcbiAgICB7XG4gICAgICAgIGlmICghdikgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX29sZFZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IFt2WzBdIC0gMSwgMSwgMl07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2WzBdICE9IHRoaXMuX29sZFZhbHVlWzBdIHx8IHZbMV0gIT0gdGhpcy5fb2xkVmFsdWVbMV0gfHwgdlsyXSAhPSB0aGlzLl9vbGRWYWx1ZVsyXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMF0gPSB2WzBdO1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMV0gPSB2WzFdO1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMl0gPSB2WzJdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgc2V0VmFsdWU0SSh2KVxuICAgIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdiB8fCB2ZWM0LmNyZWF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlQm9vbCgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSkgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgZWxzZSB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtMWkodGhpcy5fbG9jLCB0aGlzLl92YWx1ZSA/IDEgOiAwKTtcblxuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlQm9vbCh2KVxuICAgIHtcbiAgICAgICAgaWYgKHYgIT0gdGhpcy5fdmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VmFsdWVBcnJheTRGKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlQXJyYXk0RigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSkgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgZWxzZSB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTRmdih0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZUFycmF5M0YodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVBcnJheTNGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKSB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICBlbHNlIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtM2Z2KHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlQXJyYXkyRih2KVxuICAgIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZUFycmF5MkYoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgIGVsc2UgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0yZnYodGhpcy5fbG9jLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWVBcnJheUYodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVBcnJheUYoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgIGVsc2UgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0xZnYodGhpcy5fbG9jLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWVBcnJheVQodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG5cbiAgICB1cGRhdGVWYWx1ZTNGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm0rKztcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybU5hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0zZih0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlWzBdLCB0aGlzLl92YWx1ZVsxXSwgdGhpcy5fdmFsdWVbMl0pO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWUzRih2KVxuICAgIHtcbiAgICAgICAgaWYgKCF2KSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fb2xkVmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlID0gW3ZbMF0gLSAxLCAxLCAyXTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZbMF0gIT0gdGhpcy5fb2xkVmFsdWVbMF0gfHwgdlsxXSAhPSB0aGlzLl9vbGRWYWx1ZVsxXSB8fCB2WzJdICE9IHRoaXMuX29sZFZhbHVlWzJdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVswXSA9IHZbMF07XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVsxXSA9IHZbMV07XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVsyXSA9IHZbMl07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZTJGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSsrO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTJmKHRoaXMuX2xvYywgdGhpcy5fdmFsdWVbMF0sIHRoaXMuX3ZhbHVlWzFdKTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlMkYodilcbiAgICB7XG4gICAgICAgIGlmICghdikgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX29sZFZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IFt2WzBdIC0gMSwgMV07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2WzBdICE9IHRoaXMuX29sZFZhbHVlWzBdIHx8IHZbMV0gIT0gdGhpcy5fb2xkVmFsdWVbMV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzBdID0gdlswXTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzFdID0gdlsxXTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZTRGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtKys7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm1OYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwibm8gdmFsdWUgZm9yIHVuaWZvcm1cIiwgdGhpcy5fbmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm00Zih0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlWzBdLCB0aGlzLl92YWx1ZVsxXSwgdGhpcy5fdmFsdWVbMl0sIHRoaXMuX3ZhbHVlWzNdKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZTRGKHYpXG4gICAge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT0gXCJudW1iZXJcIikgdGhpcy52YWx1ZSA9IHZlYzQuY3JlYXRlKCk7IC8vIHRoaXMgc2hvdWxkIG5vdCBiZSBuZWVkZWQsIGJ1dCBzb21laG93IGl0IGNyYXNoZXMgd2l0aCBzb21lIHNoYWRlcm1vZHNcblxuICAgICAgICBpZiAoIXYpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLl9vbGRWYWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWUgPSBbdlswXSAtIDEsIDEsIDIsIDNdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodlswXSAhPSB0aGlzLl9vbGRWYWx1ZVswXSB8fCB2WzFdICE9IHRoaXMuX29sZFZhbHVlWzFdIHx8IHZbMl0gIT0gdGhpcy5fb2xkVmFsdWVbMl0gfHwgdlszXSAhPSB0aGlzLl9vbGRWYWx1ZVszXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMF0gPSB2WzBdO1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMV0gPSB2WzFdO1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMl0gPSB2WzJdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVNNCgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSsrO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZSB8fCB0aGlzLl92YWx1ZS5sZW5ndGggJSAxNiAhPSAwKSByZXR1cm4gY29uc29sZS5sb2coXCJ0aGlzLm5hbWVcIiwgdGhpcy5fbmFtZSwgdGhpcy5fdmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX2xvYywgZmFsc2UsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZU00KHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2IHx8IG1hdDQuY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVBcnJheVQoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgIGVsc2UgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0xaXYodGhpcy5fbG9jLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVUKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtKys7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm1OYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtMWkodGhpcy5fbG9jLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRWYWx1ZVQodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxufVxuXG5cblVuaWZvcm0uZ2xzbFR5cGVTdHJpbmcgPSAodCkgPT5cbntcbiAgICBpZiAodCA9PSBcImZcIikgcmV0dXJuIFwiZmxvYXRcIjtcbiAgICBpZiAodCA9PSBcImJcIikgcmV0dXJuIFwiYm9vbFwiO1xuICAgIGlmICh0ID09IFwiaVwiKSByZXR1cm4gXCJpbnRcIjtcbiAgICBpZiAodCA9PSBcIjJpXCIpIHJldHVybiBcIml2ZWMyXCI7XG4gICAgaWYgKHQgPT0gXCIyZlwiKSByZXR1cm4gXCJ2ZWMyXCI7XG4gICAgaWYgKHQgPT0gXCIzZlwiKSByZXR1cm4gXCJ2ZWMzXCI7XG4gICAgaWYgKHQgPT0gXCI0ZlwiKSByZXR1cm4gXCJ2ZWM0XCI7XG4gICAgaWYgKHQgPT0gXCJtNFwiKSByZXR1cm4gXCJtYXQ0XCI7XG5cbiAgICBpZiAodCA9PSBcInRcIikgcmV0dXJuIFwic2FtcGxlcjJEXCI7XG4gICAgaWYgKHQgPT0gXCJ0Y1wiKSByZXR1cm4gXCJzYW1wbGVyQ3ViZVwiO1xuXG4gICAgaWYgKHQgPT0gXCIzZltdXCIpIHJldHVybiBudWxsOyAvLyBpZ25vcmUgdGhpcyBmb3Igbm93Li4uXG4gICAgaWYgKHQgPT0gXCJtNFtdXCIpIHJldHVybiBudWxsOyAvLyBpZ25vcmUgdGhpcyBmb3Igbm93Li4uXG4gICAgaWYgKHQgPT0gXCJmW11cIikgcmV0dXJuIG51bGw7IC8vIGlnbm9yZSB0aGlzIGZvciBub3cuLi5cblxuICAgIGNvbnNvbGUud2FybihcIltDR0wgVU5JRk9STV0gdW5rbm93biBnbHNsIHR5cGUgc3RyaW5nIFwiLCB0KTtcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0VmFsdWVcbiAqIEBtZW1iZXJvZiBVbmlmb3JtXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fE1hdHJpeHxUZXh0dXJlfSB2YWx1ZVxuICovXG5cbmV4cG9ydCB7IFVuaWZvcm0gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader_uniform.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_simplerect.js":
/*!****************************************!*\
  !*** ./src/core/cgl/cgl_simplerect.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MESHES\": () => (/* binding */ MESHES)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_geom */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _cgl_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_mesh */ \"./src/core/cgl/cgl_mesh.js\");\n\n\n\n\nconst MESHES = {};\n\nMESHES.getSimpleRect = function (cgl, name)\n{\n    const geom = new _cg_cg_geom__WEBPACK_IMPORTED_MODULE_0__.Geometry(name);\n\n    geom.vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0];\n    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];\n    geom.verticesIndices = [0, 1, 2, 2, 1, 3];\n    geom.vertexNormals = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n\n    return new _cgl_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh(cgl, geom);\n};\n\n\nMESHES.getSimpleCube = function (cgl, name)\n{\n    const geom = new _cg_cg_geom__WEBPACK_IMPORTED_MODULE_0__.Geometry(name);\n    geom.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];\n    geom.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,]);\n    geom.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n    geom.vertexNormals = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);\n    geom.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n    geom.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);\n\n    return new _cgl_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh(cgl, geom);\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NpbXBsZXJlY3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX3NpbXBsZXJlY3QuanM/OWY1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCIuLi9jZy9jZ19nZW9tXCI7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSBcIi4vY2dsX21lc2hcIjtcblxuXG5jb25zdCBNRVNIRVMgPSB7fTtcblxuTUVTSEVTLmdldFNpbXBsZVJlY3QgPSBmdW5jdGlvbiAoY2dsLCBuYW1lKVxue1xuICAgIGNvbnN0IGdlb20gPSBuZXcgR2VvbWV0cnkobmFtZSk7XG5cbiAgICBnZW9tLnZlcnRpY2VzID0gWzEuMCwgMS4wLCAwLjAsIC0xLjAsIDEuMCwgMC4wLCAxLjAsIC0xLjAsIDAuMCwgLTEuMCwgLTEuMCwgMC4wXTtcbiAgICBnZW9tLnRleENvb3JkcyA9IFsxLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAwLjAsIDAuMF07XG4gICAgZ2VvbS52ZXJ0aWNlc0luZGljZXMgPSBbMCwgMSwgMiwgMiwgMSwgM107XG4gICAgZ2VvbS52ZXJ0ZXhOb3JtYWxzID0gWzAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjBdO1xuXG4gICAgcmV0dXJuIG5ldyBNZXNoKGNnbCwgZ2VvbSk7XG59O1xuXG5cbk1FU0hFUy5nZXRTaW1wbGVDdWJlID0gZnVuY3Rpb24gKGNnbCwgbmFtZSlcbntcbiAgICBjb25zdCBnZW9tID0gbmV3IEdlb21ldHJ5KG5hbWUpO1xuICAgIGdlb20udmVydGljZXMgPSBbLTEsIC0xLCAxLCAxLCAtMSwgMSwgMSwgMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgMSwgMSwgMSwgMSwgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxLCAtMV07XG4gICAgZ2VvbS5zZXRUZXhDb29yZHMoWzAsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDAsIDAsIDAsXSk7XG4gICAgZ2VvbS52ZXJ0aWNlc0luZGljZXMgPSBbMCwgMSwgMiwgMCwgMiwgMywgNCwgNSwgNiwgNCwgNiwgNywgOCwgOSwgMTAsIDgsIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTIsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTYsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjAsIDIyLCAyM107XG4gICAgZ2VvbS52ZXJ0ZXhOb3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMF0pO1xuICAgIGdlb20udGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdKTtcbiAgICBnZW9tLmJpVGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xXSk7XG5cbiAgICByZXR1cm4gbmV3IE1lc2goY2dsLCBnZW9tKTtcbn07XG5cblxuZXhwb3J0IHsgTUVTSEVTIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_simplerect.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_state.js":
/*!***********************************!*\
  !*** ./src/core/cgl/cgl_state.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BLENDS\": () => (/* binding */ BLENDS),\n/* harmony export */   \"Context\": () => (/* binding */ Context)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_shader */ \"./src/core/cgl/cgl_shader.js\");\n/* harmony import */ var _cgl_profiledata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_profiledata */ \"./src/core/cgl/cgl_profiledata.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _cg_cg_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cg/cg_state */ \"./src/core/cg/cg_state.js\");\n/* harmony import */ var _cg_cg_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cg/cg_constants */ \"./src/core/cg/cg_constants.js\");\n\n\n\n\n\n\n\n\n/**\n * cables gl context/state manager\n * @external CGL\n * @namespace Context\n * @class\n * @hideconstructor\n */\n// const Context(_patch)\nclass Context extends _cg_cg_state__WEBPACK_IMPORTED_MODULE_4__.CGState\n{\n    constructor(_patch)\n    {\n        super(_patch);\n        // EventTarget.apply(this);\n        // CGState.apply(this);\n\n        this.gApi = _cg_cg_constants__WEBPACK_IMPORTED_MODULE_5__.CG.GAPI_WEBGL;\n        this.aborted = false;\n\n        this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??\n        this.popMvMatrix = this.popmMatrix = this.popModelMatrix;// deprecated and wrong... still used??\n\n        this.profileData = new _cgl_profiledata__WEBPACK_IMPORTED_MODULE_2__.ProfileData(this);\n        this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"cgl_context\");\n        this._viewPort = [0, 0, 0, 0];\n        this.glVersion = 0;\n        this.glUseHalfFloatTex = false;\n        this.clearCanvasTransparent = true;\n        this.clearCanvasDepth = true;\n        this.debugOneFrame = false;\n        this.checkGlErrors = false; // true is slow // false should be default...\n        this.maxTextureUnits = 0;\n        this.maxVaryingVectors = 0;\n        this.currentProgram = null;\n        this._hadStackError = false;\n        this.glSlowRenderer = false;\n        this._isSafariCrap = false;\n\n        this.temporaryTexture = null;\n        this.frameStore = {};\n        this._onetimeCallbacks = [];\n        this.gl = null;\n\n        this._cursor = \"auto\";\n        this._currentCursor = \"\";\n\n        this._viewPortStack = [];\n        this._glFrameBufferStack = [];\n        this._frameBufferStack = [];\n        this._shaderStack = [];\n        this._stackDepthTest = [];\n        this.mainloopOp = null;\n\n        // this._pixelDensity = ;\n\n\n        this._simpleShader = new _cgl_shader__WEBPACK_IMPORTED_MODULE_1__.Shader(this, \"simpleshader\");\n        this._simpleShader.setModules([\"MODULE_VERTEX_POSITION\", \"MODULE_COLOR\", \"MODULE_BEGIN_FRAG\"]);\n        this._simpleShader.setSource(_cgl_shader__WEBPACK_IMPORTED_MODULE_1__.Shader.getDefaultVertexShader(), _cgl_shader__WEBPACK_IMPORTED_MODULE_1__.Shader.getDefaultFragmentShader());\n\n        this._currentShader = this._simpleShader;\n\n\n        this._oldCanvasWidth = -1;\n        this._oldCanvasHeight = -1;\n        this._enabledExtensions = {};\n    }\n\n    // set pixelDensity(p)\n    // {\n    //     this._pixelDensity = p;\n    // }\n\n    // get pixelDensity()\n    // {\n    //     return this._pixelDensity;\n    // }\n\n\n\n    get viewPort()\n    {\n        if (this._viewPortStack.length > 3)\n        {\n            const l = this._viewPortStack.length;\n\n            return [\n                this._viewPortStack[l - 4],\n                this._viewPortStack[l - 3],\n                this._viewPortStack[l - 2],\n                this._viewPortStack[l - 1]\n            ];\n        }\n        else\n        {\n            // workaround pre viewport stack times / or+and initial value...\n\n            return this._viewPort;\n        }\n    }\n\n\n\n    get mvMatrix() // deprecate\n    {\n        return this.mMatrix;\n    }\n\n    set mvMatrix(m) // deprecate\n    {\n        this.mMatrix = m;\n    }\n\n\n    exitError(msgId, msg)\n    {\n        console.log(msgId, msg);\n        this.patch.exitError(msgId, msg);\n        this.aborted = true;\n    }\n\n\n    _setCanvas(canv)\n    {\n        if (!canv)\n        {\n            this._log.stack(\"_setCanvas undef\");\n        }\n\n        if (!this.patch.config.canvas) this.patch.config.canvas = {};\n        if (!this.patch.config.canvas.hasOwnProperty(\"preserveDrawingBuffer\")) this.patch.config.canvas.preserveDrawingBuffer = false;\n        if (!this.patch.config.canvas.hasOwnProperty(\"premultipliedAlpha\")) this.patch.config.canvas.premultipliedAlpha = false;\n        if (!this.patch.config.canvas.hasOwnProperty(\"alpha\")) this.patch.config.canvas.alpha = false;\n\n        this.patch.config.canvas.stencil = true;\n\n        if (this.patch.config.hasOwnProperty(\"clearCanvasColor\")) this.clearCanvasTransparent = this.patch.config.clearCanvasColor;\n        if (this.patch.config.hasOwnProperty(\"clearCanvasDepth\")) this.clearCanvasDepth = this.patch.config.clearCanvasDepth;\n\n        // safari stuff..........\n        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))\n        {\n            this._isSafariCrap = true;\n            this.glUseHalfFloatTex = true;\n        }\n\n        if (!this.patch.config.canvas.forceWebGl1) this.gl = canv.getContext(\"webgl2\", this.patch.config.canvas);\n\n        if (this.gl && this.gl.getParameter(this.gl.VERSION) != \"WebGL 1.0\")\n        {\n            this.glVersion = 2;\n        }\n        else\n        {\n            this.gl = canv.getContext(\"webgl\", this.patch.config.canvas) || canv.getContext(\"experimental-webgl\", this.patch.config.canvas);\n            this.glVersion = 1;\n\n            // safari\n            // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))\n            // {\n            //     this.glUseHalfFloatTex = true;\n            // }\n\n            // ios\n            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream)\n            {\n                if (!this.patch.config.canvas.hasOwnProperty(\"powerPreference\")) this.patch.config.canvas.powerPreference = \"high-performance\";\n            }\n\n            this.enableExtension(\"OES_standard_derivatives\");\n            // this.enableExtension(\"GL_OES_standard_derivatives\");\n            const instancingExt = this.enableExtension(\"ANGLE_instanced_arrays\") || this.gl;\n            if (instancingExt.vertexAttribDivisorANGLE)\n            {\n                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);\n                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);\n            }\n        }\n\n        if (!this.gl || this.gl.isContextLost())\n        {\n            this.aborted = true;\n            this.exitError(\"NO_WEBGL\", \"sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.\");\n            return;\n        }\n\n        const dbgRenderInfo = this.enableExtension(\"WEBGL_debug_renderer_info\");\n        if (dbgRenderInfo)\n        {\n            this.glRenderer = this.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);\n            if (this.glRenderer === \"Google SwiftShader\") this.glSlowRenderer = true;\n        }\n\n        this.canvas.addEventListener(\"webglcontextlost\", (event) =>\n        {\n            if (this.aborted) return console.log(\"[cgl_state] aborted context lost... can be ignored...\");\n            this._log.error(\"canvas lost...\", event);\n            this.emitEvent(\"webglcontextlost\");\n            this.aborted = true;\n        });\n\n\n        this.maxAnisotropic = 0;\n        if (this.enableExtension(\"EXT_texture_filter_anisotropic\"))\n            this.maxAnisotropic = this.gl.getParameter(this.enableExtension(\"EXT_texture_filter_anisotropic\").MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\n\n        this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);\n        this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);\n        this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n        this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);\n        this.maxSamples = 0;\n        if (this.gl.MAX_SAMPLES) this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);\n\n        if (this.glVersion == 1)\n        {\n            this.enableExtension(\"OES_standard_derivatives\");\n            const instancingExt = this.enableExtension(\"ANGLE_instanced_arrays\") || this.gl;\n\n            if (instancingExt.vertexAttribDivisorANGLE)\n            {\n                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);\n                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);\n            }\n        }\n\n        this.DEPTH_FUNCS = [\n            this.gl.NEVER,\n            this.gl.ALWAYS,\n            this.gl.LESS,\n            this.gl.LEQUAL,\n            this.gl.GREATER,\n            this.gl.GEQUAL,\n            this.gl.EQUAL,\n            this.gl.NOTEQUAL\n        ];\n        this.CULL_MODES = [\n            null,\n            this.gl.BACK,\n            this.gl.FRONT,\n            this.gl.FRONT_AND_BACK\n        ];\n    }\n\n    getInfo()\n    {\n        return {\n            \"glVersion\": this.glVersion,\n            \"glRenderer\": this.glRenderer,\n            \"glUseHalfFloatTex\": this.glUseHalfFloatTex,\n            \"maxVaryingVectors\": this.maxVaryingVectors,\n            \"maxTextureUnits\": this.maxTextureUnits,\n            \"maxTexSize\": this.maxTexSize,\n            \"maxUniformsFrag\": this.maxUniformsFrag,\n            \"maxUniformsVert\": this.maxUniformsVert,\n            \"maxSamples\": this.maxSamples\n        };\n    }\n\n\n\n\n\n    /**\n     * @function popViewPort\n     * @memberof Context\n     * @instance\n     * @description pop viewPort stack\n     */\n\n\n    popViewPort()\n    {\n        this._viewPortStack.pop();\n        this._viewPortStack.pop();\n        this._viewPortStack.pop();\n        this._viewPortStack.pop();\n\n        if (this._viewPortStack.length == 0)\n        {\n            this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);\n            // this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n            // this.setViewPort(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n        }\n        else\n        {\n            // this.viewPort = [this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]];\n            // this.gl.viewport(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);\n            this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);\n        }\n    }\n\n    /**\n     * @function pushViewPort\n     * @memberof Context\n     * @instance\n     * @description push a new viewport onto stack\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} w\n     * @param {Number} h\n     */\n\n    pushViewPort(x, y, w, h)\n    {\n        this._viewPortStack.push(x, y, w, h);\n        this.setViewPort(x, y, w, h);\n    }\n\n\n    // old\n    getViewPort()\n    {\n        return this._viewPort;\n    }\n\n    // old\n    resetViewPort()\n    {\n        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n    }\n\n    // old\n    setViewPort(x, y, w, h)\n    {\n        this._viewPort[0] = Math.round(x);\n        this._viewPort[1] = Math.round(y);\n        this._viewPort[2] = Math.round(w);\n        this._viewPort[3] = Math.round(h);\n        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n    }\n\n\n    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)\n    {\n        if (doScreenshotClearAlpha)\n        {\n            this.gl.clearColor(1, 1, 1, 1);\n            this.gl.colorMask(false, false, false, true);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n            this.gl.colorMask(true, true, true, true);\n        }\n\n        if (this.canvas && this.canvas.toBlob)\n        {\n            this.canvas.toBlob((blob) =>\n            {\n                if (cb) cb(blob);\n                else this._log.log(\"no screenshot callback...\");\n            }, mimeType, quality);\n        }\n    }\n\n    endFrame()\n    {\n        if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);\n\n        this.setPreviousShader();\n\n        if (this._vMatrixStack.length() > 0) this.logStackError(\"view matrix stack length !=0 at end of rendering...\");\n        if (this._mMatrixStack.length() > 0) this.logStackError(\"mvmatrix stack length !=0 at end of rendering...\");\n        if (this._pMatrixStack.length() > 0) this.logStackError(\"pmatrix stack length !=0 at end of rendering...\");\n        if (this._glFrameBufferStack.length > 0) this.logStackError(\"glFrameBuffer stack length !=0 at end of rendering...\");\n        if (this._stackDepthTest.length > 0) this.logStackError(\"depthtest stack length !=0 at end of rendering...\");\n        if (this._stackDepthWrite.length > 0) this.logStackError(\"depthwrite stack length !=0 at end of rendering...\");\n        if (this._stackDepthFunc.length > 0) this.logStackError(\"depthfunc stack length !=0 at end of rendering...\");\n        if (this._stackBlend.length > 0) this.logStackError(\"blend stack length !=0 at end of rendering...\");\n        if (this._stackBlendMode.length > 0) this.logStackError(\"blendMode stack length !=0 at end of rendering...\");\n        if (this._shaderStack.length > 0) this.logStackError(\"this._shaderStack length !=0 at end of rendering...\");\n        if (this._stackCullFace.length > 0) this.logStackError(\"this._stackCullFace length !=0 at end of rendering...\");\n        if (this._stackCullFaceFacing.length > 0) this.logStackError(\"this._stackCullFaceFacing length !=0 at end of rendering...\");\n        if (this._viewPortStack.length > 0) this.logStackError(\"viewport stack length !=0 at end of rendering...\");\n\n        this._frameStarted = false;\n\n        if (this._oldCanvasWidth != this.canvasWidth || this._oldCanvasHeight != this.canvasHeight)\n        {\n            this._oldCanvasWidth = this.canvasWidth;\n            this._oldCanvasHeight = this.canvasHeight;\n            // this.setSize(this.canvasWidth / this.pixelDensity, this.canvasHeight / this.pixelDensity);\n            // this.updateSize();\n            this.emitEvent(\"resize\");\n        }\n\n        if (this._cursor != this._currentCursor)\n            this._currentCursor = this.canvas.style.cursor = this._cursor;\n\n        this.emitEvent(\"endframe\");\n\n        this.fpsCounter.endFrame();\n    }\n\n    logStackError(str)\n    {\n        if (!this._hadStackError)\n        {\n            this._hadStackError = true;\n            this._log.warn(\"[\" + this.canvas.id + \"]: \", str);\n        }\n    }\n\n    // shader stack\n    getShader()\n    {\n        if (this._currentShader) if (!this.frameStore || ((this.frameStore.renderOffscreen === true) == this._currentShader.offScreenPass) === true) return this._currentShader;\n\n        for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];\n    }\n\n    getDefaultShader()\n    {\n        return this._simpleShader;\n    }\n\n    /**\n     * push a shader to the shader stack\n     * @function pushShader\n     * @memberof Context\n     * @instance\n     * @param {Object} shader\n     * @function\n     */\n\n    pushShader(shader)\n    {\n        if (this.frameStore.forceShaderMods)\n        {\n            for (let i = 0; i < this.frameStore.forceShaderMods.length; i++)\n            {\n                // if (!currentShader.forcedMod && currentShader != this.frameStore.forceShaderMods[i])\n                // {\n                //     currentShader.forcedMod = this.frameStore.forceShaderMods[i];\n                shader = this.frameStore.forceShaderMods[i].bind(shader, false);\n                // }\n                // return currentShader;\n                // if (this.frameStore.forceShaderMods[i].currentShader() && shader != this.frameStore.forceShaderMods[i].currentShader().shader)\n            }\n        }\n\n        this._shaderStack.push(shader);\n        this._currentShader = shader;\n    }\n\n\n    /**\n     * pop current used shader from shader stack\n     * @function popShader\n     * @memberof Context\n     * @instance\n     * @function\n     */\n    setPreviousShader()\n    {\n        if (this.frameStore.forceShaderMods)\n        {\n            for (let i = 0; i < this.frameStore.forceShaderMods.length; i++)\n            {\n                // const a =\n                this.frameStore.forceShaderMods[i].unbind(false);\n                // if (a) return;\n                // this.popShader();\n            }\n        }\n\n        if (this._shaderStack.length === 0) throw new Error(\"Invalid shader stack pop!\");\n        this._shaderStack.pop();\n        this._currentShader = this._shaderStack[this._shaderStack.length - 1];\n    }\n\n    /**\n     * push a framebuffer to the framebuffer stack\n     * @function pushGlFrameBuffer\n     * @memberof Context\n     * @instance\n     * @param {Object} framebuffer\n     * @function\n     */\n    pushGlFrameBuffer(fb)\n    {\n        this._glFrameBufferStack.push(fb);\n    }\n\n    /**\n     * pop framebuffer stack\n     * @function popGlFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Object} current framebuffer or null\n     */\n    popGlFrameBuffer()\n    {\n        if (this._glFrameBufferStack.length == 0) return null;\n        this._glFrameBufferStack.pop();\n        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];\n    }\n\n    /**\n     * get current framebuffer\n     * @function getCurrentFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Object} current framebuffer or null\n     */\n    getCurrentGlFrameBuffer()\n    {\n        if (this._glFrameBufferStack.length === 0) return null;\n        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];\n    }\n\n    /**\n     * push a framebuffer to the framebuffer stack\n     * @function pushGlFrameBuffer\n     * @memberof Context\n     * @instance\n     * @param {Framebuffer} framebuffer\n     */\n    pushFrameBuffer(fb)\n    {\n        this._frameBufferStack.push(fb);\n    }\n\n    /**\n     * pop framebuffer stack\n     * @function popFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Framebuffer} current framebuffer or null\n     */\n    popFrameBuffer()\n    {\n        if (this._frameBufferStack.length == 0) return null;\n        this._frameBufferStack.pop();\n        return this._frameBufferStack[this._frameBufferStack.length - 1];\n    }\n\n    /**\n     * get current framebuffer\n     * @function getCurrentFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Framebuffer} current framebuffer or null\n     */\n    getCurrentFrameBuffer()\n    {\n        if (this._frameBufferStack.length === 0) return null;\n        return this._frameBufferStack[this._frameBufferStack.length - 1];\n    }\n\n\n    renderStart(cgl, identTranslate, identTranslateView)\n    {\n        this.fpsCounter.startFrame();\n        this.pushDepthTest(true);\n        this.pushDepthWrite(true);\n        this.pushDepthFunc(cgl.gl.LEQUAL);\n        this.pushCullFaceFacing(cgl.gl.BACK);\n        this.pushCullFace(false);\n\n        // if (this.clearCanvasTransparent)\n        // {\n        //     cgl.gl.clearColor(0, 0, 0, 0);\n        //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);\n        // }\n        // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);\n\n        cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);\n\n\n        this._startMatrixStacks(identTranslate, identTranslateView);\n\n\n        cgl.pushBlendMode(_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_NORMAL, false);\n\n        for (let i = 0; i < this._textureslots.length; i++) this._textureslots[i] = null;\n\n        this.pushShader(this._simpleShader);\n\n        this._frameStarted = true;\n\n        if (this._onetimeCallbacks.length > 0)\n        {\n            for (let i = 0; i < this._onetimeCallbacks.length; i++) this._onetimeCallbacks[i]();\n            this._onetimeCallbacks.length = 0;\n        }\n\n        this.emitEvent(\"beginFrame\");\n    }\n\n    renderEnd(cgl)\n    {\n        this._endMatrixStacks();\n\n        this.popDepthTest();\n        this.popDepthWrite();\n        this.popDepthFunc();\n        this.popCullFaceFacing();\n        this.popCullFace();\n        this.popBlend();\n        this.popBlendMode();\n\n        cgl.endFrame();\n\n        this.emitEvent(\"endFrame\");\n    }\n\n    getTexture(slot)\n    {\n        return this._textureslots[slot];\n    }\n\n    hasFrameStarted()\n    {\n        return this._frameStarted;\n    }\n\n    /**\n     * log warning to console if the rendering of one frame has not been started / handy to check for async problems\n     * @function checkFrameStarted\n     * @memberof Context\n     * @instance\n     */\n    checkFrameStarted(string)\n    {\n        if (!this._frameStarted)\n        {\n            this._log.warn(\"frame not started \" + string);\n            this.patch.printTriggerStack();\n        }\n    }\n\n\n    setTexture(slot, t, type)\n    {\n        this.checkFrameStarted(\"cgl setTexture\");\n\n        if (t === null) t = CGL.Texture.getEmptyTexture(this).tex;\n\n        // if (!this.gl.isTexture(t))\n        // {\n        //     console.log(\"not a texture!!!!\"); return false;\n        //     t = CGL.Texture.getEmptyTexture(this).tex;\n        // }\n\n        // if (!this.gl.isTexture(t))\n        // {\n        //     t = CGL.Texture.getErrorTexture(this).tex;\n        //     // this._log.stack(\"not a texture!!!!\");\n        //     // return false;\n        // }\n\n\n        if (this._textureslots[slot] != t)\n        {\n            this.gl.activeTexture(this.gl.TEXTURE0 + slot);\n            this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);\n            this._textureslots[slot] = t;\n        }\n\n\n        return true;\n    }\n\n    fullScreen()\n    {\n        if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();\n        else if (this.canvas.mozRequestFullScreen) this.canvas.mozRequestFullScreen();\n        else if (this.canvas.webkitRequestFullscreen) this.canvas.webkitRequestFullscreen();\n        else if (this.canvas.msRequestFullscreen) this.canvas.msRequestFullscreen();\n    }\n\n\n    printError(str)\n    {\n        if (!this.checkGlErrors) return;\n        let found = false;\n        let error = this.gl.getError();\n\n        if (error != this.gl.NO_ERROR)\n        {\n            let errStr = \"\";\n            if (error == this.gl.OUT_OF_MEMORY) errStr = \"OUT_OF_MEMORY\";\n            if (error == this.gl.INVALID_ENUM) errStr = \"INVALID_ENUM\";\n            if (error == this.gl.INVALID_OPERATION) errStr = \"INVALID_OPERATION\";\n            if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION) errStr = \"INVALID_FRAMEBUFFER_OPERATION\";\n            if (error == this.gl.INVALID_VALUE) errStr = \"INVALID_VALUE\";\n            if (error == this.gl.CONTEXT_LOST_WEBGL)\n            {\n                this.aborted = true;\n                errStr = \"CONTEXT_LOST_WEBGL\";\n            }\n            if (error == this.gl.NO_ERROR) errStr = \"NO_ERROR\";\n\n            found = true;\n\n\n            this._log.warn(\"gl error [\" + this.canvas.id + \"]: \", str, error, errStr);\n\n            if (this.canvas.id.indexOf(\"glGuiCanvas\") == -1)\n                if (!this._loggedGlError)\n                {\n                    this.patch.printTriggerStack();\n                    this._log.stack(\"glerror\");\n                    this._loggedGlError = true;\n                }\n        }\n        error = this.gl.getError();\n\n        return found;\n    }\n\n    saveScreenshot(filename, cb, pw, ph, noclearalpha)\n    {\n        this.patch.renderOneFrame();\n\n        let w = this.canvas.clientWidth * this.pixelDensity;\n        let h = this.canvas.clientHeight * this.pixelDensity;\n\n        if (pw)\n        {\n            this.canvas.width = pw;\n            w = pw;\n        }\n        if (ph)\n        {\n            this.canvas.height = ph;\n            h = ph;\n        }\n\n        function padLeft(nr, n, str)\n        {\n            return Array(n - String(nr).length + 1).join(str || \"0\") + nr;\n        }\n\n        const d = new Date();\n\n        const dateStr = \"\".concat(String(d.getFullYear()) + String(d.getMonth() + 1) + String(d.getDate()), \"_\").concat(padLeft(d.getHours(), 2)).concat(padLeft(d.getMinutes(), 2)).concat(padLeft(d.getSeconds(), 2));\n\n        if (!filename) filename = \"cables_\" + dateStr + \".png\";\n        else filename += \".png\";\n\n        this.patch.cgl.screenShot(function (blob)\n        {\n            this.canvas.width = w;\n            this.canvas.height = h;\n\n            if (blob)\n            {\n                const anchor = document.createElement(\"a\");\n\n                anchor.download = filename;\n                anchor.href = URL.createObjectURL(blob);\n\n                setTimeout(function ()\n                {\n                    anchor.click();\n                    if (cb) cb(blob);\n                }, 100);\n            }\n            else\n            {\n                this._log.log(\"screenshot: no blob\");\n            }\n        }.bind(this), noclearalpha);\n    }\n\n\n    _dispose()\n    {\n        this._simpleShader.dispose();\n        this.gl = null;\n    }\n}\n\n\nContext.prototype.popShader = Context.prototype.setPreviousShader;\nContext.prototype.setShader = Context.prototype.pushShader;\n\n/**\n * execute the callback next frame, once\n * @function addNextFrameOnceCallback\n * @memberof Context\n * @instance\n * @param {function} callback\n */\nContext.prototype.addNextFrameOnceCallback = function (cb)\n{\n    if (cb) this._onetimeCallbacks.push(cb);\n};\n\n// state depthtest\n\n/**\n * push depth testing enabled state\n * @function pushDepthTest\n * @param {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype._stackDepthTest = [];\nContext.prototype.pushDepthTest = function (b)\n{\n    this._stackDepthTest.push(b);\n    if (!b) this.gl.disable(this.gl.DEPTH_TEST);\n    else this.gl.enable(this.gl.DEPTH_TEST);\n};\n/**\n * current state of depth testing\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateDepthTest = function ()\n{\n    return this._stackDepthTest[this._stackDepthTest.length - 1];\n};\n\n/**\n * pop depth testing state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\nContext.prototype.popDepthTest = function ()\n{\n    this._stackDepthTest.pop();\n\n    if (!this._stackDepthTest[this._stackDepthTest.length - 1]) this.gl.disable(this.gl.DEPTH_TEST);\n    else this.gl.enable(this.gl.DEPTH_TEST);\n};\n\n// --------------------------------------\n// state depthwrite\n\n/**\n * push depth write enabled state\n * @function pushDepthTest\n * @param {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype._stackDepthWrite = [];\nContext.prototype.pushDepthWrite = function (b)\n{\n    b = b || false;\n    this._stackDepthWrite.push(b);\n    this.gl.depthMask(b);\n};\n\n/**\n * current state of depth writing\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateDepthWrite = function ()\n{\n    return this._stackDepthWrite[this._stackDepthWrite.length - 1];\n};\n\n/**\n * pop depth writing state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\nContext.prototype.popDepthWrite = function ()\n{\n    this._stackDepthWrite.pop();\n    this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || false);\n};\n\n\n// --------------------------------------\n// state CullFace\n\n/**\n * push face culling face enabled state\n * @function pushCullFaceFacing\n * @param {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype._stackCullFace = [];\nContext.prototype.pushCullFace = function (b)\n{\n    this._stackCullFace.push(b);\n\n    if (b) this.gl.enable(this.gl.CULL_FACE);\n    else this.gl.disable(this.gl.CULL_FACE);\n};\n\n/**\n * current state of face culling\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateCullFace = function ()\n{\n    return this._stackCullFace[this._stackCullFace.length - 1];\n};\n\n/**\n * pop face culling enabled state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\nContext.prototype.popCullFace = function ()\n{\n    this._stackCullFace.pop();\n\n    if (this._stackCullFace[this._stackCullFace.length - 1]) this.gl.enable(this.gl.CULL_FACE);\n    else this.gl.disable(this.gl.CULL_FACE);\n};\n\n\n// --------------------------------------\n// state CullFace Facing\n\n\n/**\n * push face culling face side\n * @function pushCullFaceFacing\n * @param {Number} cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT\n * @memberof Context\n * @instance\n */\nContext.prototype._stackCullFaceFacing = [];\nContext.prototype.pushCullFaceFacing = function (b)\n{\n    this._stackCullFaceFacing.push(b);\n    this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);\n};\n\n/**\n * current state of face culling side\n * @function stateCullFaceFacing\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateCullFaceFacing = function ()\n{\n    return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];\n};\n\n/**\n * pop face culling face side\n * @function popCullFaceFacing\n * @memberof Context\n * @instance\n */\nContext.prototype.popCullFaceFacing = function ()\n{\n    this._stackCullFaceFacing.pop();\n    if (this._stackCullFaceFacing.length > 0) this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);\n};\n\n\n// --------------------------------------\n// state depthfunc\n\nContext.prototype._stackDepthFunc = [];\n\n/**\n * enable / disable depth testing\n * like `gl.depthFunc(boolean);`\n * @function pushDepthFunc\n * @memberof Context\n * @instance\n * @param {Boolean} depthtesting\n */\nContext.prototype.pushDepthFunc = function (f)\n{\n    this._stackDepthFunc.push(f);\n    this.gl.depthFunc(f);\n};\n\n/**\n * current state of blend\n * @function stateDepthFunc\n * @memberof Context\n * @instance\n * @returns {Boolean} depth testing enabled/disabled\n */\nContext.prototype.stateDepthFunc = function ()\n{\n    if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];\n    return false;\n};\n\n/**\n * pop depth testing and set the previous state\n * @function popDepthFunc\n * @memberof Context\n * @instance\n */\nContext.prototype.popDepthFunc = function ()\n{\n    this._stackDepthFunc.pop();\n    if (this._stackDepthFunc.length > 0) this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);\n};\n\n// --------------------------------------\n// state blending\n\nContext.prototype._stackBlend = [];\n\n/**\n * enable / disable blend\n * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);\n * @function pushBlend\n * @memberof Context\n * @instance\n * @param {Boolean} blending\n */\nContext.prototype.pushBlend = function (b)\n{\n    this._stackBlend.push(b);\n    if (!b) this.gl.disable(this.gl.BLEND);\n    else this.gl.enable(this.gl.BLEND);\n};\n\n/**\n * pop blend state and set the previous state\n * @function popBlend\n * @memberof Context\n * @instance\n */\nContext.prototype.popBlend = function ()\n{\n    this._stackBlend.pop();\n\n    if (!this._stackBlend[this._stackBlend.length - 1]) this.gl.disable(this.gl.BLEND);\n    else this.gl.enable(this.gl.BLEND);\n};\n\n/**\n * current state of blend\n * @function stateBlend\n * @returns {boolean} blending enabled/disabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateBlend = function ()\n{\n    return this._stackBlend[this._stackBlend.length - 1];\n};\n\nconst BLENDS = {\n    \"BLEND_NONE\": 0,\n    \"BLEND_NORMAL\": 1,\n    \"BLEND_ADD\": 2,\n    \"BLEND_SUB\": 3,\n    \"BLEND_MUL\": 4,\n};\n\nContext.prototype._stackBlendMode = [];\nContext.prototype._stackBlendModePremul = [];\n\n/**\n * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)\n * @function pushBlendMode\n * @memberof Context\n * @instance\n * @param {Number} blendmode\n * @param {Boolean} premultiplied mode\n */\nContext.prototype.pushBlendMode = function (blendMode, premul)\n{\n    this._stackBlendMode.push(blendMode);\n    this._stackBlendModePremul.push(premul);\n\n    const n = this._stackBlendMode.length - 1;\n\n    this.pushBlend(this._stackBlendMode[n] !== _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_NONE);\n    this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);\n};\n\n/**\n * pop predefined blendmode / switch back to previous blendmode\n * @function popBlendMode\n * @memberof Context\n * @instance\n */\nContext.prototype.popBlendMode = function ()\n{\n    this._stackBlendMode.pop();\n    this._stackBlendModePremul.pop();\n\n    const n = this._stackBlendMode.length - 1;\n\n    this.popBlend(this._stackBlendMode[n] !== _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_NONE);\n\n    if (n >= 0) this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);\n};\n\n\n// --------------------------------------\n// state stencil\n\nContext.prototype._stackStencil = [];\n\n/**\n * enable / disable stencil testing\n\n* @function pushStencil\n * @memberof Context\n * @instance\n * @param {Boolean} enable\n */\nContext.prototype.pushStencil = function (b)\n{\n    this._stackStencil.push(b);\n    if (!b) this.gl.disable(this.gl.STENCIL_TEST);\n    else this.gl.enable(this.gl.STENCIL_TEST);\n};\n\n/**\n * pop stencil test state and set the previous state\n * @function popStencil\n * @memberof Context\n * @instance\n */\nContext.prototype.popStencil = function ()\n{\n    this._stackStencil.pop();\n\n    if (!this._stackStencil[this._stackStencil.length - 1]) this.gl.disable(this.gl.STENCIL_TEST);\n    else this.gl.enable(this.gl.STENCIL_TEST);\n};\n\n// --------------------------------------\n\n\nContext.prototype.glGetAttribLocation = function (prog, name)\n{\n    const l = this.gl.getAttribLocation(prog, name);\n    // if (l == -1)\n    // {\n    //     this._log.warn(\"get attr loc -1 \", name);\n    // }\n    return l;\n};\n\n\n/**\n * should an op now draw helpermeshes\n * @function shouldDrawHelpers\n * @memberof Context\n * @instance\n */\nContext.prototype.shouldDrawHelpers = function (op)\n{\n    if (this.frameStore.shadowPass) return false;\n    if (!op.patch.isEditorMode()) return false;\n\n    const fb = this.getCurrentFrameBuffer();\n    if (fb && fb.getWidth)\n    {\n        const fbshould = this.canvasWidth / this.canvasHeight == fb.getWidth() / fb.getHeight();\n        if (!fbshould) return false;\n    }\n\n    return CABLES.UI.renderHelper || (CABLES.UI.renderHelperCurrent && op.isCurrentUiOp());\n};\n\nContext.prototype._setBlendMode = function (blendMode, premul)\n{\n    const gl = this.gl;\n\n    if (blendMode == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_NONE)\n    {\n        // this.gl.disable(this.gl.BLEND);\n    }\n    else if (blendMode == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_ADD)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\n        }\n        else\n        {\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n        }\n    }\n    else if (blendMode == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_SUB)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n        }\n        else\n        {\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);\n        }\n    }\n    else if (blendMode == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_MUL)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n        }\n        else\n        {\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n        }\n    }\n    else if (blendMode == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.BLEND_MODES.BLEND_NORMAL)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        }\n        else\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        }\n    }\n    else\n    {\n        this._log.log(\"setblendmode: unknown blendmode\");\n    }\n};\n\nContext.prototype.createMesh = function (geom, options)\n{\n    if (CABLES.UTILS.isNumeric(options))options = { \"glPrimitive\": options }; // old constructor fallback...\n    return new CGL.Mesh(this, geom, options);\n};\n\n\n/**\n * set cursor\n * @function setCursor\n * @memberof Context\n * @instance\n * @param {String} css cursor string\n */\nContext.prototype.setCursor = function (str)\n{\n    this._cursor = str;\n};\n\n\n/**\n * enable a webgl extension\n * @function enableExtension\n * @memberof Context\n * @instance\n * @param {String} extension name\n * @returns {Object} extension object or null\n */\nContext.prototype.enableExtension = function (name)\n{\n    // const start = performance.now();\n\n    if (this._enabledExtensions.hasOwnProperty(name))\n    {\n        return this._enabledExtensions[name];\n    }\n\n    const o = this.gl.getExtension(name);\n    this._enabledExtensions[name] = o;\n\n    if (!o)\n        this._log.warn(\"[cgl_state] extension not available \" + name);\n    else\n        this._log.log(\"enabled extension\", name);\n\n    return o;\n};\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3N0YXRlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc3RhdGUuanM/MmFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuL2NnbF9zaGFkZXJcIjtcbmltcG9ydCB7IFByb2ZpbGVEYXRhIH0gZnJvbSBcIi4vY2dsX3Byb2ZpbGVkYXRhXCI7XG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi9jb3JlX2xvZ2dlclwiO1xuaW1wb3J0IHsgQ0dTdGF0ZSB9IGZyb20gXCIuLi9jZy9jZ19zdGF0ZVwiO1xuaW1wb3J0IHsgQ0cgfSBmcm9tIFwiLi4vY2cvY2dfY29uc3RhbnRzXCI7XG5cblxuLyoqXG4gKiBjYWJsZXMgZ2wgY29udGV4dC9zdGF0ZSBtYW5hZ2VyXG4gKiBAZXh0ZXJuYWwgQ0dMXG4gKiBAbmFtZXNwYWNlIENvbnRleHRcbiAqIEBjbGFzc1xuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG4vLyBjb25zdCBDb250ZXh0KF9wYXRjaClcbmNsYXNzIENvbnRleHQgZXh0ZW5kcyBDR1N0YXRlXG57XG4gICAgY29uc3RydWN0b3IoX3BhdGNoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoX3BhdGNoKTtcbiAgICAgICAgLy8gRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG4gICAgICAgIC8vIENHU3RhdGUuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgdGhpcy5nQXBpID0gQ0cuR0FQSV9XRUJHTDtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5wdXNoTXZNYXRyaXggPSB0aGlzLnB1c2hNb2RlbE1hdHJpeDsgLy8gZGVwcmVjYXRlZCBhbmQgd3JvbmcuLi4gc3RpbGwgdXNlZD8/XG4gICAgICAgIHRoaXMucG9wTXZNYXRyaXggPSB0aGlzLnBvcG1NYXRyaXggPSB0aGlzLnBvcE1vZGVsTWF0cml4Oy8vIGRlcHJlY2F0ZWQgYW5kIHdyb25nLi4uIHN0aWxsIHVzZWQ/P1xuXG4gICAgICAgIHRoaXMucHJvZmlsZURhdGEgPSBuZXcgUHJvZmlsZURhdGEodGhpcyk7XG4gICAgICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ2xfY29udGV4dFwiKTtcbiAgICAgICAgdGhpcy5fdmlld1BvcnQgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIHRoaXMuZ2xWZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5nbFVzZUhhbGZGbG9hdFRleCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzRGVwdGggPSB0cnVlO1xuICAgICAgICB0aGlzLmRlYnVnT25lRnJhbWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGVja0dsRXJyb3JzID0gZmFsc2U7IC8vIHRydWUgaXMgc2xvdyAvLyBmYWxzZSBzaG91bGQgYmUgZGVmYXVsdC4uLlxuICAgICAgICB0aGlzLm1heFRleHR1cmVVbml0cyA9IDA7XG4gICAgICAgIHRoaXMubWF4VmFyeWluZ1ZlY3RvcnMgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFkU3RhY2tFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdsU2xvd1JlbmRlcmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2FmYXJpQ3JhcCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5VGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhbWVTdG9yZSA9IHt9O1xuICAgICAgICB0aGlzLl9vbmV0aW1lQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2N1cnNvciA9IFwiYXV0b1wiO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yID0gXCJcIjtcblxuICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9mcmFtZUJ1ZmZlclN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX3NoYWRlclN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX3N0YWNrRGVwdGhUZXN0ID0gW107XG4gICAgICAgIHRoaXMubWFpbmxvb3BPcCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5fcGl4ZWxEZW5zaXR5ID0gO1xuXG5cbiAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyID0gbmV3IFNoYWRlcih0aGlzLCBcInNpbXBsZXNoYWRlclwiKTtcbiAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyLnNldE1vZHVsZXMoW1wiTU9EVUxFX1ZFUlRFWF9QT1NJVElPTlwiLCBcIk1PRFVMRV9DT0xPUlwiLCBcIk1PRFVMRV9CRUdJTl9GUkFHXCJdKTtcbiAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyLnNldFNvdXJjZShTaGFkZXIuZ2V0RGVmYXVsdFZlcnRleFNoYWRlcigpLCBTaGFkZXIuZ2V0RGVmYXVsdEZyYWdtZW50U2hhZGVyKCkpO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXIgPSB0aGlzLl9zaW1wbGVTaGFkZXI7XG5cblxuICAgICAgICB0aGlzLl9vbGRDYW52YXNXaWR0aCA9IC0xO1xuICAgICAgICB0aGlzLl9vbGRDYW52YXNIZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZEV4dGVuc2lvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGl4ZWxEZW5zaXR5KHApXG4gICAgLy8ge1xuICAgIC8vICAgICB0aGlzLl9waXhlbERlbnNpdHkgPSBwO1xuICAgIC8vIH1cblxuICAgIC8vIGdldCBwaXhlbERlbnNpdHkoKVxuICAgIC8vIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuX3BpeGVsRGVuc2l0eTtcbiAgICAvLyB9XG5cblxuXG4gICAgZ2V0IHZpZXdQb3J0KClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl92aWV3UG9ydFN0YWNrLmxlbmd0aCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSB0aGlzLl92aWV3UG9ydFN0YWNrLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSA0XSxcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSAzXSxcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSAyXSxcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSAxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgcHJlIHZpZXdwb3J0IHN0YWNrIHRpbWVzIC8gb3IrYW5kIGluaXRpYWwgdmFsdWUuLi5cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdQb3J0O1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIGdldCBtdk1hdHJpeCgpIC8vIGRlcHJlY2F0ZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU1hdHJpeDtcbiAgICB9XG5cbiAgICBzZXQgbXZNYXRyaXgobSkgLy8gZGVwcmVjYXRlXG4gICAge1xuICAgICAgICB0aGlzLm1NYXRyaXggPSBtO1xuICAgIH1cblxuXG4gICAgZXhpdEVycm9yKG1zZ0lkLCBtc2cpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhtc2dJZCwgbXNnKTtcbiAgICAgICAgdGhpcy5wYXRjaC5leGl0RXJyb3IobXNnSWQsIG1zZyk7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuXG5cbiAgICBfc2V0Q2FudmFzKGNhbnYpXG4gICAge1xuICAgICAgICBpZiAoIWNhbnYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5zdGFjayhcIl9zZXRDYW52YXMgdW5kZWZcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGF0Y2guY29uZmlnLmNhbnZhcykgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzID0ge307XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmhhc093blByb3BlcnR5KFwicHJlc2VydmVEcmF3aW5nQnVmZmVyXCIpKSB0aGlzLnBhdGNoLmNvbmZpZy5jYW52YXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmhhc093blByb3BlcnR5KFwicHJlbXVsdGlwbGllZEFscGhhXCIpKSB0aGlzLnBhdGNoLmNvbmZpZy5jYW52YXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmhhc093blByb3BlcnR5KFwiYWxwaGFcIikpIHRoaXMucGF0Y2guY29uZmlnLmNhbnZhcy5hbHBoYSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucGF0Y2guY29uZmlnLmNhbnZhcy5zdGVuY2lsID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5wYXRjaC5jb25maWcuaGFzT3duUHJvcGVydHkoXCJjbGVhckNhbnZhc0NvbG9yXCIpKSB0aGlzLmNsZWFyQ2FudmFzVHJhbnNwYXJlbnQgPSB0aGlzLnBhdGNoLmNvbmZpZy5jbGVhckNhbnZhc0NvbG9yO1xuICAgICAgICBpZiAodGhpcy5wYXRjaC5jb25maWcuaGFzT3duUHJvcGVydHkoXCJjbGVhckNhbnZhc0RlcHRoXCIpKSB0aGlzLmNsZWFyQ2FudmFzRGVwdGggPSB0aGlzLnBhdGNoLmNvbmZpZy5jbGVhckNhbnZhc0RlcHRoO1xuXG4gICAgICAgIC8vIHNhZmFyaSBzdHVmZi4uLi4uLi4uLi5cbiAgICAgICAgaWYgKC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZS9pKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2FmYXJpQ3JhcCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmdsVXNlSGFsZkZsb2F0VGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmZvcmNlV2ViR2wxKSB0aGlzLmdsID0gY2Fudi5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHRoaXMucGF0Y2guY29uZmlnLmNhbnZhcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2wgJiYgdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5WRVJTSU9OKSAhPSBcIldlYkdMIDEuMFwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsVmVyc2lvbiA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsID0gY2Fudi5nZXRDb250ZXh0KFwid2ViZ2xcIiwgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzKSB8fCBjYW52LmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMuZ2xWZXJzaW9uID0gMTtcblxuICAgICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgICAvLyBpZiAoL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBob25lL2kpKSlcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLmdsVXNlSGFsZkZsb2F0VGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gaW9zXG4gICAgICAgICAgICBpZiAoL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGF0Y2guY29uZmlnLmNhbnZhcy5oYXNPd25Qcm9wZXJ0eShcInBvd2VyUHJlZmVyZW5jZVwiKSkgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLnBvd2VyUHJlZmVyZW5jZSA9IFwiaGlnaC1wZXJmb3JtYW5jZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUV4dGVuc2lvbihcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZW5hYmxlRXh0ZW5zaW9uKFwiR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXCIpO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2luZ0V4dCA9IHRoaXMuZW5hYmxlRXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKSB8fCB0aGlzLmdsO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNpbmdFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IGluc3RhbmNpbmdFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFLmJpbmQoaW5zdGFuY2luZ0V4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSBpbnN0YW5jaW5nRXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFLmJpbmQoaW5zdGFuY2luZ0V4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4aXRFcnJvcihcIk5PX1dFQkdMXCIsIFwic29ycnksIGNvdWxkIG5vdCBpbml0aWFsaXplIFdlYkdMLiBQbGVhc2UgY2hlY2sgaWYgeW91ciBCcm93c2VyIHN1cHBvcnRzIFdlYkdMIG9yIHRyeSB0byByZXN0YXJ0IHlvdXIgYnJvd3Nlci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYmdSZW5kZXJJbmZvID0gdGhpcy5lbmFibGVFeHRlbnNpb24oXCJXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvXCIpO1xuICAgICAgICBpZiAoZGJnUmVuZGVySW5mbylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nbFJlbmRlcmVyID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZGJnUmVuZGVySW5mby5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nbFJlbmRlcmVyID09PSBcIkdvb2dsZSBTd2lmdFNoYWRlclwiKSB0aGlzLmdsU2xvd1JlbmRlcmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIChldmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuIGNvbnNvbGUubG9nKFwiW2NnbF9zdGF0ZV0gYWJvcnRlZCBjb250ZXh0IGxvc3QuLi4gY2FuIGJlIGlnbm9yZWQuLi5cIik7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJjYW52YXMgbG9zdC4uLlwiLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIndlYmdsY29udGV4dGxvc3RcIik7XG4gICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIHRoaXMubWF4QW5pc290cm9waWMgPSAwO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpXG4gICAgICAgICAgICB0aGlzLm1heEFuaXNvdHJvcGljID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5lbmFibGVFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcblxuXG4gICAgICAgIHRoaXMubWF4VmFyeWluZ1ZlY3RvcnMgPSB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMpO1xuICAgICAgICB0aGlzLm1heFRleHR1cmVVbml0cyA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgICAgICB0aGlzLm1heFRleFNpemUgPSB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgICAgICB0aGlzLm1heFVuaWZvcm1zRnJhZyA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyk7XG4gICAgICAgIHRoaXMubWF4VW5pZm9ybXNWZXJ0ID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyk7XG4gICAgICAgIHRoaXMubWF4U2FtcGxlcyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmdsLk1BWF9TQU1QTEVTKSB0aGlzLm1heFNhbXBsZXMgPSB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLk1BWF9TQU1QTEVTKTtcblxuICAgICAgICBpZiAodGhpcy5nbFZlcnNpb24gPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVFeHRlbnNpb24oXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIik7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jaW5nRXh0ID0gdGhpcy5lbmFibGVFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpIHx8IHRoaXMuZ2w7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jaW5nRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IgPSBpbnN0YW5jaW5nRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRS5iaW5kKGluc3RhbmNpbmdFeHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkID0gaW5zdGFuY2luZ0V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRS5iaW5kKGluc3RhbmNpbmdFeHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ERVBUSF9GVU5DUyA9IFtcbiAgICAgICAgICAgIHRoaXMuZ2wuTkVWRVIsXG4gICAgICAgICAgICB0aGlzLmdsLkFMV0FZUyxcbiAgICAgICAgICAgIHRoaXMuZ2wuTEVTUyxcbiAgICAgICAgICAgIHRoaXMuZ2wuTEVRVUFMLFxuICAgICAgICAgICAgdGhpcy5nbC5HUkVBVEVSLFxuICAgICAgICAgICAgdGhpcy5nbC5HRVFVQUwsXG4gICAgICAgICAgICB0aGlzLmdsLkVRVUFMLFxuICAgICAgICAgICAgdGhpcy5nbC5OT1RFUVVBTFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLkNVTExfTU9ERVMgPSBbXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGhpcy5nbC5CQUNLLFxuICAgICAgICAgICAgdGhpcy5nbC5GUk9OVCxcbiAgICAgICAgICAgIHRoaXMuZ2wuRlJPTlRfQU5EX0JBQ0tcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBnZXRJbmZvKClcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImdsVmVyc2lvblwiOiB0aGlzLmdsVmVyc2lvbixcbiAgICAgICAgICAgIFwiZ2xSZW5kZXJlclwiOiB0aGlzLmdsUmVuZGVyZXIsXG4gICAgICAgICAgICBcImdsVXNlSGFsZkZsb2F0VGV4XCI6IHRoaXMuZ2xVc2VIYWxmRmxvYXRUZXgsXG4gICAgICAgICAgICBcIm1heFZhcnlpbmdWZWN0b3JzXCI6IHRoaXMubWF4VmFyeWluZ1ZlY3RvcnMsXG4gICAgICAgICAgICBcIm1heFRleHR1cmVVbml0c1wiOiB0aGlzLm1heFRleHR1cmVVbml0cyxcbiAgICAgICAgICAgIFwibWF4VGV4U2l6ZVwiOiB0aGlzLm1heFRleFNpemUsXG4gICAgICAgICAgICBcIm1heFVuaWZvcm1zRnJhZ1wiOiB0aGlzLm1heFVuaWZvcm1zRnJhZyxcbiAgICAgICAgICAgIFwibWF4VW5pZm9ybXNWZXJ0XCI6IHRoaXMubWF4VW5pZm9ybXNWZXJ0LFxuICAgICAgICAgICAgXCJtYXhTYW1wbGVzXCI6IHRoaXMubWF4U2FtcGxlc1xuICAgICAgICB9O1xuICAgIH1cblxuXG5cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHBvcFZpZXdQb3J0XG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gcG9wIHZpZXdQb3J0IHN0YWNrXG4gICAgICovXG5cblxuICAgIHBvcFZpZXdQb3J0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdQb3J0U3RhY2subGVuZ3RoID09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld1BvcnQoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgLy8gdGhpcy5nbC52aWV3cG9ydCh0aGlzLl92aWV3UG9ydFswXSwgdGhpcy5fdmlld1BvcnRbMV0sIHRoaXMuX3ZpZXdQb3J0WzJdLCB0aGlzLl92aWV3UG9ydFszXSk7XG4gICAgICAgICAgICAvLyB0aGlzLnNldFZpZXdQb3J0KHRoaXMuX3ZpZXdQb3J0WzBdLCB0aGlzLl92aWV3UG9ydFsxXSwgdGhpcy5fdmlld1BvcnRbMl0sIHRoaXMuX3ZpZXdQb3J0WzNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMudmlld1BvcnQgPSBbdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSA0XSwgdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSAzXSwgdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSAyXSwgdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICAvLyB0aGlzLmdsLnZpZXdwb3J0KHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gNF0sIHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gM10sIHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gMl0sIHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3UG9ydCh0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDRdLCB0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDNdLCB0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDJdLCB0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBwdXNoVmlld1BvcnRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZXNjcmlwdGlvbiBwdXNoIGEgbmV3IHZpZXdwb3J0IG9udG8gc3RhY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaFxuICAgICAqL1xuXG4gICAgcHVzaFZpZXdQb3J0KHgsIHksIHcsIGgpXG4gICAge1xuICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrLnB1c2goeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuc2V0Vmlld1BvcnQoeCwgeSwgdywgaCk7XG4gICAgfVxuXG5cbiAgICAvLyBvbGRcbiAgICBnZXRWaWV3UG9ydCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1BvcnQ7XG4gICAgfVxuXG4gICAgLy8gb2xkXG4gICAgcmVzZXRWaWV3UG9ydCgpXG4gICAge1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHRoaXMuX3ZpZXdQb3J0WzBdLCB0aGlzLl92aWV3UG9ydFsxXSwgdGhpcy5fdmlld1BvcnRbMl0sIHRoaXMuX3ZpZXdQb3J0WzNdKTtcbiAgICB9XG5cbiAgICAvLyBvbGRcbiAgICBzZXRWaWV3UG9ydCh4LCB5LCB3LCBoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmlld1BvcnRbMF0gPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICB0aGlzLl92aWV3UG9ydFsxXSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0WzJdID0gTWF0aC5yb3VuZCh3KTtcbiAgICAgICAgdGhpcy5fdmlld1BvcnRbM10gPSBNYXRoLnJvdW5kKGgpO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHRoaXMuX3ZpZXdQb3J0WzBdLCB0aGlzLl92aWV3UG9ydFsxXSwgdGhpcy5fdmlld1BvcnRbMl0sIHRoaXMuX3ZpZXdQb3J0WzNdKTtcbiAgICB9XG5cblxuICAgIHNjcmVlblNob3QoY2IsIGRvU2NyZWVuc2hvdENsZWFyQWxwaGEsIG1pbWVUeXBlLCBxdWFsaXR5KVxuICAgIHtcbiAgICAgICAgaWYgKGRvU2NyZWVuc2hvdENsZWFyQWxwaGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuY2xlYXJDb2xvcigxLCAxLCAxLCAxKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgdGhpcy5nbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudG9CbG9iKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy50b0Jsb2IoKGJsb2IpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGNiKSBjYihibG9iKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMuX2xvZy5sb2coXCJubyBzY3JlZW5zaG90IGNhbGxiYWNrLi4uXCIpO1xuICAgICAgICAgICAgfSwgbWltZVR5cGUsIHF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5kRnJhbWUoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkpIENBQkxFUy5HTF9NQVJLRVIuZHJhd01hcmtlckxheWVyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2V0UHJldmlvdXNTaGFkZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5fdk1hdHJpeFN0YWNrLmxlbmd0aCgpID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwidmlldyBtYXRyaXggc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fbU1hdHJpeFN0YWNrLmxlbmd0aCgpID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwibXZtYXRyaXggc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fcE1hdHJpeFN0YWNrLmxlbmd0aCgpID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwicG1hdHJpeCBzdGFjayBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2subGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiZ2xGcmFtZUJ1ZmZlciBzdGFjayBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLl9zdGFja0RlcHRoVGVzdC5sZW5ndGggPiAwKSB0aGlzLmxvZ1N0YWNrRXJyb3IoXCJkZXB0aHRlc3Qgc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tEZXB0aFdyaXRlLmxlbmd0aCA+IDApIHRoaXMubG9nU3RhY2tFcnJvcihcImRlcHRod3JpdGUgc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tEZXB0aEZ1bmMubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiZGVwdGhmdW5jIHN0YWNrIGxlbmd0aCAhPTAgYXQgZW5kIG9mIHJlbmRlcmluZy4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrQmxlbmQubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiYmxlbmQgc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tCbGVuZE1vZGUubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiYmxlbmRNb2RlIHN0YWNrIGxlbmd0aCAhPTAgYXQgZW5kIG9mIHJlbmRlcmluZy4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRlclN0YWNrLmxlbmd0aCA+IDApIHRoaXMubG9nU3RhY2tFcnJvcihcInRoaXMuX3NoYWRlclN0YWNrIGxlbmd0aCAhPTAgYXQgZW5kIG9mIHJlbmRlcmluZy4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrQ3VsbEZhY2UubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwidGhpcy5fc3RhY2tDdWxsRmFjZSBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLmxlbmd0aCA+IDApIHRoaXMubG9nU3RhY2tFcnJvcihcInRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmlld1BvcnRTdGFjay5sZW5ndGggPiAwKSB0aGlzLmxvZ1N0YWNrRXJyb3IoXCJ2aWV3cG9ydCBzdGFjayBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX29sZENhbnZhc1dpZHRoICE9IHRoaXMuY2FudmFzV2lkdGggfHwgdGhpcy5fb2xkQ2FudmFzSGVpZ2h0ICE9IHRoaXMuY2FudmFzSGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRDYW52YXNXaWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9vbGRDYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIC8vIHRoaXMuc2V0U2l6ZSh0aGlzLmNhbnZhc1dpZHRoIC8gdGhpcy5waXhlbERlbnNpdHksIHRoaXMuY2FudmFzSGVpZ2h0IC8gdGhpcy5waXhlbERlbnNpdHkpO1xuICAgICAgICAgICAgLy8gdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcInJlc2l6ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IgIT0gdGhpcy5fY3VycmVudEN1cnNvcilcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3IgPSB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlbmRmcmFtZVwiKTtcblxuICAgICAgICB0aGlzLmZwc0NvdW50ZXIuZW5kRnJhbWUoKTtcbiAgICB9XG5cbiAgICBsb2dTdGFja0Vycm9yKHN0cilcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faGFkU3RhY2tFcnJvcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faGFkU3RhY2tFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIltcIiArIHRoaXMuY2FudmFzLmlkICsgXCJdOiBcIiwgc3RyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNoYWRlciBzdGFja1xuICAgIGdldFNoYWRlcigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFNoYWRlcikgaWYgKCF0aGlzLmZyYW1lU3RvcmUgfHwgKCh0aGlzLmZyYW1lU3RvcmUucmVuZGVyT2Zmc2NyZWVuID09PSB0cnVlKSA9PSB0aGlzLl9jdXJyZW50U2hhZGVyLm9mZlNjcmVlblBhc3MpID09PSB0cnVlKSByZXR1cm4gdGhpcy5fY3VycmVudFNoYWRlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmICh0aGlzLl9zaGFkZXJTdGFja1tpXSkgaWYgKHRoaXMuZnJhbWVTdG9yZS5yZW5kZXJPZmZzY3JlZW4gPT0gdGhpcy5fc2hhZGVyU3RhY2tbaV0ub2ZmU2NyZWVuUGFzcykgcmV0dXJuIHRoaXMuX3NoYWRlclN0YWNrW2ldO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRTaGFkZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZVNoYWRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdXNoIGEgc2hhZGVyIHRvIHRoZSBzaGFkZXIgc3RhY2tcbiAgICAgKiBAZnVuY3Rpb24gcHVzaFNoYWRlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNoYWRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gICAgcHVzaFNoYWRlcihzaGFkZXIpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5mcmFtZVN0b3JlLmZvcmNlU2hhZGVyTW9kcylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGlmICghY3VycmVudFNoYWRlci5mb3JjZWRNb2QgJiYgY3VycmVudFNoYWRlciAhPSB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzW2ldKVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgY3VycmVudFNoYWRlci5mb3JjZWRNb2QgPSB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzW2ldO1xuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuZnJhbWVTdG9yZS5mb3JjZVNoYWRlck1vZHNbaV0uYmluZChzaGFkZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGN1cnJlbnRTaGFkZXI7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuZnJhbWVTdG9yZS5mb3JjZVNoYWRlck1vZHNbaV0uY3VycmVudFNoYWRlcigpICYmIHNoYWRlciAhPSB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzW2ldLmN1cnJlbnRTaGFkZXIoKS5zaGFkZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaGFkZXJTdGFjay5wdXNoKHNoYWRlcik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBwb3AgY3VycmVudCB1c2VkIHNoYWRlciBmcm9tIHNoYWRlciBzdGFja1xuICAgICAqIEBmdW5jdGlvbiBwb3BTaGFkZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHNldFByZXZpb3VzU2hhZGVyKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnJhbWVTdG9yZS5mb3JjZVNoYWRlck1vZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgYSA9XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZVN0b3JlLmZvcmNlU2hhZGVyTW9kc1tpXS51bmJpbmQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIGlmIChhKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5wb3BTaGFkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXJTdGFjay5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2hhZGVyIHN0YWNrIHBvcCFcIik7XG4gICAgICAgIHRoaXMuX3NoYWRlclN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50U2hhZGVyID0gdGhpcy5fc2hhZGVyU3RhY2tbdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHVzaCBhIGZyYW1lYnVmZmVyIHRvIHRoZSBmcmFtZWJ1ZmZlciBzdGFja1xuICAgICAqIEBmdW5jdGlvbiBwdXNoR2xGcmFtZUJ1ZmZlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZyYW1lYnVmZmVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgcHVzaEdsRnJhbWVCdWZmZXIoZmIpXG4gICAge1xuICAgICAgICB0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2sucHVzaChmYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9wIGZyYW1lYnVmZmVyIHN0YWNrXG4gICAgICogQGZ1bmN0aW9uIHBvcEdsRnJhbWVCdWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGN1cnJlbnQgZnJhbWVidWZmZXIgb3IgbnVsbFxuICAgICAqL1xuICAgIHBvcEdsRnJhbWVCdWZmZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFja1t0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGN1cnJlbnQgZnJhbWVidWZmZXJcbiAgICAgKiBAZnVuY3Rpb24gZ2V0Q3VycmVudEZyYW1lQnVmZmVyXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjdXJyZW50IGZyYW1lYnVmZmVyIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50R2xGcmFtZUJ1ZmZlcigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZ2xGcmFtZUJ1ZmZlclN0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2tbdGhpcy5fZ2xGcmFtZUJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1c2ggYSBmcmFtZWJ1ZmZlciB0byB0aGUgZnJhbWVidWZmZXIgc3RhY2tcbiAgICAgKiBAZnVuY3Rpb24gcHVzaEdsRnJhbWVCdWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyXG4gICAgICovXG4gICAgcHVzaEZyYW1lQnVmZmVyKGZiKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZnJhbWVCdWZmZXJTdGFjay5wdXNoKGZiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3AgZnJhbWVidWZmZXIgc3RhY2tcbiAgICAgKiBAZnVuY3Rpb24gcG9wRnJhbWVCdWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtGcmFtZWJ1ZmZlcn0gY3VycmVudCBmcmFtZWJ1ZmZlciBvciBudWxsXG4gICAgICovXG4gICAgcG9wRnJhbWVCdWZmZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lQnVmZmVyU3RhY2subGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLl9mcmFtZUJ1ZmZlclN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVCdWZmZXJTdGFja1t0aGlzLl9mcmFtZUJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBjdXJyZW50IGZyYW1lYnVmZmVyXG4gICAgICogQGZ1bmN0aW9uIGdldEN1cnJlbnRGcmFtZUJ1ZmZlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0ZyYW1lYnVmZmVyfSBjdXJyZW50IGZyYW1lYnVmZmVyIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50RnJhbWVCdWZmZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lQnVmZmVyU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lQnVmZmVyU3RhY2tbdGhpcy5fZnJhbWVCdWZmZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG5cblxuICAgIHJlbmRlclN0YXJ0KGNnbCwgaWRlbnRUcmFuc2xhdGUsIGlkZW50VHJhbnNsYXRlVmlldylcbiAgICB7XG4gICAgICAgIHRoaXMuZnBzQ291bnRlci5zdGFydEZyYW1lKCk7XG4gICAgICAgIHRoaXMucHVzaERlcHRoVGVzdCh0cnVlKTtcbiAgICAgICAgdGhpcy5wdXNoRGVwdGhXcml0ZSh0cnVlKTtcbiAgICAgICAgdGhpcy5wdXNoRGVwdGhGdW5jKGNnbC5nbC5MRVFVQUwpO1xuICAgICAgICB0aGlzLnB1c2hDdWxsRmFjZUZhY2luZyhjZ2wuZ2wuQkFDSyk7XG4gICAgICAgIHRoaXMucHVzaEN1bGxGYWNlKGZhbHNlKTtcblxuICAgICAgICAvLyBpZiAodGhpcy5jbGVhckNhbnZhc1RyYW5zcGFyZW50KVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICBjZ2wuZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgLy8gICAgIGNnbC5nbC5jbGVhcihjZ2wuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHRoaXMuY2xlYXJDYW52YXNEZXB0aCkgY2dsLmdsLmNsZWFyKGNnbC5nbC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgICAgICBjZ2wuc2V0Vmlld1BvcnQoMCwgMCwgY2dsLmNhbnZhc1dpZHRoLCBjZ2wuY2FudmFzSGVpZ2h0KTtcblxuXG4gICAgICAgIHRoaXMuX3N0YXJ0TWF0cml4U3RhY2tzKGlkZW50VHJhbnNsYXRlLCBpZGVudFRyYW5zbGF0ZVZpZXcpO1xuXG5cbiAgICAgICAgY2dsLnB1c2hCbGVuZE1vZGUoQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX05PUk1BTCwgZmFsc2UpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGV4dHVyZXNsb3RzLmxlbmd0aDsgaSsrKSB0aGlzLl90ZXh0dXJlc2xvdHNbaV0gPSBudWxsO1xuXG4gICAgICAgIHRoaXMucHVzaFNoYWRlcih0aGlzLl9zaW1wbGVTaGFkZXIpO1xuXG4gICAgICAgIHRoaXMuX2ZyYW1lU3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uZXRpbWVDYWxsYmFja3MubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9vbmV0aW1lQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB0aGlzLl9vbmV0aW1lQ2FsbGJhY2tzW2ldKCk7XG4gICAgICAgICAgICB0aGlzLl9vbmV0aW1lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXRFdmVudChcImJlZ2luRnJhbWVcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyRW5kKGNnbClcbiAgICB7XG4gICAgICAgIHRoaXMuX2VuZE1hdHJpeFN0YWNrcygpO1xuXG4gICAgICAgIHRoaXMucG9wRGVwdGhUZXN0KCk7XG4gICAgICAgIHRoaXMucG9wRGVwdGhXcml0ZSgpO1xuICAgICAgICB0aGlzLnBvcERlcHRoRnVuYygpO1xuICAgICAgICB0aGlzLnBvcEN1bGxGYWNlRmFjaW5nKCk7XG4gICAgICAgIHRoaXMucG9wQ3VsbEZhY2UoKTtcbiAgICAgICAgdGhpcy5wb3BCbGVuZCgpO1xuICAgICAgICB0aGlzLnBvcEJsZW5kTW9kZSgpO1xuXG4gICAgICAgIGNnbC5lbmRGcmFtZSgpO1xuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiZW5kRnJhbWVcIik7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZShzbG90KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzbG90c1tzbG90XTtcbiAgICB9XG5cbiAgICBoYXNGcmFtZVN0YXJ0ZWQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lU3RhcnRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb2cgd2FybmluZyB0byBjb25zb2xlIGlmIHRoZSByZW5kZXJpbmcgb2Ygb25lIGZyYW1lIGhhcyBub3QgYmVlbiBzdGFydGVkIC8gaGFuZHkgdG8gY2hlY2sgZm9yIGFzeW5jIHByb2JsZW1zXG4gICAgICogQGZ1bmN0aW9uIGNoZWNrRnJhbWVTdGFydGVkXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjaGVja0ZyYW1lU3RhcnRlZChzdHJpbmcpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2ZyYW1lU3RhcnRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJmcmFtZSBub3Qgc3RhcnRlZCBcIiArIHN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLnBhdGNoLnByaW50VHJpZ2dlclN0YWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHNldFRleHR1cmUoc2xvdCwgdCwgdHlwZSlcbiAgICB7XG4gICAgICAgIHRoaXMuY2hlY2tGcmFtZVN0YXJ0ZWQoXCJjZ2wgc2V0VGV4dHVyZVwiKTtcblxuICAgICAgICBpZiAodCA9PT0gbnVsbCkgdCA9IENHTC5UZXh0dXJlLmdldEVtcHR5VGV4dHVyZSh0aGlzKS50ZXg7XG5cbiAgICAgICAgLy8gaWYgKCF0aGlzLmdsLmlzVGV4dHVyZSh0KSlcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJub3QgYSB0ZXh0dXJlISEhIVwiKTsgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyAgICAgdCA9IENHTC5UZXh0dXJlLmdldEVtcHR5VGV4dHVyZSh0aGlzKS50ZXg7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoIXRoaXMuZ2wuaXNUZXh0dXJlKHQpKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICB0ID0gQ0dMLlRleHR1cmUuZ2V0RXJyb3JUZXh0dXJlKHRoaXMpLnRleDtcbiAgICAgICAgLy8gICAgIC8vIHRoaXMuX2xvZy5zdGFjayhcIm5vdCBhIHRleHR1cmUhISEhXCIpO1xuICAgICAgICAvLyAgICAgLy8gcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyB9XG5cblxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZXNsb3RzW3Nsb3RdICE9IHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgc2xvdCk7XG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHR5cGUgfHwgdGhpcy5nbC5URVhUVVJFXzJELCB0KTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzbG90c1tzbG90XSA9IHQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bGxTY3JlZW4oKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLnJlcXVlc3RGdWxsc2NyZWVuKSB0aGlzLmNhbnZhcy5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbikgdGhpcy5jYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jYW52YXMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHRoaXMuY2FudmFzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHRoaXMuY2FudmFzLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9XG5cblxuICAgIHByaW50RXJyb3Ioc3RyKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrR2xFcnJvcnMpIHJldHVybjtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGxldCBlcnJvciA9IHRoaXMuZ2wuZ2V0RXJyb3IoKTtcblxuICAgICAgICBpZiAoZXJyb3IgIT0gdGhpcy5nbC5OT19FUlJPUilcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGVyclN0ciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT0gdGhpcy5nbC5PVVRfT0ZfTUVNT1JZKSBlcnJTdHIgPSBcIk9VVF9PRl9NRU1PUllcIjtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PSB0aGlzLmdsLklOVkFMSURfRU5VTSkgZXJyU3RyID0gXCJJTlZBTElEX0VOVU1cIjtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PSB0aGlzLmdsLklOVkFMSURfT1BFUkFUSU9OKSBlcnJTdHIgPSBcIklOVkFMSURfT1BFUkFUSU9OXCI7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT0gdGhpcy5nbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTikgZXJyU3RyID0gXCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiO1xuICAgICAgICAgICAgaWYgKGVycm9yID09IHRoaXMuZ2wuSU5WQUxJRF9WQUxVRSkgZXJyU3RyID0gXCJJTlZBTElEX1ZBTFVFXCI7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT0gdGhpcy5nbC5DT05URVhUX0xPU1RfV0VCR0wpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIkNPTlRFWFRfTE9TVF9XRUJHTFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yID09IHRoaXMuZ2wuTk9fRVJST1IpIGVyclN0ciA9IFwiTk9fRVJST1JcIjtcblxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG5cbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiZ2wgZXJyb3IgW1wiICsgdGhpcy5jYW52YXMuaWQgKyBcIl06IFwiLCBzdHIsIGVycm9yLCBlcnJTdHIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMuaWQuaW5kZXhPZihcImdsR3VpQ2FudmFzXCIpID09IC0xKVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9nZ2VkR2xFcnJvcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0Y2gucHJpbnRUcmlnZ2VyU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwiZ2xlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VkR2xFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuXG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICBzYXZlU2NyZWVuc2hvdChmaWxlbmFtZSwgY2IsIHB3LCBwaCwgbm9jbGVhcmFscGhhKVxuICAgIHtcbiAgICAgICAgdGhpcy5wYXRjaC5yZW5kZXJPbmVGcmFtZSgpO1xuXG4gICAgICAgIGxldCB3ID0gdGhpcy5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsRGVuc2l0eTtcbiAgICAgICAgbGV0IGggPSB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsRGVuc2l0eTtcblxuICAgICAgICBpZiAocHcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcHc7XG4gICAgICAgICAgICB3ID0gcHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwaDtcbiAgICAgICAgICAgIGggPSBwaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhZExlZnQobnIsIG4sIHN0cilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KG4gLSBTdHJpbmcobnIpLmxlbmd0aCArIDEpLmpvaW4oc3RyIHx8IFwiMFwiKSArIG5yO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgY29uc3QgZGF0ZVN0ciA9IFwiXCIuY29uY2F0KFN0cmluZyhkLmdldEZ1bGxZZWFyKCkpICsgU3RyaW5nKGQuZ2V0TW9udGgoKSArIDEpICsgU3RyaW5nKGQuZ2V0RGF0ZSgpKSwgXCJfXCIpLmNvbmNhdChwYWRMZWZ0KGQuZ2V0SG91cnMoKSwgMikpLmNvbmNhdChwYWRMZWZ0KGQuZ2V0TWludXRlcygpLCAyKSkuY29uY2F0KHBhZExlZnQoZC5nZXRTZWNvbmRzKCksIDIpKTtcblxuICAgICAgICBpZiAoIWZpbGVuYW1lKSBmaWxlbmFtZSA9IFwiY2FibGVzX1wiICsgZGF0ZVN0ciArIFwiLnBuZ1wiO1xuICAgICAgICBlbHNlIGZpbGVuYW1lICs9IFwiLnBuZ1wiO1xuXG4gICAgICAgIHRoaXMucGF0Y2guY2dsLnNjcmVlblNob3QoZnVuY3Rpb24gKGJsb2IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGg7XG5cbiAgICAgICAgICAgIGlmIChibG9iKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgICAgICAgICAgICAgYW5jaG9yLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgYW5jaG9yLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYikgY2IoYmxvYik7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cubG9nKFwic2NyZWVuc2hvdDogbm8gYmxvYlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpLCBub2NsZWFyYWxwaGEpO1xuICAgIH1cblxuXG4gICAgX2Rpc3Bvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgfVxufVxuXG5cbkNvbnRleHQucHJvdG90eXBlLnBvcFNoYWRlciA9IENvbnRleHQucHJvdG90eXBlLnNldFByZXZpb3VzU2hhZGVyO1xuQ29udGV4dC5wcm90b3R5cGUuc2V0U2hhZGVyID0gQ29udGV4dC5wcm90b3R5cGUucHVzaFNoYWRlcjtcblxuLyoqXG4gKiBleGVjdXRlIHRoZSBjYWxsYmFjayBuZXh0IGZyYW1lLCBvbmNlXG4gKiBAZnVuY3Rpb24gYWRkTmV4dEZyYW1lT25jZUNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5Db250ZXh0LnByb3RvdHlwZS5hZGROZXh0RnJhbWVPbmNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpXG57XG4gICAgaWYgKGNiKSB0aGlzLl9vbmV0aW1lQ2FsbGJhY2tzLnB1c2goY2IpO1xufTtcblxuLy8gc3RhdGUgZGVwdGh0ZXN0XG5cbi8qKlxuICogcHVzaCBkZXB0aCB0ZXN0aW5nIGVuYWJsZWQgc3RhdGVcbiAqIEBmdW5jdGlvbiBwdXNoRGVwdGhUZXN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuX3N0YWNrRGVwdGhUZXN0ID0gW107XG5Db250ZXh0LnByb3RvdHlwZS5wdXNoRGVwdGhUZXN0ID0gZnVuY3Rpb24gKGIpXG57XG4gICAgdGhpcy5fc3RhY2tEZXB0aFRlc3QucHVzaChiKTtcbiAgICBpZiAoIWIpIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgIGVsc2UgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcbn07XG4vKipcbiAqIGN1cnJlbnQgc3RhdGUgb2YgZGVwdGggdGVzdGluZ1xuICogQGZ1bmN0aW9uIHN0YXRlQ3VsbEZhY2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnN0YXRlRGVwdGhUZXN0ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tEZXB0aFRlc3RbdGhpcy5fc3RhY2tEZXB0aFRlc3QubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIHBvcCBkZXB0aCB0ZXN0aW5nIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wRGVwdGhUZXN0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja0RlcHRoVGVzdC5wb3AoKTtcblxuICAgIGlmICghdGhpcy5fc3RhY2tEZXB0aFRlc3RbdGhpcy5fc3RhY2tEZXB0aFRlc3QubGVuZ3RoIC0gMV0pIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgIGVsc2UgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzdGF0ZSBkZXB0aHdyaXRlXG5cbi8qKlxuICogcHVzaCBkZXB0aCB3cml0ZSBlbmFibGVkIHN0YXRlXG4gKiBAZnVuY3Rpb24gcHVzaERlcHRoVGVzdFxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLl9zdGFja0RlcHRoV3JpdGUgPSBbXTtcbkNvbnRleHQucHJvdG90eXBlLnB1c2hEZXB0aFdyaXRlID0gZnVuY3Rpb24gKGIpXG57XG4gICAgYiA9IGIgfHwgZmFsc2U7XG4gICAgdGhpcy5fc3RhY2tEZXB0aFdyaXRlLnB1c2goYik7XG4gICAgdGhpcy5nbC5kZXB0aE1hc2soYik7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgc3RhdGUgb2YgZGVwdGggd3JpdGluZ1xuICogQGZ1bmN0aW9uIHN0YXRlQ3VsbEZhY2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnN0YXRlRGVwdGhXcml0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrRGVwdGhXcml0ZVt0aGlzLl9zdGFja0RlcHRoV3JpdGUubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIHBvcCBkZXB0aCB3cml0aW5nIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wRGVwdGhXcml0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fc3RhY2tEZXB0aFdyaXRlLnBvcCgpO1xuICAgIHRoaXMuZ2wuZGVwdGhNYXNrKHRoaXMuX3N0YWNrRGVwdGhXcml0ZVt0aGlzLl9zdGFja0RlcHRoV3JpdGUubGVuZ3RoIC0gMV0gfHwgZmFsc2UpO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RhdGUgQ3VsbEZhY2VcblxuLyoqXG4gKiBwdXNoIGZhY2UgY3VsbGluZyBmYWNlIGVuYWJsZWQgc3RhdGVcbiAqIEBmdW5jdGlvbiBwdXNoQ3VsbEZhY2VGYWNpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tDdWxsRmFjZSA9IFtdO1xuQ29udGV4dC5wcm90b3R5cGUucHVzaEN1bGxGYWNlID0gZnVuY3Rpb24gKGIpXG57XG4gICAgdGhpcy5fc3RhY2tDdWxsRmFjZS5wdXNoKGIpO1xuXG4gICAgaWYgKGIpIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICBlbHNlIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgc3RhdGUgb2YgZmFjZSBjdWxsaW5nXG4gKiBAZnVuY3Rpb24gc3RhdGVDdWxsRmFjZVxuICogQHJldHVybnMge0Jvb2xlYW59IGVuYWJsZWRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc3RhdGVDdWxsRmFjZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrQ3VsbEZhY2VbdGhpcy5fc3RhY2tDdWxsRmFjZS5sZW5ndGggLSAxXTtcbn07XG5cbi8qKlxuICogcG9wIGZhY2UgY3VsbGluZyBlbmFibGVkIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wQ3VsbEZhY2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2UucG9wKCk7XG5cbiAgICBpZiAodGhpcy5fc3RhY2tDdWxsRmFjZVt0aGlzLl9zdGFja0N1bGxGYWNlLmxlbmd0aCAtIDFdKSB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgZWxzZSB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RhdGUgQ3VsbEZhY2UgRmFjaW5nXG5cblxuLyoqXG4gKiBwdXNoIGZhY2UgY3VsbGluZyBmYWNlIHNpZGVcbiAqIEBmdW5jdGlvbiBwdXNoQ3VsbEZhY2VGYWNpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBjZ2wuZ2wuRlJPTlRfQU5EX0JBQ0ssIGNnbC5nbC5CQUNLIG9yIGNnbC5nbC5GUk9OVFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tDdWxsRmFjZUZhY2luZyA9IFtdO1xuQ29udGV4dC5wcm90b3R5cGUucHVzaEN1bGxGYWNlRmFjaW5nID0gZnVuY3Rpb24gKGIpXG57XG4gICAgdGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZy5wdXNoKGIpO1xuICAgIHRoaXMuZ2wuY3VsbEZhY2UodGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZ1t0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLmxlbmd0aCAtIDFdKTtcbn07XG5cbi8qKlxuICogY3VycmVudCBzdGF0ZSBvZiBmYWNlIGN1bGxpbmcgc2lkZVxuICogQGZ1bmN0aW9uIHN0YXRlQ3VsbEZhY2VGYWNpbmdcbiAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnN0YXRlQ3VsbEZhY2VGYWNpbmcgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nW3RoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIHBvcCBmYWNlIGN1bGxpbmcgZmFjZSBzaWRlXG4gKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VGYWNpbmdcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wQ3VsbEZhY2VGYWNpbmcgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcucG9wKCk7XG4gICAgaWYgKHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcubGVuZ3RoID4gMCkgdGhpcy5nbC5jdWxsRmFjZSh0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nW3RoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcubGVuZ3RoIC0gMV0pO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RhdGUgZGVwdGhmdW5jXG5cbkNvbnRleHQucHJvdG90eXBlLl9zdGFja0RlcHRoRnVuYyA9IFtdO1xuXG4vKipcbiAqIGVuYWJsZSAvIGRpc2FibGUgZGVwdGggdGVzdGluZ1xuICogbGlrZSBgZ2wuZGVwdGhGdW5jKGJvb2xlYW4pO2BcbiAqIEBmdW5jdGlvbiBwdXNoRGVwdGhGdW5jXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlcHRodGVzdGluZ1xuICovXG5Db250ZXh0LnByb3RvdHlwZS5wdXNoRGVwdGhGdW5jID0gZnVuY3Rpb24gKGYpXG57XG4gICAgdGhpcy5fc3RhY2tEZXB0aEZ1bmMucHVzaChmKTtcbiAgICB0aGlzLmdsLmRlcHRoRnVuYyhmKTtcbn07XG5cbi8qKlxuICogY3VycmVudCBzdGF0ZSBvZiBibGVuZFxuICogQGZ1bmN0aW9uIHN0YXRlRGVwdGhGdW5jXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZGVwdGggdGVzdGluZyBlbmFibGVkL2Rpc2FibGVkXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnN0YXRlRGVwdGhGdW5jID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fc3RhY2tEZXB0aEZ1bmMubGVuZ3RoID4gMCkgcmV0dXJuIHRoaXMuX3N0YWNrRGVwdGhGdW5jW3RoaXMuX3N0YWNrRGVwdGhGdW5jLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogcG9wIGRlcHRoIHRlc3RpbmcgYW5kIHNldCB0aGUgcHJldmlvdXMgc3RhdGVcbiAqIEBmdW5jdGlvbiBwb3BEZXB0aEZ1bmNcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wRGVwdGhGdW5jID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja0RlcHRoRnVuYy5wb3AoKTtcbiAgICBpZiAodGhpcy5fc3RhY2tEZXB0aEZ1bmMubGVuZ3RoID4gMCkgdGhpcy5nbC5kZXB0aEZ1bmModGhpcy5fc3RhY2tEZXB0aEZ1bmNbdGhpcy5fc3RhY2tEZXB0aEZ1bmMubGVuZ3RoIC0gMV0pO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHN0YXRlIGJsZW5kaW5nXG5cbkNvbnRleHQucHJvdG90eXBlLl9zdGFja0JsZW5kID0gW107XG5cbi8qKlxuICogZW5hYmxlIC8gZGlzYWJsZSBibGVuZFxuICogbGlrZSBnbC5lbmFibGUoZ2wuQkxFTkQpOyAvIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICogQGZ1bmN0aW9uIHB1c2hCbGVuZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtCb29sZWFufSBibGVuZGluZ1xuICovXG5Db250ZXh0LnByb3RvdHlwZS5wdXNoQmxlbmQgPSBmdW5jdGlvbiAoYilcbntcbiAgICB0aGlzLl9zdGFja0JsZW5kLnB1c2goYik7XG4gICAgaWYgKCFiKSB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5CTEVORCk7XG4gICAgZWxzZSB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbn07XG5cbi8qKlxuICogcG9wIGJsZW5kIHN0YXRlIGFuZCBzZXQgdGhlIHByZXZpb3VzIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wQmxlbmRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wQmxlbmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3N0YWNrQmxlbmQucG9wKCk7XG5cbiAgICBpZiAoIXRoaXMuX3N0YWNrQmxlbmRbdGhpcy5fc3RhY2tCbGVuZC5sZW5ndGggLSAxXSkgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgIGVsc2UgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5CTEVORCk7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgc3RhdGUgb2YgYmxlbmRcbiAqIEBmdW5jdGlvbiBzdGF0ZUJsZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYmxlbmRpbmcgZW5hYmxlZC9kaXNhYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5zdGF0ZUJsZW5kID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tCbGVuZFt0aGlzLl9zdGFja0JsZW5kLmxlbmd0aCAtIDFdO1xufTtcblxuZXhwb3J0IGNvbnN0IEJMRU5EUyA9IHtcbiAgICBcIkJMRU5EX05PTkVcIjogMCxcbiAgICBcIkJMRU5EX05PUk1BTFwiOiAxLFxuICAgIFwiQkxFTkRfQUREXCI6IDIsXG4gICAgXCJCTEVORF9TVUJcIjogMyxcbiAgICBcIkJMRU5EX01VTFwiOiA0LFxufTtcblxuQ29udGV4dC5wcm90b3R5cGUuX3N0YWNrQmxlbmRNb2RlID0gW107XG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tCbGVuZE1vZGVQcmVtdWwgPSBbXTtcblxuLyoqXG4gKiBwdXNoIGFuZCBzd2l0Y2ggdG8gcHJlZGVmaW5lZCBibGVuZG1vZGUgKENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9OT05FLENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9OT1JNQUwsQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX0FERCxDT05TVEFOVFMuQkxFTkRfTU9ERVMuQkxFTkRfU1VCLENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9NVUwpXG4gKiBAZnVuY3Rpb24gcHVzaEJsZW5kTW9kZVxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtOdW1iZXJ9IGJsZW5kbW9kZVxuICogQHBhcmFtIHtCb29sZWFufSBwcmVtdWx0aXBsaWVkIG1vZGVcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucHVzaEJsZW5kTW9kZSA9IGZ1bmN0aW9uIChibGVuZE1vZGUsIHByZW11bClcbntcbiAgICB0aGlzLl9zdGFja0JsZW5kTW9kZS5wdXNoKGJsZW5kTW9kZSk7XG4gICAgdGhpcy5fc3RhY2tCbGVuZE1vZGVQcmVtdWwucHVzaChwcmVtdWwpO1xuXG4gICAgY29uc3QgbiA9IHRoaXMuX3N0YWNrQmxlbmRNb2RlLmxlbmd0aCAtIDE7XG5cbiAgICB0aGlzLnB1c2hCbGVuZCh0aGlzLl9zdGFja0JsZW5kTW9kZVtuXSAhPT0gQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX05PTkUpO1xuICAgIHRoaXMuX3NldEJsZW5kTW9kZSh0aGlzLl9zdGFja0JsZW5kTW9kZVtuXSwgdGhpcy5fc3RhY2tCbGVuZE1vZGVQcmVtdWxbbl0pO1xufTtcblxuLyoqXG4gKiBwb3AgcHJlZGVmaW5lZCBibGVuZG1vZGUgLyBzd2l0Y2ggYmFjayB0byBwcmV2aW91cyBibGVuZG1vZGVcbiAqIEBmdW5jdGlvbiBwb3BCbGVuZE1vZGVcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucG9wQmxlbmRNb2RlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja0JsZW5kTW9kZS5wb3AoKTtcbiAgICB0aGlzLl9zdGFja0JsZW5kTW9kZVByZW11bC5wb3AoKTtcblxuICAgIGNvbnN0IG4gPSB0aGlzLl9zdGFja0JsZW5kTW9kZS5sZW5ndGggLSAxO1xuXG4gICAgdGhpcy5wb3BCbGVuZCh0aGlzLl9zdGFja0JsZW5kTW9kZVtuXSAhPT0gQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX05PTkUpO1xuXG4gICAgaWYgKG4gPj0gMCkgdGhpcy5fc2V0QmxlbmRNb2RlKHRoaXMuX3N0YWNrQmxlbmRNb2RlW25dLCB0aGlzLl9zdGFja0JsZW5kTW9kZVByZW11bFtuXSk7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzdGF0ZSBzdGVuY2lsXG5cbkNvbnRleHQucHJvdG90eXBlLl9zdGFja1N0ZW5jaWwgPSBbXTtcblxuLyoqXG4gKiBlbmFibGUgLyBkaXNhYmxlIHN0ZW5jaWwgdGVzdGluZ1xuXG4qIEBmdW5jdGlvbiBwdXNoU3RlbmNpbFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucHVzaFN0ZW5jaWwgPSBmdW5jdGlvbiAoYilcbntcbiAgICB0aGlzLl9zdGFja1N0ZW5jaWwucHVzaChiKTtcbiAgICBpZiAoIWIpIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLlNURU5DSUxfVEVTVCk7XG4gICAgZWxzZSB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLlNURU5DSUxfVEVTVCk7XG59O1xuXG4vKipcbiAqIHBvcCBzdGVuY2lsIHRlc3Qgc3RhdGUgYW5kIHNldCB0aGUgcHJldmlvdXMgc3RhdGVcbiAqIEBmdW5jdGlvbiBwb3BTdGVuY2lsXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcFN0ZW5jaWwgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3N0YWNrU3RlbmNpbC5wb3AoKTtcblxuICAgIGlmICghdGhpcy5fc3RhY2tTdGVuY2lsW3RoaXMuX3N0YWNrU3RlbmNpbC5sZW5ndGggLSAxXSkgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuU1RFTkNJTF9URVNUKTtcbiAgICBlbHNlIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuU1RFTkNJTF9URVNUKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuQ29udGV4dC5wcm90b3R5cGUuZ2xHZXRBdHRyaWJMb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9nLCBuYW1lKVxue1xuICAgIGNvbnN0IGwgPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2csIG5hbWUpO1xuICAgIC8vIGlmIChsID09IC0xKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5fbG9nLndhcm4oXCJnZXQgYXR0ciBsb2MgLTEgXCIsIG5hbWUpO1xuICAgIC8vIH1cbiAgICByZXR1cm4gbDtcbn07XG5cblxuLyoqXG4gKiBzaG91bGQgYW4gb3Agbm93IGRyYXcgaGVscGVybWVzaGVzXG4gKiBAZnVuY3Rpb24gc2hvdWxkRHJhd0hlbHBlcnNcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc2hvdWxkRHJhd0hlbHBlcnMgPSBmdW5jdGlvbiAob3ApXG57XG4gICAgaWYgKHRoaXMuZnJhbWVTdG9yZS5zaGFkb3dQYXNzKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFvcC5wYXRjaC5pc0VkaXRvck1vZGUoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgZmIgPSB0aGlzLmdldEN1cnJlbnRGcmFtZUJ1ZmZlcigpO1xuICAgIGlmIChmYiAmJiBmYi5nZXRXaWR0aClcbiAgICB7XG4gICAgICAgIGNvbnN0IGZic2hvdWxkID0gdGhpcy5jYW52YXNXaWR0aCAvIHRoaXMuY2FudmFzSGVpZ2h0ID09IGZiLmdldFdpZHRoKCkgLyBmYi5nZXRIZWlnaHQoKTtcbiAgICAgICAgaWYgKCFmYnNob3VsZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBDQUJMRVMuVUkucmVuZGVySGVscGVyIHx8IChDQUJMRVMuVUkucmVuZGVySGVscGVyQ3VycmVudCAmJiBvcC5pc0N1cnJlbnRVaU9wKCkpO1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUuX3NldEJsZW5kTW9kZSA9IGZ1bmN0aW9uIChibGVuZE1vZGUsIHByZW11bClcbntcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBpZiAoYmxlbmRNb2RlID09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9OT05FKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChibGVuZE1vZGUgPT0gQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX0FERClcbiAgICB7XG4gICAgICAgIGlmIChwcmVtdWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChibGVuZE1vZGUgPT0gQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX1NVQilcbiAgICB7XG4gICAgICAgIGlmIChwcmVtdWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChibGVuZE1vZGUgPT0gQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX01VTClcbiAgICB7XG4gICAgICAgIGlmIChwcmVtdWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChibGVuZE1vZGUgPT0gQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX05PUk1BTClcbiAgICB7XG4gICAgICAgIGlmIChwcmVtdWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmxvZyhcInNldGJsZW5kbW9kZTogdW5rbm93biBibGVuZG1vZGVcIik7XG4gICAgfVxufTtcblxuQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uIChnZW9tLCBvcHRpb25zKVxue1xuICAgIGlmIChDQUJMRVMuVVRJTFMuaXNOdW1lcmljKG9wdGlvbnMpKW9wdGlvbnMgPSB7IFwiZ2xQcmltaXRpdmVcIjogb3B0aW9ucyB9OyAvLyBvbGQgY29uc3RydWN0b3IgZmFsbGJhY2suLi5cbiAgICByZXR1cm4gbmV3IENHTC5NZXNoKHRoaXMsIGdlb20sIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIHNldCBjdXJzb3JcbiAqIEBmdW5jdGlvbiBzZXRDdXJzb3JcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3MgY3Vyc29yIHN0cmluZ1xuICovXG5Db250ZXh0LnByb3RvdHlwZS5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoc3RyKVxue1xuICAgIHRoaXMuX2N1cnNvciA9IHN0cjtcbn07XG5cblxuLyoqXG4gKiBlbmFibGUgYSB3ZWJnbCBleHRlbnNpb25cbiAqIEBmdW5jdGlvbiBlbmFibGVFeHRlbnNpb25cbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHRlbnNpb24gbmFtZVxuICogQHJldHVybnMge09iamVjdH0gZXh0ZW5zaW9uIG9iamVjdCBvciBudWxsXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmVuYWJsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIC8vIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBpZiAodGhpcy5fZW5hYmxlZEV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZEV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgY29uc3QgbyA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuICAgIHRoaXMuX2VuYWJsZWRFeHRlbnNpb25zW25hbWVdID0gbztcblxuICAgIGlmICghbylcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJbY2dsX3N0YXRlXSBleHRlbnNpb24gbm90IGF2YWlsYWJsZSBcIiArIG5hbWUpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fbG9nLmxvZyhcImVuYWJsZWQgZXh0ZW5zaW9uXCIsIG5hbWUpO1xuXG4gICAgcmV0dXJuIG87XG59O1xuXG5cblxuXG5leHBvcnQgeyBDb250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_state.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_texture.js":
/*!*************************************!*\
  !*** ./src/core/cgl/cgl_texture.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Texture\": () => (/* binding */ Texture)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n\n\n\n\n\nconst DEFAULT_TEXTURE_SIZE = 8;\n\n/**\n * A Texture\n * @external CGL\n * @namespace Texture\n * @constructor\n * @param {Context} cgl\n * @param {Object} [options]\n * @hideconstructor\n * @class\n * @example\n * // generate a 256x256 pixel texture of random colors\n * const size=256;\n * const data = new Uint8Array(size*size*4);\n *\n * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;\n *\n * const tex=new CGL.Texture(cgl);\n * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);\n */\nconst Texture = function (__cgl, options = {})\n{\n    if (!__cgl) throw new Error(\"no cgl\");\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"cgl_texture\");\n    this._cgl = __cgl;\n    this.pixelFormat = options.pixelFormat || Texture.PFORMATSTR_RGBA8UB;\n    this.tex = this._cgl.gl.createTexture();\n    this.id = CABLES.uuid();\n    this.width = 0;\n    this.height = 0;\n    this.loading = false;\n    this.flip = true;\n    this.flipped = false;\n    this.shadowMap = false;\n    this.deleted = false;\n    this.image = null;\n    this.anisotropic = 0;\n    this.filter = Texture.FILTER_NEAREST;\n    this.wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    this.texTarget = this._cgl.gl.TEXTURE_2D;\n    if (options && options.type) this.texTarget = options.type;\n    this.textureType = Texture.TYPE_DEFAULT;\n    this.unpackAlpha = true;\n    this._fromData = true;\n    this.name = \"unknown\";\n\n    this._glDataType = -1;\n    this._glInternalFormat = -1;\n    this._glDataFormat = -1;\n\n\n    if (options)\n    {\n        this.name = options.name || this.name;\n        if (options.isDepthTexture)\n        {\n            this.textureType = Texture.TYPE_DEPTH;\n        }\n        if (options.isFloatingPointTexture === true) this.textureType = Texture.TYPE_FLOAT;\n\n        if (\"textureType\" in options) this.textureType = options.textureType;\n        if (\"filter\" in options) this.filter = options.filter;\n        if (\"wrap\" in options) this.wrap = options.wrap;\n        if (\"unpackAlpha\" in options) this.unpackAlpha = options.unpackAlpha;\n        if (\"flip\" in options) this.flip = options.flip;\n        if (\"shadowMap\" in options) this.shadowMap = options.shadowMap;\n        if (\"anisotropic\" in options) this.anisotropic = options.anisotropic;\n    }\n    else\n    {\n        options = {};\n    }\n\n    if (!options.pixelFormat && options.isFloatingPointTexture) this.pixelFormat = Texture.PFORMATSTR_RGBA32F;\n\n    if (this.textureType == Texture.TYPE_DEPTH) this.pixelFormat = Texture.PFORMATSTR_DEPTH;\n\n\n\n    if (!options.width) options.width = DEFAULT_TEXTURE_SIZE;\n    if (!options.height) options.height = DEFAULT_TEXTURE_SIZE;\n\n    this._cgl.profileData.profileTextureNew++;\n\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n    this._cgl.profileData.addHeavyEvent(\"texture created\", this.name, options.width + \"x\" + options.height);\n\n    this.setSize(options.width, options.height);\n    this.getInfoOneLine();\n};\n\nTexture.prototype.isFloatingPoint = function ()\n{\n    return Texture.isPixelFormatFloat(this.pixelFormat);\n};\n\n/**\n * returns true if otherTexture has same options (width/height/filter/wrap etc)\n * @function compareSettings\n * @memberof Texture\n * @instance\n * @param {Texture} otherTexture\n * @returns {Boolean}\n */\nTexture.prototype.compareSettings = function (tex)\n{\n    // if (!tex) { this._log.warn(\"compare: no tex\"); return false; }\n    // if (tex.width != this.width) this._log.warn(\"tex.width not equal\", tex.width, this.width);\n    // if (tex.height != this.height) this._log.warn(\"tex.height not equal\", tex.height, this.height);\n    // if (tex.filter != this.filter) this._log.warn(\"tex.filter not equal\");\n    // if (tex.wrap != this.wrap) this._log.warn(\"tex.wrap not equal\");\n    // if (tex.textureType != this.textureType) this._log.warn(\"tex.textureType not equal\");\n    // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn(\"tex.unpackAlpha not equal\");\n    // if (tex.anisotropic != this.anisotropic) this._log.warn(\"tex.anisotropic not equal\");\n    // if (tex.shadowMap != this.shadowMap) this._log.warn(\"tex.shadowMap not equal\");\n    // if (tex.texTarget != this.texTarget) this._log.warn(\"tex.texTarget not equal\");\n    // if (tex.flip != this.flip) this._log.warn(\"tex.flip not equal\");\n\n    if (!tex) return false;\n    return (\n        tex.width == this.width &&\n        tex.height == this.height &&\n        tex.filter == this.filter &&\n        tex.wrap == this.wrap &&\n        tex.textureType == this.textureType &&\n        tex.unpackAlpha == this.unpackAlpha &&\n        tex.anisotropic == this.anisotropic &&\n        tex.shadowMap == this.shadowMap &&\n        tex.texTarget == this.texTarget &&\n        tex.flip == this.flip\n    );\n};\n\n/**\n * returns a new texture with the same settings (does not copy texture itself)\n * @function clone\n * @memberof Texture\n * @instance\n * @returns {Texture}\n */\nTexture.prototype.clone = function ()\n{\n    const newTex = new Texture(this._cgl, {\n        \"name\": this.name,\n        \"filter\": this.filter,\n        \"anisotropic\": this.anisotropic,\n        \"wrap\": this.wrap,\n        \"textureType\": this.textureType,\n        \"pixelFormat\": this.pixelFormat,\n        \"unpackAlpha\": this.unpackAlpha,\n        \"flip\": this.flip,\n        \"width\": this.width,\n        \"height\": this.height,\n    });\n\n    this._cgl.profileData.addHeavyEvent(\"texture created\", this.name, this.width + \"x\" + this.height);\n\n    if (!this.compareSettings(newTex))\n    {\n        this._log.error(\"Cloned texture settings do not compare!\");\n        this._log.error(this);\n        this._log.error(newTex);\n    }\n\n    return newTex;\n};\n\n\nTexture.prototype.setFormat = function (o)\n{\n    this.pixelFormat = o.pixelFormat;\n    this._glDataFormat = o.glDataFormat;\n    this._glInternalFormat = o.glInternalFormat;\n    this._glDataType = o.glDataType;\n};\n\n\nTexture.setUpGlPixelFormat = function (cgl, pixelFormatStr)\n{\n    const o = {};\n\n    if (!pixelFormatStr)\n    {\n        console.log(\"no pixelformatstr!\");\n        console.log((new Error()).stack);\n        pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;\n    }\n\n    o.pixelFormatBase = pixelFormatStr;\n\n    if (cgl.glUseHalfFloatTex)\n    {\n        if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) pixelFormatStr = Texture.PFORMATSTR_RGBA16F;\n        if (pixelFormatStr == Texture.PFORMATSTR_RG32F) pixelFormatStr = Texture.PFORMATSTR_RG16F;\n        if (pixelFormatStr == Texture.PFORMATSTR_R32F) pixelFormatStr = Texture.PFORMATSTR_R16F;\n    }\n\n    o.pixelFormat = pixelFormatStr;\n    o.glDataType = cgl.gl.UNSIGNED_BYTE;\n    o.glInternalFormat = cgl.gl.RGBA8;\n    o.glDataFormat = cgl.gl.RGBA;\n\n    let floatDatatype = cgl.gl.FLOAT;\n\n    if (cgl.glVersion == 1)\n    {\n        o.glInternalFormat = cgl.gl.RGBA;\n\n        if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F || pixelFormatStr == Texture.PFORMATSTR_RG16F || pixelFormatStr == Texture.PFORMATSTR_R16F)\n        {\n            const ext = cgl.enableExtension(\"OES_texture_half_float\");\n            if (!ext) throw new Error(\"no half float texture extension\");\n\n            floatDatatype = ext.HALF_FLOAT_OES;\n        }\n    }\n\n    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB)\n    {\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGB565)\n    {\n        o.glInternalFormat = cgl.gl.RGB565;\n        o.glDataFormat = cgl.gl.RGB;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_R8UB)\n    {\n        o.glInternalFormat = cgl.gl.R8;\n        o.glDataFormat = cgl.gl.RED;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB)\n    {\n        o.glInternalFormat = cgl.gl.RG8;\n        o.glDataFormat = cgl.gl.RG;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB)\n    {\n        o.glInternalFormat = cgl.gl.RGB8;\n        o.glDataFormat = cgl.gl.RGB;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8)\n    {\n        o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;\n    }\n\n    else if (pixelFormatStr == Texture.PFORMATSTR_R32F)\n    {\n        o.glInternalFormat = cgl.gl.R32F;\n        o.glDataFormat = cgl.gl.RED;\n        o.glDataType = floatDatatype;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_R16F)\n    {\n        o.glInternalFormat = cgl.gl.R16F;\n        o.glDataType = floatDatatype;\n        o.glDataFormat = cgl.gl.RED;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RG16F)\n    {\n        o.glInternalFormat = cgl.gl.RG16F;\n        o.glDataType = floatDatatype;\n        o.glDataFormat = cgl.gl.RG;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)\n    {\n        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;\n        else o.glInternalFormat = cgl.gl.RGBA16F;\n        o.glDataType = floatDatatype;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)\n    {\n        o.glInternalFormat = cgl.gl.R11F_G11F_B10F;\n        o.glDataType = floatDatatype;\n        o.glDataFormat = cgl.gl.RGB;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)\n    {\n        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;\n        else o.glInternalFormat = cgl.gl.RGBA32F;\n        o.glDataType = floatDatatype;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH)\n    {\n        if (cgl.glVersion == 1)\n        {\n            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;\n            o.glDataType = cgl.gl.UNSIGNED_SHORT;\n            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;\n        }\n        else\n        {\n            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;\n            o.glDataType = cgl.gl.FLOAT;\n            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;\n        }\n    }\n    else\n    {\n        console.log(\"unknown pixelformat \", pixelFormatStr);\n    }\n\n    /// //////\n\n    if (pixelFormatStr.indexOf(\"32bit\") || pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)\n    {\n        if (cgl.glVersion == 2) cgl.enableExtension(\"EXT_color_buffer_float\");\n        if (cgl.glVersion == 2) cgl.enableExtension(\"EXT_float_blend\");\n\n        cgl.enableExtension(\"OES_texture_float_linear\"); // yes, i am sure, this is a webgl 1 and 2 ext\n    }\n\n    if (pixelFormatStr.indexOf(\"16bit\"))\n    {\n        cgl.enableExtension(\"EXT_color_buffer_half_float\");\n        cgl.enableExtension(\"OES_texture_float_linear\");\n    }\n\n\n    o.numColorChannels = 1;\n    if (pixelFormatStr.indexOf(\"R\") == 0)o.numColorChannels = 1;\n    if (pixelFormatStr.indexOf(\"RG\") == 0)o.numColorChannels = 2;\n    if (pixelFormatStr.indexOf(\"RGB\") == 0)o.numColorChannels = 3;\n    if (pixelFormatStr.indexOf(\"RGBA\") == 0)o.numColorChannels = 4;\n\n\n    // console.log(pixelFormatStr, this.name);\n\n    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat) console.log(\"pixelformat wrong ?!\", pixelFormatStr, o.glDataType, o.glInternalFormat, o.glDataFormat, this);\n\n    return o;\n};\n\n/**\n * set pixel size of texture\n * @function setSize\n * @memberof Texture\n * @instance\n * @param {Number} width\n * @param {Number} height\n */\nTexture.prototype.setSize = function (w, h)\n{\n    if (this._cgl.aborted) return;\n    if (w != w || w <= 0 || !w) w = DEFAULT_TEXTURE_SIZE;\n    if (h != h || h <= 0 || !h) h = DEFAULT_TEXTURE_SIZE;\n\n    if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize) this._log.error(\"texture size too big! \" + w + \"x\" + h + \" / max: \" + this._cgl.maxTexSize);\n\n    w = Math.min(w, this._cgl.maxTexSize);\n    h = Math.min(h, this._cgl.maxTexSize);\n\n    w = Math.floor(w);\n    h = Math.floor(h);\n    if (this.width == w && this.height == h) return;\n\n    // console.log(\"tex setsize\", this.name, w, h, this.id);\n\n    this.width = w;\n    this.height = h;\n    this.deleted = false;\n\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n\n\n    this.shortInfoString = this.getInfoOneLine();// w + \"x\" + h + \"\";\n    // if (this.textureType == Texture.TYPE_FLOAT) this.shortInfoString += \" Float\";\n\n    // if (this._cgl.printError(\"cgltex before\"))\n    // {\n    //     this.printInfo();\n    //     console.log((new Error()).stack);\n    // }\n\n    this._cgl.gl.bindTexture(this.texTarget, this.tex);\n    this._cgl.profileData.profileTextureResize++;\n\n    const uarr = null;\n\n\n    // if (\n    //     this._cgl.glVersion == 1 &&\n    //     this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_LINEAR &&\n    //     (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n    // )\n    // {\n    //     console.warn(\"this graphics card does not support floating point texture linear interpolation! using NEAREST\");\n    //     this.filter = Texture.FILTER_NEAREST;\n    // }\n\n\n    // else\n    // {\n    //     dataType = this._cgl.gl.UNSIGNED_BYTE;\n    //     internalFormat = this._cgl.gl.RGBA;\n    //     dataFormat = this._cgl.gl.RGBA;\n    //     // this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, w, h, 0, this._cgl.gl.RGBA, this._cgl.gl.UNSIGNED_BYTE, uarr);\n    // }\n\n    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, uarr);\n\n    this._setFilter();\n\n    // if (this._cgl.printError(\"cgltex\"))\n    // {\n    //     this.printInfo();\n    //     console.log((new Error()).stack);\n    // }\n\n    this.updateMipMap();\n\n    this._cgl.gl.bindTexture(this.texTarget, null);\n};\n\n\n\n/**\n * @function initFromData\n * @memberof Texture\n * @instance\n * @description create texturem from rgb data\n * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]\n * @param {Number} width\n * @param {Number} height\n * @param {Number} filter\n * @param {Number} wrap\n */\nTexture.prototype.initFromData = function (data, w, h, filter, wrap)\n{\n    this.filter = filter;\n    this.wrap = wrap;\n    if (filter == undefined) this.filter = Texture.FILTER_LINEAR;\n    if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    this.width = w;\n    this.height = h;\n    this._fromData = true;\n    this.deleted = false;\n\n    if (this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize)\n    {\n        const t = CGL.Texture.getTempTexture(this._cgl);\n        this.width = t.width;\n        this.height = t.height;\n        this.tex = t.tex;\n        this._log.error(\"[cgl_texture] texture size to big!!!\", this.width, this.height, this._cgl.maxTexSize);\n        return;\n    }\n\n    if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);\n\n    this._cgl.gl.bindTexture(this.texTarget, this.tex);\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n\n    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, data);\n\n    this._setFilter();\n    this.updateMipMap();\n\n    if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this._cgl.gl.bindTexture(this.texTarget, null);\n};\n\nTexture.prototype.updateMipMap = function ()\n{\n    if ((this._cgl.glVersion == 2 || this.isPowerOfTwo()) && this.filter == Texture.FILTER_MIPMAP)\n    {\n        this._cgl.gl.generateMipmap(this.texTarget);\n        this._cgl.profileData.profileGenMipMap++;\n    }\n};\n\n/**\n * set texture data from an image/canvas object\n * @function initTexture\n * @memberof Texture\n * @instance\n * @param {Object} image\n * @param {Number} filter\n */\nTexture.prototype.initTexture = function (img, filter)\n{\n    this._cgl.printError(\"before initTexture\");\n    this._cgl.checkFrameStarted(\"texture inittexture\");\n    this._fromData = false;\n    // if(filter) this.unpackAlpha=filter.unpackAlpha||this.unpackAlpha;\n\n    this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);\n    if (img.width) this.width = img.width;\n    if (img.height) this.height = img.height;\n    if (filter) this.filter = filter;\n\n    if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize)\n    {\n        const t = CGL.Texture.getTempTexture(this._cgl);\n        this.width = t.width;\n        this.height = t.height;\n        this.tex = t.tex;\n        this._log.error(\"[cgl_texture] texture size to big!!!\", img.width, img.height, this._cgl.maxTexSize);\n        return;\n    }\n\n\n    // console.log(\"loaded texture\", img.width, img.height);\n\n    this._cgl.gl.bindTexture(this.texTarget, this.tex);\n\n    this.deleted = false;\n    this.flipped = !this.flip;\n    if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);\n\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n\n    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, this._glDataFormat, this._glDataType, img);\n    // this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, this._cgl.gl.RGBA, this._cgl.gl.UNSIGNED_BYTE, img);\n\n    // if (this._cgl.printError(\"[cgl_texture] init \" + this.name));\n\n    this._setFilter();\n    this.updateMipMap();\n\n    // if (this._cgl.printError(\"[cgl_texture] init2\"));\n\n    this._cgl.gl.bindTexture(this.texTarget, null);\n    this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n    this.getInfoOneLine();\n    this._cgl.printError(\"initTexture\");\n};\n\n/**\n * delete texture. use this when texture is no longer needed\n * @function delete\n * @memberof Texture\n * @instance\n */\nTexture.prototype.delete = function ()\n{\n    if (this.loading)\n    {\n        // cant delete texture when still loading\n        // setTimeout(this.delete.bind(this), 50);\n        return;\n    }\n\n    this.deleted = true;\n    this.width = 0;\n    this.height = 0;\n    this._cgl.profileData.profileTextureDelete++;\n    this._cgl.gl.deleteTexture(this.tex);\n    this.image = null;\n\n    this.tex = null;\n};\n\n/**\n * @function isPowerOfTwo\n * @memberof Texture\n * @instance\n * @description return true if texture width and height are both power of two\n * @return {Boolean}\n */\nTexture.prototype.isPowerOfTwo = function ()\n{\n    return Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height);\n};\n\nTexture.prototype.printInfo = function ()\n{\n    console.log(this.getInfo());\n};\n\nTexture.prototype.getInfoReadable = function ()\n{\n    const info = this.getInfo();\n    let html = \"\";\n\n    info.name = info.name.substr(0, info.name.indexOf(\"?rnd=\"));\n\n    for (const i in info)\n    {\n        html += \"* \" + i + \":  **\" + info[i] + \"**\\n\";\n    }\n\n    return html;\n};\n\nTexture.prototype.getInfoOneLine = function ()\n{\n    let txt = \"\" + this.width + \"x\" + this.height;\n    txt += \" \";\n    // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += \" 32bit\"; else txt += \" 8bit\";\n    // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += \" 32bit\"; else txt += \" 8bit\";\n    txt += this.pixelFormat;\n\n    if (this.filter === CGL.Texture.FILTER_NEAREST) txt += \" nearest\";\n    if (this.filter === CGL.Texture.FILTER_LINEAR) txt += \" linear\";\n    if (this.filter === CGL.Texture.FILTER_MIPMAP) txt += \" mipmap\";\n\n    if (this.wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE) txt += \" clamp\";\n    if (this.wrap === CGL.Texture.WRAP_REPEAT) txt += \" repeat\";\n    if (this.wrap === CGL.Texture.WRAP_MIRRORED_REPEAT) txt += \" repeatmir\";\n\n    this.shortInfoString = txt;\n\n    return txt;\n};\n\nTexture.prototype.getInfoOneLineShort = function ()\n{\n    let txt = \"\" + this.width + \"x\" + this.height;\n    // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += \" 32bit\"; else txt += \" 8bit\";\n    txt += \" \";\n    txt += this.pixelFormat;\n\n    this.shortInfoString = txt;\n\n    return txt;\n};\n\n\nTexture.prototype.getInfo = function ()\n{\n    return Texture.getTexInfo(this);\n};\n\n\nTexture.prototype._setFilter = function ()\n{\n    this._cgl.printError(\"before _setFilter\");\n\n    if (!this._fromData)\n    {\n        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);\n    }\n\n    if (this.shadowMap)\n    {\n        this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE);\n        this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL);\n    }\n\n    if (this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_MIPMAP)\n    {\n        this.filter = Texture.FILTER_LINEAR;\n        this._log.stack(\"texture: HDR and mipmap filtering at the same time is not possible\");\n    }\n\n    if (this._cgl.glVersion == 1 && !this.isPowerOfTwo())\n    {\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);\n\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);\n\n        this.filter = Texture.FILTER_NEAREST;\n        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    }\n    else\n    {\n        if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);\n        }\n        else if (this.wrap == Texture.WRAP_REPEAT)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT);\n        }\n        else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT);\n        }\n\n        if (this.filter == Texture.FILTER_NEAREST)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);\n        }\n        else if (this.filter == Texture.FILTER_LINEAR)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);\n        }\n        else if (this.filter == Texture.FILTER_MIPMAP)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR);\n        }\n        else\n        {\n            this._log.log(\"unknown texture filter!\", this.filter);\n            throw new Error(\"unknown texture filter!\" + this.filter);\n        }\n\n        if (this.anisotropic)\n        {\n            const ext = this._cgl.enableExtension(\"EXT_texture_filter_anisotropic\");\n\n\n\n            if (this._cgl.maxAnisotropic)\n            {\n                const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);\n                this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, aniso);\n            }\n        }\n    }\n    this.getInfoOneLine();\n    this._cgl.printError(\"_setFilter\");\n};\n\n\n/**\n * @function load\n * @static\n * @memberof Texture\n * @description load an image from an url\n * @param {Context} cgl\n * @param {String} url\n * @param {Function} onFinished\n * @param {Object} options\n * @return {Texture}\n */\nTexture.load = function (cgl, url, finishedCallback, settings)\n{\n    if (!url) return finishedCallback({ \"error\": true });\n    let loadingId = null;\n    if (!cgl.patch.loading.existByName(url)) loadingId = cgl.patch.loading.start(\"texture\", url);\n\n    const texture = new Texture(cgl);\n    texture.name = url;\n\n    // texture.pixelFormat = Texture.PFORMATSTR_;\n\n    if (cgl.patch.isEditorMode()) gui.jobs().start({ \"id\": \"loadtexture\" + loadingId, \"title\": \"loading texture \" + CABLES.basename(url) });\n\n    texture.image = new Image();\n    texture.image.crossOrigin = \"anonymous\";\n    texture.loading = true;\n\n    if (settings && settings.hasOwnProperty(\"filter\")) texture.filter = settings.filter;\n    if (settings && settings.hasOwnProperty(\"flip\")) texture.flip = settings.flip;\n    if (settings && settings.hasOwnProperty(\"wrap\")) texture.wrap = settings.wrap;\n    if (settings && settings.hasOwnProperty(\"anisotropic\")) texture.anisotropic = settings.anisotropic;\n    if (settings && settings.hasOwnProperty(\"unpackAlpha\")) texture.unpackAlpha = settings.unpackAlpha;\n    if (settings && settings.hasOwnProperty(\"pixelFormat\")) texture.pixelFormat = settings.pixelFormat;\n\n    texture.image.onabort = texture.image.onerror = (e) =>\n    {\n        console.warn(\"[cgl.texture.load] error loading texture\", url, e);\n        texture.loading = false;\n        if (loadingId) cgl.patch.loading.finished(loadingId);\n        const error = { \"error\": true };\n        if (finishedCallback) finishedCallback(error, texture);\n        if (cgl.patch.isEditorMode()) gui.jobs().finish(\"loadtexture\" + loadingId);\n    };\n\n    texture.image.onload = function (e)\n    {\n        cgl.addNextFrameOnceCallback(() =>\n        {\n            texture.initTexture(texture.image);\n            if (loadingId) cgl.patch.loading.finished(loadingId);\n            texture.loading = false;\n            if (cgl.patch.isEditorMode()) gui.jobs().finish(\"loadtexture\" + loadingId);\n\n            if (finishedCallback) finishedCallback(null, texture);\n        });\n    };\n    texture.image.src = url;\n\n    return texture;\n};\n\n/**\n * @static\n * @function getTempTexture\n * @memberof Texture\n * @description returns the default temporary texture (grey diagonal stipes)\n * @param {Context} cgl\n * @return {Texture}\n */\nTexture.getTempTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getTempTexture] no cgl!\");\n    if (!cgl.tempTexture) cgl.tempTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT);\n    return cgl.tempTexture;\n};\n\n/**\n * @static\n * @function getErrorTexture\n * @memberof Texture\n * @description returns the default temporary texture (grey diagonal stipes)\n * @param {Context} cgl\n * @return {Texture}\n */\nTexture.getErrorTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getTempTexture] no cgl!\");\n    if (!cgl.errorTexture) cgl.errorTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT, 1, 0.2, 0.2);\n    return cgl.errorTexture;\n};\n\n\n/**\n * @function getEmptyTexture\n * @memberof Texture\n * @instance\n * @description returns a reference to a small empty (transparent) texture\n * @return {Texture}\n */\nTexture.getEmptyTexture = function (cgl, fp)\n{\n    if (fp) return Texture.getEmptyTextureFloat(cgl);\n    if (!cgl) console.error(\"[getEmptyTexture] no cgl!\");\n    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;\n\n    cgl.tempTextureEmpty = new Texture(cgl, { \"name\": \"emptyTexture\" });\n    const data = new Uint8Array(8 * 8 * 4).fill(0);\n    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;\n\n    cgl.tempTextureEmpty.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.tempTextureEmpty;\n};\n\n/**\n * @function getEmptyTextureFloat\n * @memberof Texture\n * @instance\n * @description returns a reference to a small empty (transparent) 32bit texture\n * @return {Texture}\n */\nTexture.getEmptyTextureFloat = function (cgl)\n{\n    if (!cgl) console.error(\"[getEmptyTextureFloat] no cgl!\");\n    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;\n\n    cgl.tempTextureEmptyFloat = new Texture(cgl, { \"name\": \"emptyTexture\", \"isFloatingPointTexture\": true });\n    const data = new Float32Array(8 * 8 * 4).fill(1);\n    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;\n\n    cgl.tempTextureEmptyFloat.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.tempTextureEmptyFloat;\n};\n\n\n/**\n * @function getRandomTexture\n * @memberof Texture\n * @static\n * @description returns a reference to a random texture\n * @return {Texture}\n */\nTexture.getRandomTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getRandomTexture] no cgl!\");\n    if (cgl.randomTexture) return cgl.randomTexture;\n\n    const size = 256;\n    const data = new Uint8Array(size * size * 4);\n\n    for (let x = 0; x < size * size; x++)\n    {\n        data[x * 4 + 0] = Math.random() * 255;\n        data[x * 4 + 1] = Math.random() * 255;\n        data[x * 4 + 2] = Math.random() * 255;\n        data[x * 4 + 3] = 255;\n    }\n\n    cgl.randomTexture = new Texture(cgl);\n    cgl.randomTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.randomTexture;\n};\n\n/**\n * @function getRandomFloatTexture\n * @memberof Texture\n * @static\n * @description returns a reference to a texture containing random numbers between -1 and 1\n * @return {Texture}\n */\nTexture.getRandomFloatTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getRandomTexture] no cgl!\");\n    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;\n\n    const size = 256;\n    const data = new Float32Array(size * size * 4);\n\n    for (let x = 0; x < size * size; x++)\n    {\n        data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;\n        data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;\n        data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;\n        data[x * 4 + 3] = 1;\n    }\n\n    cgl.getRandomFloatTexture = new Texture(cgl, { \"isFloatingPointTexture\": true });\n    cgl.getRandomFloatTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.getRandomFloatTexture;\n};\n\n/**\n * @function getBlackTexture\n * @memberof Texture\n * @static\n * @description returns a reference to a black texture\n * @return {Texture}\n */\nTexture.getBlackTexture = function (cgl)\n{\n    if (!cgl) this._log.error(\"[getBlackTexture] no cgl!\");\n    if (cgl.blackTexture) return cgl.blackTexture;\n\n    const size = 8;\n    const data = new Uint8Array(size * size * 4);\n\n    for (let x = 0; x < size * size; x++)\n    {\n        data[x * 4 + 0] = data[x * 4 + 1] = data[x * 4 + 2] = 0;\n        data[x * 4 + 3] = 255;\n    }\n\n    cgl.blackTexture = new Texture(cgl);\n    cgl.blackTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.blackTexture;\n};\n\n\n/**\n * @function getEmptyCubemapTexture\n * @memberof Texture\n * @static\n * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]\n * @return {Texture}\n */\nTexture.getEmptyCubemapTexture = function (cgl)\n{\n    const faces = [\n        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z\n    ];\n\n    const tex = cgl.gl.createTexture();\n    const target = cgl.gl.TEXTURE_CUBE_MAP;\n    const filter = Texture.FILTER_NEAREST;\n    const wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    const width = 8;\n    const height = 8;\n\n    cgl.profileData.profileTextureNew++;\n\n\n    cgl.gl.bindTexture(target, tex);\n    cgl.profileData.profileTextureResize++;\n\n    for (let i = 0; i < 6; i += 1)\n    {\n        const data = new Uint8Array(8 * 8 * 4);\n\n        cgl.gl.texImage2D(faces[i], 0, cgl.gl.RGBA, 8, 8, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, data);\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);\n\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);\n    }\n\n\n    cgl.gl.bindTexture(target, null);\n\n    return {\n        \"id\": CABLES.uuid(),\n        \"tex\": tex,\n        \"cubemap\": tex,\n        \"width\": width,\n        \"height\": height,\n        \"filter\": filter,\n        \"wrap\": wrap,\n        \"unpackAlpha\": true,\n        \"flip\": true,\n        \"_fromData\": true,\n        \"name\": \"emptyCubemapTexture\",\n        \"anisotropic\": 0,\n    };\n};\n\n/**\n * @static\n * @function getTempGradientTexture\n * @memberof Texture\n * @description returns a gradient texture from black to white\n * @param {Context} cgl\n * @return {Texture}\n */\nTexture.getTempGradientTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getTempGradientTexture] no cgl!\");\n\n    if (cgl.tempTextureGradient) return cgl.tempTextureGradient;\n    const temptex = new Texture(cgl);\n    const size = 256;\n    const data = new Uint8Array(size * size * 4); // .fill(0);\n\n    for (let y = 0; y < size; y++)\n    {\n        for (let x = 0; x < size; x++)\n        {\n            data[(x + y * size) * 4 + 0] = data[(x + y * size) * 4 + 1] = data[(x + y * size) * 4 + 2] = 255 - y;\n            data[(x + y * size) * 4 + 3] = 255;\n        }\n    }\n\n    temptex.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n    cgl.tempTextureGradient = temptex;\n    return temptex;\n};\n\nTexture.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b)\n{\n    if (r === undefined)r = 1;\n    if (g === undefined)g = 1;\n    if (b === undefined)b = 1;\n    const temptex = new Texture(cgl);\n    const arr = [];\n    for (let y = 0; y < size; y++)\n    {\n        for (let x = 0; x < size; x++)\n        {\n            if ((x + y) % 64 < 32)\n            {\n                arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);\n                arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);\n                arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);\n            }\n            else\n            {\n                arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);\n                arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);\n                arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);\n            }\n            arr.push(255);\n        }\n    }\n\n    const data = new Uint8Array(arr);\n    temptex.initFromData(data, size, size, filter, wrap);\n\n    return temptex;\n};\n\n/**\n * @static\n * @function createFromImage\n * @memberof Texture\n * @description create texturem from image data (e.g. image or canvas)\n * @param {Context} cgl\n * @param {Object} image\n * @param {Object} options\n */\nTexture.createFromImage = function (cgl, img, options)\n{\n    options = options || {};\n    const texture = new Texture(cgl, options);\n    texture.flip = false;\n    texture.image = img;\n    texture.width = img.width;\n    texture.height = img.height;\n    if (options.hasOwnProperty(\"wrap\"))texture.wrap = options.wrap;\n    texture.initTexture(img, options.filter);\n\n    return texture;\n};\n\n// deprecated!\nTexture.fromImage = function (cgl, img, filter, wrap)\n{\n    console.error(\"deprecated texture from image...\");\n\n    const texture = new Texture(cgl);\n    texture.flip = false;\n    if (filter) texture.filter = filter;\n    if (wrap) texture.wrap = wrap;\n    texture.image = img;\n    texture.initTexture(img);\n    return texture;\n};\n\n/**\n * @static\n * @function isPowerOfTwo\n * @memberof Texture\n * @description returns true if x is power of two\n * @param {Number} x\n * @return {Boolean}\n */\nTexture.isPowerOfTwo = function (x)\n{\n    return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384;\n};\n\nTexture.getTexInfo = function (tex)\n{\n    const obj = {};\n\n    obj.name = tex.name;\n    obj[\"power of two\"] = tex.isPowerOfTwo();\n    obj.size = tex.width + \" x \" + tex.height;\n\n    let targetString = tex.texTarget;\n    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = \"TEXTURE_2D\";\n    obj.target = targetString;\n\n    obj.unpackAlpha = tex.unpackAlpha;\n\n    if (tex.cubemap)obj.cubemap = true;\n\n    if (tex.textureType == Texture.TYPE_FLOAT) obj.textureType = \"TYPE_FLOAT\";\n    if (tex.textureType == Texture.TYPE_HALF_FLOAT) obj.textureType = \"TYPE_HALF_FLOAT\";\n    else if (tex.textureType == Texture.TYPE_DEPTH) obj.textureType = \"TYPE_DEPTH\";\n    else if (tex.textureType == Texture.TYPE_DEFAULT) obj.textureType = \"TYPE_DEFAULT\";\n    else obj.textureType = \"UNKNOWN \" + this.textureType;\n\n    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE) obj.wrap = \"CLAMP_TO_EDGE\";\n    else if (tex.wrap == Texture.WRAP_REPEAT) obj.wrap = \"WRAP_REPEAT\";\n    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT) obj.wrap = \"WRAP_MIRRORED_REPEAT\";\n    else obj.wrap = \"UNKNOWN\";\n\n    if (tex.filter == Texture.FILTER_NEAREST) obj.filter = \"FILTER_NEAREST\";\n    else if (tex.filter == Texture.FILTER_LINEAR) obj.filter = \"FILTER_LINEAR\";\n    else if (tex.filter == Texture.FILTER_MIPMAP) obj.filter = \"FILTER_MIPMAP\";\n    else obj.filter = \"UNKNOWN\";\n\n    obj.pixelFormat = tex.pixelFormat || \"unknown\";\n\n    return obj;\n};\n\n\nTexture.FILTER_NEAREST = 0;\nTexture.FILTER_LINEAR = 1;\nTexture.FILTER_MIPMAP = 2;\n\nTexture.WRAP_REPEAT = 0;\nTexture.WRAP_MIRRORED_REPEAT = 1;\nTexture.WRAP_CLAMP_TO_EDGE = 2;\n\nTexture.TYPE_DEFAULT = 0;\nTexture.TYPE_DEPTH = 1;\nTexture.TYPE_FLOAT = 2;\n\n\nTexture.PFORMATSTR_RGB565 = \"RGB 5/6/5bit ubyte\";\n\nTexture.PFORMATSTR_R8UB = \"R 8bit ubyte\";\nTexture.PFORMATSTR_RG8UB = \"RG 8bit ubyte\";\nTexture.PFORMATSTR_RGB8UB = \"RGB 8bit ubyte\";\nTexture.PFORMATSTR_RGBA8UB = \"RGBA 8bit ubyte\";\n\nTexture.PFORMATSTR_SRGBA8 = \"SRGBA 8bit ubyte\";\n\nTexture.PFORMATSTR_R11FG11FB10F = \"RGB 11/11/10bit float\";\n\nTexture.PFORMATSTR_R16F = \"R 16bit float\";\nTexture.PFORMATSTR_RG16F = \"RG 16bit float\";\nTexture.PFORMATSTR_RGB16F = \"RGB 16bit float\";\nTexture.PFORMATSTR_RGBA16F = \"RGBA 16bit float\";\n\n\nTexture.PFORMATSTR_R32F = \"R 32bit float\";\nTexture.PFORMATSTR_RGBA32F = \"RGBA 32bit float\";\n\nTexture.PFORMATSTR_DEPTH = \"DEPTH\";\n\n\nTexture.PIXELFORMATS = [\n\n    Texture.PFORMATSTR_RGB565,\n\n    Texture.PFORMATSTR_R8UB,\n    Texture.PFORMATSTR_RG8UB,\n    Texture.PFORMATSTR_RGB8UB,\n    Texture.PFORMATSTR_RGBA8UB,\n\n    Texture.PFORMATSTR_SRGBA8,\n\n    Texture.PFORMATSTR_R11FG11FB10F,\n    Texture.PFORMATSTR_R16F,\n    Texture.PFORMATSTR_RG16F,\n    Texture.PFORMATSTR_RGBA16F,\n\n    Texture.PFORMATSTR_R32F,\n    Texture.PFORMATSTR_RGBA32F\n\n];\n\nTexture.isPixelFormatFloat =\n    (pxlfrmt) =>\n    {\n        return (pxlfrmt || \"\").indexOf(\"float\") > -1;\n    };\n\nTexture.isPixelFormatHalfFloat =\n    (pxlfrmt) =>\n    {\n        return (pxlfrmt || \"\").indexOf(\"float\") > -1 && (pxlfrmt || \"\").indexOf(\"16bit\") > -1;\n    };\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3RleHR1cmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfdGV4dHVyZS5qcz9iMjdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHV1aWQgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5cblxuXG5jb25zdCBERUZBVUxUX1RFWFRVUkVfU0laRSA9IDg7XG5cbi8qKlxuICogQSBUZXh0dXJlXG4gKiBAZXh0ZXJuYWwgQ0dMXG4gKiBAbmFtZXNwYWNlIFRleHR1cmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIC8vIGdlbmVyYXRlIGEgMjU2eDI1NiBwaXhlbCB0ZXh0dXJlIG9mIHJhbmRvbSBjb2xvcnNcbiAqIGNvbnN0IHNpemU9MjU2O1xuICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNpemUqc2l6ZSo0KTtcbiAqXG4gKiBmb3IodmFyIHg9MDt4PHNpemUqc2l6ZSo0O3grKykgZGF0YVsgeCo0KzNdPTI1NTtcbiAqXG4gKiBjb25zdCB0ZXg9bmV3IENHTC5UZXh0dXJlKGNnbCk7XG4gKiB0ZXguaW5pdEZyb21EYXRhKGRhdGEsc2l6ZSxzaXplLENHTC5UZXh0dXJlLkZJTFRFUl9ORUFSRVNULENHTC5UZXh0dXJlLldSQVBfUkVQRUFUKTtcbiAqL1xuY29uc3QgVGV4dHVyZSA9IGZ1bmN0aW9uIChfX2NnbCwgb3B0aW9ucyA9IHt9KVxue1xuICAgIGlmICghX19jZ2wpIHRocm93IG5ldyBFcnJvcihcIm5vIGNnbFwiKTtcbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY2dsX3RleHR1cmVcIik7XG4gICAgdGhpcy5fY2dsID0gX19jZ2w7XG4gICAgdGhpcy5waXhlbEZvcm1hdCA9IG9wdGlvbnMucGl4ZWxGb3JtYXQgfHwgVGV4dHVyZS5QRk9STUFUU1RSX1JHQkE4VUI7XG4gICAgdGhpcy50ZXggPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMuaWQgPSBDQUJMRVMudXVpZCgpO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmZsaXAgPSB0cnVlO1xuICAgIHRoaXMuZmxpcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2hhZG93TWFwID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgdGhpcy5hbmlzb3Ryb3BpYyA9IDA7XG4gICAgdGhpcy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUO1xuICAgIHRoaXMud3JhcCA9IFRleHR1cmUuV1JBUF9DTEFNUF9UT19FREdFO1xuICAgIHRoaXMudGV4VGFyZ2V0ID0gdGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB0aGlzLnRleFRhcmdldCA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLnRleHR1cmVUeXBlID0gVGV4dHVyZS5UWVBFX0RFRkFVTFQ7XG4gICAgdGhpcy51bnBhY2tBbHBoYSA9IHRydWU7XG4gICAgdGhpcy5fZnJvbURhdGEgPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IFwidW5rbm93blwiO1xuXG4gICAgdGhpcy5fZ2xEYXRhVHlwZSA9IC0xO1xuICAgIHRoaXMuX2dsSW50ZXJuYWxGb3JtYXQgPSAtMTtcbiAgICB0aGlzLl9nbERhdGFGb3JtYXQgPSAtMTtcblxuXG4gICAgaWYgKG9wdGlvbnMpXG4gICAge1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgdGhpcy5uYW1lO1xuICAgICAgICBpZiAob3B0aW9ucy5pc0RlcHRoVGV4dHVyZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IFRleHR1cmUuVFlQRV9ERVBUSDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pc0Zsb2F0aW5nUG9pbnRUZXh0dXJlID09PSB0cnVlKSB0aGlzLnRleHR1cmVUeXBlID0gVGV4dHVyZS5UWVBFX0ZMT0FUO1xuXG4gICAgICAgIGlmIChcInRleHR1cmVUeXBlXCIgaW4gb3B0aW9ucykgdGhpcy50ZXh0dXJlVHlwZSA9IG9wdGlvbnMudGV4dHVyZVR5cGU7XG4gICAgICAgIGlmIChcImZpbHRlclwiIGluIG9wdGlvbnMpIHRoaXMuZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIGlmIChcIndyYXBcIiBpbiBvcHRpb25zKSB0aGlzLndyYXAgPSBvcHRpb25zLndyYXA7XG4gICAgICAgIGlmIChcInVucGFja0FscGhhXCIgaW4gb3B0aW9ucykgdGhpcy51bnBhY2tBbHBoYSA9IG9wdGlvbnMudW5wYWNrQWxwaGE7XG4gICAgICAgIGlmIChcImZsaXBcIiBpbiBvcHRpb25zKSB0aGlzLmZsaXAgPSBvcHRpb25zLmZsaXA7XG4gICAgICAgIGlmIChcInNoYWRvd01hcFwiIGluIG9wdGlvbnMpIHRoaXMuc2hhZG93TWFwID0gb3B0aW9ucy5zaGFkb3dNYXA7XG4gICAgICAgIGlmIChcImFuaXNvdHJvcGljXCIgaW4gb3B0aW9ucykgdGhpcy5hbmlzb3Ryb3BpYyA9IG9wdGlvbnMuYW5pc290cm9waWM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGl4ZWxGb3JtYXQgJiYgb3B0aW9ucy5pc0Zsb2F0aW5nUG9pbnRUZXh0dXJlKSB0aGlzLnBpeGVsRm9ybWF0ID0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkEzMkY7XG5cbiAgICBpZiAodGhpcy50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfREVQVEgpIHRoaXMucGl4ZWxGb3JtYXQgPSBUZXh0dXJlLlBGT1JNQVRTVFJfREVQVEg7XG5cblxuXG4gICAgaWYgKCFvcHRpb25zLndpZHRoKSBvcHRpb25zLndpZHRoID0gREVGQVVMVF9URVhUVVJFX1NJWkU7XG4gICAgaWYgKCFvcHRpb25zLmhlaWdodCkgb3B0aW9ucy5oZWlnaHQgPSBERUZBVUxUX1RFWFRVUkVfU0laRTtcblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVGV4dHVyZU5ldysrO1xuXG5cbiAgICB0aGlzLnNldEZvcm1hdChUZXh0dXJlLnNldFVwR2xQaXhlbEZvcm1hdCh0aGlzLl9jZ2wsIHRoaXMucGl4ZWxGb3JtYXQpKTtcbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEuYWRkSGVhdnlFdmVudChcInRleHR1cmUgY3JlYXRlZFwiLCB0aGlzLm5hbWUsIG9wdGlvbnMud2lkdGggKyBcInhcIiArIG9wdGlvbnMuaGVpZ2h0KTtcblxuICAgIHRoaXMuc2V0U2l6ZShvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XG4gICAgdGhpcy5nZXRJbmZvT25lTGluZSgpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuaXNGbG9hdGluZ1BvaW50ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gVGV4dHVyZS5pc1BpeGVsRm9ybWF0RmxvYXQodGhpcy5waXhlbEZvcm1hdCk7XG59O1xuXG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiBvdGhlclRleHR1cmUgaGFzIHNhbWUgb3B0aW9ucyAod2lkdGgvaGVpZ2h0L2ZpbHRlci93cmFwIGV0YylcbiAqIEBmdW5jdGlvbiBjb21wYXJlU2V0dGluZ3NcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7VGV4dHVyZX0gb3RoZXJUZXh0dXJlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuY29tcGFyZVNldHRpbmdzID0gZnVuY3Rpb24gKHRleClcbntcbiAgICAvLyBpZiAoIXRleCkgeyB0aGlzLl9sb2cud2FybihcImNvbXBhcmU6IG5vIHRleFwiKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gaWYgKHRleC53aWR0aCAhPSB0aGlzLndpZHRoKSB0aGlzLl9sb2cud2FybihcInRleC53aWR0aCBub3QgZXF1YWxcIiwgdGV4LndpZHRoLCB0aGlzLndpZHRoKTtcbiAgICAvLyBpZiAodGV4LmhlaWdodCAhPSB0aGlzLmhlaWdodCkgdGhpcy5fbG9nLndhcm4oXCJ0ZXguaGVpZ2h0IG5vdCBlcXVhbFwiLCB0ZXguaGVpZ2h0LCB0aGlzLmhlaWdodCk7XG4gICAgLy8gaWYgKHRleC5maWx0ZXIgIT0gdGhpcy5maWx0ZXIpIHRoaXMuX2xvZy53YXJuKFwidGV4LmZpbHRlciBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC53cmFwICE9IHRoaXMud3JhcCkgdGhpcy5fbG9nLndhcm4oXCJ0ZXgud3JhcCBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC50ZXh0dXJlVHlwZSAhPSB0aGlzLnRleHR1cmVUeXBlKSB0aGlzLl9sb2cud2FybihcInRleC50ZXh0dXJlVHlwZSBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC51bnBhY2tBbHBoYSAhPSB0aGlzLnVucGFja0FscGhhKSB0aGlzLl9sb2cud2FybihcInRleC51bnBhY2tBbHBoYSBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC5hbmlzb3Ryb3BpYyAhPSB0aGlzLmFuaXNvdHJvcGljKSB0aGlzLl9sb2cud2FybihcInRleC5hbmlzb3Ryb3BpYyBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC5zaGFkb3dNYXAgIT0gdGhpcy5zaGFkb3dNYXApIHRoaXMuX2xvZy53YXJuKFwidGV4LnNoYWRvd01hcCBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC50ZXhUYXJnZXQgIT0gdGhpcy50ZXhUYXJnZXQpIHRoaXMuX2xvZy53YXJuKFwidGV4LnRleFRhcmdldCBub3QgZXF1YWxcIik7XG4gICAgLy8gaWYgKHRleC5mbGlwICE9IHRoaXMuZmxpcCkgdGhpcy5fbG9nLndhcm4oXCJ0ZXguZmxpcCBub3QgZXF1YWxcIik7XG5cbiAgICBpZiAoIXRleCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoXG4gICAgICAgIHRleC53aWR0aCA9PSB0aGlzLndpZHRoICYmXG4gICAgICAgIHRleC5oZWlnaHQgPT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgICAgdGV4LmZpbHRlciA9PSB0aGlzLmZpbHRlciAmJlxuICAgICAgICB0ZXgud3JhcCA9PSB0aGlzLndyYXAgJiZcbiAgICAgICAgdGV4LnRleHR1cmVUeXBlID09IHRoaXMudGV4dHVyZVR5cGUgJiZcbiAgICAgICAgdGV4LnVucGFja0FscGhhID09IHRoaXMudW5wYWNrQWxwaGEgJiZcbiAgICAgICAgdGV4LmFuaXNvdHJvcGljID09IHRoaXMuYW5pc290cm9waWMgJiZcbiAgICAgICAgdGV4LnNoYWRvd01hcCA9PSB0aGlzLnNoYWRvd01hcCAmJlxuICAgICAgICB0ZXgudGV4VGFyZ2V0ID09IHRoaXMudGV4VGFyZ2V0ICYmXG4gICAgICAgIHRleC5mbGlwID09IHRoaXMuZmxpcFxuICAgICk7XG59O1xuXG4vKipcbiAqIHJldHVybnMgYSBuZXcgdGV4dHVyZSB3aXRoIHRoZSBzYW1lIHNldHRpbmdzIChkb2VzIG5vdCBjb3B5IHRleHR1cmUgaXRzZWxmKVxuICogQGZ1bmN0aW9uIGNsb25lXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IG5ld1RleCA9IG5ldyBUZXh0dXJlKHRoaXMuX2NnbCwge1xuICAgICAgICBcIm5hbWVcIjogdGhpcy5uYW1lLFxuICAgICAgICBcImZpbHRlclwiOiB0aGlzLmZpbHRlcixcbiAgICAgICAgXCJhbmlzb3Ryb3BpY1wiOiB0aGlzLmFuaXNvdHJvcGljLFxuICAgICAgICBcIndyYXBcIjogdGhpcy53cmFwLFxuICAgICAgICBcInRleHR1cmVUeXBlXCI6IHRoaXMudGV4dHVyZVR5cGUsXG4gICAgICAgIFwicGl4ZWxGb3JtYXRcIjogdGhpcy5waXhlbEZvcm1hdCxcbiAgICAgICAgXCJ1bnBhY2tBbHBoYVwiOiB0aGlzLnVucGFja0FscGhhLFxuICAgICAgICBcImZsaXBcIjogdGhpcy5mbGlwLFxuICAgICAgICBcIndpZHRoXCI6IHRoaXMud2lkdGgsXG4gICAgICAgIFwiaGVpZ2h0XCI6IHRoaXMuaGVpZ2h0LFxuICAgIH0pO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJ0ZXh0dXJlIGNyZWF0ZWRcIiwgdGhpcy5uYW1lLCB0aGlzLndpZHRoICsgXCJ4XCIgKyB0aGlzLmhlaWdodCk7XG5cbiAgICBpZiAoIXRoaXMuY29tcGFyZVNldHRpbmdzKG5ld1RleCkpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJDbG9uZWQgdGV4dHVyZSBzZXR0aW5ncyBkbyBub3QgY29tcGFyZSFcIik7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcih0aGlzKTtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKG5ld1RleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1RleDtcbn07XG5cblxuVGV4dHVyZS5wcm90b3R5cGUuc2V0Rm9ybWF0ID0gZnVuY3Rpb24gKG8pXG57XG4gICAgdGhpcy5waXhlbEZvcm1hdCA9IG8ucGl4ZWxGb3JtYXQ7XG4gICAgdGhpcy5fZ2xEYXRhRm9ybWF0ID0gby5nbERhdGFGb3JtYXQ7XG4gICAgdGhpcy5fZ2xJbnRlcm5hbEZvcm1hdCA9IG8uZ2xJbnRlcm5hbEZvcm1hdDtcbiAgICB0aGlzLl9nbERhdGFUeXBlID0gby5nbERhdGFUeXBlO1xufTtcblxuXG5UZXh0dXJlLnNldFVwR2xQaXhlbEZvcm1hdCA9IGZ1bmN0aW9uIChjZ2wsIHBpeGVsRm9ybWF0U3RyKVxue1xuICAgIGNvbnN0IG8gPSB7fTtcblxuICAgIGlmICghcGl4ZWxGb3JtYXRTdHIpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5vIHBpeGVsZm9ybWF0c3RyIVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgIHBpeGVsRm9ybWF0U3RyID0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkE4VUI7XG4gICAgfVxuXG4gICAgby5waXhlbEZvcm1hdEJhc2UgPSBwaXhlbEZvcm1hdFN0cjtcblxuICAgIGlmIChjZ2wuZ2xVc2VIYWxmRmxvYXRUZXgpXG4gICAge1xuICAgICAgICBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkEzMkYpIHBpeGVsRm9ybWF0U3RyID0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkExNkY7XG4gICAgICAgIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkczMkYpIHBpeGVsRm9ybWF0U3RyID0gVGV4dHVyZS5QRk9STUFUU1RSX1JHMTZGO1xuICAgICAgICBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1IzMkYpIHBpeGVsRm9ybWF0U3RyID0gVGV4dHVyZS5QRk9STUFUU1RSX1IxNkY7XG4gICAgfVxuXG4gICAgby5waXhlbEZvcm1hdCA9IHBpeGVsRm9ybWF0U3RyO1xuICAgIG8uZ2xEYXRhVHlwZSA9IGNnbC5nbC5VTlNJR05FRF9CWVRFO1xuICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SR0JBODtcbiAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SR0JBO1xuXG4gICAgbGV0IGZsb2F0RGF0YXR5cGUgPSBjZ2wuZ2wuRkxPQVQ7XG5cbiAgICBpZiAoY2dsLmdsVmVyc2lvbiA9PSAxKVxuICAgIHtcbiAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQkE7XG5cbiAgICAgICAgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMTZGIHx8IHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SRzE2RiB8fCBwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjE2RilcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXh0ID0gY2dsLmVuYWJsZUV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIik7XG4gICAgICAgICAgICBpZiAoIWV4dCkgdGhyb3cgbmV3IEVycm9yKFwibm8gaGFsZiBmbG9hdCB0ZXh0dXJlIGV4dGVuc2lvblwiKTtcblxuICAgICAgICAgICAgZmxvYXREYXRhdHlwZSA9IGV4dC5IQUxGX0ZMT0FUX09FUztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQThVQilcbiAgICB7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0I1NjUpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkdCNTY1O1xuICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SR0I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SOFVCKVxuICAgIHtcbiAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlI4O1xuICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SRUQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SRzhVQilcbiAgICB7XG4gICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SRzg7XG4gICAgICAgIG8uZ2xEYXRhRm9ybWF0ID0gY2dsLmdsLlJHO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCOFVCKVxuICAgIHtcbiAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQjg7XG4gICAgICAgIG8uZ2xEYXRhRm9ybWF0ID0gY2dsLmdsLlJHQjtcbiAgICB9XG4gICAgZWxzZSBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1NSR0JBOClcbiAgICB7XG4gICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5TUkdCOF9BTFBIQTg7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1IzMkYpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUjMyRjtcbiAgICAgICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuUkVEO1xuICAgICAgICBvLmdsRGF0YVR5cGUgPSBmbG9hdERhdGF0eXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjE2RilcbiAgICB7XG4gICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SMTZGO1xuICAgICAgICBvLmdsRGF0YVR5cGUgPSBmbG9hdERhdGF0eXBlO1xuICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SRUQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SRzE2RilcbiAgICB7XG4gICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SRzE2RjtcbiAgICAgICAgby5nbERhdGFUeXBlID0gZmxvYXREYXRhdHlwZTtcbiAgICAgICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuUkc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMTZGKVxuICAgIHtcbiAgICAgICAgaWYgKGNnbC5nbFZlcnNpb24gPT0gMSkgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQkE7XG4gICAgICAgIGVsc2Ugby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQkExNkY7XG4gICAgICAgIG8uZ2xEYXRhVHlwZSA9IGZsb2F0RGF0YXR5cGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SMTFGRzExRkIxMEYpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUjExRl9HMTFGX0IxMEY7XG4gICAgICAgIG8uZ2xEYXRhVHlwZSA9IGZsb2F0RGF0YXR5cGU7XG4gICAgICAgIG8uZ2xEYXRhRm9ybWF0ID0gY2dsLmdsLlJHQjtcbiAgICB9XG4gICAgZWxzZSBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkEzMkYpXG4gICAge1xuICAgICAgICBpZiAoY2dsLmdsVmVyc2lvbiA9PSAxKSBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkdCQTtcbiAgICAgICAgZWxzZSBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkdCQTMyRjtcbiAgICAgICAgby5nbERhdGFUeXBlID0gZmxvYXREYXRhdHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX0RFUFRIKVxuICAgIHtcbiAgICAgICAgaWYgKGNnbC5nbFZlcnNpb24gPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLkRFUFRIX0NPTVBPTkVOVDtcbiAgICAgICAgICAgIG8uZ2xEYXRhVHlwZSA9IGNnbC5nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgICAgIG8uZ2xEYXRhRm9ybWF0ID0gY2dsLmdsLkRFUFRIX0NPTVBPTkVOVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5ERVBUSF9DT01QT05FTlQzMkY7XG4gICAgICAgICAgICBvLmdsRGF0YVR5cGUgPSBjZ2wuZ2wuRkxPQVQ7XG4gICAgICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5ERVBUSF9DT01QT05FTlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ1bmtub3duIHBpeGVsZm9ybWF0IFwiLCBwaXhlbEZvcm1hdFN0cik7XG4gICAgfVxuXG4gICAgLy8vIC8vLy8vL1xuXG4gICAgaWYgKHBpeGVsRm9ybWF0U3RyLmluZGV4T2YoXCIzMmJpdFwiKSB8fCBwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGKVxuICAgIHtcbiAgICAgICAgaWYgKGNnbC5nbFZlcnNpb24gPT0gMikgY2dsLmVuYWJsZUV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIik7XG4gICAgICAgIGlmIChjZ2wuZ2xWZXJzaW9uID09IDIpIGNnbC5lbmFibGVFeHRlbnNpb24oXCJFWFRfZmxvYXRfYmxlbmRcIik7XG5cbiAgICAgICAgY2dsLmVuYWJsZUV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKTsgLy8geWVzLCBpIGFtIHN1cmUsIHRoaXMgaXMgYSB3ZWJnbCAxIGFuZCAyIGV4dFxuICAgIH1cblxuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5pbmRleE9mKFwiMTZiaXRcIikpXG4gICAge1xuICAgICAgICBjZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpO1xuICAgICAgICBjZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpO1xuICAgIH1cblxuXG4gICAgby5udW1Db2xvckNoYW5uZWxzID0gMTtcbiAgICBpZiAocGl4ZWxGb3JtYXRTdHIuaW5kZXhPZihcIlJcIikgPT0gMClvLm51bUNvbG9yQ2hhbm5lbHMgPSAxO1xuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5pbmRleE9mKFwiUkdcIikgPT0gMClvLm51bUNvbG9yQ2hhbm5lbHMgPSAyO1xuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5pbmRleE9mKFwiUkdCXCIpID09IDApby5udW1Db2xvckNoYW5uZWxzID0gMztcbiAgICBpZiAocGl4ZWxGb3JtYXRTdHIuaW5kZXhPZihcIlJHQkFcIikgPT0gMClvLm51bUNvbG9yQ2hhbm5lbHMgPSA0O1xuXG5cbiAgICAvLyBjb25zb2xlLmxvZyhwaXhlbEZvcm1hdFN0ciwgdGhpcy5uYW1lKTtcblxuICAgIGlmICghby5nbERhdGFUeXBlIHx8ICFvLmdsSW50ZXJuYWxGb3JtYXQgfHwgIW8uZ2xEYXRhRm9ybWF0KSBjb25zb2xlLmxvZyhcInBpeGVsZm9ybWF0IHdyb25nID8hXCIsIHBpeGVsRm9ybWF0U3RyLCBvLmdsRGF0YVR5cGUsIG8uZ2xJbnRlcm5hbEZvcm1hdCwgby5nbERhdGFGb3JtYXQsIHRoaXMpO1xuXG4gICAgcmV0dXJuIG87XG59O1xuXG4vKipcbiAqIHNldCBwaXhlbCBzaXplIG9mIHRleHR1cmVcbiAqIEBmdW5jdGlvbiBzZXRTaXplXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3LCBoKVxue1xuICAgIGlmICh0aGlzLl9jZ2wuYWJvcnRlZCkgcmV0dXJuO1xuICAgIGlmICh3ICE9IHcgfHwgdyA8PSAwIHx8ICF3KSB3ID0gREVGQVVMVF9URVhUVVJFX1NJWkU7XG4gICAgaWYgKGggIT0gaCB8fCBoIDw9IDAgfHwgIWgpIGggPSBERUZBVUxUX1RFWFRVUkVfU0laRTtcblxuICAgIGlmICh3ID4gdGhpcy5fY2dsLm1heFRleFNpemUgfHwgaCA+IHRoaXMuX2NnbC5tYXhUZXhTaXplKSB0aGlzLl9sb2cuZXJyb3IoXCJ0ZXh0dXJlIHNpemUgdG9vIGJpZyEgXCIgKyB3ICsgXCJ4XCIgKyBoICsgXCIgLyBtYXg6IFwiICsgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuXG4gICAgdyA9IE1hdGgubWluKHcsIHRoaXMuX2NnbC5tYXhUZXhTaXplKTtcbiAgICBoID0gTWF0aC5taW4oaCwgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuXG4gICAgdyA9IE1hdGguZmxvb3Iodyk7XG4gICAgaCA9IE1hdGguZmxvb3IoaCk7XG4gICAgaWYgKHRoaXMud2lkdGggPT0gdyAmJiB0aGlzLmhlaWdodCA9PSBoKSByZXR1cm47XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcInRleCBzZXRzaXplXCIsIHRoaXMubmFtZSwgdywgaCwgdGhpcy5pZCk7XG5cbiAgICB0aGlzLndpZHRoID0gdztcbiAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG5cblxuICAgIHRoaXMuc2V0Rm9ybWF0KFRleHR1cmUuc2V0VXBHbFBpeGVsRm9ybWF0KHRoaXMuX2NnbCwgdGhpcy5waXhlbEZvcm1hdCkpO1xuXG5cbiAgICB0aGlzLnNob3J0SW5mb1N0cmluZyA9IHRoaXMuZ2V0SW5mb09uZUxpbmUoKTsvLyB3ICsgXCJ4XCIgKyBoICsgXCJcIjtcbiAgICAvLyBpZiAodGhpcy50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfRkxPQVQpIHRoaXMuc2hvcnRJbmZvU3RyaW5nICs9IFwiIEZsb2F0XCI7XG5cbiAgICAvLyBpZiAodGhpcy5fY2dsLnByaW50RXJyb3IoXCJjZ2x0ZXggYmVmb3JlXCIpKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5wcmludEluZm8oKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMudGV4VGFyZ2V0LCB0aGlzLnRleCk7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVUZXh0dXJlUmVzaXplKys7XG5cbiAgICBjb25zdCB1YXJyID0gbnVsbDtcblxuXG4gICAgLy8gaWYgKFxuICAgIC8vICAgICB0aGlzLl9jZ2wuZ2xWZXJzaW9uID09IDEgJiZcbiAgICAvLyAgICAgdGhpcy50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfRkxPQVQgJiYgdGhpcy5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTElORUFSICYmXG4gICAgLy8gICAgICghdGhpcy5fY2dsLmVuYWJsZUV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSlcbiAgICAvLyApXG4gICAgLy8ge1xuICAgIC8vICAgICBjb25zb2xlLndhcm4oXCJ0aGlzIGdyYXBoaWNzIGNhcmQgZG9lcyBub3Qgc3VwcG9ydCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlIGxpbmVhciBpbnRlcnBvbGF0aW9uISB1c2luZyBORUFSRVNUXCIpO1xuICAgIC8vICAgICB0aGlzLmZpbHRlciA9IFRleHR1cmUuRklMVEVSX05FQVJFU1Q7XG4gICAgLy8gfVxuXG5cbiAgICAvLyBlbHNlXG4gICAgLy8ge1xuICAgIC8vICAgICBkYXRhVHlwZSA9IHRoaXMuX2NnbC5nbC5VTlNJR05FRF9CWVRFO1xuICAgIC8vICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2NnbC5nbC5SR0JBO1xuICAgIC8vICAgICBkYXRhRm9ybWF0ID0gdGhpcy5fY2dsLmdsLlJHQkE7XG4gICAgLy8gICAgIC8vIHRoaXMuX2NnbC5nbC50ZXhJbWFnZTJEKHRoaXMudGV4VGFyZ2V0LCAwLCB0aGlzLl9jZ2wuZ2wuUkdCQSwgdywgaCwgMCwgdGhpcy5fY2dsLmdsLlJHQkEsIHRoaXMuX2NnbC5nbC5VTlNJR05FRF9CWVRFLCB1YXJyKTtcbiAgICAvLyB9XG5cbiAgICB0aGlzLl9jZ2wuZ2wudGV4SW1hZ2UyRCh0aGlzLnRleFRhcmdldCwgMCwgdGhpcy5fZ2xJbnRlcm5hbEZvcm1hdCwgdywgaCwgMCwgdGhpcy5fZ2xEYXRhRm9ybWF0LCB0aGlzLl9nbERhdGFUeXBlLCB1YXJyKTtcblxuICAgIHRoaXMuX3NldEZpbHRlcigpO1xuXG4gICAgLy8gaWYgKHRoaXMuX2NnbC5wcmludEVycm9yKFwiY2dsdGV4XCIpKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5wcmludEluZm8oKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy51cGRhdGVNaXBNYXAoKTtcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLnRleFRhcmdldCwgbnVsbCk7XG59O1xuXG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gaW5pdEZyb21EYXRhXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gY3JlYXRlIHRleHR1cmVtIGZyb20gcmdiIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gZGF0YSByZ2IgY29sb3IgYXJyYXkgW3IsZyxiLGEscixnLGIsYSwuLi5dXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBmaWx0ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3cmFwXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmluaXRGcm9tRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB3LCBoLCBmaWx0ZXIsIHdyYXApXG57XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgdGhpcy53cmFwID0gd3JhcDtcbiAgICBpZiAoZmlsdGVyID09IHVuZGVmaW5lZCkgdGhpcy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9MSU5FQVI7XG4gICAgaWYgKHdyYXAgPT0gdW5kZWZpbmVkKSB0aGlzLndyYXAgPSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRTtcbiAgICB0aGlzLndpZHRoID0gdztcbiAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgdGhpcy5fZnJvbURhdGEgPSB0cnVlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaGVpZ2h0ID4gdGhpcy5fY2dsLm1heFRleFNpemUgfHwgdGhpcy53aWR0aCA+IHRoaXMuX2NnbC5tYXhUZXhTaXplKVxuICAgIHtcbiAgICAgICAgY29uc3QgdCA9IENHTC5UZXh0dXJlLmdldFRlbXBUZXh0dXJlKHRoaXMuX2NnbCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB0LndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRleCA9IHQudGV4O1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJbY2dsX3RleHR1cmVdIHRleHR1cmUgc2l6ZSB0byBiaWchISFcIiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuX2NnbC5tYXhUZXhTaXplKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZsaXApIHRoaXMuX2NnbC5nbC5waXhlbFN0b3JlaSh0aGlzLl9jZ2wuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGhpcy5mbGlwKTtcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLnRleFRhcmdldCwgdGhpcy50ZXgpO1xuXG4gICAgdGhpcy5zZXRGb3JtYXQoVGV4dHVyZS5zZXRVcEdsUGl4ZWxGb3JtYXQodGhpcy5fY2dsLCB0aGlzLnBpeGVsRm9ybWF0KSk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wudGV4SW1hZ2UyRCh0aGlzLnRleFRhcmdldCwgMCwgdGhpcy5fZ2xJbnRlcm5hbEZvcm1hdCwgdywgaCwgMCwgdGhpcy5fZ2xEYXRhRm9ybWF0LCB0aGlzLl9nbERhdGFUeXBlLCBkYXRhKTtcblxuICAgIHRoaXMuX3NldEZpbHRlcigpO1xuICAgIHRoaXMudXBkYXRlTWlwTWFwKCk7XG5cbiAgICBpZiAodGhpcy5mbGlwKSB0aGlzLl9jZ2wuZ2wucGl4ZWxTdG9yZWkodGhpcy5fY2dsLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy50ZXhUYXJnZXQsIG51bGwpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlTWlwTWFwID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoKHRoaXMuX2NnbC5nbFZlcnNpb24gPT0gMiB8fCB0aGlzLmlzUG93ZXJPZlR3bygpKSAmJiB0aGlzLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy50ZXhUYXJnZXQpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZUdlbk1pcE1hcCsrO1xuICAgIH1cbn07XG5cbi8qKlxuICogc2V0IHRleHR1cmUgZGF0YSBmcm9tIGFuIGltYWdlL2NhbnZhcyBvYmplY3RcbiAqIEBmdW5jdGlvbiBpbml0VGV4dHVyZVxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlXG4gKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmluaXRUZXh0dXJlID0gZnVuY3Rpb24gKGltZywgZmlsdGVyKVxue1xuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwiYmVmb3JlIGluaXRUZXh0dXJlXCIpO1xuICAgIHRoaXMuX2NnbC5jaGVja0ZyYW1lU3RhcnRlZChcInRleHR1cmUgaW5pdHRleHR1cmVcIik7XG4gICAgdGhpcy5fZnJvbURhdGEgPSBmYWxzZTtcbiAgICAvLyBpZihmaWx0ZXIpIHRoaXMudW5wYWNrQWxwaGE9ZmlsdGVyLnVucGFja0FscGhhfHx0aGlzLnVucGFja0FscGhhO1xuXG4gICAgdGhpcy5fY2dsLmdsLnBpeGVsU3RvcmVpKHRoaXMuX2NnbC5nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMudW5wYWNrQWxwaGEpO1xuICAgIGlmIChpbWcud2lkdGgpIHRoaXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgaWYgKGltZy5oZWlnaHQpIHRoaXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICBpZiAoZmlsdGVyKSB0aGlzLmZpbHRlciA9IGZpbHRlcjtcblxuICAgIGlmIChpbWcuaGVpZ2h0ID4gdGhpcy5fY2dsLm1heFRleFNpemUgfHwgaW1nLndpZHRoID4gdGhpcy5fY2dsLm1heFRleFNpemUpXG4gICAge1xuICAgICAgICBjb25zdCB0ID0gQ0dMLlRleHR1cmUuZ2V0VGVtcFRleHR1cmUodGhpcy5fY2dsKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHQud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGV4ID0gdC50ZXg7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltjZ2xfdGV4dHVyZV0gdGV4dHVyZSBzaXplIHRvIGJpZyEhIVwiLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIHRoaXMuX2NnbC5tYXhUZXhTaXplKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gY29uc29sZS5sb2coXCJsb2FkZWQgdGV4dHVyZVwiLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMudGV4VGFyZ2V0LCB0aGlzLnRleCk7XG5cbiAgICB0aGlzLmRlbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZsaXBwZWQgPSAhdGhpcy5mbGlwO1xuICAgIGlmICh0aGlzLmZsaXBwZWQpIHRoaXMuX2NnbC5nbC5waXhlbFN0b3JlaSh0aGlzLl9jZ2wuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGhpcy5mbGlwcGVkKTtcblxuXG4gICAgdGhpcy5zZXRGb3JtYXQoVGV4dHVyZS5zZXRVcEdsUGl4ZWxGb3JtYXQodGhpcy5fY2dsLCB0aGlzLnBpeGVsRm9ybWF0KSk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wudGV4SW1hZ2UyRCh0aGlzLnRleFRhcmdldCwgMCwgdGhpcy5fZ2xJbnRlcm5hbEZvcm1hdCwgdGhpcy5fZ2xEYXRhRm9ybWF0LCB0aGlzLl9nbERhdGFUeXBlLCBpbWcpO1xuICAgIC8vIHRoaXMuX2NnbC5nbC50ZXhJbWFnZTJEKHRoaXMudGV4VGFyZ2V0LCAwLCB0aGlzLl9jZ2wuZ2wuUkdCQSwgdGhpcy5fY2dsLmdsLlJHQkEsIHRoaXMuX2NnbC5nbC5VTlNJR05FRF9CWVRFLCBpbWcpO1xuXG4gICAgLy8gaWYgKHRoaXMuX2NnbC5wcmludEVycm9yKFwiW2NnbF90ZXh0dXJlXSBpbml0IFwiICsgdGhpcy5uYW1lKSk7XG5cbiAgICB0aGlzLl9zZXRGaWx0ZXIoKTtcbiAgICB0aGlzLnVwZGF0ZU1pcE1hcCgpO1xuXG4gICAgLy8gaWYgKHRoaXMuX2NnbC5wcmludEVycm9yKFwiW2NnbF90ZXh0dXJlXSBpbml0MlwiKSk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy50ZXhUYXJnZXQsIG51bGwpO1xuICAgIHRoaXMuX2NnbC5nbC5waXhlbFN0b3JlaSh0aGlzLl9jZ2wuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuZmxpcHBlZCkgdGhpcy5fY2dsLmdsLnBpeGVsU3RvcmVpKHRoaXMuX2NnbC5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG5cbiAgICB0aGlzLmdldEluZm9PbmVMaW5lKCk7XG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJpbml0VGV4dHVyZVwiKTtcbn07XG5cbi8qKlxuICogZGVsZXRlIHRleHR1cmUuIHVzZSB0aGlzIHdoZW4gdGV4dHVyZSBpcyBubyBsb25nZXIgbmVlZGVkXG4gKiBAZnVuY3Rpb24gZGVsZXRlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMubG9hZGluZylcbiAgICB7XG4gICAgICAgIC8vIGNhbnQgZGVsZXRlIHRleHR1cmUgd2hlbiBzdGlsbCBsb2FkaW5nXG4gICAgICAgIC8vIHNldFRpbWVvdXQodGhpcy5kZWxldGUuYmluZCh0aGlzKSwgNTApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZWxldGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVUZXh0dXJlRGVsZXRlKys7XG4gICAgdGhpcy5fY2dsLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXgpO1xuICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuXG4gICAgdGhpcy50ZXggPSBudWxsO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gaXNQb3dlck9mVHdvXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJuIHRydWUgaWYgdGV4dHVyZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBib3RoIHBvd2VyIG9mIHR3b1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuaXNQb3dlck9mVHdvID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gVGV4dHVyZS5pc1Bvd2VyT2ZUd28odGhpcy53aWR0aCkgJiYgVGV4dHVyZS5pc1Bvd2VyT2ZUd28odGhpcy5oZWlnaHQpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUucHJpbnRJbmZvID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zb2xlLmxvZyh0aGlzLmdldEluZm8oKSk7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5nZXRJbmZvUmVhZGFibGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldEluZm8oKTtcbiAgICBsZXQgaHRtbCA9IFwiXCI7XG5cbiAgICBpbmZvLm5hbWUgPSBpbmZvLm5hbWUuc3Vic3RyKDAsIGluZm8ubmFtZS5pbmRleE9mKFwiP3JuZD1cIikpO1xuXG4gICAgZm9yIChjb25zdCBpIGluIGluZm8pXG4gICAge1xuICAgICAgICBodG1sICs9IFwiKiBcIiArIGkgKyBcIjogICoqXCIgKyBpbmZvW2ldICsgXCIqKlxcblwiO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuZ2V0SW5mb09uZUxpbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCB0eHQgPSBcIlwiICsgdGhpcy53aWR0aCArIFwieFwiICsgdGhpcy5oZWlnaHQ7XG4gICAgdHh0ICs9IFwiIFwiO1xuICAgIC8vIGlmICh0aGlzLnRleHR1cmVUeXBlID09PSBDR0wuVGV4dHVyZS5UWVBFX0ZMT0FUKSB0eHQgKz0gXCIgMzJiaXRcIjsgZWxzZSB0eHQgKz0gXCIgOGJpdFwiO1xuICAgIC8vIGlmICh0aGlzLnRleHR1cmVUeXBlID09PSBDR0wuVGV4dHVyZS5UWVBFX0ZMT0FUKSB0eHQgKz0gXCIgMzJiaXRcIjsgZWxzZSB0eHQgKz0gXCIgOGJpdFwiO1xuICAgIHR4dCArPSB0aGlzLnBpeGVsRm9ybWF0O1xuXG4gICAgaWYgKHRoaXMuZmlsdGVyID09PSBDR0wuVGV4dHVyZS5GSUxURVJfTkVBUkVTVCkgdHh0ICs9IFwiIG5lYXJlc3RcIjtcbiAgICBpZiAodGhpcy5maWx0ZXIgPT09IENHTC5UZXh0dXJlLkZJTFRFUl9MSU5FQVIpIHR4dCArPSBcIiBsaW5lYXJcIjtcbiAgICBpZiAodGhpcy5maWx0ZXIgPT09IENHTC5UZXh0dXJlLkZJTFRFUl9NSVBNQVApIHR4dCArPSBcIiBtaXBtYXBcIjtcblxuICAgIGlmICh0aGlzLndyYXAgPT09IENHTC5UZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRSkgdHh0ICs9IFwiIGNsYW1wXCI7XG4gICAgaWYgKHRoaXMud3JhcCA9PT0gQ0dMLlRleHR1cmUuV1JBUF9SRVBFQVQpIHR4dCArPSBcIiByZXBlYXRcIjtcbiAgICBpZiAodGhpcy53cmFwID09PSBDR0wuVGV4dHVyZS5XUkFQX01JUlJPUkVEX1JFUEVBVCkgdHh0ICs9IFwiIHJlcGVhdG1pclwiO1xuXG4gICAgdGhpcy5zaG9ydEluZm9TdHJpbmcgPSB0eHQ7XG5cbiAgICByZXR1cm4gdHh0O1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuZ2V0SW5mb09uZUxpbmVTaG9ydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IHR4dCA9IFwiXCIgKyB0aGlzLndpZHRoICsgXCJ4XCIgKyB0aGlzLmhlaWdodDtcbiAgICAvLyBpZiAodGhpcy50ZXh0dXJlVHlwZSA9PT0gQ0dMLlRleHR1cmUuVFlQRV9GTE9BVCkgdHh0ICs9IFwiIDMyYml0XCI7IGVsc2UgdHh0ICs9IFwiIDhiaXRcIjtcbiAgICB0eHQgKz0gXCIgXCI7XG4gICAgdHh0ICs9IHRoaXMucGl4ZWxGb3JtYXQ7XG5cbiAgICB0aGlzLnNob3J0SW5mb1N0cmluZyA9IHR4dDtcblxuICAgIHJldHVybiB0eHQ7XG59O1xuXG5cblRleHR1cmUucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBUZXh0dXJlLmdldFRleEluZm8odGhpcyk7XG59O1xuXG5cblRleHR1cmUucHJvdG90eXBlLl9zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwiYmVmb3JlIF9zZXRGaWx0ZXJcIik7XG5cbiAgICBpZiAoIXRoaXMuX2Zyb21EYXRhKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLnBpeGVsU3RvcmVpKHRoaXMuX2NnbC5nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMudW5wYWNrQWxwaGEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNoYWRvd01hcClcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9DT01QQVJFX01PREUsIHRoaXMuX2NnbC5nbC5DT01QQVJFX1JFRl9UT19URVhUVVJFKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX0NPTVBBUkVfRlVOQywgdGhpcy5fY2dsLmdsLkxFUVVBTCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGV4dHVyZVR5cGUgPT0gVGV4dHVyZS5UWVBFX0ZMT0FUICYmIHRoaXMuZmlsdGVyID09IFRleHR1cmUuRklMVEVSX01JUE1BUClcbiAgICB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTElORUFSO1xuICAgICAgICB0aGlzLl9sb2cuc3RhY2soXCJ0ZXh0dXJlOiBIRFIgYW5kIG1pcG1hcCBmaWx0ZXJpbmcgYXQgdGhlIHNhbWUgdGltZSBpcyBub3QgcG9zc2libGVcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NnbC5nbFZlcnNpb24gPT0gMSAmJiAhdGhpcy5pc1Bvd2VyT2ZUd28oKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTkVBUkVTVCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fY2dsLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9jZ2wuZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgdGhpcy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUO1xuICAgICAgICB0aGlzLndyYXAgPSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMud3JhcCA9PSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fY2dsLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fY2dsLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JhcCA9PSBUZXh0dXJlLldSQVBfUkVQRUFUKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9jZ2wuZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX2NnbC5nbC5SRVBFQVQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JhcCA9PSBUZXh0dXJlLldSQVBfTUlSUk9SRURfUkVQRUFUKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9jZ2wuZ2wuTUlSUk9SRURfUkVQRUFUKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX2NnbC5nbC5NSVJST1JFRF9SRVBFQVQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyID09IFRleHR1cmUuRklMVEVSX05FQVJFU1QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fY2dsLmdsLk5FQVJFU1QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmlsdGVyID09IFRleHR1cmUuRklMVEVSX0xJTkVBUilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX2NnbC5nbC5MSU5FQVIpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX2NnbC5nbC5MSU5FQVIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmlsdGVyID09IFRleHR1cmUuRklMVEVSX01JUE1BUClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX2NnbC5nbC5MSU5FQVIpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX2NnbC5nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cubG9nKFwidW5rbm93biB0ZXh0dXJlIGZpbHRlciFcIiwgdGhpcy5maWx0ZXIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0ZXh0dXJlIGZpbHRlciFcIiArIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuaXNvdHJvcGljKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSB0aGlzLl9jZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpO1xuXG5cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NnbC5tYXhBbmlzb3Ryb3BpYylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmlzbyA9IE1hdGgubWluKHRoaXMuX2NnbC5tYXhBbmlzb3Ryb3BpYywgdGhpcy5hbmlzb3Ryb3BpYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmYodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgYW5pc28pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ2V0SW5mb09uZUxpbmUoKTtcbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcIl9zZXRGaWx0ZXJcIik7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGxvYWRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAZGVzY3JpcHRpb24gbG9hZCBhbiBpbWFnZSBmcm9tIGFuIHVybFxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRmluaXNoZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmxvYWQgPSBmdW5jdGlvbiAoY2dsLCB1cmwsIGZpbmlzaGVkQ2FsbGJhY2ssIHNldHRpbmdzKVxue1xuICAgIGlmICghdXJsKSByZXR1cm4gZmluaXNoZWRDYWxsYmFjayh7IFwiZXJyb3JcIjogdHJ1ZSB9KTtcbiAgICBsZXQgbG9hZGluZ0lkID0gbnVsbDtcbiAgICBpZiAoIWNnbC5wYXRjaC5sb2FkaW5nLmV4aXN0QnlOYW1lKHVybCkpIGxvYWRpbmdJZCA9IGNnbC5wYXRjaC5sb2FkaW5nLnN0YXJ0KFwidGV4dHVyZVwiLCB1cmwpO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGNnbCk7XG4gICAgdGV4dHVyZS5uYW1lID0gdXJsO1xuXG4gICAgLy8gdGV4dHVyZS5waXhlbEZvcm1hdCA9IFRleHR1cmUuUEZPUk1BVFNUUl87XG5cbiAgICBpZiAoY2dsLnBhdGNoLmlzRWRpdG9yTW9kZSgpKSBndWkuam9icygpLnN0YXJ0KHsgXCJpZFwiOiBcImxvYWR0ZXh0dXJlXCIgKyBsb2FkaW5nSWQsIFwidGl0bGVcIjogXCJsb2FkaW5nIHRleHR1cmUgXCIgKyBDQUJMRVMuYmFzZW5hbWUodXJsKSB9KTtcblxuICAgIHRleHR1cmUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0ZXh0dXJlLmltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICB0ZXh0dXJlLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLmhhc093blByb3BlcnR5KFwiZmlsdGVyXCIpKSB0ZXh0dXJlLmZpbHRlciA9IHNldHRpbmdzLmZpbHRlcjtcbiAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoXCJmbGlwXCIpKSB0ZXh0dXJlLmZsaXAgPSBzZXR0aW5ncy5mbGlwO1xuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShcIndyYXBcIikpIHRleHR1cmUud3JhcCA9IHNldHRpbmdzLndyYXA7XG4gICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLmhhc093blByb3BlcnR5KFwiYW5pc290cm9waWNcIikpIHRleHR1cmUuYW5pc290cm9waWMgPSBzZXR0aW5ncy5hbmlzb3Ryb3BpYztcbiAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoXCJ1bnBhY2tBbHBoYVwiKSkgdGV4dHVyZS51bnBhY2tBbHBoYSA9IHNldHRpbmdzLnVucGFja0FscGhhO1xuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShcInBpeGVsRm9ybWF0XCIpKSB0ZXh0dXJlLnBpeGVsRm9ybWF0ID0gc2V0dGluZ3MucGl4ZWxGb3JtYXQ7XG5cbiAgICB0ZXh0dXJlLmltYWdlLm9uYWJvcnQgPSB0ZXh0dXJlLmltYWdlLm9uZXJyb3IgPSAoZSkgPT5cbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltjZ2wudGV4dHVyZS5sb2FkXSBlcnJvciBsb2FkaW5nIHRleHR1cmVcIiwgdXJsLCBlKTtcbiAgICAgICAgdGV4dHVyZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2FkaW5nSWQpIGNnbC5wYXRjaC5sb2FkaW5nLmZpbmlzaGVkKGxvYWRpbmdJZCk7XG4gICAgICAgIGNvbnN0IGVycm9yID0geyBcImVycm9yXCI6IHRydWUgfTtcbiAgICAgICAgaWYgKGZpbmlzaGVkQ2FsbGJhY2spIGZpbmlzaGVkQ2FsbGJhY2soZXJyb3IsIHRleHR1cmUpO1xuICAgICAgICBpZiAoY2dsLnBhdGNoLmlzRWRpdG9yTW9kZSgpKSBndWkuam9icygpLmZpbmlzaChcImxvYWR0ZXh0dXJlXCIgKyBsb2FkaW5nSWQpO1xuICAgIH07XG5cbiAgICB0ZXh0dXJlLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uIChlKVxuICAgIHtcbiAgICAgICAgY2dsLmFkZE5leHRGcmFtZU9uY2VDYWxsYmFjaygoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0dXJlLmluaXRUZXh0dXJlKHRleHR1cmUuaW1hZ2UpO1xuICAgICAgICAgICAgaWYgKGxvYWRpbmdJZCkgY2dsLnBhdGNoLmxvYWRpbmcuZmluaXNoZWQobG9hZGluZ0lkKTtcbiAgICAgICAgICAgIHRleHR1cmUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNnbC5wYXRjaC5pc0VkaXRvck1vZGUoKSkgZ3VpLmpvYnMoKS5maW5pc2goXCJsb2FkdGV4dHVyZVwiICsgbG9hZGluZ0lkKTtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkQ2FsbGJhY2spIGZpbmlzaGVkQ2FsbGJhY2sobnVsbCwgdGV4dHVyZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGV4dHVyZS5pbWFnZS5zcmMgPSB1cmw7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGdldFRlbXBUZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgdGhlIGRlZmF1bHQgdGVtcG9yYXJ5IHRleHR1cmUgKGdyZXkgZGlhZ29uYWwgc3RpcGVzKVxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEByZXR1cm4ge1RleHR1cmV9XG4gKi9cblRleHR1cmUuZ2V0VGVtcFRleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSBjb25zb2xlLmVycm9yKFwiW2dldFRlbXBUZXh0dXJlXSBubyBjZ2whXCIpO1xuICAgIGlmICghY2dsLnRlbXBUZXh0dXJlKSBjZ2wudGVtcFRleHR1cmUgPSBUZXh0dXJlLmdldFRlbXBvcmFyeVRleHR1cmUoY2dsLCAyNTYsIFRleHR1cmUuRklMVEVSX0xJTkVBUiwgVGV4dHVyZS5SRVBFQVQpO1xuICAgIHJldHVybiBjZ2wudGVtcFRleHR1cmU7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBnZXRFcnJvclRleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyB0aGUgZGVmYXVsdCB0ZW1wb3JhcnkgdGV4dHVyZSAoZ3JleSBkaWFnb25hbCBzdGlwZXMpXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNnbFxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRFcnJvclRleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSBjb25zb2xlLmVycm9yKFwiW2dldFRlbXBUZXh0dXJlXSBubyBjZ2whXCIpO1xuICAgIGlmICghY2dsLmVycm9yVGV4dHVyZSkgY2dsLmVycm9yVGV4dHVyZSA9IFRleHR1cmUuZ2V0VGVtcG9yYXJ5VGV4dHVyZShjZ2wsIDI1NiwgVGV4dHVyZS5GSUxURVJfTElORUFSLCBUZXh0dXJlLlJFUEVBVCwgMSwgMC4yLCAwLjIpO1xuICAgIHJldHVybiBjZ2wuZXJyb3JUZXh0dXJlO1xufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRFbXB0eVRleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGEgc21hbGwgZW1wdHkgKHRyYW5zcGFyZW50KSB0ZXh0dXJlXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmdldEVtcHR5VGV4dHVyZSA9IGZ1bmN0aW9uIChjZ2wsIGZwKVxue1xuICAgIGlmIChmcCkgcmV0dXJuIFRleHR1cmUuZ2V0RW1wdHlUZXh0dXJlRmxvYXQoY2dsKTtcbiAgICBpZiAoIWNnbCkgY29uc29sZS5lcnJvcihcIltnZXRFbXB0eVRleHR1cmVdIG5vIGNnbCFcIik7XG4gICAgaWYgKGNnbC50ZW1wVGV4dHVyZUVtcHR5KSByZXR1cm4gY2dsLnRlbXBUZXh0dXJlRW1wdHk7XG5cbiAgICBjZ2wudGVtcFRleHR1cmVFbXB0eSA9IG5ldyBUZXh0dXJlKGNnbCwgeyBcIm5hbWVcIjogXCJlbXB0eVRleHR1cmVcIiB9KTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoOCAqIDggKiA0KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOCAqIDggKiA0OyBpICs9IDQpIGRhdGFbaSArIDNdID0gMDtcblxuICAgIGNnbC50ZW1wVGV4dHVyZUVtcHR5LmluaXRGcm9tRGF0YShkYXRhLCA4LCA4LCBUZXh0dXJlLkZJTFRFUl9ORUFSRVNULCBUZXh0dXJlLldSQVBfUkVQRUFUKTtcblxuICAgIHJldHVybiBjZ2wudGVtcFRleHR1cmVFbXB0eTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEVtcHR5VGV4dHVyZUZsb2F0XG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNtYWxsIGVtcHR5ICh0cmFuc3BhcmVudCkgMzJiaXQgdGV4dHVyZVxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRFbXB0eVRleHR1cmVGbG9hdCA9IGZ1bmN0aW9uIChjZ2wpXG57XG4gICAgaWYgKCFjZ2wpIGNvbnNvbGUuZXJyb3IoXCJbZ2V0RW1wdHlUZXh0dXJlRmxvYXRdIG5vIGNnbCFcIik7XG4gICAgaWYgKGNnbC50ZW1wVGV4dHVyZUVtcHR5RmxvYXQpIHJldHVybiBjZ2wudGVtcFRleHR1cmVFbXB0eUZsb2F0O1xuXG4gICAgY2dsLnRlbXBUZXh0dXJlRW1wdHlGbG9hdCA9IG5ldyBUZXh0dXJlKGNnbCwgeyBcIm5hbWVcIjogXCJlbXB0eVRleHR1cmVcIiwgXCJpc0Zsb2F0aW5nUG9pbnRUZXh0dXJlXCI6IHRydWUgfSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCAqIDggKiA0KS5maWxsKDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOCAqIDggKiA0OyBpICs9IDQpIGRhdGFbaSArIDNdID0gMDtcblxuICAgIGNnbC50ZW1wVGV4dHVyZUVtcHR5RmxvYXQuaW5pdEZyb21EYXRhKGRhdGEsIDgsIDgsIFRleHR1cmUuRklMVEVSX05FQVJFU1QsIFRleHR1cmUuV1JBUF9SRVBFQVQpO1xuXG4gICAgcmV0dXJuIGNnbC50ZW1wVGV4dHVyZUVtcHR5RmxvYXQ7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldFJhbmRvbVRleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAc3RhdGljXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHJhbmRvbSB0ZXh0dXJlXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmdldFJhbmRvbVRleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSBjb25zb2xlLmVycm9yKFwiW2dldFJhbmRvbVRleHR1cmVdIG5vIGNnbCFcIik7XG4gICAgaWYgKGNnbC5yYW5kb21UZXh0dXJlKSByZXR1cm4gY2dsLnJhbmRvbVRleHR1cmU7XG5cbiAgICBjb25zdCBzaXplID0gMjU2O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDQpO1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplICogc2l6ZTsgeCsrKVxuICAgIHtcbiAgICAgICAgZGF0YVt4ICogNCArIDBdID0gTWF0aC5yYW5kb20oKSAqIDI1NTtcbiAgICAgICAgZGF0YVt4ICogNCArIDFdID0gTWF0aC5yYW5kb20oKSAqIDI1NTtcbiAgICAgICAgZGF0YVt4ICogNCArIDJdID0gTWF0aC5yYW5kb20oKSAqIDI1NTtcbiAgICAgICAgZGF0YVt4ICogNCArIDNdID0gMjU1O1xuICAgIH1cblxuICAgIGNnbC5yYW5kb21UZXh0dXJlID0gbmV3IFRleHR1cmUoY2dsKTtcbiAgICBjZ2wucmFuZG9tVGV4dHVyZS5pbml0RnJvbURhdGEoZGF0YSwgc2l6ZSwgc2l6ZSwgVGV4dHVyZS5GSUxURVJfTkVBUkVTVCwgVGV4dHVyZS5XUkFQX1JFUEVBVCk7XG5cbiAgICByZXR1cm4gY2dsLnJhbmRvbVRleHR1cmU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRSYW5kb21GbG9hdFRleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAc3RhdGljXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHRleHR1cmUgY29udGFpbmluZyByYW5kb20gbnVtYmVycyBiZXR3ZWVuIC0xIGFuZCAxXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmdldFJhbmRvbUZsb2F0VGV4dHVyZSA9IGZ1bmN0aW9uIChjZ2wpXG57XG4gICAgaWYgKCFjZ2wpIGNvbnNvbGUuZXJyb3IoXCJbZ2V0UmFuZG9tVGV4dHVyZV0gbm8gY2dsIVwiKTtcbiAgICBpZiAoY2dsLmdldFJhbmRvbUZsb2F0VGV4dHVyZSkgcmV0dXJuIGNnbC5nZXRSYW5kb21GbG9hdFRleHR1cmU7XG5cbiAgICBjb25zdCBzaXplID0gMjU2O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBzaXplICogNCk7XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemUgKiBzaXplOyB4KyspXG4gICAge1xuICAgICAgICBkYXRhW3ggKiA0ICsgMF0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjA7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAxXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMDtcbiAgICAgICAgZGF0YVt4ICogNCArIDJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wO1xuICAgICAgICBkYXRhW3ggKiA0ICsgM10gPSAxO1xuICAgIH1cblxuICAgIGNnbC5nZXRSYW5kb21GbG9hdFRleHR1cmUgPSBuZXcgVGV4dHVyZShjZ2wsIHsgXCJpc0Zsb2F0aW5nUG9pbnRUZXh0dXJlXCI6IHRydWUgfSk7XG4gICAgY2dsLmdldFJhbmRvbUZsb2F0VGV4dHVyZS5pbml0RnJvbURhdGEoZGF0YSwgc2l6ZSwgc2l6ZSwgVGV4dHVyZS5GSUxURVJfTkVBUkVTVCwgVGV4dHVyZS5XUkFQX1JFUEVBVCk7XG5cbiAgICByZXR1cm4gY2dsLmdldFJhbmRvbUZsb2F0VGV4dHVyZTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEJsYWNrVGV4dHVyZVxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBzdGF0aWNcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGEgYmxhY2sgdGV4dHVyZVxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRCbGFja1RleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSB0aGlzLl9sb2cuZXJyb3IoXCJbZ2V0QmxhY2tUZXh0dXJlXSBubyBjZ2whXCIpO1xuICAgIGlmIChjZ2wuYmxhY2tUZXh0dXJlKSByZXR1cm4gY2dsLmJsYWNrVGV4dHVyZTtcblxuICAgIGNvbnN0IHNpemUgPSA4O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDQpO1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplICogc2l6ZTsgeCsrKVxuICAgIHtcbiAgICAgICAgZGF0YVt4ICogNCArIDBdID0gZGF0YVt4ICogNCArIDFdID0gZGF0YVt4ICogNCArIDJdID0gMDtcbiAgICAgICAgZGF0YVt4ICogNCArIDNdID0gMjU1O1xuICAgIH1cblxuICAgIGNnbC5ibGFja1RleHR1cmUgPSBuZXcgVGV4dHVyZShjZ2wpO1xuICAgIGNnbC5ibGFja1RleHR1cmUuaW5pdEZyb21EYXRhKGRhdGEsIHNpemUsIHNpemUsIFRleHR1cmUuRklMVEVSX05FQVJFU1QsIFRleHR1cmUuV1JBUF9SRVBFQVQpO1xuXG4gICAgcmV0dXJuIGNnbC5ibGFja1RleHR1cmU7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEVtcHR5Q3ViZW1hcFRleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAc3RhdGljXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhbiBlbXB0eSBjdWJlbWFwIHRleHR1cmUgd2l0aCByZ2JhID0gWzAsIDAsIDAsIDBdXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmdldEVtcHR5Q3ViZW1hcFRleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGNvbnN0IGZhY2VzID0gW1xuICAgICAgICBjZ2wuZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLFxuICAgICAgICBjZ2wuZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLFxuICAgICAgICBjZ2wuZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLFxuICAgICAgICBjZ2wuZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLFxuICAgICAgICBjZ2wuZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLFxuICAgICAgICBjZ2wuZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXG4gICAgXTtcblxuICAgIGNvbnN0IHRleCA9IGNnbC5nbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVA7XG4gICAgY29uc3QgZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTkVBUkVTVDtcbiAgICBjb25zdCB3cmFwID0gVGV4dHVyZS5XUkFQX0NMQU1QX1RPX0VER0U7XG4gICAgY29uc3Qgd2lkdGggPSA4O1xuICAgIGNvbnN0IGhlaWdodCA9IDg7XG5cbiAgICBjZ2wucHJvZmlsZURhdGEucHJvZmlsZVRleHR1cmVOZXcrKztcblxuXG4gICAgY2dsLmdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgICBjZ2wucHJvZmlsZURhdGEucHJvZmlsZVRleHR1cmVSZXNpemUrKztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSArPSAxKVxuICAgIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDggKiA4ICogNCk7XG5cbiAgICAgICAgY2dsLmdsLnRleEltYWdlMkQoZmFjZXNbaV0sIDAsIGNnbC5nbC5SR0JBLCA4LCA4LCAwLCBjZ2wuZ2wuUkdCQSwgY2dsLmdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICAgICAgICBjZ2wuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIGNnbC5nbC5URVhUVVJFX01BR19GSUxURVIsIGNnbC5nbC5ORUFSRVNUKTtcbiAgICAgICAgY2dsLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBjZ2wuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBjZ2wuZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgY2dsLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBjZ2wuZ2wuVEVYVFVSRV9XUkFQX1MsIGNnbC5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgY2dsLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBjZ2wuZ2wuVEVYVFVSRV9XUkFQX1QsIGNnbC5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB9XG5cblxuICAgIGNnbC5nbC5iaW5kVGV4dHVyZSh0YXJnZXQsIG51bGwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJpZFwiOiBDQUJMRVMudXVpZCgpLFxuICAgICAgICBcInRleFwiOiB0ZXgsXG4gICAgICAgIFwiY3ViZW1hcFwiOiB0ZXgsXG4gICAgICAgIFwid2lkdGhcIjogd2lkdGgsXG4gICAgICAgIFwiaGVpZ2h0XCI6IGhlaWdodCxcbiAgICAgICAgXCJmaWx0ZXJcIjogZmlsdGVyLFxuICAgICAgICBcIndyYXBcIjogd3JhcCxcbiAgICAgICAgXCJ1bnBhY2tBbHBoYVwiOiB0cnVlLFxuICAgICAgICBcImZsaXBcIjogdHJ1ZSxcbiAgICAgICAgXCJfZnJvbURhdGFcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiZW1wdHlDdWJlbWFwVGV4dHVyZVwiLFxuICAgICAgICBcImFuaXNvdHJvcGljXCI6IDAsXG4gICAgfTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGdldFRlbXBHcmFkaWVudFRleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhIGdyYWRpZW50IHRleHR1cmUgZnJvbSBibGFjayB0byB3aGl0ZVxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEByZXR1cm4ge1RleHR1cmV9XG4gKi9cblRleHR1cmUuZ2V0VGVtcEdyYWRpZW50VGV4dHVyZSA9IGZ1bmN0aW9uIChjZ2wpXG57XG4gICAgaWYgKCFjZ2wpIGNvbnNvbGUuZXJyb3IoXCJbZ2V0VGVtcEdyYWRpZW50VGV4dHVyZV0gbm8gY2dsIVwiKTtcblxuICAgIGlmIChjZ2wudGVtcFRleHR1cmVHcmFkaWVudCkgcmV0dXJuIGNnbC50ZW1wVGV4dHVyZUdyYWRpZW50O1xuICAgIGNvbnN0IHRlbXB0ZXggPSBuZXcgVGV4dHVyZShjZ2wpO1xuICAgIGNvbnN0IHNpemUgPSAyNTY7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNpemUgKiBzaXplICogNCk7IC8vIC5maWxsKDApO1xuXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyB5KyspXG4gICAge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7IHgrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YVsoeCArIHkgKiBzaXplKSAqIDQgKyAwXSA9IGRhdGFbKHggKyB5ICogc2l6ZSkgKiA0ICsgMV0gPSBkYXRhWyh4ICsgeSAqIHNpemUpICogNCArIDJdID0gMjU1IC0geTtcbiAgICAgICAgICAgIGRhdGFbKHggKyB5ICogc2l6ZSkgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZW1wdGV4LmluaXRGcm9tRGF0YShkYXRhLCBzaXplLCBzaXplLCBUZXh0dXJlLkZJTFRFUl9ORUFSRVNULCBUZXh0dXJlLldSQVBfUkVQRUFUKTtcbiAgICBjZ2wudGVtcFRleHR1cmVHcmFkaWVudCA9IHRlbXB0ZXg7XG4gICAgcmV0dXJuIHRlbXB0ZXg7XG59O1xuXG5UZXh0dXJlLmdldFRlbXBvcmFyeVRleHR1cmUgPSBmdW5jdGlvbiAoY2dsLCBzaXplLCBmaWx0ZXIsIHdyYXAsIHIsIGcsIGIpXG57XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZClyID0gMTtcbiAgICBpZiAoZyA9PT0gdW5kZWZpbmVkKWcgPSAxO1xuICAgIGlmIChiID09PSB1bmRlZmluZWQpYiA9IDE7XG4gICAgY29uc3QgdGVtcHRleCA9IG5ldyBUZXh0dXJlKGNnbCk7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyB5KyspXG4gICAge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7IHgrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCh4ICsgeSkgJSA2NCA8IDMyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCgyMDAgKyAoeSAvIHNpemUpICogMjUgKyAoeCAvIHNpemUpICogMjUpICogcik7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goKDIwMCArICh5IC8gc2l6ZSkgKiAyNSArICh4IC8gc2l6ZSkgKiAyNSkgKiBnKTtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgoMjAwICsgKHkgLyBzaXplKSAqIDI1ICsgKHggLyBzaXplKSAqIDI1KSAqIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCg0MCArICh5IC8gc2l6ZSkgKiAyNSArICh4IC8gc2l6ZSkgKiAyNSkgKiByKTtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgoNDAgKyAoeSAvIHNpemUpICogMjUgKyAoeCAvIHNpemUpICogMjUpICogZyk7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goKDQwICsgKHkgLyBzaXplKSAqIDI1ICsgKHggLyBzaXplKSAqIDI1KSAqIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyLnB1c2goMjU1KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShhcnIpO1xuICAgIHRlbXB0ZXguaW5pdEZyb21EYXRhKGRhdGEsIHNpemUsIHNpemUsIGZpbHRlciwgd3JhcCk7XG5cbiAgICByZXR1cm4gdGVtcHRleDtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGNyZWF0ZUZyb21JbWFnZVxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBkZXNjcmlwdGlvbiBjcmVhdGUgdGV4dHVyZW0gZnJvbSBpbWFnZSBkYXRhIChlLmcuIGltYWdlIG9yIGNhbnZhcylcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2dsXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblRleHR1cmUuY3JlYXRlRnJvbUltYWdlID0gZnVuY3Rpb24gKGNnbCwgaW1nLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShjZ2wsIG9wdGlvbnMpO1xuICAgIHRleHR1cmUuZmxpcCA9IGZhbHNlO1xuICAgIHRleHR1cmUuaW1hZ2UgPSBpbWc7XG4gICAgdGV4dHVyZS53aWR0aCA9IGltZy53aWR0aDtcbiAgICB0ZXh0dXJlLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJ3cmFwXCIpKXRleHR1cmUud3JhcCA9IG9wdGlvbnMud3JhcDtcbiAgICB0ZXh0dXJlLmluaXRUZXh0dXJlKGltZywgb3B0aW9ucy5maWx0ZXIpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vLyBkZXByZWNhdGVkIVxuVGV4dHVyZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbiAoY2dsLCBpbWcsIGZpbHRlciwgd3JhcClcbntcbiAgICBjb25zb2xlLmVycm9yKFwiZGVwcmVjYXRlZCB0ZXh0dXJlIGZyb20gaW1hZ2UuLi5cIik7XG5cbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoY2dsKTtcbiAgICB0ZXh0dXJlLmZsaXAgPSBmYWxzZTtcbiAgICBpZiAoZmlsdGVyKSB0ZXh0dXJlLmZpbHRlciA9IGZpbHRlcjtcbiAgICBpZiAod3JhcCkgdGV4dHVyZS53cmFwID0gd3JhcDtcbiAgICB0ZXh0dXJlLmltYWdlID0gaW1nO1xuICAgIHRleHR1cmUuaW5pdFRleHR1cmUoaW1nKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGlzUG93ZXJPZlR3b1xuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHRydWUgaWYgeCBpcyBwb3dlciBvZiB0d29cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5UZXh0dXJlLmlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh4KVxue1xuICAgIHJldHVybiB4ID09IDEgfHwgeCA9PSAyIHx8IHggPT0gNCB8fCB4ID09IDggfHwgeCA9PSAxNiB8fCB4ID09IDMyIHx8IHggPT0gNjQgfHwgeCA9PSAxMjggfHwgeCA9PSAyNTYgfHwgeCA9PSA1MTIgfHwgeCA9PSAxMDI0IHx8IHggPT0gMjA0OCB8fCB4ID09IDQwOTYgfHwgeCA9PSA4MTkyIHx8IHggPT0gMTYzODQ7XG59O1xuXG5UZXh0dXJlLmdldFRleEluZm8gPSBmdW5jdGlvbiAodGV4KVxue1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgb2JqLm5hbWUgPSB0ZXgubmFtZTtcbiAgICBvYmpbXCJwb3dlciBvZiB0d29cIl0gPSB0ZXguaXNQb3dlck9mVHdvKCk7XG4gICAgb2JqLnNpemUgPSB0ZXgud2lkdGggKyBcIiB4IFwiICsgdGV4LmhlaWdodDtcblxuICAgIGxldCB0YXJnZXRTdHJpbmcgPSB0ZXgudGV4VGFyZ2V0O1xuICAgIGlmICh0ZXgudGV4VGFyZ2V0ID09IHRleC5fY2dsLmdsLlRFWFRVUkVfMkQpIHRhcmdldFN0cmluZyA9IFwiVEVYVFVSRV8yRFwiO1xuICAgIG9iai50YXJnZXQgPSB0YXJnZXRTdHJpbmc7XG5cbiAgICBvYmoudW5wYWNrQWxwaGEgPSB0ZXgudW5wYWNrQWxwaGE7XG5cbiAgICBpZiAodGV4LmN1YmVtYXApb2JqLmN1YmVtYXAgPSB0cnVlO1xuXG4gICAgaWYgKHRleC50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfRkxPQVQpIG9iai50ZXh0dXJlVHlwZSA9IFwiVFlQRV9GTE9BVFwiO1xuICAgIGlmICh0ZXgudGV4dHVyZVR5cGUgPT0gVGV4dHVyZS5UWVBFX0hBTEZfRkxPQVQpIG9iai50ZXh0dXJlVHlwZSA9IFwiVFlQRV9IQUxGX0ZMT0FUXCI7XG4gICAgZWxzZSBpZiAodGV4LnRleHR1cmVUeXBlID09IFRleHR1cmUuVFlQRV9ERVBUSCkgb2JqLnRleHR1cmVUeXBlID0gXCJUWVBFX0RFUFRIXCI7XG4gICAgZWxzZSBpZiAodGV4LnRleHR1cmVUeXBlID09IFRleHR1cmUuVFlQRV9ERUZBVUxUKSBvYmoudGV4dHVyZVR5cGUgPSBcIlRZUEVfREVGQVVMVFwiO1xuICAgIGVsc2Ugb2JqLnRleHR1cmVUeXBlID0gXCJVTktOT1dOIFwiICsgdGhpcy50ZXh0dXJlVHlwZTtcblxuICAgIGlmICh0ZXgud3JhcCA9PSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRSkgb2JqLndyYXAgPSBcIkNMQU1QX1RPX0VER0VcIjtcbiAgICBlbHNlIGlmICh0ZXgud3JhcCA9PSBUZXh0dXJlLldSQVBfUkVQRUFUKSBvYmoud3JhcCA9IFwiV1JBUF9SRVBFQVRcIjtcbiAgICBlbHNlIGlmICh0ZXgud3JhcCA9PSBUZXh0dXJlLldSQVBfTUlSUk9SRURfUkVQRUFUKSBvYmoud3JhcCA9IFwiV1JBUF9NSVJST1JFRF9SRVBFQVRcIjtcbiAgICBlbHNlIG9iai53cmFwID0gXCJVTktOT1dOXCI7XG5cbiAgICBpZiAodGV4LmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUKSBvYmouZmlsdGVyID0gXCJGSUxURVJfTkVBUkVTVFwiO1xuICAgIGVsc2UgaWYgKHRleC5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTElORUFSKSBvYmouZmlsdGVyID0gXCJGSUxURVJfTElORUFSXCI7XG4gICAgZWxzZSBpZiAodGV4LmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApIG9iai5maWx0ZXIgPSBcIkZJTFRFUl9NSVBNQVBcIjtcbiAgICBlbHNlIG9iai5maWx0ZXIgPSBcIlVOS05PV05cIjtcblxuICAgIG9iai5waXhlbEZvcm1hdCA9IHRleC5waXhlbEZvcm1hdCB8fCBcInVua25vd25cIjtcblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cblRleHR1cmUuRklMVEVSX05FQVJFU1QgPSAwO1xuVGV4dHVyZS5GSUxURVJfTElORUFSID0gMTtcblRleHR1cmUuRklMVEVSX01JUE1BUCA9IDI7XG5cblRleHR1cmUuV1JBUF9SRVBFQVQgPSAwO1xuVGV4dHVyZS5XUkFQX01JUlJPUkVEX1JFUEVBVCA9IDE7XG5UZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRSA9IDI7XG5cblRleHR1cmUuVFlQRV9ERUZBVUxUID0gMDtcblRleHR1cmUuVFlQRV9ERVBUSCA9IDE7XG5UZXh0dXJlLlRZUEVfRkxPQVQgPSAyO1xuXG5cblRleHR1cmUuUEZPUk1BVFNUUl9SR0I1NjUgPSBcIlJHQiA1LzYvNWJpdCB1Ynl0ZVwiO1xuXG5UZXh0dXJlLlBGT1JNQVRTVFJfUjhVQiA9IFwiUiA4Yml0IHVieXRlXCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkc4VUIgPSBcIlJHIDhiaXQgdWJ5dGVcIjtcblRleHR1cmUuUEZPUk1BVFNUUl9SR0I4VUIgPSBcIlJHQiA4Yml0IHVieXRlXCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkdCQThVQiA9IFwiUkdCQSA4Yml0IHVieXRlXCI7XG5cblRleHR1cmUuUEZPUk1BVFNUUl9TUkdCQTggPSBcIlNSR0JBIDhiaXQgdWJ5dGVcIjtcblxuVGV4dHVyZS5QRk9STUFUU1RSX1IxMUZHMTFGQjEwRiA9IFwiUkdCIDExLzExLzEwYml0IGZsb2F0XCI7XG5cblRleHR1cmUuUEZPUk1BVFNUUl9SMTZGID0gXCJSIDE2Yml0IGZsb2F0XCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkcxNkYgPSBcIlJHIDE2Yml0IGZsb2F0XCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkdCMTZGID0gXCJSR0IgMTZiaXQgZmxvYXRcIjtcblRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMTZGID0gXCJSR0JBIDE2Yml0IGZsb2F0XCI7XG5cblxuVGV4dHVyZS5QRk9STUFUU1RSX1IzMkYgPSBcIlIgMzJiaXQgZmxvYXRcIjtcblRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGID0gXCJSR0JBIDMyYml0IGZsb2F0XCI7XG5cblRleHR1cmUuUEZPUk1BVFNUUl9ERVBUSCA9IFwiREVQVEhcIjtcblxuXG5UZXh0dXJlLlBJWEVMRk9STUFUUyA9IFtcblxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SR0I1NjUsXG5cbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUjhVQixcbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUkc4VUIsXG4gICAgVGV4dHVyZS5QRk9STUFUU1RSX1JHQjhVQixcbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQThVQixcblxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9TUkdCQTgsXG5cbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGLFxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SMTZGLFxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SRzE2RixcbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQTE2RixcblxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SMzJGLFxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGXG5cbl07XG5cblRleHR1cmUuaXNQaXhlbEZvcm1hdEZsb2F0ID1cbiAgICAocHhsZnJtdCkgPT5cbiAgICB7XG4gICAgICAgIHJldHVybiAocHhsZnJtdCB8fCBcIlwiKS5pbmRleE9mKFwiZmxvYXRcIikgPiAtMTtcbiAgICB9O1xuXG5UZXh0dXJlLmlzUGl4ZWxGb3JtYXRIYWxmRmxvYXQgPVxuICAgIChweGxmcm10KSA9PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIChweGxmcm10IHx8IFwiXCIpLmluZGV4T2YoXCJmbG9hdFwiKSA+IC0xICYmIChweGxmcm10IHx8IFwiXCIpLmluZGV4T2YoXCIxNmJpdFwiKSA+IC0xO1xuICAgIH07XG5cblxuXG5cbmV4cG9ydCB7IFRleHR1cmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_texture.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_textureeffect.js":
/*!*******************************************!*\
  !*** ./src/core/cgl/cgl_textureeffect.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureEffect\": () => (/* binding */ TextureEffect)\n/* harmony export */ });\n/* harmony import */ var _cgl_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_texture */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _cgl_simplerect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_simplerect */ \"./src/core/cgl/cgl_simplerect.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n\n\n\n\nconst TextureEffect = function (cgl, options)\n{\n    this._cgl = cgl;\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\"cgl_TextureEffect\");\n\n    if (!cgl.TextureEffectMesh) this.createMesh();\n\n    this._textureSource = null;\n    this._options = options;\n\n    // TODO: do we still need the options ?\n    // var opts=options ||\n    //     {\n    //         isFloatingPointTexture:false,\n    //         filter:CGL.Texture.FILTER_LINEAR\n    //     };\n    // if(options && options.fp)opts.isFloatingPointTexture=true;\n\n    this.imgCompVer = 0;\n    this.aspectRatio = 1;\n    this._textureTarget = null; // new CGL.Texture(this._cgl,opts);\n    this._frameBuf = this._cgl.gl.createFramebuffer();\n    this._frameBuf2 = this._cgl.gl.createFramebuffer();\n    this._renderbuffer = this._cgl.gl.createRenderbuffer();\n    this._renderbuffer2 = this._cgl.gl.createRenderbuffer();\n    this.switched = false;\n    this.depth = false;\n};\n\nTextureEffect.prototype.dispose = function ()\n{\n    if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);\n    if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);\n    if (this._renderbuffer2) this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);\n    if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);\n};\n\nTextureEffect.prototype.getWidth = function ()\n{\n    return this._textureSource.width;\n};\n\nTextureEffect.prototype.getHeight = function ()\n{\n    return this._textureSource.height;\n};\n\nTextureEffect.prototype.setSourceTexture = function (tex)\n{\n    // if (tex.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F) this._cgl.gl.getExtension(\"EXT_color_buffer_float\");\n    // if (tex.pixelFormat == Texture.PFORMATSTR_RGBA32F) this._cgl.gl.getExtension(\"EXT_color_buffer_float\");\n    // if (tex.pixelFormat == Texture.PFORMATSTR_RGBA16F) this._cgl.gl.getExtension(\"EXT_color_buffer_half_float\");\n\n    if (tex === null)\n    {\n        this._textureSource = new _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture(this._cgl);\n        this._textureSource.setSize(16, 16);\n    }\n    else\n    {\n        this._textureSource = tex;\n    }\n\n\n    if (!this._textureSource.compareSettings(this._textureTarget))\n    {\n        if (this._textureTarget) this._textureTarget.delete();\n\n        this._textureTarget = this._textureSource.clone();\n\n        this._cgl.profileData.profileEffectBuffercreate++;\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);\n\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer);\n\n        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);\n        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);\n\n        if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);\n        if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer);\n\n        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);\n\n        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);\n\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2);\n\n        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);\n        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);\n\n        if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);\n\n        if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2);\n\n        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);\n\n        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n    }\n\n    this.aspectRatio = this._textureSource.width / this._textureSource.height;\n};\nTextureEffect.prototype.continueEffect = function ()\n{\n    this._cgl.pushDepthTest(false);\n\n    this._cgl.pushModelMatrix();\n\n    this._cgl.pushPMatrix();\n\n    this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);\n    // this._cgl.gl.viewport(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);\n    mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, 0.1, 1100.0);\n\n    this._cgl.pushPMatrix();\n    mat4.identity(this._cgl.pMatrix);\n\n    this._cgl.pushViewMatrix();\n    mat4.identity(this._cgl.vMatrix);\n\n    this._cgl.pushModelMatrix();\n    mat4.identity(this._cgl.mMatrix);\n};\n\n\nTextureEffect.prototype.startEffect = function (bgTex)\n{\n    if (!this._textureTarget)\n    {\n        this._log.warn(\"effect has no target\");\n        return;\n    }\n\n    this.switched = false;\n\n    this.continueEffect();\n\n    if (bgTex)\n    {\n        this._bgTex = bgTex;\n    }\n    this._countEffects = 0;\n};\n\nTextureEffect.prototype.endEffect = function ()\n{\n    this._cgl.popDepthTest();\n    this._cgl.popModelMatrix();\n\n    this._cgl.popPMatrix();\n    this._cgl.popModelMatrix();\n    this._cgl.popViewMatrix();\n\n    this._cgl.popPMatrix();\n    this._cgl.popViewPort();\n};\n\nTextureEffect.prototype.bind = function ()\n{\n    if (this._textureSource === null)\n    {\n        this._log.warn(\"no base texture set!\");\n        return;\n    }\n\n    if (!this.switched)\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);\n        this._cgl.pushGlFrameBuffer(this._frameBuf);\n    }\n    else\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);\n        this._cgl.pushGlFrameBuffer(this._frameBuf2);\n    }\n};\n\nTextureEffect.prototype.finish = function ()\n{\n    if (this._textureSource === null)\n    {\n        this._log.warn(\"no base texture set!\");\n        return;\n    }\n\n    this._cgl.TextureEffectMesh.render(this._cgl.getShader());\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());\n\n    this._cgl.profileData.profileTextureEffect++;\n\n    // this._textureTarget.updateMipMap();\n\n    if (this._textureTarget.filter == _cgl_texture__WEBPACK_IMPORTED_MODULE_0__.Texture.FILTER_MIPMAP)\n    {\n        if (!this.switched)\n        {\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex);\n            this._textureTarget.updateMipMap();\n        }\n        else\n        {\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex);\n            this._textureSource.updateMipMap();\n        }\n\n        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n    }\n\n    this.switched = !this.switched;\n    this._countEffects++;\n};\n\nTextureEffect.prototype.getCurrentTargetTexture = function ()\n{\n    if (this.switched) return this._textureSource;\n    return this._textureTarget;\n};\n\nTextureEffect.prototype.getCurrentSourceTexture = function ()\n{\n    if (this._countEffects == 0 && this._bgTex) return this._bgTex;\n\n    if (this.switched) return this._textureTarget;\n    return this._textureSource;\n};\n\nTextureEffect.prototype.delete = function ()\n{\n    if (this._textureTarget) this._textureTarget.delete();\n    if (this._textureSource) this._textureSource.delete();\n    this._cgl.gl.deleteRenderbuffer(this._renderbuffer);\n    this._cgl.gl.deleteFramebuffer(this._frameBuf);\n};\n\nTextureEffect.prototype.createMesh = function ()\n{\n    this._cgl.TextureEffectMesh = _cgl_simplerect__WEBPACK_IMPORTED_MODULE_1__.MESHES.getSimpleRect(this._cgl, \"texEffectRect\");\n};\n\n// ---------------------------------------------------------------------------------\n\nTextureEffect.checkOpNotInTextureEffect = function (op)\n{\n    if (!op.patch.cgl) return true;\n    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect)\n    {\n        op.setUiError(\"textureeffect\", null);\n        return true;\n    }\n    if (!op.patch.cgl.currentTextureEffect) return true;\n\n    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error)\n    {\n        op.setUiError(\"textureeffect\", \"This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.\", 0);\n        return false;\n    }\n\n    if (op.patch.cgl.currentTextureEffect) return false;\n    return true;\n};\n\nTextureEffect.checkOpInEffect = function (op, minver)\n{\n    minver = minver || 0;\n\n    if (op.patch.cgl.currentTextureEffect)\n    {\n        if (op.uiAttribs.uierrors && op.patch.cgl.currentTextureEffect.imgCompVer >= minver)\n        {\n            op.setUiError(\"texeffect\", null);\n            return true;\n        }\n\n        if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver)\n        {\n            op.setUiError(\"texeffect\", \"This op must be a child of an ImageCompose op with version >=\" + minver + \" <span class=\\\"button-small\\\" onclick=\\\"gui.patchView.downGradeOp('\" + op.id + \"','\" + op.name + \"')\\\">Downgrade</span> to previous version\", 1);\n        }\n    }\n\n    if (op.patch.cgl.currentTextureEffect) return true;\n\n    if (!op.patch.cgl.currentTextureEffect && (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0))\n    {\n        op.setUiError(\"texeffect\", \"This op must be a child of an ImageCompose op! More infos <a href=\\\"https://docs.cables.gl/image_composition/image_composition.html\\\" target=\\\"_blank\\\">here</a>. \", 1);\n        return false;\n    }\n\n    if (!op.patch.cgl.currentTextureEffect) return false;\n    return true;\n};\n\nTextureEffect.getBlendCode = function (ver)\n{\n    let src = \"\".endl()\n        + \"vec3 _blend(vec3 base,vec3 blend)\".endl()\n        + \"{\".endl()\n        + \"   vec3 colNew=blend;\".endl()\n        + \"   #ifdef BM_MULTIPLY\".endl()\n        + \"       colNew=base*blend;\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_MULTIPLY_INV\".endl()\n        + \"       colNew=base* vec3(1.0)-blend;\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_AVERAGE\".endl()\n        + \"       colNew=((base + blend) / 2.0);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_ADD\".endl()\n        + \"       colNew=min(base + blend, vec3(1.0));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_SUBTRACT_ONE\".endl()\n        + \"       colNew=max(base + blend - vec3(1.0), vec3(0.0));\".endl()\n        + \"   #endif\".endl()\n\n        + \"   #ifdef BM_SUBTRACT\".endl()\n        + \"       colNew=base - blend;\".endl()\n        + \"   #endif\".endl()\n\n        + \"   #ifdef BM_DIFFERENCE\".endl()\n        + \"       colNew=abs(base - blend);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_NEGATION\".endl()\n        + \"       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_EXCLUSION\".endl()\n        + \"       colNew=(base + blend - 2.0 * base * blend);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_LIGHTEN\".endl()\n        + \"       colNew=max(blend, base);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_DARKEN\".endl()\n        + \"       colNew=min(blend, base);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_OVERLAY\".endl()\n        + \"      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\"\n            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'\n            //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'\n            .endl()\n        + \"      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_SCREEN\".endl()\n        + \"      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))\"\n            // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'\n            // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'\n            .endl()\n        + \"      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_SOFTLIGHT\".endl()\n        + \"      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))\"\n            // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'\n            //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'\n            .endl()\n        + \"      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_HARDLIGHT\".endl()\n        + \"      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\"\n            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'\n            // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'\n            .endl()\n        + \"      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_COLORDODGE\".endl()\n        + \"      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))\"\n            // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'\n            .endl()\n        + \"      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_COLORBURN\".endl()\n        + \"      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))\"\n            // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'\n            .endl()\n        + \"      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n\n\n\n\n\n\n\n\n\n\n        + \"   return colNew;\".endl()\n        + \"}\".endl();\n\n    if (!ver)\n        src += \"vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)\".endl()\n                + \"{\".endl()\n                    + \"vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);\".endl()\n                    + \"col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);\".endl()\n                    + \"return col;\".endl()\n                + \"}\".endl();\n\n    if (ver >= 3)\n        src += \"vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)\".endl() +\n                \"{\".endl() +\n\n                \"#ifdef BM_MATH_ADD\".endl() +\n                \"   return vec4(base.rgb+col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n                \"#ifdef BM_MATH_SUB\".endl() +\n                \"   return vec4(base.rgb-col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n                \"#ifdef BM_MATH_MUL\".endl() +\n                \"   return vec4(base.rgb*col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n                \"#ifdef BM_MATH_DIV\".endl() +\n                \"   return vec4(base.rgb/col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n\n                    \"#ifndef BM_MATH\".endl() +\n                        \"vec3 colNew=_blend(base.rgb,col.rgb);\".endl() +\n\n                        \"float newA=clamp(base.a+(col.a*amount),0.,1.);\".endl() +\n\n                        \"#ifdef BM_ALPHAMASKED\".endl() +\n                            \"newA=base.a;\".endl() +\n                        \"#endif\".endl() +\n\n                        \"return vec4(\".endl() +\n                            \"mix(colNew,base.rgb,1.0-(amount*col.a)),\".endl() +\n                            \"newA);\".endl() +\n\n                    \"#endif\".endl() +\n    \"}\".endl();\n\n    return src;\n};\n\nTextureEffect.onChangeBlendSelect = function (shader, blendName, maskAlpha = false)\n{\n    blendName = String(blendName);\n    shader.toggleDefine(\"BM_NORMAL\", blendName == \"normal\");\n    shader.toggleDefine(\"BM_MULTIPLY\", blendName == \"multiply\");\n    shader.toggleDefine(\"BM_MULTIPLY_INV\", blendName == \"multiply invert\");\n    shader.toggleDefine(\"BM_AVERAGE\", blendName == \"average\");\n    shader.toggleDefine(\"BM_ADD\", blendName == \"add\");\n    shader.toggleDefine(\"BM_SUBTRACT_ONE\", blendName == \"subtract one\");\n    shader.toggleDefine(\"BM_SUBTRACT\", blendName == \"subtract\");\n    shader.toggleDefine(\"BM_DIFFERENCE\", blendName == \"difference\");\n    shader.toggleDefine(\"BM_NEGATION\", blendName == \"negation\");\n    shader.toggleDefine(\"BM_EXCLUSION\", blendName == \"exclusion\");\n    shader.toggleDefine(\"BM_LIGHTEN\", blendName == \"lighten\");\n    shader.toggleDefine(\"BM_DARKEN\", blendName == \"darken\");\n    shader.toggleDefine(\"BM_OVERLAY\", blendName == \"overlay\");\n    shader.toggleDefine(\"BM_SCREEN\", blendName == \"screen\");\n    shader.toggleDefine(\"BM_SOFTLIGHT\", blendName == \"softlight\");\n    shader.toggleDefine(\"BM_HARDLIGHT\", blendName == \"hardlight\");\n    shader.toggleDefine(\"BM_COLORDODGE\", blendName == \"color dodge\");\n    shader.toggleDefine(\"BM_COLORBURN\", blendName == \"color burn\");\n\n    shader.toggleDefine(\"BM_MATH_ADD\", blendName == \"Math Add\");\n    shader.toggleDefine(\"BM_MATH_SUB\", blendName == \"Math Subtract\");\n    shader.toggleDefine(\"BM_MATH_MUL\", blendName == \"Math Multiply\");\n    shader.toggleDefine(\"BM_MATH_DIV\", blendName == \"Math Divide\");\n\n    shader.toggleDefine(\"BM_MATH\", blendName.indexOf(\"Math \") == 0);\n\n\n    shader.toggleDefine(\"BM_ALPHAMASKED\", maskAlpha);\n};\n\nTextureEffect.AddBlendSelect = function (op, name, defaultMode)\n{\n    const p = op.inValueSelect(name || \"Blend Mode\", [\n        \"normal\", \"lighten\", \"darken\", \"multiply\", \"multiply invert\", \"average\", \"add\", \"subtract\", \"difference\", \"negation\", \"exclusion\", \"overlay\", \"screen\", \"color dodge\", \"color burn\", \"softlight\", \"hardlight\", \"subtract one\",\n        \"Math Add\",\n        \"Math Subtract\",\n        \"Math Multiply\",\n        \"Math Divide\",\n\n    ], defaultMode || \"normal\");\n    return p;\n};\n\nTextureEffect.AddBlendAlphaMask = function (op, name, defaultMode)\n{\n    const p = op.inSwitch(name || \"Alpha Mask\", [\"Off\", \"On\"], defaultMode || \"Off\");\n    return p;\n};\n\nTextureEffect.setupBlending = function (op, shader, blendPort, amountPort, alphaMaskPort)\n{\n    const onChange = () =>\n    {\n        let maskAlpha = false;\n        if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == \"On\";\n        TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);\n\n        let str = blendPort.get();\n        if (str == \"normal\") str = null;\n        else if (str == \"multiply\") str = \"mul\";\n        else if (str == \"multiply invert\") str = \"mulinv\";\n        else if (str == \"lighten\") str = \"light\";\n        else if (str == \"darken\") str = \"darken\";\n        else if (str == \"average\") str = \"avg\";\n        else if (str == \"subtract one\") str = \"sub one\";\n        else if (str == \"subtract\") str = \"sub\";\n        else if (str == \"difference\") str = \"diff\";\n        else if (str == \"negation\") str = \"neg\";\n        else if (str == \"exclusion\") str = \"exc\";\n        else if (str == \"overlay\") str = \"ovl\";\n        else if (str == \"color dodge\") str = \"dodge\";\n        else if (str == \"color burn\") str = \"burn\";\n        else if (str == \"softlight\") str = \"soft\";\n        else if (str == \"hardlight\") str = \"hard\";\n        else if (str == \"Math Add\") str = \"+\";\n        else if (str == \"Math Subtract\") str = \"-\";\n        else if (str == \"Math Multiply\") str = \"*\";\n        else if (str == \"Math Divide\") str = \"/\";\n\n        op.setUiAttrib({ \"extendTitle\": str });\n    };\n    op.setPortGroup(\"Blending\", [blendPort, amountPort, alphaMaskPort]);\n\n    let maskAlpha = false;\n\n    blendPort.onChange = onChange;\n    if (alphaMaskPort)\n    {\n        alphaMaskPort.onChange = onChange;\n        maskAlpha = alphaMaskPort.get() == \"On\";\n    }\n\n    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3RleHR1cmVlZmZlY3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX3RleHR1cmVlZmZlY3QuanM/MTFlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4vY2dsX3RleHR1cmVcIjtcbmltcG9ydCB7IE1FU0hFUyB9IGZyb20gXCIuL2NnbF9zaW1wbGVyZWN0XCI7XG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi9jb3JlX2xvZ2dlclwiO1xuXG5jb25zdCBUZXh0dXJlRWZmZWN0ID0gZnVuY3Rpb24gKGNnbCwgb3B0aW9ucylcbntcbiAgICB0aGlzLl9jZ2wgPSBjZ2w7XG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNnbF9UZXh0dXJlRWZmZWN0XCIpO1xuXG4gICAgaWYgKCFjZ2wuVGV4dHVyZUVmZmVjdE1lc2gpIHRoaXMuY3JlYXRlTWVzaCgpO1xuXG4gICAgdGhpcy5fdGV4dHVyZVNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvLyBUT0RPOiBkbyB3ZSBzdGlsbCBuZWVkIHRoZSBvcHRpb25zID9cbiAgICAvLyB2YXIgb3B0cz1vcHRpb25zIHx8XG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgIGlzRmxvYXRpbmdQb2ludFRleHR1cmU6ZmFsc2UsXG4gICAgLy8gICAgICAgICBmaWx0ZXI6Q0dMLlRleHR1cmUuRklMVEVSX0xJTkVBUlxuICAgIC8vICAgICB9O1xuICAgIC8vIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5mcClvcHRzLmlzRmxvYXRpbmdQb2ludFRleHR1cmU9dHJ1ZTtcblxuICAgIHRoaXMuaW1nQ29tcFZlciA9IDA7XG4gICAgdGhpcy5hc3BlY3RSYXRpbyA9IDE7XG4gICAgdGhpcy5fdGV4dHVyZVRhcmdldCA9IG51bGw7IC8vIG5ldyBDR0wuVGV4dHVyZSh0aGlzLl9jZ2wsb3B0cyk7XG4gICAgdGhpcy5fZnJhbWVCdWYgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLl9mcmFtZUJ1ZjIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLl9yZW5kZXJidWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgdGhpcy5fcmVuZGVyYnVmZmVyMiA9IHRoaXMuX2NnbC5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICB0aGlzLnN3aXRjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXB0aCA9IGZhbHNlO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3JlbmRlcmJ1ZmZlcikgdGhpcy5fY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9yZW5kZXJidWZmZXIpO1xuICAgIGlmICh0aGlzLl9mcmFtZUJ1ZikgdGhpcy5fY2dsLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX2ZyYW1lQnVmKTtcbiAgICBpZiAodGhpcy5fcmVuZGVyYnVmZmVyMikgdGhpcy5fY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9yZW5kZXJidWZmZXIyKTtcbiAgICBpZiAodGhpcy5fZnJhbWVCdWYyKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZnJhbWVCdWYyKTtcbn07XG5cblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aDtcbn07XG5cblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0O1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuc2V0U291cmNlVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXgpXG57XG4gICAgLy8gaWYgKHRleC5waXhlbEZvcm1hdCA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGKSB0aGlzLl9jZ2wuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKTtcbiAgICAvLyBpZiAodGV4LnBpeGVsRm9ybWF0ID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGKSB0aGlzLl9jZ2wuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKTtcbiAgICAvLyBpZiAodGV4LnBpeGVsRm9ybWF0ID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMTZGKSB0aGlzLl9jZ2wuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpO1xuXG4gICAgaWYgKHRleCA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVTb3VyY2UgPSBuZXcgVGV4dHVyZSh0aGlzLl9jZ2wpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlU291cmNlLnNldFNpemUoMTYsIDE2KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVNvdXJjZSA9IHRleDtcbiAgICB9XG5cblxuICAgIGlmICghdGhpcy5fdGV4dHVyZVNvdXJjZS5jb21wYXJlU2V0dGluZ3ModGhpcy5fdGV4dHVyZVRhcmdldCkpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZVRhcmdldCkgdGhpcy5fdGV4dHVyZVRhcmdldC5kZWxldGUoKTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJlVGFyZ2V0ID0gdGhpcy5fdGV4dHVyZVNvdXJjZS5jbG9uZSgpO1xuXG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlRWZmZWN0QnVmZmVyY3JlYXRlKys7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmKTtcblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9yZW5kZXJidWZmZXIpO1xuXG4gICAgICAgIC8vIGlmKHRleC50ZXh0dXJlVHlwZT09Q0dMLlRleHR1cmUuVFlQRV9GTE9BVCkgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUix0aGlzLl9jZ2wuZ2wuUkdCQTMyRiwgdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCx0aGlzLl90ZXh0dXJlU291cmNlLmhlaWdodCk7XG4gICAgICAgIC8vIGVsc2UgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUix0aGlzLl9jZ2wuZ2wuUkdCQTgsIHRoaXMuX3RleHR1cmVTb3VyY2Uud2lkdGgsdGhpcy5fdGV4dHVyZVNvdXJjZS5oZWlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLmRlcHRoKSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuX3RleHR1cmVTb3VyY2Uud2lkdGgsIHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZVRhcmdldC50ZXgsIDApO1xuICAgICAgICBpZiAodGhpcy5kZXB0aCkgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX3JlbmRlcmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZVRhcmdldC50ZXgsIDApO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmMik7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fcmVuZGVyYnVmZmVyMik7XG5cbiAgICAgICAgLy8gaWYodGV4LnRleHR1cmVUeXBlPT1DR0wuVGV4dHVyZS5UWVBFX0ZMT0FUKSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLHRoaXMuX2NnbC5nbC5SR0JBMzJGLCB0aGlzLl90ZXh0dXJlU291cmNlLndpZHRoLHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgLy8gZWxzZSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLHRoaXMuX2NnbC5nbC5SR0JBOCwgdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCx0aGlzLl90ZXh0dXJlU291cmNlLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVwdGgpIHRoaXMuX2NnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2NnbC5nbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCwgdGhpcy5fdGV4dHVyZVNvdXJjZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlU291cmNlLnRleCwgMCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVwdGgpIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5ERVBUSF9BVFRBQ0hNRU5ULCB0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9yZW5kZXJidWZmZXIyKTtcblxuICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlU291cmNlLnRleCwgMCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzcGVjdFJhdGlvID0gdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCAvIHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0O1xufTtcblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmNvbnRpbnVlRWZmZWN0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jZ2wucHVzaERlcHRoVGVzdChmYWxzZSk7XG5cbiAgICB0aGlzLl9jZ2wucHVzaE1vZGVsTWF0cml4KCk7XG5cbiAgICB0aGlzLl9jZ2wucHVzaFBNYXRyaXgoKTtcblxuICAgIHRoaXMuX2NnbC5wdXNoVmlld1BvcnQoMCwgMCwgdGhpcy5nZXRDdXJyZW50VGFyZ2V0VGV4dHVyZSgpLndpZHRoLCB0aGlzLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlKCkuaGVpZ2h0KTtcbiAgICAvLyB0aGlzLl9jZ2wuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5nZXRDdXJyZW50VGFyZ2V0VGV4dHVyZSgpLndpZHRoLCB0aGlzLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlKCkuaGVpZ2h0KTtcbiAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMuX2NnbC5wTWF0cml4LCA0NSwgdGhpcy5nZXRDdXJyZW50VGFyZ2V0VGV4dHVyZSgpLndpZHRoIC8gdGhpcy5nZXRDdXJyZW50VGFyZ2V0VGV4dHVyZSgpLmhlaWdodCwgMC4xLCAxMTAwLjApO1xuXG4gICAgdGhpcy5fY2dsLnB1c2hQTWF0cml4KCk7XG4gICAgbWF0NC5pZGVudGl0eSh0aGlzLl9jZ2wucE1hdHJpeCk7XG5cbiAgICB0aGlzLl9jZ2wucHVzaFZpZXdNYXRyaXgoKTtcbiAgICBtYXQ0LmlkZW50aXR5KHRoaXMuX2NnbC52TWF0cml4KTtcblxuICAgIHRoaXMuX2NnbC5wdXNoTW9kZWxNYXRyaXgoKTtcbiAgICBtYXQ0LmlkZW50aXR5KHRoaXMuX2NnbC5tTWF0cml4KTtcbn07XG5cblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuc3RhcnRFZmZlY3QgPSBmdW5jdGlvbiAoYmdUZXgpXG57XG4gICAgaWYgKCF0aGlzLl90ZXh0dXJlVGFyZ2V0KVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJlZmZlY3QgaGFzIG5vIHRhcmdldFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuY29udGludWVFZmZlY3QoKTtcblxuICAgIGlmIChiZ1RleClcbiAgICB7XG4gICAgICAgIHRoaXMuX2JnVGV4ID0gYmdUZXg7XG4gICAgfVxuICAgIHRoaXMuX2NvdW50RWZmZWN0cyA9IDA7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5lbmRFZmZlY3QgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2NnbC5wb3BEZXB0aFRlc3QoKTtcbiAgICB0aGlzLl9jZ2wucG9wTW9kZWxNYXRyaXgoKTtcblxuICAgIHRoaXMuX2NnbC5wb3BQTWF0cml4KCk7XG4gICAgdGhpcy5fY2dsLnBvcE1vZGVsTWF0cml4KCk7XG4gICAgdGhpcy5fY2dsLnBvcFZpZXdNYXRyaXgoKTtcblxuICAgIHRoaXMuX2NnbC5wb3BQTWF0cml4KCk7XG4gICAgdGhpcy5fY2dsLnBvcFZpZXdQb3J0KCk7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fdGV4dHVyZVNvdXJjZSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwibm8gYmFzZSB0ZXh0dXJlIHNldCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3dpdGNoZWQpXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWYpO1xuICAgICAgICB0aGlzLl9jZ2wucHVzaEdsRnJhbWVCdWZmZXIodGhpcy5fZnJhbWVCdWYpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWYyKTtcbiAgICAgICAgdGhpcy5fY2dsLnB1c2hHbEZyYW1lQnVmZmVyKHRoaXMuX2ZyYW1lQnVmMik7XG4gICAgfVxufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fdGV4dHVyZVNvdXJjZSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwibm8gYmFzZSB0ZXh0dXJlIHNldCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jZ2wuVGV4dHVyZUVmZmVjdE1lc2gucmVuZGVyKHRoaXMuX2NnbC5nZXRTaGFkZXIoKSk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLnBvcEdsRnJhbWVCdWZmZXIoKSk7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVRleHR1cmVFZmZlY3QrKztcblxuICAgIC8vIHRoaXMuX3RleHR1cmVUYXJnZXQudXBkYXRlTWlwTWFwKCk7XG5cbiAgICBpZiAodGhpcy5fdGV4dHVyZVRhcmdldC5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTUlQTUFQKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnN3aXRjaGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVUYXJnZXQudGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVUYXJnZXQudXBkYXRlTWlwTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVTb3VyY2UudGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVTb3VyY2UudXBkYXRlTWlwTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoZWQgPSAhdGhpcy5zd2l0Y2hlZDtcbiAgICB0aGlzLl9jb3VudEVmZmVjdHMrKztcbn07XG5cblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5zd2l0Y2hlZCkgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2U7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVUYXJnZXQ7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5nZXRDdXJyZW50U291cmNlVGV4dHVyZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2NvdW50RWZmZWN0cyA9PSAwICYmIHRoaXMuX2JnVGV4KSByZXR1cm4gdGhpcy5fYmdUZXg7XG5cbiAgICBpZiAodGhpcy5zd2l0Y2hlZCkgcmV0dXJuIHRoaXMuX3RleHR1cmVUYXJnZXQ7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2U7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl90ZXh0dXJlVGFyZ2V0KSB0aGlzLl90ZXh0dXJlVGFyZ2V0LmRlbGV0ZSgpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlU291cmNlKSB0aGlzLl90ZXh0dXJlU291cmNlLmRlbGV0ZSgpO1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5fcmVuZGVyYnVmZmVyKTtcbiAgICB0aGlzLl9jZ2wuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZnJhbWVCdWYpO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY2dsLlRleHR1cmVFZmZlY3RNZXNoID0gTUVTSEVTLmdldFNpbXBsZVJlY3QodGhpcy5fY2dsLCBcInRleEVmZmVjdFJlY3RcIik7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuVGV4dHVyZUVmZmVjdC5jaGVja09wTm90SW5UZXh0dXJlRWZmZWN0ID0gZnVuY3Rpb24gKG9wKVxue1xuICAgIGlmICghb3AucGF0Y2guY2dsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAob3AudWlBdHRyaWJzLmVycm9yICYmICFvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QpXG4gICAge1xuICAgICAgICBvcC5zZXRVaUVycm9yKFwidGV4dHVyZWVmZmVjdFwiLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QgJiYgIW9wLnVpQXR0cmlicy5lcnJvcilcbiAgICB7XG4gICAgICAgIG9wLnNldFVpRXJyb3IoXCJ0ZXh0dXJlZWZmZWN0XCIsIFwiVGhpcyBvcCBjYW4gbm90IGJlIGEgY2hpbGQgb2YgYSBJbWFnZUNvbXBvc2UvdGV4dHVyZSBlZmZlY3QhIGltYWdlY29tcG9zZSBzaG91bGQgb25seSBoYXZlIHRleHR1cmVlZmZlY3QgY2hpbGRzLlwiLCAwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblRleHR1cmVFZmZlY3QuY2hlY2tPcEluRWZmZWN0ID0gZnVuY3Rpb24gKG9wLCBtaW52ZXIpXG57XG4gICAgbWludmVyID0gbWludmVyIHx8IDA7XG5cbiAgICBpZiAob3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0KVxuICAgIHtcbiAgICAgICAgaWYgKG9wLnVpQXR0cmlicy51aWVycm9ycyAmJiBvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QuaW1nQ29tcFZlciA+PSBtaW52ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wLnNldFVpRXJyb3IoXCJ0ZXhlZmZlY3RcIiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW52ZXIgJiYgb3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0LmltZ0NvbXBWZXIgPCBtaW52ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wLnNldFVpRXJyb3IoXCJ0ZXhlZmZlY3RcIiwgXCJUaGlzIG9wIG11c3QgYmUgYSBjaGlsZCBvZiBhbiBJbWFnZUNvbXBvc2Ugb3Agd2l0aCB2ZXJzaW9uID49XCIgKyBtaW52ZXIgKyBcIiA8c3BhbiBjbGFzcz1cXFwiYnV0dG9uLXNtYWxsXFxcIiBvbmNsaWNrPVxcXCJndWkucGF0Y2hWaWV3LmRvd25HcmFkZU9wKCdcIiArIG9wLmlkICsgXCInLCdcIiArIG9wLm5hbWUgKyBcIicpXFxcIj5Eb3duZ3JhZGU8L3NwYW4+IHRvIHByZXZpb3VzIHZlcnNpb25cIiwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmICghb3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0ICYmICghb3AudWlBdHRyaWJzLnVpZXJyb3JzIHx8IG9wLnVpQXR0cmlicy51aWVycm9ycy5sZW5ndGggPT0gMCkpXG4gICAge1xuICAgICAgICBvcC5zZXRVaUVycm9yKFwidGV4ZWZmZWN0XCIsIFwiVGhpcyBvcCBtdXN0IGJlIGEgY2hpbGQgb2YgYW4gSW1hZ2VDb21wb3NlIG9wISBNb3JlIGluZm9zIDxhIGhyZWY9XFxcImh0dHBzOi8vZG9jcy5jYWJsZXMuZ2wvaW1hZ2VfY29tcG9zaXRpb24vaW1hZ2VfY29tcG9zaXRpb24uaHRtbFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPmhlcmU8L2E+LiBcIiwgMSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIW9wLnBhdGNoLmNnbC5jdXJyZW50VGV4dHVyZUVmZmVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuVGV4dHVyZUVmZmVjdC5nZXRCbGVuZENvZGUgPSBmdW5jdGlvbiAodmVyKVxue1xuICAgIGxldCBzcmMgPSBcIlwiLmVuZGwoKVxuICAgICAgICArIFwidmVjMyBfYmxlbmQodmVjMyBiYXNlLHZlYzMgYmxlbmQpXCIuZW5kbCgpXG4gICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICB2ZWMzIGNvbE5ldz1ibGVuZDtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9NVUxUSVBMWVwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgIGNvbE5ldz1iYXNlKmJsZW5kO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fTVVMVElQTFlfSU5WXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PWJhc2UqIHZlYzMoMS4wKS1ibGVuZDtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX0FWRVJBR0VcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICBjb2xOZXc9KChiYXNlICsgYmxlbmQpIC8gMi4wKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX0FERFwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgIGNvbE5ldz1taW4oYmFzZSArIGJsZW5kLCB2ZWMzKDEuMCkpO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fU1VCVFJBQ1RfT05FXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PW1heChiYXNlICsgYmxlbmQgLSB2ZWMzKDEuMCksIHZlYzMoMC4wKSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcblxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX1NVQlRSQUNUXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PWJhc2UgLSBibGVuZDtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fRElGRkVSRU5DRVwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgIGNvbE5ldz1hYnMoYmFzZSAtIGJsZW5kKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX05FR0FUSU9OXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PSh2ZWMzKDEuMCkgLSBhYnModmVjMygxLjApIC0gYmFzZSAtIGJsZW5kKSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9FWENMVVNJT05cIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICBjb2xOZXc9KGJhc2UgKyBibGVuZCAtIDIuMCAqIGJhc2UgKiBibGVuZCk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9MSUdIVEVOXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PW1heChibGVuZCwgYmFzZSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9EQVJLRU5cIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICBjb2xOZXc9bWluKGJsZW5kLCBiYXNlKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX09WRVJMQVlcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICNkZWZpbmUgQmxlbmRPdmVybGF5ZihiYXNlLCBibGVuZCkgIChiYXNlIDwgMC41ID8gKDIuMCAqIGJhc2UgKiBibGVuZCkgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UpICogKDEuMCAtIGJsZW5kKSkpXCJcbiAgICAgICAgICAgIC8vIC5lbmRsKCkrJyAgICAgICAjZGVmaW5lIEJsZW5kT3ZlcmxheShiYXNlLCBibGVuZCkgICAgICAgQmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kT3ZlcmxheWYpJ1xuICAgICAgICAgICAgLy8gICAgLmVuZGwoKSsnICAgICAgY29sTmV3PUJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZE92ZXJsYXlmKTsnXG4gICAgICAgICAgICAuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICBjb2xOZXc9dmVjMyhCbGVuZE92ZXJsYXlmKGJhc2UuciwgYmxlbmQuciksQmxlbmRPdmVybGF5ZihiYXNlLmcsIGJsZW5kLmcpLEJsZW5kT3ZlcmxheWYoYmFzZS5iLCBibGVuZC5iKSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9TQ1JFRU5cIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICNkZWZpbmUgQmxlbmRTY3JlZW5mKGJhc2UsIGJsZW5kKSAgICAgICAoMS4wIC0gKCgxLjAgLSBiYXNlKSAqICgxLjAgLSBibGVuZCkpKVwiXG4gICAgICAgICAgICAvLyAuZW5kbCgpKycgICAgICAgI2RlZmluZSBCbGVuZFNjcmVlbihiYXNlLCBibGVuZCkgICAgICAgIEJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZFNjcmVlbmYpJ1xuICAgICAgICAgICAgLy8gLmVuZGwoKSsnICAgICAgY29sTmV3PUJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZFNjcmVlbmYpOydcbiAgICAgICAgICAgIC5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgIGNvbE5ldz12ZWMzKEJsZW5kU2NyZWVuZihiYXNlLnIsIGJsZW5kLnIpLEJsZW5kU2NyZWVuZihiYXNlLmcsIGJsZW5kLmcpLEJsZW5kU2NyZWVuZihiYXNlLmIsIGJsZW5kLmIpKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX1NPRlRMSUdIVFwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgI2RlZmluZSBCbGVuZFNvZnRMaWdodGYoYmFzZSwgYmxlbmQpICAgICgoYmxlbmQgPCAwLjUpID8gKDIuMCAqIGJhc2UgKiBibGVuZCArIGJhc2UgKiBiYXNlICogKDEuMCAtIDIuMCAqIGJsZW5kKSkgOiAoc3FydChiYXNlKSAqICgyLjAgKiBibGVuZCAtIDEuMCkgKyAyLjAgKiBiYXNlICogKDEuMCAtIGJsZW5kKSkpXCJcbiAgICAgICAgICAgIC8vIC5lbmRsKCkrJyAgICAgICAjZGVmaW5lIEJsZW5kU29mdExpZ2h0KGJhc2UsIGJsZW5kKSAgICAgQmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kU29mdExpZ2h0ZiknXG4gICAgICAgICAgICAvLyAgICAuZW5kbCgpKycgICAgICBjb2xOZXc9QmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kU29mdExpZ2h0Zik7J1xuICAgICAgICAgICAgLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgY29sTmV3PXZlYzMoQmxlbmRTb2Z0TGlnaHRmKGJhc2UuciwgYmxlbmQuciksQmxlbmRTb2Z0TGlnaHRmKGJhc2UuZywgYmxlbmQuZyksQmxlbmRTb2Z0TGlnaHRmKGJhc2UuYiwgYmxlbmQuYikpO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fSEFSRExJR0hUXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAjZGVmaW5lIEJsZW5kT3ZlcmxheWYoYmFzZSwgYmxlbmQpICAoYmFzZSA8IDAuNSA/ICgyLjAgKiBiYXNlICogYmxlbmQpIDogKDEuMCAtIDIuMCAqICgxLjAgLSBiYXNlKSAqICgxLjAgLSBibGVuZCkpKVwiXG4gICAgICAgICAgICAvLyAuZW5kbCgpKycgICAgICAgI2RlZmluZSBCbGVuZE92ZXJsYXkoYmFzZSwgYmxlbmQpICAgICAgIEJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZE92ZXJsYXlmKSdcbiAgICAgICAgICAgIC8vIC5lbmRsKCkrJyAgICAgIGNvbE5ldz1CbGVuZChibGVuZCwgYmFzZSwgQmxlbmRPdmVybGF5Zik7J1xuICAgICAgICAgICAgLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgY29sTmV3PXZlYzMoQmxlbmRPdmVybGF5ZihiYXNlLnIsIGJsZW5kLnIpLEJsZW5kT3ZlcmxheWYoYmFzZS5nLCBibGVuZC5nKSxCbGVuZE92ZXJsYXlmKGJhc2UuYiwgYmxlbmQuYikpO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fQ09MT1JET0RHRVwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgI2RlZmluZSBCbGVuZENvbG9yRG9kZ2VmKGJhc2UsIGJsZW5kKSAgICgoYmxlbmQgPT0gMS4wKSA/IGJsZW5kIDogbWluKGJhc2UgLyAoMS4wIC0gYmxlbmQpLCAxLjApKVwiXG4gICAgICAgICAgICAvLyAuZW5kbCgpKycgICAgICBjb2xOZXc9QmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kQ29sb3JEb2RnZWYpOydcbiAgICAgICAgICAgIC5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgIGNvbE5ldz12ZWMzKEJsZW5kQ29sb3JEb2RnZWYoYmFzZS5yLCBibGVuZC5yKSxCbGVuZENvbG9yRG9kZ2VmKGJhc2UuZywgYmxlbmQuZyksQmxlbmRDb2xvckRvZGdlZihiYXNlLmIsIGJsZW5kLmIpKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX0NPTE9SQlVSTlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgI2RlZmluZSBCbGVuZENvbG9yQnVybmYoYmFzZSwgYmxlbmQpICAgICgoYmxlbmQgPT0gMC4wKSA/IGJsZW5kIDogbWF4KCgxLjAgLSAoKDEuMCAtIGJhc2UpIC8gYmxlbmQpKSwgMC4wKSlcIlxuICAgICAgICAgICAgLy8gLmVuZGwoKSsnICAgICAgY29sTmV3PUJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZENvbG9yQnVybmYpOydcbiAgICAgICAgICAgIC5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgIGNvbE5ldz12ZWMzKEJsZW5kQ29sb3JCdXJuZihiYXNlLnIsIGJsZW5kLnIpLEJsZW5kQ29sb3JCdXJuZihiYXNlLmcsIGJsZW5kLmcpLEJsZW5kQ29sb3JCdXJuZihiYXNlLmIsIGJsZW5kLmIpKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICsgXCIgICByZXR1cm4gY29sTmV3O1wiLmVuZGwoKVxuICAgICAgICArIFwifVwiLmVuZGwoKTtcblxuICAgIGlmICghdmVyKVxuICAgICAgICBzcmMgKz0gXCJ2ZWM0IGNnbF9ibGVuZCh2ZWM0IG9sZENvbG9yLHZlYzQgbmV3Q29sb3IsZmxvYXQgYW1vdW50KVwiLmVuZGwoKVxuICAgICAgICAgICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgICAgICsgXCJ2ZWM0IGNvbD12ZWM0KCBfYmxlbmQob2xkQ29sb3IucmdiLG5ld0NvbG9yLnJnYikgLDEuMCk7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgICAgICsgXCJjb2w9dmVjNCggbWl4KCBjb2wucmdiLCBvbGRDb2xvci5yZ2IgLDEuMC1vbGRDb2xvci5hKmFtb3VudCksMS4wKTtcIi5lbmRsKClcbiAgICAgICAgICAgICAgICAgICAgKyBcInJldHVybiBjb2w7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgKyBcIn1cIi5lbmRsKCk7XG5cbiAgICBpZiAodmVyID49IDMpXG4gICAgICAgIHNyYyArPSBcInZlYzQgY2dsX2JsZW5kUGl4ZWwodmVjNCBiYXNlLHZlYzQgY29sLGZsb2F0IGFtb3VudClcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgIFwie1wiLmVuZGwoKSArXG5cbiAgICAgICAgICAgICAgICBcIiNpZmRlZiBCTV9NQVRIX0FERFwiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIgICByZXR1cm4gdmVjNChiYXNlLnJnYitjb2wucmdiKmFtb3VudCwxLjApO1wiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIjZW5kaWZcIi5lbmRsKCkgK1xuXG4gICAgICAgICAgICAgICAgXCIjaWZkZWYgQk1fTUFUSF9TVUJcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgIFwiICAgcmV0dXJuIHZlYzQoYmFzZS5yZ2ItY29sLnJnYiphbW91bnQsMS4wKTtcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgIFwiI2VuZGlmXCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgIFwiI2lmZGVmIEJNX01BVEhfTVVMXCIuZW5kbCgpICtcbiAgICAgICAgICAgICAgICBcIiAgIHJldHVybiB2ZWM0KGJhc2UucmdiKmNvbC5yZ2IqYW1vdW50LDEuMCk7XCIuZW5kbCgpICtcbiAgICAgICAgICAgICAgICBcIiNlbmRpZlwiLmVuZGwoKSArXG5cbiAgICAgICAgICAgICAgICBcIiNpZmRlZiBCTV9NQVRIX0RJVlwiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIgICByZXR1cm4gdmVjNChiYXNlLnJnYi9jb2wucmdiKmFtb3VudCwxLjApO1wiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIjZW5kaWZcIi5lbmRsKCkgK1xuXG5cbiAgICAgICAgICAgICAgICAgICAgXCIjaWZuZGVmIEJNX01BVEhcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2ZWMzIGNvbE5ldz1fYmxlbmQoYmFzZS5yZ2IsY29sLnJnYik7XCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdCBuZXdBPWNsYW1wKGJhc2UuYSsoY29sLmEqYW1vdW50KSwwLiwxLik7XCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXCIjaWZkZWYgQk1fQUxQSEFNQVNLRURcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV3QT1iYXNlLmE7XCIuZW5kbCgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiI2VuZGlmXCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXR1cm4gdmVjNChcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWl4KGNvbE5ldyxiYXNlLnJnYiwxLjAtKGFtb3VudCpjb2wuYSkpLFwiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXdBKTtcIi5lbmRsKCkgK1xuXG4gICAgICAgICAgICAgICAgICAgIFwiI2VuZGlmXCIuZW5kbCgpICtcbiAgICBcIn1cIi5lbmRsKCk7XG5cbiAgICByZXR1cm4gc3JjO1xufTtcblxuVGV4dHVyZUVmZmVjdC5vbkNoYW5nZUJsZW5kU2VsZWN0ID0gZnVuY3Rpb24gKHNoYWRlciwgYmxlbmROYW1lLCBtYXNrQWxwaGEgPSBmYWxzZSlcbntcbiAgICBibGVuZE5hbWUgPSBTdHJpbmcoYmxlbmROYW1lKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTk9STUFMXCIsIGJsZW5kTmFtZSA9PSBcIm5vcm1hbFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTVVMVElQTFlcIiwgYmxlbmROYW1lID09IFwibXVsdGlwbHlcIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX01VTFRJUExZX0lOVlwiLCBibGVuZE5hbWUgPT0gXCJtdWx0aXBseSBpbnZlcnRcIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0FWRVJBR0VcIiwgYmxlbmROYW1lID09IFwiYXZlcmFnZVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fQUREXCIsIGJsZW5kTmFtZSA9PSBcImFkZFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fU1VCVFJBQ1RfT05FXCIsIGJsZW5kTmFtZSA9PSBcInN1YnRyYWN0IG9uZVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fU1VCVFJBQ1RcIiwgYmxlbmROYW1lID09IFwic3VidHJhY3RcIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0RJRkZFUkVOQ0VcIiwgYmxlbmROYW1lID09IFwiZGlmZmVyZW5jZVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTkVHQVRJT05cIiwgYmxlbmROYW1lID09IFwibmVnYXRpb25cIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0VYQ0xVU0lPTlwiLCBibGVuZE5hbWUgPT0gXCJleGNsdXNpb25cIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0xJR0hURU5cIiwgYmxlbmROYW1lID09IFwibGlnaHRlblwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fREFSS0VOXCIsIGJsZW5kTmFtZSA9PSBcImRhcmtlblwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fT1ZFUkxBWVwiLCBibGVuZE5hbWUgPT0gXCJvdmVybGF5XCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9TQ1JFRU5cIiwgYmxlbmROYW1lID09IFwic2NyZWVuXCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9TT0ZUTElHSFRcIiwgYmxlbmROYW1lID09IFwic29mdGxpZ2h0XCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9IQVJETElHSFRcIiwgYmxlbmROYW1lID09IFwiaGFyZGxpZ2h0XCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9DT0xPUkRPREdFXCIsIGJsZW5kTmFtZSA9PSBcImNvbG9yIGRvZGdlXCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9DT0xPUkJVUk5cIiwgYmxlbmROYW1lID09IFwiY29sb3IgYnVyblwiKTtcblxuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9NQVRIX0FERFwiLCBibGVuZE5hbWUgPT0gXCJNYXRoIEFkZFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSF9TVUJcIiwgYmxlbmROYW1lID09IFwiTWF0aCBTdWJ0cmFjdFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSF9NVUxcIiwgYmxlbmROYW1lID09IFwiTWF0aCBNdWx0aXBseVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSF9ESVZcIiwgYmxlbmROYW1lID09IFwiTWF0aCBEaXZpZGVcIik7XG5cbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSFwiLCBibGVuZE5hbWUuaW5kZXhPZihcIk1hdGggXCIpID09IDApO1xuXG5cbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fQUxQSEFNQVNLRURcIiwgbWFza0FscGhhKTtcbn07XG5cblRleHR1cmVFZmZlY3QuQWRkQmxlbmRTZWxlY3QgPSBmdW5jdGlvbiAob3AsIG5hbWUsIGRlZmF1bHRNb2RlKVxue1xuICAgIGNvbnN0IHAgPSBvcC5pblZhbHVlU2VsZWN0KG5hbWUgfHwgXCJCbGVuZCBNb2RlXCIsIFtcbiAgICAgICAgXCJub3JtYWxcIiwgXCJsaWdodGVuXCIsIFwiZGFya2VuXCIsIFwibXVsdGlwbHlcIiwgXCJtdWx0aXBseSBpbnZlcnRcIiwgXCJhdmVyYWdlXCIsIFwiYWRkXCIsIFwic3VidHJhY3RcIiwgXCJkaWZmZXJlbmNlXCIsIFwibmVnYXRpb25cIiwgXCJleGNsdXNpb25cIiwgXCJvdmVybGF5XCIsIFwic2NyZWVuXCIsIFwiY29sb3IgZG9kZ2VcIiwgXCJjb2xvciBidXJuXCIsIFwic29mdGxpZ2h0XCIsIFwiaGFyZGxpZ2h0XCIsIFwic3VidHJhY3Qgb25lXCIsXG4gICAgICAgIFwiTWF0aCBBZGRcIixcbiAgICAgICAgXCJNYXRoIFN1YnRyYWN0XCIsXG4gICAgICAgIFwiTWF0aCBNdWx0aXBseVwiLFxuICAgICAgICBcIk1hdGggRGl2aWRlXCIsXG5cbiAgICBdLCBkZWZhdWx0TW9kZSB8fCBcIm5vcm1hbFwiKTtcbiAgICByZXR1cm4gcDtcbn07XG5cblRleHR1cmVFZmZlY3QuQWRkQmxlbmRBbHBoYU1hc2sgPSBmdW5jdGlvbiAob3AsIG5hbWUsIGRlZmF1bHRNb2RlKVxue1xuICAgIGNvbnN0IHAgPSBvcC5pblN3aXRjaChuYW1lIHx8IFwiQWxwaGEgTWFza1wiLCBbXCJPZmZcIiwgXCJPblwiXSwgZGVmYXVsdE1vZGUgfHwgXCJPZmZcIik7XG4gICAgcmV0dXJuIHA7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnNldHVwQmxlbmRpbmcgPSBmdW5jdGlvbiAob3AsIHNoYWRlciwgYmxlbmRQb3J0LCBhbW91bnRQb3J0LCBhbHBoYU1hc2tQb3J0KVxue1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT5cbiAgICB7XG4gICAgICAgIGxldCBtYXNrQWxwaGEgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFscGhhTWFza1BvcnQpIG1hc2tBbHBoYSA9IGFscGhhTWFza1BvcnQuZ2V0KCkgPT0gXCJPblwiO1xuICAgICAgICBUZXh0dXJlRWZmZWN0Lm9uQ2hhbmdlQmxlbmRTZWxlY3Qoc2hhZGVyLCBibGVuZFBvcnQuZ2V0KCksIG1hc2tBbHBoYSk7XG5cbiAgICAgICAgbGV0IHN0ciA9IGJsZW5kUG9ydC5nZXQoKTtcbiAgICAgICAgaWYgKHN0ciA9PSBcIm5vcm1hbFwiKSBzdHIgPSBudWxsO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJtdWx0aXBseVwiKSBzdHIgPSBcIm11bFwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJtdWx0aXBseSBpbnZlcnRcIikgc3RyID0gXCJtdWxpbnZcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwibGlnaHRlblwiKSBzdHIgPSBcImxpZ2h0XCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcImRhcmtlblwiKSBzdHIgPSBcImRhcmtlblwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJhdmVyYWdlXCIpIHN0ciA9IFwiYXZnXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcInN1YnRyYWN0IG9uZVwiKSBzdHIgPSBcInN1YiBvbmVcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwic3VidHJhY3RcIikgc3RyID0gXCJzdWJcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiZGlmZmVyZW5jZVwiKSBzdHIgPSBcImRpZmZcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwibmVnYXRpb25cIikgc3RyID0gXCJuZWdcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiZXhjbHVzaW9uXCIpIHN0ciA9IFwiZXhjXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIm92ZXJsYXlcIikgc3RyID0gXCJvdmxcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiY29sb3IgZG9kZ2VcIikgc3RyID0gXCJkb2RnZVwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJjb2xvciBidXJuXCIpIHN0ciA9IFwiYnVyblwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJzb2Z0bGlnaHRcIikgc3RyID0gXCJzb2Z0XCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcImhhcmRsaWdodFwiKSBzdHIgPSBcImhhcmRcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiTWF0aCBBZGRcIikgc3RyID0gXCIrXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIk1hdGggU3VidHJhY3RcIikgc3RyID0gXCItXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIk1hdGggTXVsdGlwbHlcIikgc3RyID0gXCIqXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIk1hdGggRGl2aWRlXCIpIHN0ciA9IFwiL1wiO1xuXG4gICAgICAgIG9wLnNldFVpQXR0cmliKHsgXCJleHRlbmRUaXRsZVwiOiBzdHIgfSk7XG4gICAgfTtcbiAgICBvcC5zZXRQb3J0R3JvdXAoXCJCbGVuZGluZ1wiLCBbYmxlbmRQb3J0LCBhbW91bnRQb3J0LCBhbHBoYU1hc2tQb3J0XSk7XG5cbiAgICBsZXQgbWFza0FscGhhID0gZmFsc2U7XG5cbiAgICBibGVuZFBvcnQub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICBpZiAoYWxwaGFNYXNrUG9ydClcbiAgICB7XG4gICAgICAgIGFscGhhTWFza1BvcnQub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgICAgbWFza0FscGhhID0gYWxwaGFNYXNrUG9ydC5nZXQoKSA9PSBcIk9uXCI7XG4gICAgfVxuXG4gICAgVGV4dHVyZUVmZmVjdC5vbkNoYW5nZUJsZW5kU2VsZWN0KHNoYWRlciwgYmxlbmRQb3J0LmdldCgpLCBtYXNrQWxwaGEpO1xufTtcblxuZXhwb3J0IHsgVGV4dHVyZUVmZmVjdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_textureeffect.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_unicolorshader.js":
/*!********************************************!*\
  !*** ./src/core/cgl/cgl_unicolorshader.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniColorShader\": () => (/* binding */ UniColorShader)\n/* harmony export */ });\n\n\nclass UniColorShader\n{\n    constructor(_cgl)\n    {\n        this.shader = new CGL.Shader(_cgl, \"markermaterial\");\n\n        const frag = \"\"\n            .endl() + \"void main()\"\n            .endl() + \"{\"\n            .endl() + \"    outColor = vec4(color.rgb,1.0);\"\n            .endl() + \"}\";\n\n\n        const vert = \"\"\n            .endl() + \"IN vec3 vPosition;\"\n            .endl() + \"UNI mat4 projMatrix;\"\n            .endl() + \"UNI mat4 mvMatrix;\"\n\n            .endl() + \"void main()\"\n            .endl() + \"{\"\n            .endl() + \"   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);\"\n            .endl() + \"}\";\n\n        this.shader.setSource(vert, frag);\n        this.coloruni = this.shader.addUniformFrag(\"4f\", \"color\", [1, 0.777, 1, 1]);\n    }\n\n    setColor(r, g, b, a)\n    {\n        this.coloruni.set(r, g, b, a);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3VuaWNvbG9yc2hhZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfdW5pY29sb3JzaGFkZXIuanM/NDY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBVbmlDb2xvclNoYWRlciB9O1xuXG5jbGFzcyBVbmlDb2xvclNoYWRlclxue1xuICAgIGNvbnN0cnVjdG9yKF9jZ2wpXG4gICAge1xuICAgICAgICB0aGlzLnNoYWRlciA9IG5ldyBDR0wuU2hhZGVyKF9jZ2wsIFwibWFya2VybWF0ZXJpYWxcIik7XG5cbiAgICAgICAgY29uc3QgZnJhZyA9IFwiXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcInZvaWQgbWFpbigpXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIntcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiICAgIG91dENvbG9yID0gdmVjNChjb2xvci5yZ2IsMS4wKTtcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwifVwiO1xuXG5cbiAgICAgICAgY29uc3QgdmVydCA9IFwiXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIklOIHZlYzMgdlBvc2l0aW9uO1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJVTkkgbWF0NCBwcm9qTWF0cml4O1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJVTkkgbWF0NCBtdk1hdHJpeDtcIlxuXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJ2b2lkIG1haW4oKVwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJ7XCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiAgIGdsX1Bvc2l0aW9uID0gcHJvak1hdHJpeCAqIG12TWF0cml4ICogdmVjNCh2UG9zaXRpb24sMS4wKTtcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwifVwiO1xuXG4gICAgICAgIHRoaXMuc2hhZGVyLnNldFNvdXJjZSh2ZXJ0LCBmcmFnKTtcbiAgICAgICAgdGhpcy5jb2xvcnVuaSA9IHRoaXMuc2hhZGVyLmFkZFVuaWZvcm1GcmFnKFwiNGZcIiwgXCJjb2xvclwiLCBbMSwgMC43NzcsIDEsIDFdKTtcbiAgICB9XG5cbiAgICBzZXRDb2xvcihyLCBnLCBiLCBhKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb2xvcnVuaS5zZXQociwgZywgYiwgYSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_unicolorshader.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_utils.js":
/*!***********************************!*\
  !*** ./src/core/cgl/cgl_utils.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEG2RAD\": () => (/* binding */ DEG2RAD),\n/* harmony export */   \"RAD2DEG\": () => (/* binding */ RAD2DEG),\n/* harmony export */   \"escapeHTML\": () => (/* binding */ escapeHTML),\n/* harmony export */   \"getWheelDelta\": () => (/* binding */ getWheelDelta),\n/* harmony export */   \"getWheelSpeed\": () => (/* binding */ getWheelSpeed),\n/* harmony export */   \"isWindows\": () => (/* binding */ isWindows),\n/* harmony export */   \"onLoadingAssetsFinished\": () => (/* binding */ onLoadingAssetsFinished)\n/* harmony export */ });\n/** @namespace CGL */\n\n/**\n * multiply to get radians from degree, e.g. `360 * CGL.DEG2RAD`\n * @const {Number}\n * @memberof CGL\n * @static\n */\nconst DEG2RAD = Math.PI / 180.0;\n\n/**\n * to get degrees from radians, e.g. `3.14 * CGL.RAD2DEG`\n * @const {number}\n * @memberof CGL\n */\nconst RAD2DEG = 180.0 / Math.PI;\n\nconst onLoadingAssetsFinished = null; // deprecated / remove later\n\n/**\n * get normalized mouse wheel delta (including browser specific adjustment)\n * @function getWheelDelta\n * @static\n * @memberof CGL\n * @param {MouseEvent} event\n * @return {Number} normalized delta\n */\nconst isWindows = window.navigator.userAgent.indexOf(\"Windows\") != -1;\nconst getWheelDelta_ = function (event)\n{\n    let normalized;\n    if (event.wheelDelta)\n    {\n        // chrome\n        normalized = (event.wheelDelta % 120) - 0 == -0 ? event.wheelDelta / 120 : event.wheelDelta / 30;\n        normalized *= -1.5;\n        if (isWindows) normalized *= 2;\n    }\n    else\n    {\n        // firefox\n        let d = event.deltaY;\n        if (event.shiftKey) d = event.deltaX;\n        const rawAmmount = d || event.detail;\n        normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);\n        normalized *= -3;\n    }\n\n    if (normalized > 20) normalized = 20;\n    if (normalized < -20) normalized = -20;\n\n    return normalized;\n};\n\nconst getWheelSpeed = getWheelDelta_;\nconst getWheelDelta = getWheelDelta_;\n\n// from https://github.com/lodash/lodash/blob/master/escape.js\n\nconst htmlEscapes = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"\\\"\": \"&quot;\",\n    \"'\": \"&#39;\",\n};\n\n/** Used to match HTML entities and HTML characters. */\nconst reUnescapedHtml = /[&<>\"']/g;\nconst reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n/*  eslint-disable */\nconst escapeHTML = function(string)\n{\n    return string && reHasUnescapedHtml.test(string) ?\n        string.replace(reUnescapedHtml, function(chr) { return htmlEscapes[chr]; })\n        : string || \"\";\n}\n/* eslint-enable */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfdXRpbHMuanM/YzkyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG5hbWVzcGFjZSBDR0wgKi9cblxuLyoqXG4gKiBtdWx0aXBseSB0byBnZXQgcmFkaWFucyBmcm9tIGRlZ3JlZSwgZS5nLiBgMzYwICogQ0dMLkRFRzJSQURgXG4gKiBAY29uc3Qge051bWJlcn1cbiAqIEBtZW1iZXJvZiBDR0xcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLjA7XG5cbi8qKlxuICogdG8gZ2V0IGRlZ3JlZXMgZnJvbSByYWRpYW5zLCBlLmcuIGAzLjE0ICogQ0dMLlJBRDJERUdgXG4gKiBAY29uc3Qge251bWJlcn1cbiAqIEBtZW1iZXJvZiBDR0xcbiAqL1xuZXhwb3J0IGNvbnN0IFJBRDJERUcgPSAxODAuMCAvIE1hdGguUEk7XG5cbmV4cG9ydCBjb25zdCBvbkxvYWRpbmdBc3NldHNGaW5pc2hlZCA9IG51bGw7IC8vIGRlcHJlY2F0ZWQgLyByZW1vdmUgbGF0ZXJcblxuLyoqXG4gKiBnZXQgbm9ybWFsaXplZCBtb3VzZSB3aGVlbCBkZWx0YSAoaW5jbHVkaW5nIGJyb3dzZXIgc3BlY2lmaWMgYWRqdXN0bWVudClcbiAqIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgQ0dMXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG5vcm1hbGl6ZWQgZGVsdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGlzV2luZG93cyA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJXaW5kb3dzXCIpICE9IC0xO1xuY29uc3QgZ2V0V2hlZWxEZWx0YV8gPSBmdW5jdGlvbiAoZXZlbnQpXG57XG4gICAgbGV0IG5vcm1hbGl6ZWQ7XG4gICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpXG4gICAge1xuICAgICAgICAvLyBjaHJvbWVcbiAgICAgICAgbm9ybWFsaXplZCA9IChldmVudC53aGVlbERlbHRhICUgMTIwKSAtIDAgPT0gLTAgPyBldmVudC53aGVlbERlbHRhIC8gMTIwIDogZXZlbnQud2hlZWxEZWx0YSAvIDMwO1xuICAgICAgICBub3JtYWxpemVkICo9IC0xLjU7XG4gICAgICAgIGlmIChpc1dpbmRvd3MpIG5vcm1hbGl6ZWQgKj0gMjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gZmlyZWZveFxuICAgICAgICBsZXQgZCA9IGV2ZW50LmRlbHRhWTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBkID0gZXZlbnQuZGVsdGFYO1xuICAgICAgICBjb25zdCByYXdBbW1vdW50ID0gZCB8fCBldmVudC5kZXRhaWw7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSAtKHJhd0FtbW91bnQgJSAzID8gcmF3QW1tb3VudCAqIDEwIDogcmF3QW1tb3VudCAvIDMpO1xuICAgICAgICBub3JtYWxpemVkICo9IC0zO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkID4gMjApIG5vcm1hbGl6ZWQgPSAyMDtcbiAgICBpZiAobm9ybWFsaXplZCA8IC0yMCkgbm9ybWFsaXplZCA9IC0yMDtcblxuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFdoZWVsU3BlZWQgPSBnZXRXaGVlbERlbHRhXztcbmV4cG9ydCBjb25zdCBnZXRXaGVlbERlbHRhID0gZ2V0V2hlZWxEZWx0YV87XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvZXNjYXBlLmpzXG5cbmNvbnN0IGh0bWxFc2NhcGVzID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImIzM5O1wiLFxufTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuY29uc3QgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2c7XG5jb25zdCByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qICBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZUhUTUwgPSBmdW5jdGlvbihzdHJpbmcpXG57XG4gICAgcmV0dXJuIHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpID9cbiAgICAgICAgc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGh0bWxFc2NhcGVzW2Nocl07IH0pXG4gICAgICAgIDogc3RyaW5nIHx8IFwiXCI7XG59XG4vKiBlc2xpbnQtZW5hYmxlICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_utils.js\n");

/***/ }),

/***/ "./src/core/cgl/constants.js":
/*!***********************************!*\
  !*** ./src/core/cgl/constants.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS)\n/* harmony export */ });\nconst SHADER = {\n    // default attributes\n    \"SHADERVAR_VERTEX_POSITION\": \"vPosition\",\n    \"SHADERVAR_VERTEX_NUMBER\": \"attrVertIndex\",\n    \"SHADERVAR_VERTEX_NORMAL\": \"attrVertNormal\",\n    \"SHADERVAR_VERTEX_TEXCOORD\": \"attrTexCoord\",\n    \"SHADERVAR_INSTANCE_MMATRIX\": \"instMat\",\n    \"SHADERVAR_VERTEX_COLOR\": \"attrVertColor\",\n\n    \"SHADERVAR_INSTANCE_INDEX\": \"instanceIndex\",\n\n    // default uniforms\n    \"SHADERVAR_UNI_PROJMAT\": \"projMatrix\",\n    \"SHADERVAR_UNI_VIEWMAT\": \"viewMatrix\",\n    \"SHADERVAR_UNI_MODELMAT\": \"modelMatrix\",\n    \"SHADERVAR_UNI_NORMALMAT\": \"normalMatrix\",\n    \"SHADERVAR_UNI_INVVIEWMAT\": \"inverseViewMatrix\",\n    \"SHADERVAR_UNI_INVPROJMAT\": \"invProjMatrix\",\n    \"SHADERVAR_UNI_MATERIALID\": \"materialId\",\n    \"SHADERVAR_UNI_OBJECTID\": \"objectId\",\n\n    \"SHADERVAR_UNI_VIEWPOS\": \"camPos\",\n};\n\n\nconst BLEND_MODES = {\n    \"BLEND_NONE\": 0,\n    \"BLEND_NORMAL\": 1,\n    \"BLEND_ADD\": 2,\n    \"BLEND_SUB\": 3,\n    \"BLEND_MUL\": 4,\n};\n\n\n\n\n\nconst RAD2DEG = 180.0 / Math.PI;\nconst DEG2RAD = Math.PI / 180.0;\n\nconst CONSTANTS = {\n    \"MATH\": {\n        \"DEG2RAD\": DEG2RAD,\n        \"RAD2DEG\": RAD2DEG,\n    },\n    \"SHADER\": SHADER,\n    \"BLEND_MODES\": BLEND_MODES,\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY29uc3RhbnRzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY29uc3RhbnRzLmpzPzhkNWIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU0hBREVSID0ge1xuICAgIC8vIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgIFwiU0hBREVSVkFSX1ZFUlRFWF9QT1NJVElPTlwiOiBcInZQb3NpdGlvblwiLFxuICAgIFwiU0hBREVSVkFSX1ZFUlRFWF9OVU1CRVJcIjogXCJhdHRyVmVydEluZGV4XCIsXG4gICAgXCJTSEFERVJWQVJfVkVSVEVYX05PUk1BTFwiOiBcImF0dHJWZXJ0Tm9ybWFsXCIsXG4gICAgXCJTSEFERVJWQVJfVkVSVEVYX1RFWENPT1JEXCI6IFwiYXR0clRleENvb3JkXCIsXG4gICAgXCJTSEFERVJWQVJfSU5TVEFOQ0VfTU1BVFJJWFwiOiBcImluc3RNYXRcIixcbiAgICBcIlNIQURFUlZBUl9WRVJURVhfQ09MT1JcIjogXCJhdHRyVmVydENvbG9yXCIsXG5cbiAgICBcIlNIQURFUlZBUl9JTlNUQU5DRV9JTkRFWFwiOiBcImluc3RhbmNlSW5kZXhcIixcblxuICAgIC8vIGRlZmF1bHQgdW5pZm9ybXNcbiAgICBcIlNIQURFUlZBUl9VTklfUFJPSk1BVFwiOiBcInByb2pNYXRyaXhcIixcbiAgICBcIlNIQURFUlZBUl9VTklfVklFV01BVFwiOiBcInZpZXdNYXRyaXhcIixcbiAgICBcIlNIQURFUlZBUl9VTklfTU9ERUxNQVRcIjogXCJtb2RlbE1hdHJpeFwiLFxuICAgIFwiU0hBREVSVkFSX1VOSV9OT1JNQUxNQVRcIjogXCJub3JtYWxNYXRyaXhcIixcbiAgICBcIlNIQURFUlZBUl9VTklfSU5WVklFV01BVFwiOiBcImludmVyc2VWaWV3TWF0cml4XCIsXG4gICAgXCJTSEFERVJWQVJfVU5JX0lOVlBST0pNQVRcIjogXCJpbnZQcm9qTWF0cml4XCIsXG4gICAgXCJTSEFERVJWQVJfVU5JX01BVEVSSUFMSURcIjogXCJtYXRlcmlhbElkXCIsXG4gICAgXCJTSEFERVJWQVJfVU5JX09CSkVDVElEXCI6IFwib2JqZWN0SWRcIixcblxuICAgIFwiU0hBREVSVkFSX1VOSV9WSUVXUE9TXCI6IFwiY2FtUG9zXCIsXG59O1xuXG5cbmNvbnN0IEJMRU5EX01PREVTID0ge1xuICAgIFwiQkxFTkRfTk9ORVwiOiAwLFxuICAgIFwiQkxFTkRfTk9STUFMXCI6IDEsXG4gICAgXCJCTEVORF9BRERcIjogMixcbiAgICBcIkJMRU5EX1NVQlwiOiAzLFxuICAgIFwiQkxFTkRfTVVMXCI6IDQsXG59O1xuXG5cblxuXG5cbmNvbnN0IFJBRDJERUcgPSAxODAuMCAvIE1hdGguUEk7XG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MC4wO1xuXG5jb25zdCBDT05TVEFOVFMgPSB7XG4gICAgXCJNQVRIXCI6IHtcbiAgICAgICAgXCJERUcyUkFEXCI6IERFRzJSQUQsXG4gICAgICAgIFwiUkFEMkRFR1wiOiBSQUQyREVHLFxuICAgIH0sXG4gICAgXCJTSEFERVJcIjogU0hBREVSLFxuICAgIFwiQkxFTkRfTU9ERVNcIjogQkxFTkRfTU9ERVMsXG59O1xuXG5cbmV4cG9ydCB7IENPTlNUQU5UUyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/constants.js\n");

/***/ }),

/***/ "./src/core/cgl/index.js":
/*!*******************************!*\
  !*** ./src/core/cgl/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CGL\": () => (/* binding */ CGL)\n/* harmony export */ });\n/* harmony import */ var _cgl_framebuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_framebuffer */ \"./src/core/cgl/cgl_framebuffer.js\");\n/* harmony import */ var _cgl_framebuffer2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_framebuffer2 */ \"./src/core/cgl/cgl_framebuffer2.js\");\n/* harmony import */ var _cgl_marker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_marker */ \"./src/core/cgl/cgl_marker.js\");\n/* harmony import */ var _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_mesh */ \"./src/core/cgl/cgl_mesh.js\");\n/* harmony import */ var _cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cgl_shader_uniform */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _cgl_shader_lib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cgl_shader_lib */ \"./src/core/cgl/cgl_shader_lib.js\");\n/* harmony import */ var _cgl_unicolorshader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cgl_unicolorshader */ \"./src/core/cgl/cgl_unicolorshader.js\");\n/* harmony import */ var _cgl_shader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cgl_shader */ \"./src/core/cgl/cgl_shader.js\");\n/* harmony import */ var _cgl_simplerect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cgl_simplerect */ \"./src/core/cgl/cgl_simplerect.js\");\n/* harmony import */ var _cgl_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cgl_state */ \"./src/core/cgl/cgl_state.js\");\n/* harmony import */ var _cgl_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cgl_utils */ \"./src/core/cgl/cgl_utils.js\");\n/* harmony import */ var _cgl_texture__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cgl_texture */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _cgl_textureeffect__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cgl_textureeffect */ \"./src/core/cgl/cgl_textureeffect.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./constants */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_profiledata__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cgl_profiledata */ \"./src/core/cgl/cgl_profiledata.js\");\n/* harmony import */ var _cg_cg_matrixstack__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../cg/cg_matrixstack */ \"./src/core/cg/cg_matrixstack.js\");\n/* harmony import */ var _cg_cg_geom__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../cg/cg_geom */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _cg_cg_boundingbox__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../cg/cg_boundingbox */ \"./src/core/cg/cg_boundingbox.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst CGL = {\n    \"Framebuffer\": _cgl_framebuffer__WEBPACK_IMPORTED_MODULE_0__.Framebuffer,\n    \"Framebuffer2\": _cgl_framebuffer2__WEBPACK_IMPORTED_MODULE_1__.Framebuffer2,\n    \"Geometry\": _cg_cg_geom__WEBPACK_IMPORTED_MODULE_16__.Geometry,\n    \"BoundingBox\": _cg_cg_boundingbox__WEBPACK_IMPORTED_MODULE_17__.BoundingBox,\n    \"Marker\": _cgl_marker__WEBPACK_IMPORTED_MODULE_2__.Marker,\n    \"WirePoint\": _cgl_marker__WEBPACK_IMPORTED_MODULE_2__.WirePoint,\n    \"WireCube\": _cgl_marker__WEBPACK_IMPORTED_MODULE_2__.WireCube,\n    \"MatrixStack\": _cg_cg_matrixstack__WEBPACK_IMPORTED_MODULE_15__.MatrixStack,\n    \"Mesh\": _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__.Mesh,\n    \"MESH\": _cgl_mesh__WEBPACK_IMPORTED_MODULE_3__.MESH,\n    \"ShaderLibMods\": _cgl_shader_lib__WEBPACK_IMPORTED_MODULE_5__.ShaderLibMods,\n    \"Shader\": _cgl_shader__WEBPACK_IMPORTED_MODULE_7__.Shader,\n    \"Uniform\": _cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_4__.Uniform,\n    \"MESHES\": _cgl_simplerect__WEBPACK_IMPORTED_MODULE_8__.MESHES,\n    \"Context\": _cgl_state__WEBPACK_IMPORTED_MODULE_9__.Context,\n    \"Texture\": _cgl_texture__WEBPACK_IMPORTED_MODULE_11__.Texture,\n    \"TextureEffect\": _cgl_textureeffect__WEBPACK_IMPORTED_MODULE_12__.TextureEffect,\n    \"isWindows\": _cgl_utils__WEBPACK_IMPORTED_MODULE_10__.isWindows,\n    \"getWheelSpeed\": _cgl_utils__WEBPACK_IMPORTED_MODULE_10__.getWheelSpeed,\n    \"getWheelDelta\": _cgl_utils__WEBPACK_IMPORTED_MODULE_10__.getWheelDelta,\n    \"onLoadingAssetsFinished\": _cgl_utils__WEBPACK_IMPORTED_MODULE_10__.onLoadingAssetsFinished,\n    \"ProfileData\": _cgl_profiledata__WEBPACK_IMPORTED_MODULE_14__.ProfileData,\n    \"UniColorShader\": _cgl_unicolorshader__WEBPACK_IMPORTED_MODULE_6__.UniColorShader,\n    ..._constants__WEBPACK_IMPORTED_MODULE_13__.CONSTANTS.BLEND_MODES,\n    ..._constants__WEBPACK_IMPORTED_MODULE_13__.CONSTANTS.SHADER,\n    ..._constants__WEBPACK_IMPORTED_MODULE_13__.CONSTANTS.MATH,\n    ..._constants__WEBPACK_IMPORTED_MODULE_13__.CONSTANTS.BLEND_MODES,\n};\n\nwindow.CGL = CGL;\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9pbmRleC5qcz82NjE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZyYW1lYnVmZmVyIH0gZnJvbSBcIi4vY2dsX2ZyYW1lYnVmZmVyXCI7XG5pbXBvcnQgeyBGcmFtZWJ1ZmZlcjIgfSBmcm9tIFwiLi9jZ2xfZnJhbWVidWZmZXIyXCI7XG5pbXBvcnQgeyBNYXJrZXIsIFdpcmVDdWJlLCBXaXJlUG9pbnQgfSBmcm9tIFwiLi9jZ2xfbWFya2VyXCI7XG5pbXBvcnQgeyBNZXNoLCBNRVNIIH0gZnJvbSBcIi4vY2dsX21lc2hcIjtcbmltcG9ydCB7IFVuaWZvcm0gfSBmcm9tIFwiLi9jZ2xfc2hhZGVyX3VuaWZvcm1cIjtcbmltcG9ydCB7IFNoYWRlckxpYk1vZHMgfSBmcm9tIFwiLi9jZ2xfc2hhZGVyX2xpYlwiO1xuaW1wb3J0IHsgVW5pQ29sb3JTaGFkZXIgfSBmcm9tIFwiLi9jZ2xfdW5pY29sb3JzaGFkZXJcIjtcblxuXG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tIFwiLi9jZ2xfc2hhZGVyXCI7XG5pbXBvcnQgeyBNRVNIRVMgfSBmcm9tIFwiLi9jZ2xfc2ltcGxlcmVjdFwiO1xuaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCIuL2NnbF9zdGF0ZVwiO1xuaW1wb3J0IHtcbiAgICBpc1dpbmRvd3MsIGdldFdoZWVsU3BlZWQsIGdldFdoZWVsRGVsdGEsIG9uTG9hZGluZ0Fzc2V0c0ZpbmlzaGVkLFxufSBmcm9tIFwiLi9jZ2xfdXRpbHNcIjtcbmltcG9ydCB7XG4gICAgVGV4dHVyZSxcbn0gZnJvbSBcIi4vY2dsX3RleHR1cmVcIjtcblxuaW1wb3J0IHsgVGV4dHVyZUVmZmVjdCB9IGZyb20gXCIuL2NnbF90ZXh0dXJlZWZmZWN0XCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFByb2ZpbGVEYXRhIH0gZnJvbSBcIi4vY2dsX3Byb2ZpbGVkYXRhXCI7XG5pbXBvcnQgeyBNYXRyaXhTdGFjayB9IGZyb20gXCIuLi9jZy9jZ19tYXRyaXhzdGFja1wiO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tIFwiLi4vY2cvY2dfZ2VvbVwiO1xuaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tIFwiLi4vY2cvY2dfYm91bmRpbmdib3hcIjtcblxuY29uc3QgQ0dMID0ge1xuICAgIFwiRnJhbWVidWZmZXJcIjogRnJhbWVidWZmZXIsXG4gICAgXCJGcmFtZWJ1ZmZlcjJcIjogRnJhbWVidWZmZXIyLFxuICAgIFwiR2VvbWV0cnlcIjogR2VvbWV0cnksXG4gICAgXCJCb3VuZGluZ0JveFwiOiBCb3VuZGluZ0JveCxcbiAgICBcIk1hcmtlclwiOiBNYXJrZXIsXG4gICAgXCJXaXJlUG9pbnRcIjogV2lyZVBvaW50LFxuICAgIFwiV2lyZUN1YmVcIjogV2lyZUN1YmUsXG4gICAgXCJNYXRyaXhTdGFja1wiOiBNYXRyaXhTdGFjayxcbiAgICBcIk1lc2hcIjogTWVzaCxcbiAgICBcIk1FU0hcIjogTUVTSCxcbiAgICBcIlNoYWRlckxpYk1vZHNcIjogU2hhZGVyTGliTW9kcyxcbiAgICBcIlNoYWRlclwiOiBTaGFkZXIsXG4gICAgXCJVbmlmb3JtXCI6IFVuaWZvcm0sXG4gICAgXCJNRVNIRVNcIjogTUVTSEVTLFxuICAgIFwiQ29udGV4dFwiOiBDb250ZXh0LFxuICAgIFwiVGV4dHVyZVwiOiBUZXh0dXJlLFxuICAgIFwiVGV4dHVyZUVmZmVjdFwiOiBUZXh0dXJlRWZmZWN0LFxuICAgIFwiaXNXaW5kb3dzXCI6IGlzV2luZG93cyxcbiAgICBcImdldFdoZWVsU3BlZWRcIjogZ2V0V2hlZWxTcGVlZCxcbiAgICBcImdldFdoZWVsRGVsdGFcIjogZ2V0V2hlZWxEZWx0YSxcbiAgICBcIm9uTG9hZGluZ0Fzc2V0c0ZpbmlzaGVkXCI6IG9uTG9hZGluZ0Fzc2V0c0ZpbmlzaGVkLFxuICAgIFwiUHJvZmlsZURhdGFcIjogUHJvZmlsZURhdGEsXG4gICAgXCJVbmlDb2xvclNoYWRlclwiOiBVbmlDb2xvclNoYWRlcixcbiAgICAuLi5DT05TVEFOVFMuQkxFTkRfTU9ERVMsXG4gICAgLi4uQ09OU1RBTlRTLlNIQURFUixcbiAgICAuLi5DT05TVEFOVFMuTUFUSCxcbiAgICAuLi5DT05TVEFOVFMuQkxFTkRfTU9ERVMsXG59O1xuXG53aW5kb3cuQ0dMID0gQ0dMO1xuXG5leHBvcnQgeyBDR0wgfTtcblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/index.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_mesh.js":
/*!**********************************!*\
  !*** ./src/core/cgp/cgp_mesh.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _cgp_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgp_pipeline */ \"./src/core/cgp/cgp_pipeline.js\");\n\n\n\nclass Mesh\n{\n    constructor(_cgp, __geom)\n    {\n        this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_mesh\");\n        this._cgp = _cgp;\n        this._geom = null;\n        this.numIndex = 0;\n\n        this._pipe = new _cgp_pipeline__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this._cgp);\n\n        this._numNonIndexed = 0;\n        this._positionBuffer = null;\n        this._bufVerticesIndizes = null;\n        this._attributes = [];\n\n        this._needsPipelineUpdate = false;\n\n        if (__geom) this.setGeom(__geom);\n    }\n\n    _createBuffer(device, data, usage)\n    {\n        const buffer = device.createBuffer({\n            \"size\": data.byteLength,\n            \"usage\": usage,\n            \"mappedAtCreation\": true,\n        });\n        const dst = new data.constructor(buffer.getMappedRange());\n        dst.set(data);\n        buffer.unmap();\n        return buffer;\n    }\n\n    /**\n     * @function setGeom\n     * @memberof Mesh\n     * @instance\n     * @description set geometry for mesh\n     * @param {Geometry} geometry\n     */\n    setGeom(geom, removeRef)\n    {\n        this._needsPipelineUpdate = true;\n        this._geom = geom;\n        this._disposeAttributes();\n\n        this._positionBuffer = this._createBuffer(this._cgp.device, new Float32Array(geom.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);\n\n        let vi = geom.verticesIndices;\n        if (!geom.isIndexed()) vi = Array.from(Array(geom.vertices.length / 3).keys());\n        this._numIndices = vi.length;\n        this._indicesBuffer = this._createBuffer(this._cgp.device, new Uint32Array(vi), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);\n\n        if (geom.texCoords && geom.texCoords.length) this.setAttribute(\"texCoords\", geom.texCoords, 2);\n        if (geom.vertexNormals && geom.vertexNormals.length) this.setAttribute(\"normals\", geom.vertexNormals, 3);\n    }\n\n\n    _disposeAttributes()\n    {\n        this._needsPipelineUpdate = true;\n        for (let i = 0; i < this._attributes.length; i++)\n        {\n            this._attributes[i].buffer.destroy();\n        }\n        this._attributes.length = 0;\n    }\n\n    dispose()\n    {\n        this._disposeAttributes();\n    }\n\n    /**\n     * @function setAttribute\n     * @description update attribute\n     * @memberof Mesh\n     * @instance\n     * @param {String} attribute name\n     * @param {Array} data\n     * @param {Number} itemSize\n     * @param {Object} options\n     */\n    setAttribute(name, array, itemSize, options)\n    {\n        if (!array)\n        {\n            this._log.error(\"mesh addAttribute - no array given! \" + name);\n            throw new Error();\n        }\n\n        for (let i = 0; i < this._attributes.length; i++)\n        {\n            const attr = this._attributes[i];\n            if (attr.name == name)\n            {\n                // if (attr.numItems === numItems)\n                // {\n                // }\n                // else\n                // {\n                //     // this._log.log(\"wrong buffer size\", this._geom.name, attr.name, attr.numItems, numItems);\n                //     this._resizeAttr(array, attr);\n                // }\n                // normalBuffer = this._createBuffer(this._cgp.device, new Float32Array(geom.vertexNormals), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);\n\n                // this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n                // this._bufferArray(array, attr);\n\n                return attr;\n            }\n        }\n\n        const buffer = this._createBuffer(this._cgp.device, new Float32Array(array), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);\n\n        const attr = {\n            \"buffer\": buffer,\n            \"name\": name,\n            // \"cb\": cb,\n            // \"itemSize\": itemSize,\n            // \"numItems\": numItems,\n            // \"startItem\": 0,\n            // \"instanced\": instanced,\n            // \"type\": type\n        };\n        this._attributes.push(attr);\n\n        return attr;\n    }\n\n    // setPipeline()\n    // {\n\n    //     this._cgp.passEncoder.setPipeline(this._pipe.getPiplelineObject(this._cgp.getShader(),this));\n\n\n    // }\n\n    render()\n    {\n        if (!this._positionBuffer) return;\n\n        // this.setPipeline();\n\n        const shader = this._cgp.getShader();\n        if (shader)shader.bind();\n\n        if (!this._cgp.getShader() || !this._cgp.getShader().isValid)\n        {\n            // console.log(\"invalid\");\n            return;\n        }\n\n        this._pipe.setPipeline(this._cgp.getShader(), this);\n\n        if (!this._pipe.isValid)\n        {\n            // console.log(\"invalid\");\n            return;\n        }\n\n\n        this._cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);\n        for (let i = 0; i < this._attributes.length; i++)\n        {\n            this._cgp.passEncoder.setVertexBuffer(i + 1, this._attributes[i].buffer);\n        }\n\n        this._cgp.passEncoder.setIndexBuffer(this._indicesBuffer, \"uint32\");\n\n        if (this._numNonIndexed)\n            this._cgp.passEncoder.draw(this._numIndices);\n        else\n            this._cgp.passEncoder.drawIndexed(this._numIndices);\n\n        // if (shader)shader.unbind();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX21lc2guanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NncC9jZ3BfbWVzaC5qcz84YzgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5pbXBvcnQgUGlwZWxpbmUgZnJvbSBcIi4vY2dwX3BpcGVsaW5lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc2hcbntcbiAgICBjb25zdHJ1Y3RvcihfY2dwLCBfX2dlb20pXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY2dsX21lc2hcIik7XG4gICAgICAgIHRoaXMuX2NncCA9IF9jZ3A7XG4gICAgICAgIHRoaXMuX2dlb20gPSBudWxsO1xuICAgICAgICB0aGlzLm51bUluZGV4ID0gMDtcblxuICAgICAgICB0aGlzLl9waXBlID0gbmV3IFBpcGVsaW5lKHRoaXMuX2NncCk7XG5cbiAgICAgICAgdGhpcy5fbnVtTm9uSW5kZXhlZCA9IDA7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX25lZWRzUGlwZWxpbmVVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX19nZW9tKSB0aGlzLnNldEdlb20oX19nZW9tKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQnVmZmVyKGRldmljZSwgZGF0YSwgdXNhZ2UpXG4gICAge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIFwic2l6ZVwiOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBcInVzYWdlXCI6IHVzYWdlLFxuICAgICAgICAgICAgXCJtYXBwZWRBdENyZWF0aW9uXCI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkc3QgPSBuZXcgZGF0YS5jb25zdHJ1Y3RvcihidWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICAgIGRzdC5zZXQoZGF0YSk7XG4gICAgICAgIGJ1ZmZlci51bm1hcCgpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzZXRHZW9tXG4gICAgICogQG1lbWJlcm9mIE1lc2hcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gc2V0IGdlb21ldHJ5IGZvciBtZXNoXG4gICAgICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAgICAgKi9cbiAgICBzZXRHZW9tKGdlb20sIHJlbW92ZVJlZilcbiAgICB7XG4gICAgICAgIHRoaXMuX25lZWRzUGlwZWxpbmVVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9nZW9tID0gZ2VvbTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZUF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB0aGlzLl9wb3NpdGlvbkJ1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgRmxvYXQzMkFycmF5KGdlb20udmVydGljZXMpLCBHUFVCdWZmZXJVc2FnZS5WRVJURVggfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk7XG5cbiAgICAgICAgbGV0IHZpID0gZ2VvbS52ZXJ0aWNlc0luZGljZXM7XG4gICAgICAgIGlmICghZ2VvbS5pc0luZGV4ZWQoKSkgdmkgPSBBcnJheS5mcm9tKEFycmF5KGdlb20udmVydGljZXMubGVuZ3RoIC8gMykua2V5cygpKTtcbiAgICAgICAgdGhpcy5fbnVtSW5kaWNlcyA9IHZpLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faW5kaWNlc0J1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgVWludDMyQXJyYXkodmkpLCBHUFVCdWZmZXJVc2FnZS5JTkRFWCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTtcblxuICAgICAgICBpZiAoZ2VvbS50ZXhDb29yZHMgJiYgZ2VvbS50ZXhDb29yZHMubGVuZ3RoKSB0aGlzLnNldEF0dHJpYnV0ZShcInRleENvb3Jkc1wiLCBnZW9tLnRleENvb3JkcywgMik7XG4gICAgICAgIGlmIChnZW9tLnZlcnRleE5vcm1hbHMgJiYgZ2VvbS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJub3JtYWxzXCIsIGdlb20udmVydGV4Tm9ybWFscywgMyk7XG4gICAgfVxuXG5cbiAgICBfZGlzcG9zZUF0dHJpYnV0ZXMoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbmVlZHNQaXBlbGluZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tpXS5idWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBkaXNwb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNldEF0dHJpYnV0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgYXR0cmlidXRlXG4gICAgICogQG1lbWJlcm9mIE1lc2hcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1TaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUobmFtZSwgYXJyYXksIGl0ZW1TaXplLCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwibWVzaCBhZGRBdHRyaWJ1dGUgLSBubyBhcnJheSBnaXZlbiEgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5fYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYXR0ci5udW1JdGVtcyA9PT0gbnVtSXRlbXMpXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyB0aGlzLl9sb2cubG9nKFwid3JvbmcgYnVmZmVyIHNpemVcIiwgdGhpcy5fZ2VvbS5uYW1lLCBhdHRyLm5hbWUsIGF0dHIubnVtSXRlbXMsIG51bUl0ZW1zKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5fcmVzaXplQXR0cihhcnJheSwgYXR0cik7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbEJ1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgRmxvYXQzMkFycmF5KGdlb20udmVydGV4Tm9ybWFscyksIEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGF0dHIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9idWZmZXJBcnJheShhcnJheSwgYXR0cik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSwgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpO1xuXG4gICAgICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICAgICAgICBcImJ1ZmZlclwiOiBidWZmZXIsXG4gICAgICAgICAgICBcIm5hbWVcIjogbmFtZSxcbiAgICAgICAgICAgIC8vIFwiY2JcIjogY2IsXG4gICAgICAgICAgICAvLyBcIml0ZW1TaXplXCI6IGl0ZW1TaXplLFxuICAgICAgICAgICAgLy8gXCJudW1JdGVtc1wiOiBudW1JdGVtcyxcbiAgICAgICAgICAgIC8vIFwic3RhcnRJdGVtXCI6IDAsXG4gICAgICAgICAgICAvLyBcImluc3RhbmNlZFwiOiBpbnN0YW5jZWQsXG4gICAgICAgICAgICAvLyBcInR5cGVcIjogdHlwZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG5cbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuXG4gICAgLy8gc2V0UGlwZWxpbmUoKVxuICAgIC8vIHtcblxuICAgIC8vICAgICB0aGlzLl9jZ3AucGFzc0VuY29kZXIuc2V0UGlwZWxpbmUodGhpcy5fcGlwZS5nZXRQaXBsZWxpbmVPYmplY3QodGhpcy5fY2dwLmdldFNoYWRlcigpLHRoaXMpKTtcblxuXG4gICAgLy8gfVxuXG4gICAgcmVuZGVyKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fcG9zaXRpb25CdWZmZXIpIHJldHVybjtcblxuICAgICAgICAvLyB0aGlzLnNldFBpcGVsaW5lKCk7XG5cbiAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fY2dwLmdldFNoYWRlcigpO1xuICAgICAgICBpZiAoc2hhZGVyKXNoYWRlci5iaW5kKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jZ3AuZ2V0U2hhZGVyKCkgfHwgIXRoaXMuX2NncC5nZXRTaGFkZXIoKS5pc1ZhbGlkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImludmFsaWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9waXBlLnNldFBpcGVsaW5lKHRoaXMuX2NncC5nZXRTaGFkZXIoKSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9waXBlLmlzVmFsaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW52YWxpZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcigwLCB0aGlzLl9wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihpICsgMSwgdGhpcy5fYXR0cmlidXRlc1tpXS5idWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldEluZGV4QnVmZmVyKHRoaXMuX2luZGljZXNCdWZmZXIsIFwidWludDMyXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9udW1Ob25JbmRleGVkKVxuICAgICAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLmRyYXcodGhpcy5fbnVtSW5kaWNlcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX2NncC5wYXNzRW5jb2Rlci5kcmF3SW5kZXhlZCh0aGlzLl9udW1JbmRpY2VzKTtcblxuICAgICAgICAvLyBpZiAoc2hhZGVyKXNoYWRlci51bmJpbmQoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_mesh.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_pipeline.js":
/*!**************************************!*\
  !*** ./src/core/cgp/cgp_pipeline.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pipeline)\n/* harmony export */ });\n/* harmony import */ var _cgl_cgl_shader_uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cgl/cgl_shader_uniform */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _cgp_uniformbuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgp_uniformbuffer */ \"./src/core/cgp/cgp_uniformbuffer.js\");\n\n\n\nclass Pipeline\n{\n    constructor(_cgp, _name)\n    {\n        if (!_cgp) throw new Error(\"Pipeline constructed without cgp \" + _name);\n        this._cgp = _cgp;\n        this._isValid = true;\n\n        this._pipeCfg = null;\n        this._renderPipeline = null;\n\n        this._fsUniformBuffer = null;\n        this._vsUniformBuffer = null;\n\n        this._old = {};\n\n\n        this.DEPTH_COMPARE_FUNCS_STRINGS = [\n            \"never\",\n            \"less\",\n            \"equal\",\n            \"lessequal\",\n            \"greater\",\n            \"notequal\",\n            \"greaterequal\",\n            \"always\"];\n    }\n\n    get isValid() { return this._isValid; }\n\n    setPipeline(shader, mesh)\n    {\n        if (!mesh || !shader)\n        {\n            console.log(\"pipeline unknown shader/mesh\");\n            return;\n        }\n\n        let needsRebuild =\n            !this._renderPipeline ||\n            !this._pipeCfg ||\n            this._old.mesh != mesh ||\n            this._old.shader != shader ||\n            mesh.needsPipelineUpdate ||\n            shader.needsPipelineUpdate;\n\n        if (this._pipeCfg)\n        {\n            if (this._pipeCfg.depthStencil.depthWriteEnabled != this._cgp.stateDepthWrite())\n            {\n                needsRebuild = true;\n                this._pipeCfg.depthStencil.depthWriteEnabled = this._cgp.stateDepthWrite();\n            }\n\n            if (this._cgp.stateDepthTest() === false)\n            {\n                if (this._pipeCfg.depthStencil.depthCompare != \"never\")\n                {\n                    this._pipeCfg.depthStencil.depthCompare = \"never\";\n                    needsRebuild = true;\n                }\n            }\n            else\n            if (this._pipeCfg.depthStencil.depthCompare != this._cgp.stateDepthFunc())\n            {\n                needsRebuild = true;\n                this._pipeCfg.depthStencil.depthCompare = this._cgp.stateDepthFunc();\n            }\n\n\n            if (this._cgp.stateCullFace() === false)\n            {\n                if (this._pipeCfg.primitive.cullMode != \"none\")\n                {\n                    needsRebuild = true;\n                    this._pipeCfg.primitive.cullMode = \"none\";\n                }\n            }\n            else\n            {\n                needsRebuild = true;\n                this._pipeCfg.primitive.cullMode = this._cgp.stateCullFaceFacing();\n            }\n        }\n\n        if (needsRebuild)\n        {\n            if (!this._pipeCfg || this._old.shader != shader) this._pipeCfg = this.getPiplelineObject(shader, mesh);\n\n            this._old.shader = shader;\n            this._old.mesh = mesh;\n\n\n            // try\n            // {\n            this._renderPipeline = this._cgp.device.createRenderPipeline(this._pipeCfg);\n            // }\n            // catch (e)\n            // {\n            //     console.error(e.message);\n            // }\n\n            this._bindUniforms(shader);\n        }\n\n        if (this._renderPipeline && this._isValid)\n        {\n            mat4.copy(this._matModel, this._cgp.mMatrix);\n            mat4.copy(this._matView, this._cgp.vMatrix);\n            mat4.copy(this._matProj, this._cgp.pMatrix);\n\n            this._cgp.device.queue.writeBuffer(\n                this._vsUniformBuffer,\n                0,\n                this._vsUniformValues.buffer,\n                this._vsUniformValues.byteOffset,\n                this._vsUniformValues.byteLength\n            );\n\n            this._uniBufFrag.updateUniformValues();\n\n            this._cgp.passEncoder.setPipeline(this._renderPipeline);\n            this._cgp.passEncoder.setBindGroup(0, this._bindGroup);\n            // this._pipeline = this._cgp.device.createRenderPipeline(this._pipeCfg);\n        }\n    }\n\n    getPiplelineObject(shader, mesh)\n    {\n        const pipeCfg = {\n            \"layout\": \"auto\",\n            \"vertex\": {\n                \"module\": shader.shaderModule,\n                \"entryPoint\": \"myVSMain\",\n                \"buffers\": [\n                    // position\n                    {\n                        \"arrayStride\": 3 * 4, // 3 floats, 4 bytes each\n                        \"attributes\": [\n                            { \"shaderLocation\": 0, \"offset\": 0, \"format\": \"float32x3\" },\n                        ],\n                    },\n                    // normals\n                    {\n                        \"arrayStride\": 3 * 4, // 3 floats, 4 bytes each\n                        \"attributes\": [\n                            { \"shaderLocation\": 1, \"offset\": 0, \"format\": \"float32x3\" },\n                        ],\n                    },\n                    // texcoords\n                    {\n                        \"arrayStride\": 2 * 4, // 2 floats, 4 bytes each\n                        \"attributes\": [\n                            { \"shaderLocation\": 2, \"offset\": 0, \"format\": \"float32x2\", },\n                        ],\n                    },\n                ],\n            },\n            \"fragment\": {\n                \"module\": shader.shaderModule,\n                \"entryPoint\": \"myFSMain\",\n                \"targets\": [\n                    { \"format\": this._cgp.presentationFormat },\n                ],\n            },\n            \"primitive\": {\n                \"topology\": \"triangle-list\",\n                \"cullMode\": \"back\", // back/none/front\n\n                // \"point-list\",\n                // \"line-list\",\n                // \"line-strip\",\n                // \"triangle-list\",\n                // \"triangle-strip\"\n            },\n            \"depthStencil\": {\n                \"depthWriteEnabled\": true,\n                \"depthCompare\": \"less\",\n                \"format\": \"depth24plus\",\n            },\n\n        };\n\n        return pipeCfg;\n    }\n\n\n    _bindUniforms(shader)\n    {\n        this._cgp.pushErrorScope();\n\n\n        const counts = { };\n\n        this._uniBufFrag = new _cgp_uniformbuffer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](shader, \"frag\");\n\n        // for (let i = 0; i < shader.uniforms.length; i++)\n        // {\n        //     const uni = shader.uniforms[i];\n        //     const type = uni.shaderType;\n        //     counts[type] = counts[type] || 0;\n\n\n        //     counts[type] += uni.getSizeBytes();\n        // }\n        // console.log(counts, counts.frag);\n\n\n        const vUniformBufferSize = 3 * 16 * 4; // 2 mat4s * 16 floats per mat * 4 bytes per float\n        // const fUniformBufferSize = counts.frag;// 2 * 3 * 4; // 1 vec3 * 3 floats per vec3 * 4 bytes per float\n\n        this._vsUniformBuffer = this._cgp.device.createBuffer({\n            \"size\": vUniformBufferSize,\n            \"usage\": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        // this._fsUniformBuffer = this._cgp.device.createBuffer({\n        //     \"size\": fUniformBufferSize,\n        //     \"usage\": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        // });\n\n        // this._fsUniformValues = new Float32Array(counts.frag / 4);\n\n        this._vsUniformValues = new Float32Array(vUniformBufferSize / 4);\n\n        this._matModel = this._vsUniformValues.subarray(0, 16);\n        this._matView = this._vsUniformValues.subarray(16, 32);\n        this._matProj = this._vsUniformValues.subarray(32, 48);\n\n\n        // this._fsUniformValues[1] = 1.0;\n        // this._fsUniformValues[0] = 1.0;\n        // const lightDirection = this._fsUniformValues.subarray(0, 3);\n\n        // console.log(\"pipeline bindgrouplayout \", pipeline.getBindGroupLayout(0));\n\n        this._bindGroup = this._cgp.device.createBindGroup(\n            {\n                \"layout\": this._renderPipeline.getBindGroupLayout(0),\n                \"entries\": [\n                    { \"binding\": 0, \"resource\": { \"buffer\": this._vsUniformBuffer } },\n                    { \"binding\": 1, \"resource\": { \"buffer\": this._uniBufFrag._gpuBuffer } }\n                    //   { binding: 2, resource: sampler },\n                    //   { binding: 3, resource: tex.createView() },\n                ],\n            });\n\n        this._cgp.device.queue.writeBuffer(\n            this._vsUniformBuffer,\n            0,\n            this._vsUniformValues.buffer,\n            this._vsUniformValues.byteOffset,\n            this._vsUniformValues.byteLength\n        );\n\n        this._uniBufFrag.updateUniformValues();\n        this._cgp.popErrorScope(\"cgp_pipeline end\", (e) =>\n        {\n            this._isValid = false;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3BpcGVsaW5lLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF9waXBlbGluZS5qcz8xMmFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVuaWZvcm0gfSBmcm9tIFwiLi4vY2dsL2NnbF9zaGFkZXJfdW5pZm9ybVwiO1xuaW1wb3J0IFVuaWZvcm1CdWZmZXIgZnJvbSBcIi4vY2dwX3VuaWZvcm1idWZmZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGlwZWxpbmVcbntcbiAgICBjb25zdHJ1Y3RvcihfY2dwLCBfbmFtZSlcbiAgICB7XG4gICAgICAgIGlmICghX2NncCkgdGhyb3cgbmV3IEVycm9yKFwiUGlwZWxpbmUgY29uc3RydWN0ZWQgd2l0aG91dCBjZ3AgXCIgKyBfbmFtZSk7XG4gICAgICAgIHRoaXMuX2NncCA9IF9jZ3A7XG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3BpcGVDZmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW5kZXJQaXBlbGluZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZnNVbmlmb3JtQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdnNVbmlmb3JtQnVmZmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9vbGQgPSB7fTtcblxuXG4gICAgICAgIHRoaXMuREVQVEhfQ09NUEFSRV9GVU5DU19TVFJJTkdTID0gW1xuICAgICAgICAgICAgXCJuZXZlclwiLFxuICAgICAgICAgICAgXCJsZXNzXCIsXG4gICAgICAgICAgICBcImVxdWFsXCIsXG4gICAgICAgICAgICBcImxlc3NlcXVhbFwiLFxuICAgICAgICAgICAgXCJncmVhdGVyXCIsXG4gICAgICAgICAgICBcIm5vdGVxdWFsXCIsXG4gICAgICAgICAgICBcImdyZWF0ZXJlcXVhbFwiLFxuICAgICAgICAgICAgXCJhbHdheXNcIl07XG4gICAgfVxuXG4gICAgZ2V0IGlzVmFsaWQoKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkOyB9XG5cbiAgICBzZXRQaXBlbGluZShzaGFkZXIsIG1lc2gpXG4gICAge1xuICAgICAgICBpZiAoIW1lc2ggfHwgIXNoYWRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwaXBlbGluZSB1bmtub3duIHNoYWRlci9tZXNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5lZWRzUmVidWlsZCA9XG4gICAgICAgICAgICAhdGhpcy5fcmVuZGVyUGlwZWxpbmUgfHxcbiAgICAgICAgICAgICF0aGlzLl9waXBlQ2ZnIHx8XG4gICAgICAgICAgICB0aGlzLl9vbGQubWVzaCAhPSBtZXNoIHx8XG4gICAgICAgICAgICB0aGlzLl9vbGQuc2hhZGVyICE9IHNoYWRlciB8fFxuICAgICAgICAgICAgbWVzaC5uZWVkc1BpcGVsaW5lVXBkYXRlIHx8XG4gICAgICAgICAgICBzaGFkZXIubmVlZHNQaXBlbGluZVVwZGF0ZTtcblxuICAgICAgICBpZiAodGhpcy5fcGlwZUNmZylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BpcGVDZmcuZGVwdGhTdGVuY2lsLmRlcHRoV3JpdGVFbmFibGVkICE9IHRoaXMuX2NncC5zdGF0ZURlcHRoV3JpdGUoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZWVkc1JlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BpcGVDZmcuZGVwdGhTdGVuY2lsLmRlcHRoV3JpdGVFbmFibGVkID0gdGhpcy5fY2dwLnN0YXRlRGVwdGhXcml0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2dwLnN0YXRlRGVwdGhUZXN0KCkgPT09IGZhbHNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9waXBlQ2ZnLmRlcHRoU3RlbmNpbC5kZXB0aENvbXBhcmUgIT0gXCJuZXZlclwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGlwZUNmZy5kZXB0aFN0ZW5jaWwuZGVwdGhDb21wYXJlID0gXCJuZXZlclwiO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1JlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9waXBlQ2ZnLmRlcHRoU3RlbmNpbC5kZXB0aENvbXBhcmUgIT0gdGhpcy5fY2dwLnN0YXRlRGVwdGhGdW5jKCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmVlZHNSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9waXBlQ2ZnLmRlcHRoU3RlbmNpbC5kZXB0aENvbXBhcmUgPSB0aGlzLl9jZ3Auc3RhdGVEZXB0aEZ1bmMoKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2dwLnN0YXRlQ3VsbEZhY2UoKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BpcGVDZmcucHJpbWl0aXZlLmN1bGxNb2RlICE9IFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGlwZUNmZy5wcmltaXRpdmUuY3VsbE1vZGUgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmVlZHNSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9waXBlQ2ZnLnByaW1pdGl2ZS5jdWxsTW9kZSA9IHRoaXMuX2NncC5zdGF0ZUN1bGxGYWNlRmFjaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNSZWJ1aWxkKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BpcGVDZmcgfHwgdGhpcy5fb2xkLnNoYWRlciAhPSBzaGFkZXIpIHRoaXMuX3BpcGVDZmcgPSB0aGlzLmdldFBpcGxlbGluZU9iamVjdChzaGFkZXIsIG1lc2gpO1xuXG4gICAgICAgICAgICB0aGlzLl9vbGQuc2hhZGVyID0gc2hhZGVyO1xuICAgICAgICAgICAgdGhpcy5fb2xkLm1lc2ggPSBtZXNoO1xuXG5cbiAgICAgICAgICAgIC8vIHRyeVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUGlwZWxpbmUgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHRoaXMuX3BpcGVDZmcpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gY2F0Y2ggKGUpXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0aGlzLl9iaW5kVW5pZm9ybXMoc2hhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJQaXBlbGluZSAmJiB0aGlzLl9pc1ZhbGlkKVxuICAgICAgICB7XG4gICAgICAgICAgICBtYXQ0LmNvcHkodGhpcy5fbWF0TW9kZWwsIHRoaXMuX2NncC5tTWF0cml4KTtcbiAgICAgICAgICAgIG1hdDQuY29weSh0aGlzLl9tYXRWaWV3LCB0aGlzLl9jZ3Audk1hdHJpeCk7XG4gICAgICAgICAgICBtYXQ0LmNvcHkodGhpcy5fbWF0UHJvaiwgdGhpcy5fY2dwLnBNYXRyaXgpO1xuXG4gICAgICAgICAgICB0aGlzLl9jZ3AuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5idWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5fdnNVbmlmb3JtVmFsdWVzLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fdnNVbmlmb3JtVmFsdWVzLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3VuaUJ1ZkZyYWcudXBkYXRlVW5pZm9ybVZhbHVlcygpO1xuXG4gICAgICAgICAgICB0aGlzLl9jZ3AucGFzc0VuY29kZXIuc2V0UGlwZWxpbmUodGhpcy5fcmVuZGVyUGlwZWxpbmUpO1xuICAgICAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCB0aGlzLl9iaW5kR3JvdXApO1xuICAgICAgICAgICAgLy8gdGhpcy5fcGlwZWxpbmUgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHRoaXMuX3BpcGVDZmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UGlwbGVsaW5lT2JqZWN0KHNoYWRlciwgbWVzaClcbiAgICB7XG4gICAgICAgIGNvbnN0IHBpcGVDZmcgPSB7XG4gICAgICAgICAgICBcImxheW91dFwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwidmVydGV4XCI6IHtcbiAgICAgICAgICAgICAgICBcIm1vZHVsZVwiOiBzaGFkZXIuc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgIFwiZW50cnlQb2ludFwiOiBcIm15VlNNYWluXCIsXG4gICAgICAgICAgICAgICAgXCJidWZmZXJzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcnJheVN0cmlkZVwiOiAzICogNCwgLy8gMyBmbG9hdHMsIDQgYnl0ZXMgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwic2hhZGVyTG9jYXRpb25cIjogMCwgXCJvZmZzZXRcIjogMCwgXCJmb3JtYXRcIjogXCJmbG9hdDMyeDNcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsc1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFycmF5U3RyaWRlXCI6IDMgKiA0LCAvLyAzIGZsb2F0cywgNCBieXRlcyBlYWNoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZXNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXCJzaGFkZXJMb2NhdGlvblwiOiAxLCBcIm9mZnNldFwiOiAwLCBcImZvcm1hdFwiOiBcImZsb2F0MzJ4M1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyB0ZXhjb29yZHNcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcnJheVN0cmlkZVwiOiAyICogNCwgLy8gMiBmbG9hdHMsIDQgYnl0ZXMgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwic2hhZGVyTG9jYXRpb25cIjogMiwgXCJvZmZzZXRcIjogMCwgXCJmb3JtYXRcIjogXCJmbG9hdDMyeDJcIiwgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZyYWdtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcIm1vZHVsZVwiOiBzaGFkZXIuc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgIFwiZW50cnlQb2ludFwiOiBcIm15RlNNYWluXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBcImZvcm1hdFwiOiB0aGlzLl9jZ3AucHJlc2VudGF0aW9uRm9ybWF0IH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByaW1pdGl2ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0b3BvbG9neVwiOiBcInRyaWFuZ2xlLWxpc3RcIixcbiAgICAgICAgICAgICAgICBcImN1bGxNb2RlXCI6IFwiYmFja1wiLCAvLyBiYWNrL25vbmUvZnJvbnRcblxuICAgICAgICAgICAgICAgIC8vIFwicG9pbnQtbGlzdFwiLFxuICAgICAgICAgICAgICAgIC8vIFwibGluZS1saXN0XCIsXG4gICAgICAgICAgICAgICAgLy8gXCJsaW5lLXN0cmlwXCIsXG4gICAgICAgICAgICAgICAgLy8gXCJ0cmlhbmdsZS1saXN0XCIsXG4gICAgICAgICAgICAgICAgLy8gXCJ0cmlhbmdsZS1zdHJpcFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkZXB0aFN0ZW5jaWxcIjoge1xuICAgICAgICAgICAgICAgIFwiZGVwdGhXcml0ZUVuYWJsZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlcHRoQ29tcGFyZVwiOiBcImxlc3NcIixcbiAgICAgICAgICAgICAgICBcImZvcm1hdFwiOiBcImRlcHRoMjRwbHVzXCIsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHBpcGVDZmc7XG4gICAgfVxuXG5cbiAgICBfYmluZFVuaWZvcm1zKHNoYWRlcilcbiAgICB7XG4gICAgICAgIHRoaXMuX2NncC5wdXNoRXJyb3JTY29wZSgpO1xuXG5cbiAgICAgICAgY29uc3QgY291bnRzID0geyB9O1xuXG4gICAgICAgIHRoaXMuX3VuaUJ1ZkZyYWcgPSBuZXcgVW5pZm9ybUJ1ZmZlcihzaGFkZXIsIFwiZnJhZ1wiKTtcblxuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHNoYWRlci51bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgY29uc3QgdW5pID0gc2hhZGVyLnVuaWZvcm1zW2ldO1xuICAgICAgICAvLyAgICAgY29uc3QgdHlwZSA9IHVuaS5zaGFkZXJUeXBlO1xuICAgICAgICAvLyAgICAgY291bnRzW3R5cGVdID0gY291bnRzW3R5cGVdIHx8IDA7XG5cblxuICAgICAgICAvLyAgICAgY291bnRzW3R5cGVdICs9IHVuaS5nZXRTaXplQnl0ZXMoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhjb3VudHMsIGNvdW50cy5mcmFnKTtcblxuXG4gICAgICAgIGNvbnN0IHZVbmlmb3JtQnVmZmVyU2l6ZSA9IDMgKiAxNiAqIDQ7IC8vIDIgbWF0NHMgKiAxNiBmbG9hdHMgcGVyIG1hdCAqIDQgYnl0ZXMgcGVyIGZsb2F0XG4gICAgICAgIC8vIGNvbnN0IGZVbmlmb3JtQnVmZmVyU2l6ZSA9IGNvdW50cy5mcmFnOy8vIDIgKiAzICogNDsgLy8gMSB2ZWMzICogMyBmbG9hdHMgcGVyIHZlYzMgKiA0IGJ5dGVzIHBlciBmbG9hdFxuXG4gICAgICAgIHRoaXMuX3ZzVW5pZm9ybUJ1ZmZlciA9IHRoaXMuX2NncC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIFwic2l6ZVwiOiB2VW5pZm9ybUJ1ZmZlclNpemUsXG4gICAgICAgICAgICBcInVzYWdlXCI6IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcy5fZnNVbmlmb3JtQnVmZmVyID0gdGhpcy5fY2dwLmRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAvLyAgICAgXCJzaXplXCI6IGZVbmlmb3JtQnVmZmVyU2l6ZSxcbiAgICAgICAgLy8gICAgIFwidXNhZ2VcIjogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgICAvLyB9KTtcblxuICAgICAgICAvLyB0aGlzLl9mc1VuaWZvcm1WYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50cy5mcmFnIC8gNCk7XG5cbiAgICAgICAgdGhpcy5fdnNVbmlmb3JtVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2VW5pZm9ybUJ1ZmZlclNpemUgLyA0KTtcblxuICAgICAgICB0aGlzLl9tYXRNb2RlbCA9IHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgIHRoaXMuX21hdFZpZXcgPSB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuc3ViYXJyYXkoMTYsIDMyKTtcbiAgICAgICAgdGhpcy5fbWF0UHJvaiA9IHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5zdWJhcnJheSgzMiwgNDgpO1xuXG5cbiAgICAgICAgLy8gdGhpcy5fZnNVbmlmb3JtVmFsdWVzWzFdID0gMS4wO1xuICAgICAgICAvLyB0aGlzLl9mc1VuaWZvcm1WYWx1ZXNbMF0gPSAxLjA7XG4gICAgICAgIC8vIGNvbnN0IGxpZ2h0RGlyZWN0aW9uID0gdGhpcy5fZnNVbmlmb3JtVmFsdWVzLnN1YmFycmF5KDAsIDMpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwicGlwZWxpbmUgYmluZGdyb3VwbGF5b3V0IFwiLCBwaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCkpO1xuXG4gICAgICAgIHRoaXMuX2JpbmRHcm91cCA9IHRoaXMuX2NncC5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibGF5b3V0XCI6IHRoaXMuX3JlbmRlclBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxcbiAgICAgICAgICAgICAgICBcImVudHJpZXNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7IFwiYmluZGluZ1wiOiAwLCBcInJlc291cmNlXCI6IHsgXCJidWZmZXJcIjogdGhpcy5fdnNVbmlmb3JtQnVmZmVyIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBcImJpbmRpbmdcIjogMSwgXCJyZXNvdXJjZVwiOiB7IFwiYnVmZmVyXCI6IHRoaXMuX3VuaUJ1ZkZyYWcuX2dwdUJ1ZmZlciB9IH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICB7IGJpbmRpbmc6IDIsIHJlc291cmNlOiBzYW1wbGVyIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgeyBiaW5kaW5nOiAzLCByZXNvdXJjZTogdGV4LmNyZWF0ZVZpZXcoKSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9jZ3AuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxuICAgICAgICAgICAgdGhpcy5fdnNVbmlmb3JtQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5ieXRlTGVuZ3RoXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fdW5pQnVmRnJhZy51cGRhdGVVbmlmb3JtVmFsdWVzKCk7XG4gICAgICAgIHRoaXMuX2NncC5wb3BFcnJvclNjb3BlKFwiY2dwX3BpcGVsaW5lIGVuZFwiLCAoZSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_pipeline.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_shader.js":
/*!************************************!*\
  !*** ./src/core/cgp/cgp_shader.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n/* harmony import */ var _cgp_uniform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp_uniform */ \"./src/core/cgp/cgp_uniform.js\");\n/* harmony import */ var _cgl_shader_default_wgsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_shader_default.wgsl */ \"./src/core/cgp/cgl_shader_default.wgsl\");\n\n\n\n\n\nclass Shader\n{\n    constructor(_cgp, _name)\n    {\n        if (!_cgp) throw new Error(\"shader constructed without cgp \" + _name);\n        this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgp_shader\");\n        this._cgp = _cgp;\n        this._name = _name;\n        this._uniforms = [];\n\n        if (!_name) this._log.stack(\"no shader name given\");\n        this._name = _name || \"unknown\";\n        this.id = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.simpleId)();\n        this._isValid = true;\n        this._compileReason = \"\";\n        this.shaderModule = null;\n        this._needsRecompile = true;\n\n        this._src = \"\";\n    }\n\n    get isValid()\n    {\n        return this._isValid;\n    }\n\n    get uniforms()\n    {\n        return this._uniforms;\n    }\n\n    getName()\n    {\n        return this._name;\n    }\n\n    setWhyCompile(why)\n    {\n        this._compileReason = why;\n    }\n\n    setSource(src)\n    {\n        this._src = src;\n        this.setWhyCompile(\"Source changed\");\n        this._needsRecompile = true;\n    }\n\n    compile()\n    {\n        this._isValid = true;\n        console.log(\"compiling shader...\", this._compileReason);\n        this._cgp.pushErrorScope();\n        this.shaderModule = this._cgp.device.createShaderModule({ \"code\": this._src });\n        this._cgp.popErrorScope(\"cgp_shader \" + this._name, this.error.bind(this));\n        this._needsRecompile = false;\n    }\n\n    error(e)\n    {\n        this._isValid = false;\n    }\n\n\n    bind()\n    {\n        let sizes = {};\n        for (let i = 0; i < this._uniforms.length; i++)\n        {\n            // console.log(this._uniforms[i]);\n        }\n\n        if (this._needsRecompile) this.compile();\n    }\n\n    /**\n     * add a uniform to the fragment shader\n     * @param {String} type ['f','t', etc]\n     * @param {String} name\n     * @param {any} value or port\n     * @memberof Shader\n     * @instance\n     * @function addUniformFrag\n     * @returns {Uniform}\n     */\n    addUniformFrag(type, name, valueOrPort, p2, p3, p4)\n    {\n        const uni = new _cgp_uniform__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, type, name, valueOrPort, p2, p3, p4);\n        uni.shaderType = \"frag\";\n        return uni;\n    }\n\n    /**\n     * add a uniform to the vertex shader\n     * @param {String} type ['f','t', etc]\n     * @param {String} name\n     * @param {any} value or port\n     * @memberof Shader\n     * @instance\n     * @function addUniformVert\n     * @returns {Uniform}\n     */\n    addUniformVert(type, name, valueOrPort, p2, p3, p4)\n    {\n        const uni = new _cgp_uniform__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, type, name, valueOrPort, p2, p3, p4);\n        uni.shaderType = \"vert\";\n        return uni;\n    }\n\n    /**\n     * add a uniform to all shader programs\n     * @param {String} type ['f','t', etc]\n     * @param {String} name\n     * @param {any} value or port\n     * @memberof Shader\n     * @instance\n     * @function addUniform\n     * @returns {Uniform}\n     */\n    addUniform(type, name, valueOrPort, p2, p3, p4)\n    {\n        const uni = new _cgp_uniform__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, type, name, valueOrPort, p2, p3, p4);\n        uni.shaderType = \"both\";\n        return uni;\n    }\n\n\n    _addUniform(uni)\n    {\n        this._uniforms.push(uni);\n        this.setWhyCompile(\"add uniform \" + name);\n        this._needsRecompile = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3NoYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF9zaGFkZXIuanM/MGM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi9jb3JlX2xvZ2dlclwiO1xuaW1wb3J0IHsgc2ltcGxlSWQgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBVbmlmb3JtIGZyb20gXCIuL2NncF91bmlmb3JtXCI7XG5pbXBvcnQgZGVmYXVsdFNoYWRlclNyY1ZlcnQgZnJvbSBcIi4vY2dsX3NoYWRlcl9kZWZhdWx0Lndnc2xcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyXG57XG4gICAgY29uc3RydWN0b3IoX2NncCwgX25hbWUpXG4gICAge1xuICAgICAgICBpZiAoIV9jZ3ApIHRocm93IG5ldyBFcnJvcihcInNoYWRlciBjb25zdHJ1Y3RlZCB3aXRob3V0IGNncCBcIiArIF9uYW1lKTtcbiAgICAgICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNncF9zaGFkZXJcIik7XG4gICAgICAgIHRoaXMuX2NncCA9IF9jZ3A7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMgPSBbXTtcblxuICAgICAgICBpZiAoIV9uYW1lKSB0aGlzLl9sb2cuc3RhY2soXCJubyBzaGFkZXIgbmFtZSBnaXZlblwiKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lIHx8IFwidW5rbm93blwiO1xuICAgICAgICB0aGlzLmlkID0gc2ltcGxlSWQoKTtcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVSZWFzb24gPSBcIlwiO1xuICAgICAgICB0aGlzLnNoYWRlck1vZHVsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9zcmMgPSBcIlwiO1xuICAgIH1cblxuICAgIGdldCBpc1ZhbGlkKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGdldCB1bmlmb3JtcygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5pZm9ybXM7XG4gICAgfVxuXG4gICAgZ2V0TmFtZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG5cbiAgICBzZXRXaHlDb21waWxlKHdoeSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVSZWFzb24gPSB3aHk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlKHNyYylcbiAgICB7XG4gICAgICAgIHRoaXMuX3NyYyA9IHNyYztcbiAgICAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwiU291cmNlIGNoYW5nZWRcIik7XG4gICAgICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21waWxlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvbXBpbGluZyBzaGFkZXIuLi5cIiwgdGhpcy5fY29tcGlsZVJlYXNvbik7XG4gICAgICAgIHRoaXMuX2NncC5wdXNoRXJyb3JTY29wZSgpO1xuICAgICAgICB0aGlzLnNoYWRlck1vZHVsZSA9IHRoaXMuX2NncC5kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgXCJjb2RlXCI6IHRoaXMuX3NyYyB9KTtcbiAgICAgICAgdGhpcy5fY2dwLnBvcEVycm9yU2NvcGUoXCJjZ3Bfc2hhZGVyIFwiICsgdGhpcy5fbmFtZSwgdGhpcy5lcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlcnJvcihlKVxuICAgIHtcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgYmluZCgpXG4gICAge1xuICAgICAgICBsZXQgc2l6ZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5fdW5pZm9ybXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX25lZWRzUmVjb21waWxlKSB0aGlzLmNvbXBpbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSB1bmlmb3JtIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBbJ2YnLCd0JywgZXRjXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlIG9yIHBvcnRcbiAgICAgKiBAbWVtYmVyb2YgU2hhZGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1GcmFnXG4gICAgICogQHJldHVybnMge1VuaWZvcm19XG4gICAgICovXG4gICAgYWRkVW5pZm9ybUZyYWcodHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpXG4gICAge1xuICAgICAgICBjb25zdCB1bmkgPSBuZXcgVW5pZm9ybSh0aGlzLCB0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNCk7XG4gICAgICAgIHVuaS5zaGFkZXJUeXBlID0gXCJmcmFnXCI7XG4gICAgICAgIHJldHVybiB1bmk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgdW5pZm9ybSB0byB0aGUgdmVydGV4IHNoYWRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFsnZicsJ3QnLCBldGNdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgb3IgcG9ydFxuICAgICAqIEBtZW1iZXJvZiBTaGFkZXJcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZnVuY3Rpb24gYWRkVW5pZm9ybVZlcnRcbiAgICAgKiBAcmV0dXJucyB7VW5pZm9ybX1cbiAgICAgKi9cbiAgICBhZGRVbmlmb3JtVmVydCh0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNClcbiAgICB7XG4gICAgICAgIGNvbnN0IHVuaSA9IG5ldyBVbmlmb3JtKHRoaXMsIHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KTtcbiAgICAgICAgdW5pLnNoYWRlclR5cGUgPSBcInZlcnRcIjtcbiAgICAgICAgcmV0dXJuIHVuaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSB1bmlmb3JtIHRvIGFsbCBzaGFkZXIgcHJvZ3JhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBbJ2YnLCd0JywgZXRjXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlIG9yIHBvcnRcbiAgICAgKiBAbWVtYmVyb2YgU2hhZGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1cbiAgICAgKiBAcmV0dXJucyB7VW5pZm9ybX1cbiAgICAgKi9cbiAgICBhZGRVbmlmb3JtKHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KVxuICAgIHtcbiAgICAgICAgY29uc3QgdW5pID0gbmV3IFVuaWZvcm0odGhpcywgdHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpO1xuICAgICAgICB1bmkuc2hhZGVyVHlwZSA9IFwiYm90aFwiO1xuICAgICAgICByZXR1cm4gdW5pO1xuICAgIH1cblxuXG4gICAgX2FkZFVuaWZvcm0odW5pKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMucHVzaCh1bmkpO1xuICAgICAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJhZGQgdW5pZm9ybSBcIiArIG5hbWUpO1xuICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_shader.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_state.js":
/*!***********************************!*\
  !*** ./src/core/cgp/cgp_state.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebGpuContext\": () => (/* binding */ WebGpuContext)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_constants */ \"./src/core/cg/cg_constants.js\");\n/* harmony import */ var _cg_cg_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cg/cg_state */ \"./src/core/cg/cg_state.js\");\n/* harmony import */ var _cgp_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp_shader */ \"./src/core/cgp/cgp_shader.js\");\n/* harmony import */ var _cgl_shader_default_wgsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_shader_default.wgsl */ \"./src/core/cgp/cgl_shader_default.wgsl\");\n\n\n\n\n\n/**\n * cables webgpu context/state manager\n * @external CGP\n * @namespace Context\n * @class\n * @hideconstructor\n */\n// const Context = function (_patch)\nclass WebGpuContext extends _cg_cg_state__WEBPACK_IMPORTED_MODULE_1__.CGState\n{\n    constructor(_patch)\n    {\n        super();\n\n        this.patch = _patch;\n\n        this.gApi = _cg_cg_constants__WEBPACK_IMPORTED_MODULE_0__.CG.GAPI_WEBGPU;\n        this._viewport = [0, 0, 256, 256];\n        this._shaderStack = [];\n        this._simpleShader = null;\n\n        this._stackCullFaceFacing = [];\n        this._stackDepthTest = [];\n        this._stackCullFace = [];\n        this._stackDepthFunc = [];\n        this._stackDepthWrite = [];\n\n        this.DEPTH_FUNCS = [\n            \"never\",\n            \"always\",\n            \"less\",\n            \"less-equal\",\n            \"greater\",\n            \"greater-equal\",\n            \"equal\",\n            \"not-equal\"\n        ];\n\n        this.CULL_MODES = [\n            \"none\",\n            \"back\",\n            \"front\",\n            \"none\" // both does not exist in webgpu\n        ];\n    }\n\n\n    /// ////////////////////\n\n    getViewPort()\n    {\n        return [0, 0, this.canvasWidth, this.canvasHeight];\n    }\n\n    renderStart(cgp, identTranslate, identTranslateView)\n    {\n        if (!this._simpleShader)\n        {\n            this._simpleShader = new _cgp_shader__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, \"simple default shader\");\n            this._simpleShader.setSource(_cgl_shader_default_wgsl__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n            this._simpleShader.addUniformFrag(\"4f\", \"color\", 1, 1, 0, 1);\n        }\n\n        this.fpsCounter.startFrame();\n\n        this._startMatrixStacks(identTranslate, identTranslateView);\n        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);\n\n        this.pushShader(this._simpleShader);\n        this.pushDepthTest(true);\n        this.pushDepthWrite(true);\n        this.pushDepthFunc(\"less-equal\");\n\n        this.emitEvent(\"beginFrame\");\n    }\n\n    renderEnd()\n    {\n        this._endMatrixStacks();\n\n        this.popShader();\n        this.popDepthFunc();\n        this.popDepthWrite();\n        this.popDepthTest();\n\n        this.emitEvent(\"endFrame\");\n        this.fpsCounter.endFrame();\n    }\n\n\n    setViewPort(x, y, w, h)\n    {\n        this._viewport = [x, y, w, h];\n    }\n\n    /**\n     * @function getViewPort\n     * @memberof Context\n     * @instance\n     * @description get current gl viewport\n     * @returns {Array} array [x,y,w,h]\n     */\n    getViewPort()\n    {\n        return this._viewPort;\n    }\n\n\n    createMesh(geom, glPrimitive)\n    {\n        return new CGP.Mesh(this, geom, glPrimitive);\n    }\n\n    getShader()\n    {\n        return {};\n    }\n\n    /**\n     * push a shader to the shader stack\n     * @function pushShader\n     * @memberof Context\n     * @instance\n     * @param {Object} shader\n     * @function\n    */\n    pushShader(shader)\n    {\n        this._shaderStack.push(shader);\n        // currentShader = shader;\n    }\n\n    /**\n     * pop current used shader from shader stack\n     * @function popShader\n     * @memberof Context\n     * @instance\n     * @function\n     */\n    popShader()\n    {\n        if (this._shaderStack.length === 0) throw new Error(\"Invalid shader stack pop!\");\n        this._shaderStack.pop();\n        // currentShader = this._shaderStack[this._shaderStack.length - 1];\n    }\n\n    getShader()\n    {\n        return this._shaderStack[this._shaderStack.length - 1];\n        // if (currentShader) if (!this.frameStore || ((this.frameStore.renderOffscreen === true) == currentShader.offScreenPass) === true) return currentShader;\n        // for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];\n    }\n\n    pushErrorScope()\n    {\n        this.device.pushErrorScope(\"validation\");\n    }\n\n    popErrorScope(name, cb)\n    {\n        this.device.popErrorScope().then((error) =>\n        {\n            if (error)\n            {\n                this.patch.emitEvent(\"criticalError\", { \"title\": \"WebGPU error \\\"\" + name + \"\\\"\", \"codeText\": error.message });\n                // if (this.patch.isEditorMode())console.log(\"WebGPU error \" + this._name, error.message);\n\n                console.warn(\"[cgp]\", name, error.message, error, cb);\n                if (cb)cb(error);\n            }\n        });\n    }\n\n    /**\n     * push depth testing enabled state\n     * @function pushDepthTest\n     * @param {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n\n    pushDepthTest(b)\n    {\n        this._stackDepthTest.push(b);\n    }\n\n    /**\n     * current state of depth testing\n     * @function stateDepthTest\n     * @returns {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    stateDepthTest()\n    {\n        return this._stackDepthTest[this._stackDepthTest.length - 1];\n    }\n\n    /**\n     * pop depth testing state\n     * @function popDepthTest\n     * @memberof Context\n     * @instance\n     */\n    popDepthTest()\n    {\n        this._stackDepthTest.pop();\n    }\n\n    // --------------------------------------\n    // state depthwrite\n\n    /**\n     * push depth write enabled state\n     * @function pushDepthTest\n     * @param {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n\n    pushDepthWrite(b)\n    {\n        b = b || false;\n        this._stackDepthWrite.push(b);\n    }\n\n    /**\n     * current state of depth writing\n     * @function stateCullFace\n     * @returns {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    stateDepthWrite()\n    {\n        return this._stackDepthWrite[this._stackDepthWrite.length - 1];\n    }\n\n    /**\n     * pop depth writing state\n     * @function popCullFace\n     * @memberof Context\n     * @instance\n     */\n    popDepthWrite()\n    {\n        this._stackDepthWrite.pop();\n    }\n\n\n    // --------------------------------------\n    // state depthfunc\n\n\n    /**\n     * @function pushDepthFunc\n     * @memberof Context\n     * @instance\n     * @param {string} depth compare func\n     */\n    pushDepthFunc(f)\n    {\n        this._stackDepthFunc.push(f);\n    }\n\n    /**\n     * @function stateDepthFunc\n     * @memberof Context\n     * @instance\n     * @returns {string}\n     */\n    stateDepthFunc()\n    {\n        if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];\n        return false;\n    }\n\n    /**\n     * pop depth compare func\n     * @function popDepthFunc\n     * @memberof Context\n     * @instance\n     */\n    popDepthFunc()\n    {\n        this._stackDepthFunc.pop();\n    }\n\n\n\n    // --------------------------------------\n    // state CullFace\n\n    /**\n     * push face culling face enabled state\n     * @function pushCullFaceFacing\n     * @param {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    pushCullFace(b)\n    {\n        this._stackCullFace.push(b);\n    }\n\n    /**\n * current state of face culling\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\n    stateCullFace()\n    {\n        return this._stackCullFace[this._stackCullFace.length - 1];\n    }\n\n    /**\n * pop face culling enabled state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\n    popCullFace()\n    {\n        this._stackCullFace.pop();\n    }\n\n\n    // --------------------------------------\n    // state CullFace Facing\n\n\n    /**\n     * push face culling face side\n     * @function pushCullFaceFacing\n     * @memberof Context\n     * @instance\n     */\n\n    pushCullFaceFacing(b)\n    {\n        this._stackCullFaceFacing.push(b);\n    }\n\n    /**\n     * current state of face culling side\n     * @function stateCullFaceFacing\n     * @returns {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    stateCullFaceFacing()\n    {\n        return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];\n    }\n\n    /**\n     * pop face culling face side\n     * @function popCullFaceFacing\n     * @memberof Context\n     * @instance\n     */\n    popCullFaceFacing()\n    {\n        this._stackCullFaceFacing.pop();\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3N0YXRlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NncC9jZ3Bfc3RhdGUuanM/NDliMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDRyB9IGZyb20gXCIuLi9jZy9jZ19jb25zdGFudHNcIjtcbmltcG9ydCB7IENHU3RhdGUgfSBmcm9tIFwiLi4vY2cvY2dfc3RhdGVcIjtcbmltcG9ydCBTaGFkZXIgZnJvbSBcIi4vY2dwX3NoYWRlclwiO1xuaW1wb3J0IGRlZmF1bHRTaGFkZXJTcmNWZXJ0IGZyb20gXCIuL2NnbF9zaGFkZXJfZGVmYXVsdC53Z3NsXCI7XG5cbi8qKlxuICogY2FibGVzIHdlYmdwdSBjb250ZXh0L3N0YXRlIG1hbmFnZXJcbiAqIEBleHRlcm5hbCBDR1BcbiAqIEBuYW1lc3BhY2UgQ29udGV4dFxuICogQGNsYXNzXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbi8vIGNvbnN0IENvbnRleHQgPSBmdW5jdGlvbiAoX3BhdGNoKVxuY2xhc3MgV2ViR3B1Q29udGV4dCBleHRlbmRzIENHU3RhdGVcbntcbiAgICBjb25zdHJ1Y3RvcihfcGF0Y2gpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMucGF0Y2ggPSBfcGF0Y2g7XG5cbiAgICAgICAgdGhpcy5nQXBpID0gQ0cuR0FQSV9XRUJHUFU7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gWzAsIDAsIDI1NiwgMjU2XTtcbiAgICAgICAgdGhpcy5fc2hhZGVyU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nID0gW107XG4gICAgICAgIHRoaXMuX3N0YWNrRGVwdGhUZXN0ID0gW107XG4gICAgICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aEZ1bmMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aFdyaXRlID0gW107XG5cbiAgICAgICAgdGhpcy5ERVBUSF9GVU5DUyA9IFtcbiAgICAgICAgICAgIFwibmV2ZXJcIixcbiAgICAgICAgICAgIFwiYWx3YXlzXCIsXG4gICAgICAgICAgICBcImxlc3NcIixcbiAgICAgICAgICAgIFwibGVzcy1lcXVhbFwiLFxuICAgICAgICAgICAgXCJncmVhdGVyXCIsXG4gICAgICAgICAgICBcImdyZWF0ZXItZXF1YWxcIixcbiAgICAgICAgICAgIFwiZXF1YWxcIixcbiAgICAgICAgICAgIFwibm90LWVxdWFsXCJcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLkNVTExfTU9ERVMgPSBbXG4gICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgIFwiYmFja1wiLFxuICAgICAgICAgICAgXCJmcm9udFwiLFxuICAgICAgICAgICAgXCJub25lXCIgLy8gYm90aCBkb2VzIG5vdCBleGlzdCBpbiB3ZWJncHVcbiAgICAgICAgXTtcbiAgICB9XG5cblxuICAgIC8vLyAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgZ2V0Vmlld1BvcnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodF07XG4gICAgfVxuXG4gICAgcmVuZGVyU3RhcnQoY2dwLCBpZGVudFRyYW5zbGF0ZSwgaWRlbnRUcmFuc2xhdGVWaWV3KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaW1wbGVTaGFkZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3NpbXBsZVNoYWRlciA9IG5ldyBTaGFkZXIodGhpcywgXCJzaW1wbGUgZGVmYXVsdCBzaGFkZXJcIik7XG4gICAgICAgICAgICB0aGlzLl9zaW1wbGVTaGFkZXIuc2V0U291cmNlKGRlZmF1bHRTaGFkZXJTcmNWZXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX3NpbXBsZVNoYWRlci5hZGRVbmlmb3JtRnJhZyhcIjRmXCIsIFwiY29sb3JcIiwgMSwgMSwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZwc0NvdW50ZXIuc3RhcnRGcmFtZSgpO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0TWF0cml4U3RhY2tzKGlkZW50VHJhbnNsYXRlLCBpZGVudFRyYW5zbGF0ZVZpZXcpO1xuICAgICAgICB0aGlzLnNldFZpZXdQb3J0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnB1c2hTaGFkZXIodGhpcy5fc2ltcGxlU2hhZGVyKTtcbiAgICAgICAgdGhpcy5wdXNoRGVwdGhUZXN0KHRydWUpO1xuICAgICAgICB0aGlzLnB1c2hEZXB0aFdyaXRlKHRydWUpO1xuICAgICAgICB0aGlzLnB1c2hEZXB0aEZ1bmMoXCJsZXNzLWVxdWFsXCIpO1xuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiYmVnaW5GcmFtZVwiKTtcbiAgICB9XG5cbiAgICByZW5kZXJFbmQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZW5kTWF0cml4U3RhY2tzKCk7XG5cbiAgICAgICAgdGhpcy5wb3BTaGFkZXIoKTtcbiAgICAgICAgdGhpcy5wb3BEZXB0aEZ1bmMoKTtcbiAgICAgICAgdGhpcy5wb3BEZXB0aFdyaXRlKCk7XG4gICAgICAgIHRoaXMucG9wRGVwdGhUZXN0KCk7XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlbmRGcmFtZVwiKTtcbiAgICAgICAgdGhpcy5mcHNDb3VudGVyLmVuZEZyYW1lKCk7XG4gICAgfVxuXG5cbiAgICBzZXRWaWV3UG9ydCh4LCB5LCB3LCBoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBbeCwgeSwgdywgaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGdldFZpZXdQb3J0XG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gZ2V0IGN1cnJlbnQgZ2wgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IFt4LHksdyxoXVxuICAgICAqL1xuICAgIGdldFZpZXdQb3J0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3UG9ydDtcbiAgICB9XG5cblxuICAgIGNyZWF0ZU1lc2goZ2VvbSwgZ2xQcmltaXRpdmUpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IENHUC5NZXNoKHRoaXMsIGdlb20sIGdsUHJpbWl0aXZlKTtcbiAgICB9XG5cbiAgICBnZXRTaGFkZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1c2ggYSBzaGFkZXIgdG8gdGhlIHNoYWRlciBzdGFja1xuICAgICAqIEBmdW5jdGlvbiBwdXNoU2hhZGVyXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2hhZGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgKi9cbiAgICBwdXNoU2hhZGVyKHNoYWRlcilcbiAgICB7XG4gICAgICAgIHRoaXMuX3NoYWRlclN0YWNrLnB1c2goc2hhZGVyKTtcbiAgICAgICAgLy8gY3VycmVudFNoYWRlciA9IHNoYWRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3AgY3VycmVudCB1c2VkIHNoYWRlciBmcm9tIHNoYWRlciBzdGFja1xuICAgICAqIEBmdW5jdGlvbiBwb3BTaGFkZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHBvcFNoYWRlcigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNoYWRlciBzdGFjayBwb3AhXCIpO1xuICAgICAgICB0aGlzLl9zaGFkZXJTdGFjay5wb3AoKTtcbiAgICAgICAgLy8gY3VycmVudFNoYWRlciA9IHRoaXMuX3NoYWRlclN0YWNrW3RoaXMuX3NoYWRlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGdldFNoYWRlcigpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZGVyU3RhY2tbdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIGlmIChjdXJyZW50U2hhZGVyKSBpZiAoIXRoaXMuZnJhbWVTdG9yZSB8fCAoKHRoaXMuZnJhbWVTdG9yZS5yZW5kZXJPZmZzY3JlZW4gPT09IHRydWUpID09IGN1cnJlbnRTaGFkZXIub2ZmU2NyZWVuUGFzcykgPT09IHRydWUpIHJldHVybiBjdXJyZW50U2hhZGVyO1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmICh0aGlzLl9zaGFkZXJTdGFja1tpXSkgaWYgKHRoaXMuZnJhbWVTdG9yZS5yZW5kZXJPZmZzY3JlZW4gPT0gdGhpcy5fc2hhZGVyU3RhY2tbaV0ub2ZmU2NyZWVuUGFzcykgcmV0dXJuIHRoaXMuX3NoYWRlclN0YWNrW2ldO1xuICAgIH1cblxuICAgIHB1c2hFcnJvclNjb3BlKClcbiAgICB7XG4gICAgICAgIHRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKTtcbiAgICB9XG5cbiAgICBwb3BFcnJvclNjb3BlKG5hbWUsIGNiKVxuICAgIHtcbiAgICAgICAgdGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4oKGVycm9yKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaC5lbWl0RXZlbnQoXCJjcml0aWNhbEVycm9yXCIsIHsgXCJ0aXRsZVwiOiBcIldlYkdQVSBlcnJvciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIsIFwiY29kZVRleHRcIjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5wYXRjaC5pc0VkaXRvck1vZGUoKSljb25zb2xlLmxvZyhcIldlYkdQVSBlcnJvciBcIiArIHRoaXMuX25hbWUsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW2NncF1cIiwgbmFtZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IsIGNiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2IpY2IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdXNoIGRlcHRoIHRlc3RpbmcgZW5hYmxlZCBzdGF0ZVxuICAgICAqIEBmdW5jdGlvbiBwdXNoRGVwdGhUZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIHB1c2hEZXB0aFRlc3QoYilcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YWNrRGVwdGhUZXN0LnB1c2goYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3VycmVudCBzdGF0ZSBvZiBkZXB0aCB0ZXN0aW5nXG4gICAgICogQGZ1bmN0aW9uIHN0YXRlRGVwdGhUZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRlRGVwdGhUZXN0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja0RlcHRoVGVzdFt0aGlzLl9zdGFja0RlcHRoVGVzdC5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3AgZGVwdGggdGVzdGluZyBzdGF0ZVxuICAgICAqIEBmdW5jdGlvbiBwb3BEZXB0aFRlc3RcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHBvcERlcHRoVGVzdCgpXG4gICAge1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoVGVzdC5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHN0YXRlIGRlcHRod3JpdGVcblxuICAgIC8qKlxuICAgICAqIHB1c2ggZGVwdGggd3JpdGUgZW5hYmxlZCBzdGF0ZVxuICAgICAqIEBmdW5jdGlvbiBwdXNoRGVwdGhUZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIHB1c2hEZXB0aFdyaXRlKGIpXG4gICAge1xuICAgICAgICBiID0gYiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aFdyaXRlLnB1c2goYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3VycmVudCBzdGF0ZSBvZiBkZXB0aCB3cml0aW5nXG4gICAgICogQGZ1bmN0aW9uIHN0YXRlQ3VsbEZhY2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGVEZXB0aFdyaXRlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja0RlcHRoV3JpdGVbdGhpcy5fc3RhY2tEZXB0aFdyaXRlLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBvcCBkZXB0aCB3cml0aW5nIHN0YXRlXG4gICAgICogQGZ1bmN0aW9uIHBvcEN1bGxGYWNlXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBwb3BEZXB0aFdyaXRlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YWNrRGVwdGhXcml0ZS5wb3AoKTtcbiAgICB9XG5cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc3RhdGUgZGVwdGhmdW5jXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBwdXNoRGVwdGhGdW5jXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVwdGggY29tcGFyZSBmdW5jXG4gICAgICovXG4gICAgcHVzaERlcHRoRnVuYyhmKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aEZ1bmMucHVzaChmKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc3RhdGVEZXB0aEZ1bmNcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGVEZXB0aEZ1bmMoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrRGVwdGhGdW5jLmxlbmd0aCA+IDApIHJldHVybiB0aGlzLl9zdGFja0RlcHRoRnVuY1t0aGlzLl9zdGFja0RlcHRoRnVuYy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBvcCBkZXB0aCBjb21wYXJlIGZ1bmNcbiAgICAgKiBAZnVuY3Rpb24gcG9wRGVwdGhGdW5jXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBwb3BEZXB0aEZ1bmMoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aEZ1bmMucG9wKCk7XG4gICAgfVxuXG5cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc3RhdGUgQ3VsbEZhY2VcblxuICAgIC8qKlxuICAgICAqIHB1c2ggZmFjZSBjdWxsaW5nIGZhY2UgZW5hYmxlZCBzdGF0ZVxuICAgICAqIEBmdW5jdGlvbiBwdXNoQ3VsbEZhY2VGYWNpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHB1c2hDdWxsRmFjZShiKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tDdWxsRmFjZS5wdXNoKGIpO1xuICAgIH1cblxuICAgIC8qKlxuICogY3VycmVudCBzdGF0ZSBvZiBmYWNlIGN1bGxpbmdcbiAqIEBmdW5jdGlvbiBzdGF0ZUN1bGxGYWNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZW5hYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG4gICAgc3RhdGVDdWxsRmFjZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tDdWxsRmFjZVt0aGlzLl9zdGFja0N1bGxGYWNlLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICogcG9wIGZhY2UgY3VsbGluZyBlbmFibGVkIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuICAgIHBvcEN1bGxGYWNlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2UucG9wKCk7XG4gICAgfVxuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHN0YXRlIEN1bGxGYWNlIEZhY2luZ1xuXG5cbiAgICAvKipcbiAgICAgKiBwdXNoIGZhY2UgY3VsbGluZyBmYWNlIHNpZGVcbiAgICAgKiBAZnVuY3Rpb24gcHVzaEN1bGxGYWNlRmFjaW5nXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIHB1c2hDdWxsRmFjZUZhY2luZyhiKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZy5wdXNoKGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgc3RhdGUgb2YgZmFjZSBjdWxsaW5nIHNpZGVcbiAgICAgKiBAZnVuY3Rpb24gc3RhdGVDdWxsRmFjZUZhY2luZ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0ZUN1bGxGYWNlRmFjaW5nKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nW3RoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9wIGZhY2UgY3VsbGluZyBmYWNlIHNpZGVcbiAgICAgKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VGYWNpbmdcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHBvcEN1bGxGYWNlRmFjaW5nKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcucG9wKCk7XG4gICAgfVxufVxuZXhwb3J0IHsgV2ViR3B1Q29udGV4dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_state.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_texture.js":
/*!*************************************!*\
  !*** ./src/core/cgp/cgp_texture.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Texture)\n/* harmony export */ });\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logger */ \"./src/core/core_logger.js\");\n\n\nclass Texture\n{\n    constructor(_cgp, options)\n    {\n        if (!_cgp) throw new Error(\"no cgp\");\n        this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgp_texture\");\n        this._cgp = _cgp;\n        this.id = CABLES.uuid();\n\n        options = options || {};\n\n        this.name = options.name || \"unknown\";\n    }\n\n    /**\n     * set texture data from an image/canvas object\n     * @function initTexture\n     * @memberof Texture\n     * @instance\n     * @param {Object} image\n     * @param {Number} filter\n     */\n    initTexture(img, filter)\n    {\n        this.width = img.width;\n        this.height = img.height;\n\n        this.textureType = \"rgba8unorm\";\n\n        const textureDescriptor = {\n            // Unlike in WebGL, the size of our texture must be set at texture creation time.\n            // This means we have to wait until the image is loaded to create the texture, since we won't\n            // know the size until then.\n            \"size\": { \"width\": img.width, \"height\": img.height },\n            \"format\": this.textureType,\n            \"usage\": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\n        };\n        const texture = this._cgp.device.createTexture(textureDescriptor);\n\n        this._cgp.device.queue.copyExternalImageToTexture({ \"source\": img }, { \"texture\": texture }, textureDescriptor.size);\n\n        return texture;\n    }\n\n    getInfo()\n    {\n        const tex = this;\n        const obj = {};\n\n        obj.name = tex.name;\n        obj.size = tex.width + \" x \" + tex.height;\n\n        obj.textureType = tex.textureType;\n\n        return obj;\n    }\n}\n\n\n/**\n * @function load\n * @static\n * @memberof Texture\n * @description load an image from an url\n * @param {Context} cgl\n * @param {String} url\n * @param {Function} onFinished\n * @param {Object} options\n * @return {Texture}\n */\nTexture.load = function (cgp, url, onFinished, settings)\n{\n    fetch(url).then((response) =>\n    {\n        response.blob().then((blob) =>\n        {\n            createImageBitmap(blob).then((imgBitmap) =>\n            {\n                const texture = new Texture(cgp, { \"name\": url });\n                texture.initTexture(imgBitmap);\n                if (onFinished)onFinished(texture);\n                else console.log(\"Texture.load no onFinished callback\");\n            });\n        });\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3RleHR1cmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NncC9jZ3BfdGV4dHVyZS5qcz8xMGYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL2NvcmVfbG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVcbntcbiAgICBjb25zdHJ1Y3RvcihfY2dwLCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKCFfY2dwKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBjZ3BcIik7XG4gICAgICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ3BfdGV4dHVyZVwiKTtcbiAgICAgICAgdGhpcy5fY2dwID0gX2NncDtcbiAgICAgICAgdGhpcy5pZCA9IENBQkxFUy51dWlkKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IFwidW5rbm93blwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0ZXh0dXJlIGRhdGEgZnJvbSBhbiBpbWFnZS9jYW52YXMgb2JqZWN0XG4gICAgICogQGZ1bmN0aW9uIGluaXRUZXh0dXJlXG4gICAgICogQG1lbWJlcm9mIFRleHR1cmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyXG4gICAgICovXG4gICAgaW5pdFRleHR1cmUoaW1nLCBmaWx0ZXIpXG4gICAge1xuICAgICAgICB0aGlzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IFwicmdiYTh1bm9ybVwiO1xuXG4gICAgICAgIGNvbnN0IHRleHR1cmVEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgLy8gVW5saWtlIGluIFdlYkdMLCB0aGUgc2l6ZSBvZiBvdXIgdGV4dHVyZSBtdXN0IGJlIHNldCBhdCB0ZXh0dXJlIGNyZWF0aW9uIHRpbWUuXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIGhhdmUgdG8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgaXMgbG9hZGVkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZSwgc2luY2Ugd2Ugd29uJ3RcbiAgICAgICAgICAgIC8vIGtub3cgdGhlIHNpemUgdW50aWwgdGhlbi5cbiAgICAgICAgICAgIFwic2l6ZVwiOiB7IFwid2lkdGhcIjogaW1nLndpZHRoLCBcImhlaWdodFwiOiBpbWcuaGVpZ2h0IH0sXG4gICAgICAgICAgICBcImZvcm1hdFwiOiB0aGlzLnRleHR1cmVUeXBlLFxuICAgICAgICAgICAgXCJ1c2FnZVwiOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGV4dHVyZURlc2NyaXB0b3IpO1xuXG4gICAgICAgIHRoaXMuX2NncC5kZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoeyBcInNvdXJjZVwiOiBpbWcgfSwgeyBcInRleHR1cmVcIjogdGV4dHVyZSB9LCB0ZXh0dXJlRGVzY3JpcHRvci5zaXplKTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG5cbiAgICBnZXRJbmZvKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHRleCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgICAgIG9iai5uYW1lID0gdGV4Lm5hbWU7XG4gICAgICAgIG9iai5zaXplID0gdGV4LndpZHRoICsgXCIgeCBcIiArIHRleC5oZWlnaHQ7XG5cbiAgICAgICAgb2JqLnRleHR1cmVUeXBlID0gdGV4LnRleHR1cmVUeXBlO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGxvYWRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAZGVzY3JpcHRpb24gbG9hZCBhbiBpbWFnZSBmcm9tIGFuIHVybFxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRmluaXNoZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmxvYWQgPSBmdW5jdGlvbiAoY2dwLCB1cmwsIG9uRmluaXNoZWQsIHNldHRpbmdzKVxue1xuICAgIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+XG4gICAge1xuICAgICAgICByZXNwb25zZS5ibG9iKCkudGhlbigoYmxvYikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYikudGhlbigoaW1nQml0bWFwKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShjZ3AsIHsgXCJuYW1lXCI6IHVybCB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmluaXRUZXh0dXJlKGltZ0JpdG1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRmluaXNoZWQpb25GaW5pc2hlZCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnNvbGUubG9nKFwiVGV4dHVyZS5sb2FkIG5vIG9uRmluaXNoZWQgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_texture.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_uniform.js":
/*!*************************************!*\
  !*** ./src/core/cgp/cgp_uniform.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Uniform)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_uniform */ \"./src/core/cg/cg_uniform.js\");\n\n\nclass Uniform extends _cg_cg_uniform__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n    {\n        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);\n        this._loc = -1;\n        this._cgl = __shader._cgl;\n    }\n\n\n    updateValueF() { }\n\n    setValueF(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValue2F() { }\n\n    setValue2F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValue3F() { }\n\n    setValue3F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValue4F() { }\n\n    setValue4F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    getSizeBytes()\n    {\n        if (this._type == \"f\") return 1 * 4;\n        if (this._type == \"i\") return 1 * 4;\n        if (this._type == \"2i\") return 2 * 4;\n        if (this._type == \"2f\") return 2 * 4;\n        if (this._type == \"3f\") return 3 * 4;\n        if (this._type == \"4f\") return 4 * 4;\n        if (this._type == \"m4\") return 4 * 4 * 4;\n\n        this._log.warn(\"unknown type getSizeBytes\");\n        // if (this._type == \"t\") return \"sampler2D\";\n        // if (this._type == \"tc\") return \"samplerCube\";\n        // if (this._type == \"b\") return \"bool\";\n\n        // if (t == \"3f[]\") return null; // ignore this for now...\n        // if (t == \"m4[]\") return null; // ignore this for now...\n        // if (t == \"f[]\") return null; // ignore this for now...\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3VuaWZvcm0uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NncC9jZ3BfdW5pZm9ybS5qcz83ZTdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDZ1VuaWZvcm0gZnJvbSBcIi4uL2NnL2NnX3VuaWZvcm1cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pZm9ybSBleHRlbmRzIENnVW5pZm9ybVxue1xuICAgIGNvbnN0cnVjdG9yKF9fc2hhZGVyLCBfX3R5cGUsIF9fbmFtZSwgX3ZhbHVlLCBfcG9ydDIsIF9wb3J0MywgX3BvcnQ0LCBfc3RydWN0VW5pZm9ybU5hbWUsIF9zdHJ1Y3ROYW1lLCBfcHJvcGVydHlOYW1lKVxuICAgIHtcbiAgICAgICAgc3VwZXIoX19zaGFkZXIsIF9fdHlwZSwgX19uYW1lLCBfdmFsdWUsIF9wb3J0MiwgX3BvcnQzLCBfcG9ydDQsIF9zdHJ1Y3RVbmlmb3JtTmFtZSwgX3N0cnVjdE5hbWUsIF9wcm9wZXJ0eU5hbWUpO1xuICAgICAgICB0aGlzLl9sb2MgPSAtMTtcbiAgICAgICAgdGhpcy5fY2dsID0gX19zaGFkZXIuX2NnbDtcbiAgICB9XG5cblxuICAgIHVwZGF0ZVZhbHVlRigpIHsgfVxuXG4gICAgc2V0VmFsdWVGKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlMkYoKSB7IH1cblxuICAgIHNldFZhbHVlMkYodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUzRigpIHsgfVxuXG4gICAgc2V0VmFsdWUzRih2KVxuICAgIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZTRGKCkgeyB9XG5cbiAgICBzZXRWYWx1ZTRGKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIGdldFNpemVCeXRlcygpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PSBcImZcIikgcmV0dXJuIDEgKiA0O1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PSBcImlcIikgcmV0dXJuIDEgKiA0O1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PSBcIjJpXCIpIHJldHVybiAyICogNDtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT0gXCIyZlwiKSByZXR1cm4gMiAqIDQ7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09IFwiM2ZcIikgcmV0dXJuIDMgKiA0O1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PSBcIjRmXCIpIHJldHVybiA0ICogNDtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT0gXCJtNFwiKSByZXR1cm4gNCAqIDQgKiA0O1xuXG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwidW5rbm93biB0eXBlIGdldFNpemVCeXRlc1wiKTtcbiAgICAgICAgLy8gaWYgKHRoaXMuX3R5cGUgPT0gXCJ0XCIpIHJldHVybiBcInNhbXBsZXIyRFwiO1xuICAgICAgICAvLyBpZiAodGhpcy5fdHlwZSA9PSBcInRjXCIpIHJldHVybiBcInNhbXBsZXJDdWJlXCI7XG4gICAgICAgIC8vIGlmICh0aGlzLl90eXBlID09IFwiYlwiKSByZXR1cm4gXCJib29sXCI7XG5cbiAgICAgICAgLy8gaWYgKHQgPT0gXCIzZltdXCIpIHJldHVybiBudWxsOyAvLyBpZ25vcmUgdGhpcyBmb3Igbm93Li4uXG4gICAgICAgIC8vIGlmICh0ID09IFwibTRbXVwiKSByZXR1cm4gbnVsbDsgLy8gaWdub3JlIHRoaXMgZm9yIG5vdy4uLlxuICAgICAgICAvLyBpZiAodCA9PSBcImZbXVwiKSByZXR1cm4gbnVsbDsgLy8gaWdub3JlIHRoaXMgZm9yIG5vdy4uLlxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_uniform.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_uniformbuffer.js":
/*!*******************************************!*\
  !*** ./src/core/cgp/cgp_uniformbuffer.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UniformBuffer)\n/* harmony export */ });\nclass UniformBuffer\n{\n    constructor(shader, shaderType)\n    {\n        this._shaderType = shaderType; // frag, vert...\n        this._shader = shader;\n        this._cgp = shader._cgp;\n\n        this._gpuBuffer = null;\n        this._values = null;\n\n        this._sizeBytes = 0;\n        this.update();\n    }\n\n    update()\n    {\n        this._sizeBytes = 0;\n\n        for (let i = 0; i < this._shader.uniforms.length; i++)\n        {\n            const uni = this._shader.uniforms[i];\n\n            if (this._shaderType == uni.shaderType)\n                this._sizeBytes += uni.getSizeBytes();\n        }\n\n        this._gpuBuffer = this._cgp.device.createBuffer(\n            {\n                \"size\": this._sizeBytes,\n                \"usage\": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n\n\n        this._values = new Float32Array(this._sizeBytes / 4);\n        this.updateUniformValues();\n    }\n\n    updateUniformValues()\n    {\n        let count = 0;\n        for (let i = 0; i < this._shader.uniforms.length; i++)\n        {\n            const uni = this._shader.uniforms[i];\n            if (uni.shaderType == this._shaderType)\n            {\n                if (uni.getSizeBytes() / 4 > 1)\n                {\n                    for (let j = 0; j < uni.getValue().length; j++)\n                    {\n                        this._values[count] = uni.getValue()[j];\n                        count++;\n                    }\n                }\n                else\n                {\n                    this._values[count] = uni.getValue();\n                    count++;\n                }\n            }\n        }\n\n\n        this._cgp.device.queue.writeBuffer(\n            this._gpuBuffer,\n            0,\n            this._values.buffer,\n            this._values.byteOffset,\n            this._values.byteLength\n        );\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3VuaWZvcm1idWZmZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NncC9jZ3BfdW5pZm9ybWJ1ZmZlci5qcz9hYzU1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaWZvcm1CdWZmZXJcbntcbiAgICBjb25zdHJ1Y3RvcihzaGFkZXIsIHNoYWRlclR5cGUpXG4gICAge1xuICAgICAgICB0aGlzLl9zaGFkZXJUeXBlID0gc2hhZGVyVHlwZTsgLy8gZnJhZywgdmVydC4uLlxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgIHRoaXMuX2NncCA9IHNoYWRlci5fY2dwO1xuXG4gICAgICAgIHRoaXMuX2dwdUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2l6ZUJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc2l6ZUJ5dGVzID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NoYWRlci51bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gdGhpcy5fc2hhZGVyLnVuaWZvcm1zW2ldO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hhZGVyVHlwZSA9PSB1bmkuc2hhZGVyVHlwZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zaXplQnl0ZXMgKz0gdW5pLmdldFNpemVCeXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3B1QnVmZmVyID0gdGhpcy5fY2dwLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IHRoaXMuX3NpemVCeXRlcyxcbiAgICAgICAgICAgICAgICBcInVzYWdlXCI6IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9zaXplQnl0ZXMgLyA0KTtcbiAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtVmFsdWVzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVW5pZm9ybVZhbHVlcygpXG4gICAge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NoYWRlci51bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gdGhpcy5fc2hhZGVyLnVuaWZvcm1zW2ldO1xuICAgICAgICAgICAgaWYgKHVuaS5zaGFkZXJUeXBlID09IHRoaXMuX3NoYWRlclR5cGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaS5nZXRTaXplQnl0ZXMoKSAvIDQgPiAxKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmkuZ2V0VmFsdWUoKS5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2NvdW50XSA9IHVuaS5nZXRWYWx1ZSgpW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbY291bnRdID0gdW5pLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLl9jZ3AuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxuICAgICAgICAgICAgdGhpcy5fZ3B1QnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5ieXRlTGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_uniformbuffer.js\n");

/***/ }),

/***/ "./src/core/cgp/index.js":
/*!*******************************!*\
  !*** ./src/core/cgp/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CGP\": () => (/* binding */ CGP)\n/* harmony export */ });\n/* harmony import */ var _cgp_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgp_state */ \"./src/core/cgp/cgp_state.js\");\n/* harmony import */ var _cgp_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgp_shader */ \"./src/core/cgp/cgp_shader.js\");\n/* harmony import */ var _cgp_mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp_mesh */ \"./src/core/cgp/cgp_mesh.js\");\n/* harmony import */ var _cgp_pipeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgp_pipeline */ \"./src/core/cgp/cgp_pipeline.js\");\n/* harmony import */ var _cgp_texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cgp_texture */ \"./src/core/cgp/cgp_texture.js\");\n\n\n\n\n\n\nconst CGP = {\n    \"Context\": _cgp_state__WEBPACK_IMPORTED_MODULE_0__.WebGpuContext,\n    \"Shader\": _cgp_shader__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    \"Mesh\": _cgp_mesh__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    \"Pipeline\": _cgp_pipeline__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    \"Texture\": _cgp_texture__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n};\n\nwindow.CGP = CGP;\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2luZGV4LmpzPzM2NjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2ViR3B1Q29udGV4dCB9IGZyb20gXCIuL2NncF9zdGF0ZVwiO1xuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi9jZ3Bfc2hhZGVyXCI7XG5pbXBvcnQgTWVzaCBmcm9tIFwiLi9jZ3BfbWVzaFwiO1xuaW1wb3J0IFBpcGVsaW5lIGZyb20gXCIuL2NncF9waXBlbGluZVwiO1xuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4vY2dwX3RleHR1cmVcIjtcblxuY29uc3QgQ0dQID0ge1xuICAgIFwiQ29udGV4dFwiOiBXZWJHcHVDb250ZXh0LFxuICAgIFwiU2hhZGVyXCI6IFNoYWRlcixcbiAgICBcIk1lc2hcIjogTWVzaCxcbiAgICBcIlBpcGVsaW5lXCI6IFBpcGVsaW5lLFxuICAgIFwiVGV4dHVyZVwiOiBUZXh0dXJlLFxufTtcblxud2luZG93LkNHUCA9IENHUDtcblxuXG5leHBvcnQgeyBDR1AgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgp/index.js\n");

/***/ }),

/***/ "./src/core/constants.js":
/*!*******************************!*\
  !*** ./src/core/constants.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS)\n/* harmony export */ });\nconst CONSTANTS = {\n    \"ANIM\": {\n        \"EASINGS\": [\n            \"linear\",\n            \"absolute\",\n            \"smoothstep\",\n            \"smootherstep\",\n            \"Cubic In\",\n            \"Cubic Out\",\n            \"Cubic In Out\",\n            \"Expo In\",\n            \"Expo Out\",\n            \"Expo In Out\",\n            \"Sin In\",\n            \"Sin Out\",\n            \"Sin In Out\",\n            \"Quart In\",\n            \"Quart Out\",\n            \"Quart In Out\",\n            \"Quint In\",\n            \"Quint Out\",\n            \"Quint In Out\",\n            \"Back In\",\n            \"Back Out\",\n            \"Back In Out\",\n            \"Elastic In\",\n            \"Elastic Out\",\n            \"Bounce In\",\n            \"Bounce Out\",\n        ],\n        \"EASING_LINEAR\": 0,\n        \"EASING_ABSOLUTE\": 1,\n        \"EASING_SMOOTHSTEP\": 2,\n        \"EASING_SMOOTHERSTEP\": 3,\n        \"EASING_CUBICSPLINE\": 4,\n\n        \"EASING_CUBIC_IN\": 5,\n        \"EASING_CUBIC_OUT\": 6,\n        \"EASING_CUBIC_INOUT\": 7,\n\n        \"EASING_EXPO_IN\": 8,\n        \"EASING_EXPO_OUT\": 9,\n        \"EASING_EXPO_INOUT\": 10,\n\n        \"EASING_SIN_IN\": 11,\n        \"EASING_SIN_OUT\": 12,\n        \"EASING_SIN_INOUT\": 13,\n\n        \"EASING_BACK_IN\": 14,\n        \"EASING_BACK_OUT\": 15,\n        \"EASING_BACK_INOUT\": 16,\n\n        \"EASING_ELASTIC_IN\": 17,\n        \"EASING_ELASTIC_OUT\": 18,\n\n        \"EASING_BOUNCE_IN\": 19,\n        \"EASING_BOUNCE_OUT\": 21,\n\n        \"EASING_QUART_IN\": 22,\n        \"EASING_QUART_OUT\": 23,\n        \"EASING_QUART_INOUT\": 24,\n\n        \"EASING_QUINT_IN\": 25,\n        \"EASING_QUINT_OUT\": 26,\n        \"EASING_QUINT_INOUT\": 27,\n    },\n\n    \"OP\": {\n        \"OP_PORT_TYPE_VALUE\": 0,\n        \"OP_PORT_TYPE_FUNCTION\": 1,\n        \"OP_PORT_TYPE_TRIGGER\": 1,\n        \"OP_PORT_TYPE_OBJECT\": 2,\n        \"OP_PORT_TYPE_TEXTURE\": 2,\n        \"OP_PORT_TYPE_ARRAY\": 3,\n        \"OP_PORT_TYPE_DYNAMIC\": 4,\n        \"OP_PORT_TYPE_STRING\": 5,\n\n        \"OP_VERSION_PREFIX\": \"_v\",\n    },\n\n    \"PORT\": {\n        \"PORT_DIR_IN\": 0,\n        \"PORT_DIR_OUT\": 1,\n    },\n\n    \"PACO\": {\n        \"PACO_CLEAR\": 0,\n        \"PACO_VALUECHANGE\": 1,\n        \"PACO_OP_DELETE\": 2,\n        \"PACO_UNLINK\": 3,\n        \"PACO_LINK\": 4,\n        \"PACO_LOAD\": 5,\n        \"PACO_OP_CREATE\": 6,\n        \"PACO_OP_ENABLE\": 7,\n        \"PACO_OP_DISABLE\": 8,\n        \"PACO_UIATTRIBS\": 9,\n        \"PACO_VARIABLES\": 10,\n        \"PACO_TRIGGERS\": 11,\n        \"PACO_PORT_SETVARIABLE\": 12,\n        \"PACO_PORT_SETANIMATED\": 13,\n        \"PACO_PORT_ANIM_UPDATED\": 14,\n        \"PACO_DESERIALIZE\": 15\n\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NvbnN0YW50cy5qcz82MTE5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBDT05TVEFOVFMgPSB7XG4gICAgXCJBTklNXCI6IHtcbiAgICAgICAgXCJFQVNJTkdTXCI6IFtcbiAgICAgICAgICAgIFwibGluZWFyXCIsXG4gICAgICAgICAgICBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBcInNtb290aHN0ZXBcIixcbiAgICAgICAgICAgIFwic21vb3RoZXJzdGVwXCIsXG4gICAgICAgICAgICBcIkN1YmljIEluXCIsXG4gICAgICAgICAgICBcIkN1YmljIE91dFwiLFxuICAgICAgICAgICAgXCJDdWJpYyBJbiBPdXRcIixcbiAgICAgICAgICAgIFwiRXhwbyBJblwiLFxuICAgICAgICAgICAgXCJFeHBvIE91dFwiLFxuICAgICAgICAgICAgXCJFeHBvIEluIE91dFwiLFxuICAgICAgICAgICAgXCJTaW4gSW5cIixcbiAgICAgICAgICAgIFwiU2luIE91dFwiLFxuICAgICAgICAgICAgXCJTaW4gSW4gT3V0XCIsXG4gICAgICAgICAgICBcIlF1YXJ0IEluXCIsXG4gICAgICAgICAgICBcIlF1YXJ0IE91dFwiLFxuICAgICAgICAgICAgXCJRdWFydCBJbiBPdXRcIixcbiAgICAgICAgICAgIFwiUXVpbnQgSW5cIixcbiAgICAgICAgICAgIFwiUXVpbnQgT3V0XCIsXG4gICAgICAgICAgICBcIlF1aW50IEluIE91dFwiLFxuICAgICAgICAgICAgXCJCYWNrIEluXCIsXG4gICAgICAgICAgICBcIkJhY2sgT3V0XCIsXG4gICAgICAgICAgICBcIkJhY2sgSW4gT3V0XCIsXG4gICAgICAgICAgICBcIkVsYXN0aWMgSW5cIixcbiAgICAgICAgICAgIFwiRWxhc3RpYyBPdXRcIixcbiAgICAgICAgICAgIFwiQm91bmNlIEluXCIsXG4gICAgICAgICAgICBcIkJvdW5jZSBPdXRcIixcbiAgICAgICAgXSxcbiAgICAgICAgXCJFQVNJTkdfTElORUFSXCI6IDAsXG4gICAgICAgIFwiRUFTSU5HX0FCU09MVVRFXCI6IDEsXG4gICAgICAgIFwiRUFTSU5HX1NNT09USFNURVBcIjogMixcbiAgICAgICAgXCJFQVNJTkdfU01PT1RIRVJTVEVQXCI6IDMsXG4gICAgICAgIFwiRUFTSU5HX0NVQklDU1BMSU5FXCI6IDQsXG5cbiAgICAgICAgXCJFQVNJTkdfQ1VCSUNfSU5cIjogNSxcbiAgICAgICAgXCJFQVNJTkdfQ1VCSUNfT1VUXCI6IDYsXG4gICAgICAgIFwiRUFTSU5HX0NVQklDX0lOT1VUXCI6IDcsXG5cbiAgICAgICAgXCJFQVNJTkdfRVhQT19JTlwiOiA4LFxuICAgICAgICBcIkVBU0lOR19FWFBPX09VVFwiOiA5LFxuICAgICAgICBcIkVBU0lOR19FWFBPX0lOT1VUXCI6IDEwLFxuXG4gICAgICAgIFwiRUFTSU5HX1NJTl9JTlwiOiAxMSxcbiAgICAgICAgXCJFQVNJTkdfU0lOX09VVFwiOiAxMixcbiAgICAgICAgXCJFQVNJTkdfU0lOX0lOT1VUXCI6IDEzLFxuXG4gICAgICAgIFwiRUFTSU5HX0JBQ0tfSU5cIjogMTQsXG4gICAgICAgIFwiRUFTSU5HX0JBQ0tfT1VUXCI6IDE1LFxuICAgICAgICBcIkVBU0lOR19CQUNLX0lOT1VUXCI6IDE2LFxuXG4gICAgICAgIFwiRUFTSU5HX0VMQVNUSUNfSU5cIjogMTcsXG4gICAgICAgIFwiRUFTSU5HX0VMQVNUSUNfT1VUXCI6IDE4LFxuXG4gICAgICAgIFwiRUFTSU5HX0JPVU5DRV9JTlwiOiAxOSxcbiAgICAgICAgXCJFQVNJTkdfQk9VTkNFX09VVFwiOiAyMSxcblxuICAgICAgICBcIkVBU0lOR19RVUFSVF9JTlwiOiAyMixcbiAgICAgICAgXCJFQVNJTkdfUVVBUlRfT1VUXCI6IDIzLFxuICAgICAgICBcIkVBU0lOR19RVUFSVF9JTk9VVFwiOiAyNCxcblxuICAgICAgICBcIkVBU0lOR19RVUlOVF9JTlwiOiAyNSxcbiAgICAgICAgXCJFQVNJTkdfUVVJTlRfT1VUXCI6IDI2LFxuICAgICAgICBcIkVBU0lOR19RVUlOVF9JTk9VVFwiOiAyNyxcbiAgICB9LFxuXG4gICAgXCJPUFwiOiB7XG4gICAgICAgIFwiT1BfUE9SVF9UWVBFX1ZBTFVFXCI6IDAsXG4gICAgICAgIFwiT1BfUE9SVF9UWVBFX0ZVTkNUSU9OXCI6IDEsXG4gICAgICAgIFwiT1BfUE9SVF9UWVBFX1RSSUdHRVJcIjogMSxcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfT0JKRUNUXCI6IDIsXG4gICAgICAgIFwiT1BfUE9SVF9UWVBFX1RFWFRVUkVcIjogMixcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfQVJSQVlcIjogMyxcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfRFlOQU1JQ1wiOiA0LFxuICAgICAgICBcIk9QX1BPUlRfVFlQRV9TVFJJTkdcIjogNSxcblxuICAgICAgICBcIk9QX1ZFUlNJT05fUFJFRklYXCI6IFwiX3ZcIixcbiAgICB9LFxuXG4gICAgXCJQT1JUXCI6IHtcbiAgICAgICAgXCJQT1JUX0RJUl9JTlwiOiAwLFxuICAgICAgICBcIlBPUlRfRElSX09VVFwiOiAxLFxuICAgIH0sXG5cbiAgICBcIlBBQ09cIjoge1xuICAgICAgICBcIlBBQ09fQ0xFQVJcIjogMCxcbiAgICAgICAgXCJQQUNPX1ZBTFVFQ0hBTkdFXCI6IDEsXG4gICAgICAgIFwiUEFDT19PUF9ERUxFVEVcIjogMixcbiAgICAgICAgXCJQQUNPX1VOTElOS1wiOiAzLFxuICAgICAgICBcIlBBQ09fTElOS1wiOiA0LFxuICAgICAgICBcIlBBQ09fTE9BRFwiOiA1LFxuICAgICAgICBcIlBBQ09fT1BfQ1JFQVRFXCI6IDYsXG4gICAgICAgIFwiUEFDT19PUF9FTkFCTEVcIjogNyxcbiAgICAgICAgXCJQQUNPX09QX0RJU0FCTEVcIjogOCxcbiAgICAgICAgXCJQQUNPX1VJQVRUUklCU1wiOiA5LFxuICAgICAgICBcIlBBQ09fVkFSSUFCTEVTXCI6IDEwLFxuICAgICAgICBcIlBBQ09fVFJJR0dFUlNcIjogMTEsXG4gICAgICAgIFwiUEFDT19QT1JUX1NFVFZBUklBQkxFXCI6IDEyLFxuICAgICAgICBcIlBBQ09fUE9SVF9TRVRBTklNQVRFRFwiOiAxMyxcbiAgICAgICAgXCJQQUNPX1BPUlRfQU5JTV9VUERBVEVEXCI6IDE0LFxuICAgICAgICBcIlBBQ09fREVTRVJJQUxJWkVcIjogMTVcblxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/constants.js\n");

/***/ }),

/***/ "./src/core/core_link.js":
/*!*******************************!*\
  !*** ./src/core/core_link.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Link\": () => (/* binding */ Link)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n\n\n\n/**\n * @external CABLES\n * @namespace Link\n * @param {Object} patch The patch object\n * @description a link is a connection between two ops/ports -> one input and one output port\n * @hideconstructor\n * @class\n */\nconst Link = function (scene)\n{\n    _eventtarget__WEBPACK_IMPORTED_MODULE_1__.EventTarget.apply(this);\n\n    this.id = CABLES.simpleId();\n    this.portIn = null;\n    this.portOut = null;\n    this.scene = scene; // todo: make private and rename to patch\n    this.activityCounter = 0;\n    this.ignoreInSerialize = false;\n};\n\nLink.prototype.setValue = function (v)\n{\n    if (v === undefined) this._setValue();\n    else this.portIn.set(v);\n};\n\nLink.prototype.activity = function ()\n{\n    this.activityCounter++;\n    // if(Date.now()-this.lastTime>100)\n    // {\n    //     // this.lastTime=Date.now();\n    //     // this.changesPerSecond=this.changesCounter*10;\n    //     this.changesCounter=0;\n    // }\n};\n\nLink.prototype._setValue = function ()\n{\n    if (!this.portOut)\n    {\n        this.remove();\n        return;\n    }\n    const v = this.portOut.get();\n\n    if (v == v) // NaN is the only JavaScript value that is treated as unequal to itself\n    {\n        if (this.portIn.type != _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) this.activity();\n\n        if (this.portIn.get() !== v)\n        {\n            this.portIn.set(v);\n        }\n        else\n        {\n            if (this.portIn.changeAlways) this.portIn.set(v);\n            if (this.portOut.forceRefChange) this.portIn.forceChange();\n        }\n    }\n};\n\n/**\n * @function getOtherPort\n * @memberof Link\n * @instance\n * @param {Port} port\n * @description returns the port of the link, which is not port\n */\nLink.prototype.getOtherPort = function (p)\n{\n    if (p == this.portIn) return this.portOut;\n    return this.portIn;\n};\n\n/**\n * @function remove\n * @memberof Link\n * @instance\n * @description unlink/remove this link from all ports\n */\nLink.prototype.remove = function ()\n{\n    if (this.portIn) this.portIn.removeLink(this);\n    if (this.portOut) this.portOut.removeLink(this);\n    if (this.scene)\n    {\n        this.scene.emitEvent(\"onUnLink\", this.portIn, this.portOut, this);\n    }\n\n    if (this.portIn && (this.portIn.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT || this.portIn.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY))\n    {\n        this.portIn.set(null);\n        if (this.portIn.links.length > 0) this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());\n    }\n\n    if (this.portIn) this.portIn.op._checkLinksNeededToWork();\n    if (this.portOut) this.portOut.op._checkLinksNeededToWork();\n\n    this.portIn = null;\n    this.portOut = null;\n    this.scene = null;\n};\n\n/**\n * @function link\n * @memberof Link\n * @instance\n * @description link those two ports\n * @param {Port} port1\n * @param {Port} port2\n */\nLink.prototype.link = function (p1, p2)\n{\n    if (!Link.canLink(p1, p2))\n    {\n        console.warn(\"[core_link] cannot link ports!\", p1, p2);\n        return false;\n    }\n\n    if (p1.direction == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.PORT.PORT_DIR_IN)\n    {\n        this.portIn = p1;\n        this.portOut = p2;\n    }\n    else\n    {\n        this.portIn = p2;\n        this.portOut = p1;\n    }\n\n    p1.addLink(this);\n    p2.addLink(this);\n\n    this.setValue();\n\n    if (p1.onLink) p1.onLink(this);\n    if (p2.onLink) p2.onLink(this);\n\n    p1.op._checkLinksNeededToWork();\n    p2.op._checkLinksNeededToWork();\n};\n\nLink.prototype.getSerialized = function ()\n{\n    const obj = {};\n\n    obj.portIn = this.portIn.getName();\n    obj.portOut = this.portOut.getName();\n    obj.objIn = this.portIn.op.id;\n    obj.objOut = this.portOut.op.id;\n\n    return obj;\n};\n\n// --------------------------------------------\n\n/**\n * @function canLinkText\n * @memberof Link\n * @instance\n * @description return a text message with human readable reason if ports can not be linked, or can be\n * @param {Port} port1\n * @param {Port} port2\n */\nLink.canLinkText = function (p1, p2)\n{\n    if (p1.direction == p2.direction)\n    {\n        let txt = \"(out)\";\n        if (p2.direction == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.PORT.PORT_DIR_IN) txt = \"(in)\";\n        return \"can not link: same direction \" + txt;\n    }\n    if (p1.op == p2.op) return \"can not link: same op\";\n    if (p1.type != _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC && p2.type != _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)\n    {\n        if (p1.type != p2.type) return \"can not link: different type\";\n    }\n\n    if (CABLES.UI && p1.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT && p2.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT)\n    {\n        if (p1.uiAttribs.objType && p2.uiAttribs.objType)\n            if (p1.uiAttribs.objType != p2.uiAttribs.objType)\n                return \"incompatible objects\";\n    }\n\n\n    if (!p1) return \"can not link: port 1 invalid\";\n    if (!p2) return \"can not link: port 2 invalid\";\n\n    if (p1.direction == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated()) return \"can not link: is animated\";\n    if (p2.direction == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated()) return \"can not link: is animated\";\n\n    // if(p1.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p1.links.length>0)return 'input port already busy';\n    // if(p2.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p2.links.length>0)return 'input port already busy';\n    if (p1.isLinkedTo(p2)) return \"ports already linked\";\n\n    if ((p1.canLink && !p1.canLink(p2)) || (p2.canLink && !p2.canLink(p1))) return \"Incompatible\";\n\n    return \"can link\";\n};\n\n/**\n * @function canLink\n * @memberof Link\n * @instance\n * @description return true if ports can be linked\n * @param {Port} port1\n * @param {Port} port2\n * @returns {Boolean}\n */\nLink.canLink = function (p1, p2)\n{\n    if (!p1) return false;\n    if (!p2) return false;\n    if (p1.direction == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated()) return false;\n    if (p2.direction == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated()) return false;\n\n    if (p1.isHidden() || p2.isHidden()) return false;\n\n    if (p1.isLinkedTo(p2)) return false;\n\n    if (p1.direction == p2.direction) return false;\n\n    if (CABLES.UI && p1.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT && p2.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT)\n    {\n        if (p1.uiAttribs.objType && p2.uiAttribs.objType)\n        {\n            if (p1.uiAttribs.objType.indexOf(\"sg_\") == 0 && p2.uiAttribs.objType.indexOf(\"sg_\") == 0) return true;\n            if (p1.uiAttribs.objType != p2.uiAttribs.objType)\n                return false;\n        }\n    }\n\n    if (p1.type != p2.type && (p1.type != _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC && p2.type != _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)) return false;\n    if (p1.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC || p2.type == _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;\n\n    if (p1.op == p2.op) return false;\n\n    if (p1.canLink && !p1.canLink(p2)) return false;\n    if (p2.canLink && !p2.canLink(p1)) return false;\n\n    return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX2xpbmsuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9saW5rLmpzPzYzNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50dGFyZ2V0XCI7XG5cbi8qKlxuICogQGV4dGVybmFsIENBQkxFU1xuICogQG5hbWVzcGFjZSBMaW5rXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2ggVGhlIHBhdGNoIG9iamVjdFxuICogQGRlc2NyaXB0aW9uIGEgbGluayBpcyBhIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gb3BzL3BvcnRzIC0+IG9uZSBpbnB1dCBhbmQgb25lIG91dHB1dCBwb3J0XG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAY2xhc3NcbiAqL1xuY29uc3QgTGluayA9IGZ1bmN0aW9uIChzY2VuZSlcbntcbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuaWQgPSBDQUJMRVMuc2ltcGxlSWQoKTtcbiAgICB0aGlzLnBvcnRJbiA9IG51bGw7XG4gICAgdGhpcy5wb3J0T3V0ID0gbnVsbDtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7IC8vIHRvZG86IG1ha2UgcHJpdmF0ZSBhbmQgcmVuYW1lIHRvIHBhdGNoXG4gICAgdGhpcy5hY3Rpdml0eUNvdW50ZXIgPSAwO1xuICAgIHRoaXMuaWdub3JlSW5TZXJpYWxpemUgPSBmYWxzZTtcbn07XG5cbkxpbmsucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpXG57XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdGhpcy5fc2V0VmFsdWUoKTtcbiAgICBlbHNlIHRoaXMucG9ydEluLnNldCh2KTtcbn07XG5cbkxpbmsucHJvdG90eXBlLmFjdGl2aXR5ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmFjdGl2aXR5Q291bnRlcisrO1xuICAgIC8vIGlmKERhdGUubm93KCktdGhpcy5sYXN0VGltZT4xMDApXG4gICAgLy8ge1xuICAgIC8vICAgICAvLyB0aGlzLmxhc3RUaW1lPURhdGUubm93KCk7XG4gICAgLy8gICAgIC8vIHRoaXMuY2hhbmdlc1BlclNlY29uZD10aGlzLmNoYW5nZXNDb3VudGVyKjEwO1xuICAgIC8vICAgICB0aGlzLmNoYW5nZXNDb3VudGVyPTA7XG4gICAgLy8gfVxufTtcblxuTGluay5wcm90b3R5cGUuX3NldFZhbHVlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMucG9ydE91dClcbiAgICB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdiA9IHRoaXMucG9ydE91dC5nZXQoKTtcblxuICAgIGlmICh2ID09IHYpIC8vIE5hTiBpcyB0aGUgb25seSBKYXZhU2NyaXB0IHZhbHVlIHRoYXQgaXMgdHJlYXRlZCBhcyB1bmVxdWFsIHRvIGl0c2VsZlxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucG9ydEluLnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTikgdGhpcy5hY3Rpdml0eSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnBvcnRJbi5nZXQoKSAhPT0gdilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wb3J0SW4uc2V0KHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydEluLmNoYW5nZUFsd2F5cykgdGhpcy5wb3J0SW4uc2V0KHYpO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydE91dC5mb3JjZVJlZkNoYW5nZSkgdGhpcy5wb3J0SW4uZm9yY2VDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldE90aGVyUG9ydFxuICogQG1lbWJlcm9mIExpbmtcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtQb3J0fSBwb3J0XG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyB0aGUgcG9ydCBvZiB0aGUgbGluaywgd2hpY2ggaXMgbm90IHBvcnRcbiAqL1xuTGluay5wcm90b3R5cGUuZ2V0T3RoZXJQb3J0ID0gZnVuY3Rpb24gKHApXG57XG4gICAgaWYgKHAgPT0gdGhpcy5wb3J0SW4pIHJldHVybiB0aGlzLnBvcnRPdXQ7XG4gICAgcmV0dXJuIHRoaXMucG9ydEluO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gcmVtb3ZlXG4gKiBAbWVtYmVyb2YgTGlua1xuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gdW5saW5rL3JlbW92ZSB0aGlzIGxpbmsgZnJvbSBhbGwgcG9ydHNcbiAqL1xuTGluay5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5wb3J0SW4pIHRoaXMucG9ydEluLnJlbW92ZUxpbmsodGhpcyk7XG4gICAgaWYgKHRoaXMucG9ydE91dCkgdGhpcy5wb3J0T3V0LnJlbW92ZUxpbmsodGhpcyk7XG4gICAgaWYgKHRoaXMuc2NlbmUpXG4gICAge1xuICAgICAgICB0aGlzLnNjZW5lLmVtaXRFdmVudChcIm9uVW5MaW5rXCIsIHRoaXMucG9ydEluLCB0aGlzLnBvcnRPdXQsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBvcnRJbiAmJiAodGhpcy5wb3J0SW4udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCB8fCB0aGlzLnBvcnRJbi50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfQVJSQVkpKVxuICAgIHtcbiAgICAgICAgdGhpcy5wb3J0SW4uc2V0KG51bGwpO1xuICAgICAgICBpZiAodGhpcy5wb3J0SW4ubGlua3MubGVuZ3RoID4gMCkgdGhpcy5wb3J0SW4uc2V0KHRoaXMucG9ydEluLmxpbmtzWzBdLmdldE90aGVyUG9ydCh0aGlzLnBvcnRJbikuZ2V0KCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBvcnRJbikgdGhpcy5wb3J0SW4ub3AuX2NoZWNrTGlua3NOZWVkZWRUb1dvcmsoKTtcbiAgICBpZiAodGhpcy5wb3J0T3V0KSB0aGlzLnBvcnRPdXQub3AuX2NoZWNrTGlua3NOZWVkZWRUb1dvcmsoKTtcblxuICAgIHRoaXMucG9ydEluID0gbnVsbDtcbiAgICB0aGlzLnBvcnRPdXQgPSBudWxsO1xuICAgIHRoaXMuc2NlbmUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gbGlua1xuICogQG1lbWJlcm9mIExpbmtcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGxpbmsgdGhvc2UgdHdvIHBvcnRzXG4gKiBAcGFyYW0ge1BvcnR9IHBvcnQxXG4gKiBAcGFyYW0ge1BvcnR9IHBvcnQyXG4gKi9cbkxpbmsucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbiAocDEsIHAyKVxue1xuICAgIGlmICghTGluay5jYW5MaW5rKHAxLCBwMikpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbY29yZV9saW5rXSBjYW5ub3QgbGluayBwb3J0cyFcIiwgcDEsIHAyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwMS5kaXJlY3Rpb24gPT0gQ09OU1RBTlRTLlBPUlQuUE9SVF9ESVJfSU4pXG4gICAge1xuICAgICAgICB0aGlzLnBvcnRJbiA9IHAxO1xuICAgICAgICB0aGlzLnBvcnRPdXQgPSBwMjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5wb3J0SW4gPSBwMjtcbiAgICAgICAgdGhpcy5wb3J0T3V0ID0gcDE7XG4gICAgfVxuXG4gICAgcDEuYWRkTGluayh0aGlzKTtcbiAgICBwMi5hZGRMaW5rKHRoaXMpO1xuXG4gICAgdGhpcy5zZXRWYWx1ZSgpO1xuXG4gICAgaWYgKHAxLm9uTGluaykgcDEub25MaW5rKHRoaXMpO1xuICAgIGlmIChwMi5vbkxpbmspIHAyLm9uTGluayh0aGlzKTtcblxuICAgIHAxLm9wLl9jaGVja0xpbmtzTmVlZGVkVG9Xb3JrKCk7XG4gICAgcDIub3AuX2NoZWNrTGlua3NOZWVkZWRUb1dvcmsoKTtcbn07XG5cbkxpbmsucHJvdG90eXBlLmdldFNlcmlhbGl6ZWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgb2JqLnBvcnRJbiA9IHRoaXMucG9ydEluLmdldE5hbWUoKTtcbiAgICBvYmoucG9ydE91dCA9IHRoaXMucG9ydE91dC5nZXROYW1lKCk7XG4gICAgb2JqLm9iakluID0gdGhpcy5wb3J0SW4ub3AuaWQ7XG4gICAgb2JqLm9iak91dCA9IHRoaXMucG9ydE91dC5vcC5pZDtcblxuICAgIHJldHVybiBvYmo7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEBmdW5jdGlvbiBjYW5MaW5rVGV4dFxuICogQG1lbWJlcm9mIExpbmtcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybiBhIHRleHQgbWVzc2FnZSB3aXRoIGh1bWFuIHJlYWRhYmxlIHJlYXNvbiBpZiBwb3J0cyBjYW4gbm90IGJlIGxpbmtlZCwgb3IgY2FuIGJlXG4gKiBAcGFyYW0ge1BvcnR9IHBvcnQxXG4gKiBAcGFyYW0ge1BvcnR9IHBvcnQyXG4gKi9cbkxpbmsuY2FuTGlua1RleHQgPSBmdW5jdGlvbiAocDEsIHAyKVxue1xuICAgIGlmIChwMS5kaXJlY3Rpb24gPT0gcDIuZGlyZWN0aW9uKVxuICAgIHtcbiAgICAgICAgbGV0IHR4dCA9IFwiKG91dClcIjtcbiAgICAgICAgaWYgKHAyLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTikgdHh0ID0gXCIoaW4pXCI7XG4gICAgICAgIHJldHVybiBcImNhbiBub3QgbGluazogc2FtZSBkaXJlY3Rpb24gXCIgKyB0eHQ7XG4gICAgfVxuICAgIGlmIChwMS5vcCA9PSBwMi5vcCkgcmV0dXJuIFwiY2FuIG5vdCBsaW5rOiBzYW1lIG9wXCI7XG4gICAgaWYgKHAxLnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDICYmIHAyLnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKVxuICAgIHtcbiAgICAgICAgaWYgKHAxLnR5cGUgIT0gcDIudHlwZSkgcmV0dXJuIFwiY2FuIG5vdCBsaW5rOiBkaWZmZXJlbnQgdHlwZVwiO1xuICAgIH1cblxuICAgIGlmIChDQUJMRVMuVUkgJiYgcDEudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCAmJiBwMi50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUKVxuICAgIHtcbiAgICAgICAgaWYgKHAxLnVpQXR0cmlicy5vYmpUeXBlICYmIHAyLnVpQXR0cmlicy5vYmpUeXBlKVxuICAgICAgICAgICAgaWYgKHAxLnVpQXR0cmlicy5vYmpUeXBlICE9IHAyLnVpQXR0cmlicy5vYmpUeXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImluY29tcGF0aWJsZSBvYmplY3RzXCI7XG4gICAgfVxuXG5cbiAgICBpZiAoIXAxKSByZXR1cm4gXCJjYW4gbm90IGxpbms6IHBvcnQgMSBpbnZhbGlkXCI7XG4gICAgaWYgKCFwMikgcmV0dXJuIFwiY2FuIG5vdCBsaW5rOiBwb3J0IDIgaW52YWxpZFwiO1xuXG4gICAgaWYgKHAxLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTiAmJiBwMS5pc0FuaW1hdGVkKCkpIHJldHVybiBcImNhbiBub3QgbGluazogaXMgYW5pbWF0ZWRcIjtcbiAgICBpZiAocDIuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOICYmIHAyLmlzQW5pbWF0ZWQoKSkgcmV0dXJuIFwiY2FuIG5vdCBsaW5rOiBpcyBhbmltYXRlZFwiO1xuXG4gICAgLy8gaWYocDEuZGlyZWN0aW9uPT1DQUJMRVMuQ09OU1RBTlRTLlBPUlQuUE9SVF9ESVJfSU4gJiYgcDEubGlua3MubGVuZ3RoPjApcmV0dXJuICdpbnB1dCBwb3J0IGFscmVhZHkgYnVzeSc7XG4gICAgLy8gaWYocDIuZGlyZWN0aW9uPT1DQUJMRVMuQ09OU1RBTlRTLlBPUlQuUE9SVF9ESVJfSU4gJiYgcDIubGlua3MubGVuZ3RoPjApcmV0dXJuICdpbnB1dCBwb3J0IGFscmVhZHkgYnVzeSc7XG4gICAgaWYgKHAxLmlzTGlua2VkVG8ocDIpKSByZXR1cm4gXCJwb3J0cyBhbHJlYWR5IGxpbmtlZFwiO1xuXG4gICAgaWYgKChwMS5jYW5MaW5rICYmICFwMS5jYW5MaW5rKHAyKSkgfHwgKHAyLmNhbkxpbmsgJiYgIXAyLmNhbkxpbmsocDEpKSkgcmV0dXJuIFwiSW5jb21wYXRpYmxlXCI7XG5cbiAgICByZXR1cm4gXCJjYW4gbGlua1wiO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY2FuTGlua1xuICogQG1lbWJlcm9mIExpbmtcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybiB0cnVlIGlmIHBvcnRzIGNhbiBiZSBsaW5rZWRcbiAqIEBwYXJhbSB7UG9ydH0gcG9ydDFcbiAqIEBwYXJhbSB7UG9ydH0gcG9ydDJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5MaW5rLmNhbkxpbmsgPSBmdW5jdGlvbiAocDEsIHAyKVxue1xuICAgIGlmICghcDEpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXAyKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHAxLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTiAmJiBwMS5pc0FuaW1hdGVkKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocDIuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOICYmIHAyLmlzQW5pbWF0ZWQoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHAxLmlzSGlkZGVuKCkgfHwgcDIuaXNIaWRkZW4oKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHAxLmlzTGlua2VkVG8ocDIpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocDEuZGlyZWN0aW9uID09IHAyLmRpcmVjdGlvbikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKENBQkxFUy5VSSAmJiBwMS50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUICYmIHAyLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QpXG4gICAge1xuICAgICAgICBpZiAocDEudWlBdHRyaWJzLm9ialR5cGUgJiYgcDIudWlBdHRyaWJzLm9ialR5cGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwMS51aUF0dHJpYnMub2JqVHlwZS5pbmRleE9mKFwic2dfXCIpID09IDAgJiYgcDIudWlBdHRyaWJzLm9ialR5cGUuaW5kZXhPZihcInNnX1wiKSA9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwMS51aUF0dHJpYnMub2JqVHlwZSAhPSBwMi51aUF0dHJpYnMub2JqVHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocDEudHlwZSAhPSBwMi50eXBlICYmIChwMS50eXBlICE9IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRFlOQU1JQyAmJiBwMi50eXBlICE9IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRFlOQU1JQykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocDEudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMgfHwgcDIudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMpIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKHAxLm9wID09IHAyLm9wKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocDEuY2FuTGluayAmJiAhcDEuY2FuTGluayhwMikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocDIuY2FuTGluayAmJiAhcDIuY2FuTGluayhwMSkpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IHsgTGluayB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_link.js\n");

/***/ }),

/***/ "./src/core/core_logger.js":
/*!*********************************!*\
  !*** ./src/core/core_logger.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Logger)\n/* harmony export */ });\n/* eslint-disable no-console */\n\nclass Logger\n{\n    constructor(initiator)\n    {\n        this._logs = [];\n        this.initiator = initiator;\n    }\n\n    stack(t)\n    {\n        console.info(\"[\" + this.initiator + \"] \", t);\n        console.log((new Error()).stack);\n        // if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"error\", t);\n    }\n\n    groupCollapsed(t)\n    {\n        console.groupCollapsed(\"[\" + this.initiator + \"] \" + t);\n    }\n\n    table(t)\n    {\n        console.table(t);\n    }\n\n    groupEnd()\n    {\n        console.groupEnd();\n    }\n\n    error(args)\n    {\n        console.error(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"error\", arguments);\n    }\n\n    info(args)\n    {\n        console.error(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"info\", arguments);\n    }\n\n    warn(args)\n    {\n        console.warn(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"warn\", arguments);\n    }\n\n    verbose()\n    {\n        if ((CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments)) || !CABLES.logSilent)\n            console.log(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"verbose\", arguments);\n    }\n\n    log(args)\n    {\n        if ((CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments)) || !CABLES.logSilent)\n            console.log(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"log\", arguments);\n    }\n\n    userInteraction(text)\n    {\n        // this.log({ \"initiator\": \"userinteraction\", \"text\": text });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX2xvZ2dlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9sb2dnZXIuanM/YTYzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2dlclxue1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYXRvcilcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5pbml0aWF0b3IgPSBpbml0aWF0b3I7XG4gICAgfVxuXG4gICAgc3RhY2sodClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdIFwiLCB0KTtcbiAgICAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgIC8vIGlmICh3aW5kb3cuZ3VpKSB3aW5kb3cuZ3VpLmVtaXRFdmVudChcImNvcmVMb2dFdmVudFwiLCB0aGlzLmluaXRpYXRvciwgXCJlcnJvclwiLCB0KTtcbiAgICB9XG5cbiAgICBncm91cENvbGxhcHNlZCh0KVxuICAgIHtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdIFwiICsgdCk7XG4gICAgfVxuXG4gICAgdGFibGUodClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUudGFibGUodCk7XG4gICAgfVxuXG4gICAgZ3JvdXBFbmQoKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cblxuICAgIGVycm9yKGFyZ3MpXG4gICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW1wiICsgdGhpcy5pbml0aWF0b3IgKyBcIl1cIiwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHdpbmRvdy5ndWkpIHdpbmRvdy5ndWkuZW1pdEV2ZW50KFwiY29yZUxvZ0V2ZW50XCIsIHRoaXMuaW5pdGlhdG9yLCBcImVycm9yXCIsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgaW5mbyhhcmdzKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdXCIsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh3aW5kb3cuZ3VpKSB3aW5kb3cuZ3VpLmVtaXRFdmVudChcImNvcmVMb2dFdmVudFwiLCB0aGlzLmluaXRpYXRvciwgXCJpbmZvXCIsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgd2FybihhcmdzKVxuICAgIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1wiICsgdGhpcy5pbml0aWF0b3IgKyBcIl1cIiwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHdpbmRvdy5ndWkpIHdpbmRvdy5ndWkuZW1pdEV2ZW50KFwiY29yZUxvZ0V2ZW50XCIsIHRoaXMuaW5pdGlhdG9yLCBcIndhcm5cIiwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2ZXJib3NlKClcbiAgICB7XG4gICAgICAgIGlmICgoQ0FCTEVTLlVJICYmIENBQkxFUy5VSS5sb2dGaWx0ZXIuc2hvdWxkUHJpbnQodGhpcy5pbml0aWF0b3IsIC4uLmFyZ3VtZW50cykpIHx8ICFDQUJMRVMubG9nU2lsZW50KVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbXCIgKyB0aGlzLmluaXRpYXRvciArIFwiXVwiLCAuLi5hcmd1bWVudHMpO1xuICAgICAgICBpZiAod2luZG93Lmd1aSkgd2luZG93Lmd1aS5lbWl0RXZlbnQoXCJjb3JlTG9nRXZlbnRcIiwgdGhpcy5pbml0aWF0b3IsIFwidmVyYm9zZVwiLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGxvZyhhcmdzKVxuICAgIHtcbiAgICAgICAgaWYgKChDQUJMRVMuVUkgJiYgQ0FCTEVTLlVJLmxvZ0ZpbHRlci5zaG91bGRQcmludCh0aGlzLmluaXRpYXRvciwgLi4uYXJndW1lbnRzKSkgfHwgIUNBQkxFUy5sb2dTaWxlbnQpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdXCIsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh3aW5kb3cuZ3VpKSB3aW5kb3cuZ3VpLmVtaXRFdmVudChcImNvcmVMb2dFdmVudFwiLCB0aGlzLmluaXRpYXRvciwgXCJsb2dcIiwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB1c2VySW50ZXJhY3Rpb24odGV4dClcbiAgICB7XG4gICAgICAgIC8vIHRoaXMubG9nKHsgXCJpbml0aWF0b3JcIjogXCJ1c2VyaW50ZXJhY3Rpb25cIiwgXCJ0ZXh0XCI6IHRleHQgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_logger.js\n");

/***/ }),

/***/ "./src/core/core_op.js":
/*!*****************************!*\
  !*** ./src/core/core_op.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Op\": () => (/* binding */ Op)\n/* harmony export */ });\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/* harmony import */ var _core_port__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core_port */ \"./src/core/core_port.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _core_port_switch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core_port_switch */ \"./src/core/core_port_switch.js\");\n/* harmony import */ var _core_port_select__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core_port_select */ \"./src/core/core_port_select.js\");\n\n\n\n\n\n\n\n\n/**\n * op the class of all operators\n * @external CABLES\n * @namespace Op\n * @hideconstructor\n */\n\n/**\n * @type {Object}\n * @name attachments\n * @instance\n * @memberof Op\n * @description access file attachments as String values\n * @example\n * // set shader source to attached files (files are called shader.vert / shader.frag)\n * shader.setSource(attachments.shader_vert,attachments.shader_frag);\n */\n\nconst Ops = {};\n\nconst Op = function ()\n{\n    _eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"core_op\");\n    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops\n    this.storage = {}; // op-specific data to be included in export\n    this._objName = \"\";\n    this.portsOut = [];\n    this.portsIn = [];\n    this.portsInData = []; // original loaded patch data\n    this.opId = \"\"; // unique op id\n    this.uiAttribs = {};\n    this.enabled = true;\n    this.patch = arguments[0];\n    this.name = arguments[1];\n\n    this._linkTimeRules = {\n        \"needsLinkedToWork\": [],\n        \"needsParentOp\": null\n    };\n\n    this.shouldWork = {};\n    this.hasUiErrors = false;\n    this._uiErrors = {};\n    this._hasAnimPort = false;\n\n    if (arguments[1])\n    {\n        this._shortOpName = CABLES.getShortOpName(arguments[1]);\n        this.getTitle();\n    }\n\n    this.id = arguments[2] || (0,_utils__WEBPACK_IMPORTED_MODULE_1__.shortId)(); // instance id\n    this.onAddPort = null;\n    this.onCreate = null;\n    this.onResize = null;\n    this.onLoaded = null;\n    this.onDelete = null;\n    this.onUiAttrChange = null;\n    this.onError = null;\n\n    this._instances = null;\n\n    /**\n     * overwrite this to prerender shader and meshes / will be called by op `loadingStatus`\n     * @function preRender\n     * @memberof Op\n     * @instance\n     */\n    this.preRender = null;\n\n    /**\n     * overwrite this to initialize your op\n     * @function init\n     * @memberof Op\n     * @instance\n     */\n    this.init = null;\n\n    Object.defineProperty(this, \"objName\", { get() { return this._objName; } });\n    Object.defineProperty(this, \"shortName\", { get() { return this._shortOpName; } });\n\n    if (this.initUi) this.initUi();\n};\n\n{\n    Op.prototype.clearUiAttrib = function (name)\n    {\n        const obj = {};\n        obj.name = null;\n        this.uiAttrib(obj);\n    };\n\n    Op.prototype.checkMainloopExists = function ()\n    {\n        if (!CABLES.UI) return;\n        if (!this.patch.cgl.mainloopOp) this.setUiError(\"nomainloop\", \"patch should have a mainloop to use this op\");\n        else this.setUiError(\"nomainloop\", null);\n    };\n\n    Op.prototype.getTitle = function ()\n    {\n        if (!this.uiAttribs) return \"nouiattribs\" + this.name;\n\n        if ((this.uiAttribs.title === undefined || this.uiAttribs.title === \"\") && this.objName.indexOf(\"Ops.Ui.\") == -1)\n            this.uiAttribs.title = this._shortOpName;\n\n        if (this.uiAttribs.title === undefined) this.uiAttribs.title = this._shortOpName;\n\n        return this.uiAttribs.title;\n    };\n\n    Op.prototype.setTitle = function (name)\n    {\n        const doEmitEvent = this.name != name;\n        this.name = name;\n\n        if (this.uiAttribs.title != name) this.uiAttr({ \"title\": name });\n        if (doEmitEvent) this.emitEvent(\"onTitleChange\", name);\n    };\n\n    Op.prototype.setStorage = function (newAttribs)\n    {\n        if (!newAttribs) return;\n        this.storage = this.storage || {};\n\n        let changed = false;\n        for (const p in newAttribs)\n        {\n            if (this.storage[p] != newAttribs[p]) changed = true;\n            this.storage[p] = newAttribs[p];\n        }\n\n        if (changed) this.emitEvent(\"onStorageChange\", newAttribs);\n    };\n\n    Op.prototype.isSubPatchOp = function ()\n    {\n        if (this.storage) return (this.storage.subPatchVer || 0);\n    };\n\n\n    // Op.isSubPatchOpName = function (name)\n    // {\n    //     return name == \"Ops.Ui.Patch\" || name == \"Ops.Ui.SubPatch\";\n    // };\n\n\n    const _setUiAttrib = function (newAttribs)\n    {\n        if (!newAttribs) return;\n\n        if (newAttribs.error || newAttribs.warning || newAttribs.hint)\n        {\n            this._log.warn(\"old ui error/warning attribute in \" + this.name + \", use op.setUiError !\", newAttribs);\n        }\n\n        // if (newAttribs.warning) this._log.warn(\"old ui warning attribute in \" + this.name + \", use op.setUiError !\");\n        // if (newAttribs.hint) this._log.warn(\"old ui hint attribute in \" + this.name + \", use op.setUiError !\");\n\n        if (typeof newAttribs != \"object\") this._log.error(\"op.uiAttrib attribs are not of type object\");\n        if (!this.uiAttribs) this.uiAttribs = {};\n\n\n        let emitMove = false;\n        if (\n            CABLES.UI &&\n            newAttribs.hasOwnProperty(\"translate\") &&\n            (\n                !this.uiAttribs.translate ||\n                this.uiAttribs.translate.x != newAttribs.translate.x ||\n                this.uiAttribs.translate.y != newAttribs.translate.y\n            )) emitMove = true;\n\n\n        let changed = false;\n        for (const p in newAttribs)\n        {\n            if (this.uiAttribs[p] != newAttribs[p]) changed = true;\n            this.uiAttribs[p] = newAttribs[p];\n        }\n\n        if (this.uiAttribs.hasOwnProperty(\"selected\") && this.uiAttribs.selected == false) delete this.uiAttribs.selected;\n        if (newAttribs.title && newAttribs.title != this.name) this.setTitle(newAttribs.title);\n\n        if (changed)\n        {\n            this.emitEvent(\"onUiAttribsChange\", newAttribs);\n            this.patch.emitEvent(\"onUiAttribsChange\", this, newAttribs);\n        }\n\n        if (emitMove) this.emitEvent(\"move\");\n    };\n    /**\n     * setUiAttrib\n     * possible values:\n     * <pre>\n     * warning - warning message - showing up in op parameter panel\n     * error - error message - showing up in op parameter panel\n     * extendTitle - op title extension, e.g. [ + ]\n     * </pre>\n     * @function setUiAttrib\n     * @param {Object} newAttribs, e.g. {\"attrib\":value}\n     * @memberof Op\n     * @instance\n     * @example\n     * op.setUiAttrib({\"extendTitle\":str});\n     */\n    Op.prototype.setUiAttribs = Op.prototype.setUiAttrib = Op.prototype.uiAttr = _setUiAttrib;\n\n    Op.prototype.getName = function ()\n    {\n        if (this.uiAttribs.name) return this.uiAttribs.name;\n\n\n        // return this.objName.split(\".\");\n\n        return this.name;\n    };\n\n    Op.prototype.addOutPort = function (p)\n    {\n        p.direction = _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_OUT;\n        p._op = this;\n        this.portsOut.push(p);\n        this.emitEvent(\"onPortAdd\", p);\n        return p;\n    };\n\n    // Op.prototype.hasPort = function(name) {\n    //     for (var ipi = 0; ipi < this.portsIn.length; ipi++)\n    //         if (this.portsIn[i].getName() == name) return true;\n    //     return false;\n    // };\n\n    Op.prototype.hasDynamicPort = function ()\n    {\n        let i = 0;\n        for (i = 0; i < this.portsIn.length; i++)\n        {\n            if (this.portsIn[i].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;\n            if (this.portsIn[i].getName() == \"dyn\") return true;\n        }\n        for (i = 0; i < this.portsOut.length; i++)\n        {\n            if (this.portsOut[i].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;\n            if (this.portsOut[i].getName() == \"dyn\") return true;\n        }\n\n        return false;\n    };\n\n    Op.prototype.addInPort = function (p)\n    {\n        if (!(p instanceof _core_port__WEBPACK_IMPORTED_MODULE_3__.Port))\n            throw new Error(\"parameter is not a port!\");\n\n\n        p.direction = _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN;\n        p._op = this;\n\n        this.portsIn.push(p);\n        this.emitEvent(\"onPortAdd\", p);\n\n\n        return p;\n    };\n\n    /**\n     * create a trigger input port\n     * @function inTrigger\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     *\n     */\n    Op.prototype.inFunction = Op.prototype.inTrigger = function (name, v)\n    {\n        const p = this.addInPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION));\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create multiple UI trigger buttons\n     * @function inTriggerButton\n     * @memberof Op\n     * @instance\n     * @param {String} name\n     * @param {Array} names\n     * @return {Port} created port\n     */\n    Op.prototype.inFunctionButton = Op.prototype.inTriggerButton = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {\n                \"display\": \"button\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    Op.prototype.inFunctionButton = Op.prototype.inUiTriggerButtons = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {\n                \"display\": \"buttons\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create a number value input port\n     * @function inFloat\n     * @memberof Op\n     * @instance\n     * @param {String} name\n     * @param {Number} value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueFloat = Op.prototype.inValue = Op.prototype.inFloat = function (name, v)\n    {\n        const p = this.addInPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE));\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a boolean input port, displayed as a checkbox\n     * @function inBool\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Boolean} value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueBool = Op.prototype.inBool = function (name, v)\n    {\n        // old\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"bool\"\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = p.get();\n        }\n        return p;\n    };\n\n    /**\n     * create a String value input port\n     * @function inString\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueString = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\"\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    // new string\n    Op.prototype.inString = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\"\n            })\n        );\n        v = v || \"\";\n        p.value = v;\n        p.set(v);\n        p.defaultValue = v;\n        return p;\n    };\n\n    /**\n     * create a String value input port displayed as TextArea\n     * @function inValueText\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueText = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\",\n                \"display\": \"text\"\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    Op.prototype.inTextarea = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\",\n                \"display\": \"text\"\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a String value input port displayed as editor\n     * @function inStringEditor\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    // new string\n    Op.prototype.inStringEditor = function (name, v, syntax, hideFormatButton = true)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\",\n                \"display\": \"editor\",\n                \"editShortcut\": true,\n                \"editorSyntax\": syntax,\n                \"hideFormatButton\": hideFormatButton\n            }));\n\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    // old\n    Op.prototype.inValueEditor = function (name, v, syntax, hideFormatButton = true)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\",\n                \"display\": \"editor\",\n                \"editorSyntax\": syntax,\n                \"hideFormatButton\": hideFormatButton\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a string select box\n     * @function inDropDown\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Array} values\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueSelect = Op.prototype.inDropDown = function (name, values, v, noindex)\n    {\n        let p = null;\n        if (!noindex)\n        {\n            const indexPort = new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name + \" index\", _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"increment\": \"integer\",\n                \"hideParam\": true\n            });\n            const n = this.addInPort(indexPort);\n\n            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);\n\n            const valuePort = new _core_port_select__WEBPACK_IMPORTED_MODULE_6__.ValueSelectPort(\n                this,\n                name,\n                _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE,\n                {\n                    \"display\": \"dropdown\",\n                    \"hidePort\": true,\n                    \"type\": \"string\",\n                    \"values\": values\n                },\n                n\n            );\n\n            valuePort.indexPort = indexPort;\n\n            indexPort.onLinkChanged = function ()\n            {\n                valuePort.setUiAttribs({ \"greyout\": indexPort.isLinked() });\n            };\n\n            p = this.addInPort(valuePort);\n\n            if (v !== undefined)\n            {\n                p.set(v);\n                const index = values.findIndex((item) => { return item == v; });\n                n.setValue(index);\n                p.defaultValue = v;\n                n.defaultValue = index;\n            }\n        }\n        else\n        {\n            const valuePort = new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"dropdown\",\n                \"hidePort\": true,\n                \"type\": \"string\",\n                values\n            });\n\n            p = this.addInPort(valuePort);\n        }\n\n        return p;\n    };\n\n    /**\n     * create a string switch box\n     * @function inSwitch\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Array} values\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inSwitch = function (name, values, v, noindex)\n    {\n        let p = null;\n        if (!noindex)\n        {\n            if (!v)v = values[0];\n            const indexPort = new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name + \" index\", _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"increment\": \"integer\",\n                \"hideParam\": true\n            });\n            const n = this.addInPort(indexPort);\n\n            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);\n\n            const switchPort = new _core_port_switch__WEBPACK_IMPORTED_MODULE_5__.SwitchPort(\n                this,\n                name,\n                _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING,\n                {\n                    \"display\": \"switch\",\n                    \"hidePort\": true,\n                    \"type\": \"string\",\n                    \"values\": values\n                },\n                n\n            );\n\n            indexPort.onLinkChanged = function ()\n            {\n                switchPort.setUiAttribs({ \"greyout\": indexPort.isLinked() });\n            };\n            p = this.addInPort(switchPort);\n\n            if (v !== undefined)\n            {\n                p.set(v);\n                const index = values.findIndex((item) => { return item == v; });\n                n.setValue(index);\n                p.defaultValue = v;\n                n.defaultValue = index;\n            }\n        }\n        else\n        {\n            const switchPort = new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"display\": \"switch\",\n                \"hidePort\": true,\n                \"type\": \"string\",\n                \"values\": values\n            });\n            p = this.addInPort(switchPort);\n        }\n\n        return p;\n    };\n\n    /**\n     * create a integer input port\n     * @function inInt\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {number} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueInt = Op.prototype.inInt = function (name, v)\n    {\n        // old\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"increment\": \"integer\"\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a file/URL input port\n     * @function inURL\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inFile = function (name, filter, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"file\",\n                \"type\": \"string\",\n                \"filter\": filter\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    Op.prototype.inUrl = function (name, filter, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"display\": \"file\",\n                \"type\": \"string\",\n                \"filter\": filter\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a texture input port\n     * @function inTexture\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inTexture = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {\n                \"display\": \"texture\",\n                \"objType\": \"texture\",\n                \"preview\": true\n            })\n        );\n        p.ignoreValueSerialize = true;\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n\n    /**\n     * create a object input port\n     * @function inObject\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inObject = function (name, v, objType)\n    {\n        const p = this.addInPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, { \"objType\": objType }));\n        p.ignoreValueSerialize = true;\n\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    Op.prototype.inGradient = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"gradient\",\n                \"hidePort\": true\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create a array input port\n     * @function inArray\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inArray = function (name, v, stride)\n    {\n        if (!stride && CABLES.UTILS.isNumeric(v))stride = v;\n\n        const p = this.addInPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY, { \"stride\": stride }));\n\n        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);\n\n        // if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create a value slider input port\n     * @function inFloatSlider\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {number} defaultvalue\n     * @param {number} min\n     * @param {number} max\n     * @return {Port} created port\n     */\n    Op.prototype.inValueSlider = Op.prototype.inFloatSlider = function (name, v, min, max)\n    {\n        const uiattribs = { \"display\": \"range\" };\n\n        if (min != undefined && max != undefined)\n        {\n            uiattribs.min = min;\n            uiattribs.max = max;\n        }\n\n        const p = this.addInPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, uiattribs));\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create output trigger port\n     * @function outTrigger\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outFunction = Op.prototype.outTrigger = function (name, v)\n    {\n        // old\n        const p = this.addOutPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION));\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create output value port\n     * @function outNumber\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {number} default value\n     * @return {Port} created port\n     */\n    Op.prototype.outValue = Op.prototype.outNumber = function (name, v)\n    {\n        // old\n        const p = this.addOutPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE));\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create output boolean port\n     * @function outBool\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outValueBool = Op.prototype.outBool = function (name, v)\n    {\n        // old\n        const p = this.addOutPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"bool\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        else p.set(0);\n        return p;\n    };\n\n    /**\n     * create output boolean port,value will be converted to 0 or 1\n     * @function outBool\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outBoolNum = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"boolnum\"\n            })\n        );\n\n        p.set = function (b)\n        {\n            this.setValue(b ? 1 : 0);\n            // console.log(\"bool set\", b, this.get());\n        }.bind(p);\n\n        if (v !== undefined) p.set(v);\n        else p.set(0);\n        return p;\n    };\n\n    /**\n     * create output string port\n     * @function outString\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outValueString = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n    Op.prototype.outString = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        else p.set(\"\");\n        return p;\n    };\n\n    /**\n     * create output object port\n     * @function outObject\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outObject = function (name, v, objType)\n    {\n        const p = this.addOutPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, { \"objType\": objType || null }));\n        p.set(v || null);\n        p.ignoreValueSerialize = true;\n        return p;\n    };\n\n    /**\n     * create output array port\n     * @function outArray\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outArray = function (name, v, stride)\n    {\n        if (!stride && CABLES.UTILS.isNumeric(v))stride = v;\n        const p = this.addOutPort(new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY, { \"stride\": stride }));\n        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);\n\n        p.ignoreValueSerialize = true;\n        return p;\n    };\n\n    /**\n     * create output texture port\n     * @function outTexture\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outTexture = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {\n                \"preview\": true,\n                \"objType\": \"texture\"\n            })\n        );\n        if (v !== undefined) p.set(v || CGL.Texture.getEmptyTexture(this.patch.cgl));\n\n        p.ignoreValueSerialize = true;\n        return p;\n    };\n\n    Op.prototype.inDynamic = function (name, filter, options, v)\n    {\n        const p = new _core_port__WEBPACK_IMPORTED_MODULE_3__.Port(this, name, _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC, options);\n\n        p.shouldLink = function (p1, p2)\n        {\n            if (filter && _utils__WEBPACK_IMPORTED_MODULE_1__.UTILS.isArray(filter))\n            {\n                for (let i = 0; i < filter.length; i++)\n                {\n                    if (p1 == this && p2.type === filter[i]) return true;\n                    if (p2 == this && p1.type === filter[i]) return true;\n                }\n                return false; // types do not match\n            }\n            return true; // no filter set\n        };\n\n        this.addInPort(p);\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    Op.prototype.removeLinks = function ()\n    {\n        for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].removeLinks();\n        for (let ipo = 0; ipo < this.portsOut.length; ipo++) this.portsOut[ipo].removeLinks();\n    };\n\n    Op.prototype.getSerialized = function ()\n    {\n        const op = {};\n\n        if (this.opId) op.opId = this.opId;\n        if (this.patch.storeObjNames) op.objName = this.objName;\n\n        if (!this.enabled)op.disabled = true;\n\n        op.id = this.id;\n        op.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};\n\n        if (this.storage && Object.keys(this.storage).length > 0) op.storage = JSON.parse(JSON.stringify(this.storage));\n        if (this.uiAttribs.hasOwnProperty(\"working\") && this.uiAttribs.working == true) delete this.uiAttribs.working;\n        if (op.uiAttribs.hasOwnProperty(\"uierrors\")) delete op.uiAttribs.uierrors;\n\n        if (op.uiAttribs.title == this._shortOpName) delete op.uiAttribs.title;\n\n        op.portsIn = [];\n        op.portsOut = [];\n\n        for (let i = 0; i < this.portsIn.length; i++)\n        {\n            const s = this.portsIn[i].getSerialized();\n            if (s)op.portsIn.push(s);\n        }\n        for (const ipo in this.portsOut)\n        {\n            const s = this.portsOut[ipo].getSerialized();\n            if (s)op.portsOut.push(s);\n        }\n\n        if (op.portsIn.length == 0) delete op.portsIn;\n        if (op.portsOut.length == 0) delete op.portsOut;\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cleanJson)(op);\n\n        return op;\n    };\n\n    Op.prototype.getFirstOutPortByType = function (type)\n    {\n        for (const ipo in this.portsOut) if (this.portsOut[ipo].type == type) return this.portsOut[ipo];\n    };\n\n    Op.prototype.getFirstInPortByType = function (type)\n    {\n        for (const ipo in this.portsIn) if (this.portsIn[ipo].type == type) return this.portsIn[ipo];\n    };\n\n    /**\n     * return port by the name portName\n     * @function getPort\n     * @instance\n     * @memberof Op\n     * @param {String} portName\n     * @return {Port}\n     */\n    Op.prototype.getPort = Op.prototype.getPortByName = function (name, lowerCase)\n    {\n        if (lowerCase)\n        {\n            for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n                if (this.portsIn[ipi].getName().toLowerCase() == name || this.portsIn[ipi].id.toLowerCase() == name)\n                    return this.portsIn[ipi];\n\n            for (let ipo = 0; ipo < this.portsOut.length; ipo++)\n                if (this.portsOut[ipo].getName().toLowerCase() == name || this.portsOut[ipo].id.toLowerCase() == name)\n                    return this.portsOut[ipo];\n        }\n        else\n        {\n            for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n                if (this.portsIn[ipi].getName() == name || this.portsIn[ipi].id == name)\n                    return this.portsIn[ipi];\n\n            for (let ipo = 0; ipo < this.portsOut.length; ipo++)\n                if (this.portsOut[ipo].getName() == name || this.portsOut[ipo].id == name)\n                    return this.portsOut[ipo];\n        }\n    };\n\n\n    /**\n     * return port by the name id\n     * @function getPortById\n     * @instance\n     * @memberof Op\n     * @param {String} id\n     * @return {Port}\n     */\n    Op.prototype.getPortById = function (id)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++) if (this.portsIn[ipi].id == id) return this.portsIn[ipi];\n        for (let ipo = 0; ipo < this.portsOut.length; ipo++) if (this.portsOut[ipo].id == id) return this.portsOut[ipo];\n    };\n\n    Op.prototype.updateAnims = function ()\n    {\n        if (this._hasAnimPort)\n            for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].updateAnim();\n    };\n\n    Op.prototype.log = function ()\n    {\n        const initiator = \"op \" + this.objName;\n        if (CABLES.UI && !CABLES.UI.logFilter.shouldPrint(initiator, ...arguments)) return;\n        if (!CABLES.UI && this.patch.silent) return;\n\n        const args = [\"[op \" + CABLES.getShortOpName(this.objName) + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.log, [console, args]);// eslint-disable-line\n    };\n\n    Op.prototype.error = Op.prototype.logError = function ()\n    {\n        if (!this)\n        {\n            console.log(\"no this...!!!\");\n            debugger;\n            return;\n        }\n\n        // if (this.patch.silent) return;\n        const args = [\"[op \" + CABLES.getShortOpName(this.objName) + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.error, [console, args]);// eslint-disable-line\n        if (window.gui) window.gui.emitEvent(\"opLogEvent\", this.objName, \"error\", arguments);\n    };\n\n    Op.prototype.warn = Op.prototype.logWarn = function ()\n    {\n        // if (this.patch.silent) return;\n        const args = [\"[op \" + CABLES.getShortOpName(this.objName) + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.warn, [console, args]);// eslint-disable-line\n    };\n\n    Op.prototype.verbose = Op.prototype.logVerbose = function ()\n    {\n        const initiator = \"op \" + CABLES.getShortOpName(this.objName);\n        if (CABLES.UI && !CABLES.UI.logFilter.shouldPrint(initiator, ...arguments)) return;\n\n        if (!CABLES.UI && this.patch.silent) return;\n\n        const args = [\"[\" + initiator + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.info, [console, args]);// eslint-disable-line\n    };\n\n\n    Op.prototype.profile = function (enable)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            this.portsIn[ipi]._onTriggered = this.portsIn[ipi]._onTriggeredProfiling;\n            this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;\n        }\n    };\n\n    Op.prototype.findParent = function (objName)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            if (this.portsIn[ipi].isLinked())\n            {\n                if (this.portsIn[ipi].links[0].portOut.parent.objName == objName)\n                    return this.portsIn[ipi].links[0].portOut.parent;\n\n                let found = null;\n                found = this.portsIn[ipi].links[0].portOut.parent.findParent(objName);\n                if (found) return found;\n            }\n        }\n        return null;\n    };\n\n\n    // todo: check instancing stuff?\n    Op.prototype.cleanUp = function ()\n    {\n        if (this._instances)\n        {\n            for (let i = 0; i < this._instances.length; i++)\n            {\n                if (this._instances[i].onDelete) this._instances[i].onDelete();\n            }\n\n\n            this._instances.length = 0;\n        }\n        for (let i = 0; i < this.portsIn.length; i++)\n        {\n            this.portsIn[i].setAnimated(false);\n        }\n\n        if (this.onAnimFrame) this.patch.removeOnAnimFrame(this);\n    };\n\n    // todo: check instancing stuff?\n    Op.prototype.instanced = function (triggerPort)\n    {\n        console.log(\"instanced\", this.patch.instancing.numCycles());\n        if (this.patch.instancing.numCycles() === 0) return false;\n\n\n        let i = 0;\n        let ipi = 0;\n        if (!this._instances || this._instances.length != this.patch.instancing.numCycles())\n        {\n            if (!this._instances) this._instances = [];\n            this._.log(\"creating instances of \", this.objName, this.patch.instancing.numCycles(), this._instances.length);\n            this._instances.length = this.patch.instancing.numCycles();\n\n            for (i = 0; i < this._instances.length; i++)\n            {\n                this._instances[i] = this.patch.createOp(this.objName, true);\n                this._instances[i].instanced = function ()\n                {\n                    return false;\n                };\n                this._instances[i].uiAttr(this.uiAttribs);\n\n                for (let ipo = 0; ipo < this.portsOut.length; ipo++)\n                {\n                    if (this.portsOut[ipo].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n                    {\n                        this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);\n                    }\n                }\n            }\n\n            for (ipi = 0; ipi < this.portsIn.length; ipi++)\n            {\n                this.portsIn[ipi].onChange = null;\n                this.portsIn[ipi].onValueChanged = null;\n            }\n        }\n\n        const theTriggerPort = null;\n        for (ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            if (\n                this.portsIn[ipi].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE ||\n                this.portsIn[ipi].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY\n            )\n            {\n                this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());\n            }\n            if (this.portsIn[ipi].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n            {\n                // if(this._instances[ this.patch.instancing.index() ].portsIn[ipi].name==triggerPort.name)\n                // theTriggerPort=this._instances[ this.patch.instancing.index() ].portsIn[ipi];\n            }\n        }\n\n        if (theTriggerPort) theTriggerPort.onTriggered();\n\n        for (ipi = 0; ipi < this.portsOut.length; ipi++)\n        {\n            if (this.portsOut[ipi].type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE)\n            {\n                this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());\n            }\n        }\n\n        return true;\n    };\n\n    // todo: check instancing stuff?\n    Op.prototype.initInstancable = function ()\n    {\n        //         if(this.isInstanced)\n        //         {\n        //             console.log('cancel instancing');\n        //             return;\n        //         }\n        //         this._instances=[];\n        //         for(var ipi=0;ipi<this.portsIn.length;ipi++)\n        //         {\n        //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_VALUE)\n        //             {\n        //\n        //             }\n        //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n        //             {\n        //                 // var piIndex=ipi;\n        //                 this.portsIn[ipi].onTriggered=function(piIndex)\n        //                 {\n        //\n        //                     var i=0;\n        // // console.log('trigger',this._instances.length);\n        //\n        //                 }.bind(this,ipi );\n        //\n        //             }\n        // };\n        // this._instances=null;\n    };\n\n    Op.prototype.setValues = function (obj)\n    {\n        for (const i in obj)\n        {\n            const port = this.getPortByName(i);\n            if (port) port.set(obj[i]);\n            else this._log.warn(\"op.setValues: port not found:\", i);\n        }\n    };\n\n    /**\n     * return true if op has this error message id\n     * @function hasUiError\n     * @instance\n     * @memberof Op\n     * @param {id} error id\n     * @returns {Boolean} - has id\n     */\n    Op.prototype.hasUiError = function (id)\n    {\n        return this._uiErrors.hasOwnProperty(id) && this._uiErrors[id];\n    };\n\n    /**\n     * show op error message - set message to null to remove error message\n     * @function setUiError\n     * @instance\n     * @memberof Op\n     * @param {id} error id\n     * @param {txt} text message\n     * @param {level} level\n     */\n    Op.prototype.setUiError = function (id, txt, level)\n    {\n        if (!txt && !this.hasUiErrors) return;\n        if (!txt && !this._uiErrors.hasOwnProperty(id)) return;\n        if (this._uiErrors.hasOwnProperty(id) && this._uiErrors[id].txt == txt) return;\n\n        if (id.indexOf(\" \") > -1) this._log.warn(\"setuierror id cant have spaces! \", id);\n        id = id.replaceAll(\" \", \"_\");\n\n        if (!txt && this._uiErrors.hasOwnProperty(id)) delete this._uiErrors[id];\n        else\n        {\n            if (txt && (!this._uiErrors.hasOwnProperty(id) || this._uiErrors[id].txt != txt))\n            {\n                if (level == undefined) level = 2;\n                this._uiErrors[id] = { \"txt\": txt, \"level\": level, \"id\": id };\n            }\n        }\n\n        const errorArr = [];\n        for (const i in this._uiErrors) errorArr.push(this._uiErrors[i]);\n\n        this.uiAttr({ \"uierrors\": errorArr });\n        this.hasUiErrors = Object.keys(this._uiErrors).length;\n\n        this.emitEvent(\"uiErrorChange\");\n    };\n\n    // todo: remove\n    Op.prototype.setError = function (id, txt)\n    {\n        this._log.warn(\"old error message op.error() - use op.setUiError()\");\n    };\n\n\n    /**\n     * enable/disable op\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {boolean}\n     */\n    Op.prototype.setEnabled = function (b)\n    {\n        this.enabled = b;\n        this.emitEvent(\"onEnabledChange\", b);\n        if (!this.enabled) this.setUiError(\"_disabled\", \"Op is disabled\", 0);\n        else this.setUiError(\"_disabled\", null);\n    };\n\n    /**\n     * organize ports into a group\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Array} ports\n     */\n    Op.prototype.setPortGroup = function (name, ports)\n    {\n        for (let i = 0; i < ports.length; i++)\n        {\n            if (ports[i])\n                if (ports[i].setUiAttribs) ports[i].setUiAttribs({ \"group\": name });\n                else\n                {\n                    this._log.error(\"setPortGroup: invalid port!\");\n                }\n        }\n    };\n\n    /**\n     * visually indicate ports that they are coordinate inputs\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {Port} portX\n     * @param {Port} portY\n     * @param {Port} portZ\n     */\n    Op.prototype.setUiAxisPorts = function (px, py, pz)\n    {\n        if (px) px.setUiAttribs({ \"axis\": \"X\" });\n        if (py) py.setUiAttribs({ \"axis\": \"Y\" });\n        if (pz) pz.setUiAttribs({ \"axis\": \"Z\" });\n    };\n\n    /**\n     * remove port from op\n     * @function removePort\n     * @instance\n     * @memberof Op\n     * @param {Port} port to remove\n     */\n    Op.prototype.removePort = function (port)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            if (this.portsIn[ipi] == port)\n            {\n                this.portsIn.splice(ipi, 1);\n                this.emitEvent(\"onUiAttribsChange\", {});\n                this.emitEvent(\"onPortRemoved\", {});\n                return;\n            }\n        }\n    };\n\n    Op.prototype._checkLinksNeededToWork = function () {};\n\n    /**\n     * show a warning of this op is not a child of parentOpName\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {String} parentOpName\n     */\n    Op.prototype.toWorkNeedsParent = function (parentOpName)\n    {\n        if (!this.patch.isEditorMode()) return;\n\n        this._linkTimeRules.needsParentOp = parentOpName;\n    };\n\n    // /**\n    //  * show a warning of this op is a child of parentOpName\n    //  * @function\n    //  * @instance\n    //  * @memberof Op\n    //  * @param {String} parentOpName\n    //  */\n    Op.prototype.toWorkShouldNotBeChild = function (parentOpName, type)\n    {\n        if (!this.patch.isEditorMode()) return;\n        this._linkTimeRules.forbiddenParent = parentOpName;\n        if (type != undefined) this._linkTimeRules.forbiddenParentType = type;\n    };\n\n\n    /**\n     * show a small X to indicate op is not working when given ports are not linked\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {Port} port1\n     * @param {Port} port2\n     * @param {Port} port3\n     */\n    Op.prototype.toWorkPortsNeedToBeLinked = function ()\n    {\n        if (!this.patch.isEditorMode()) return;\n        for (let i = 0; i < arguments.length; i++)\n            if (this._linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1) this._linkTimeRules.needsLinkedToWork.push(arguments[i]);\n    };\n    Op.prototype.toWorkPortsNeedToBeLinkedReset = function ()\n    {\n        if (!this.patch.isEditorMode()) return;\n        this._linkTimeRules.needsLinkedToWork.length = 0;\n        if (this.checkLinkTimeWarnings) this.checkLinkTimeWarnings();\n    };\n\n    Op.prototype.initVarPorts = function ()\n    {\n        for (let i = 0; i < this.portsIn.length; i++)\n        {\n            if (this.portsIn[i].getVariableName()) this.portsIn[i].setVariable(this.portsIn[i].getVariableName());\n        }\n    };\n\n    /**\n     * refresh op parameters, if current op is selected\n     * @function\n     * @instance\n     * @memberof Op\n     */\n    Op.prototype.refreshParams = function ()\n    {\n        if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp())\n        {\n            gui.opParams.show(this);\n        }\n    };\n\n    /**\n     * Returns true if op is selected and parameter are shown in the editor, can only return true if in editor/ui\n     * @function isCurrentUiOp\n     * @instance\n     * @memberof Op\n     * @returns {Boolean} - is current ui op\n     */\n    Op.prototype.isCurrentUiOp = function ()\n    {\n        if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this);\n    };\n\n    /**\n     * Implement to render 2d canvas based graphics from in an op\n     * @function isCurrentUiOp\n     * @instance\n     * @memberof Op\n     * @param {ctx} context of canvas 2d\n     * @param {Object} layer info\n     * @param {number} layer.x x position on canvas\n     * @param {number} layer.y y position on canvas\n     * @param {number} layer.width width of canvas\n     * @param {number} layer.height height of canvas\n     * @param {number} layer.scale current scaling of patchfield view\n     */\n    Op.prototype.renderVizLayer = null; // optionaly defined in op instance\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX29wLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jb3JlX29wLmpzPzBkNzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudHRhcmdldFwiO1xuaW1wb3J0IHsgVVRJTFMsIGNsZWFuSnNvbiwgc2hvcnRJZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnRcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4vY29yZV9sb2dnZXJcIjtcbmltcG9ydCB7IFN3aXRjaFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnRfc3dpdGNoXCI7XG5pbXBvcnQgeyBWYWx1ZVNlbGVjdFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnRfc2VsZWN0XCI7XG5cbi8qKlxuICogb3AgdGhlIGNsYXNzIG9mIGFsbCBvcGVyYXRvcnNcbiAqIEBleHRlcm5hbCBDQUJMRVNcbiAqIEBuYW1lc3BhY2UgT3BcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAbmFtZSBhdHRhY2htZW50c1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgT3BcbiAqIEBkZXNjcmlwdGlvbiBhY2Nlc3MgZmlsZSBhdHRhY2htZW50cyBhcyBTdHJpbmcgdmFsdWVzXG4gKiBAZXhhbXBsZVxuICogLy8gc2V0IHNoYWRlciBzb3VyY2UgdG8gYXR0YWNoZWQgZmlsZXMgKGZpbGVzIGFyZSBjYWxsZWQgc2hhZGVyLnZlcnQgLyBzaGFkZXIuZnJhZylcbiAqIHNoYWRlci5zZXRTb3VyY2UoYXR0YWNobWVudHMuc2hhZGVyX3ZlcnQsYXR0YWNobWVudHMuc2hhZGVyX2ZyYWcpO1xuICovXG5cbmNvbnN0IE9wcyA9IHt9O1xuXG5jb25zdCBPcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY29yZV9vcFwiKTtcbiAgICB0aGlzLmRhdGEgPSB7fTsgLy8gVU5VU0VELCBERVBSRUNBVEVELCBvbmx5IGxlZnQgaW4gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdXNlcm9wc1xuICAgIHRoaXMuc3RvcmFnZSA9IHt9OyAvLyBvcC1zcGVjaWZpYyBkYXRhIHRvIGJlIGluY2x1ZGVkIGluIGV4cG9ydFxuICAgIHRoaXMuX29iak5hbWUgPSBcIlwiO1xuICAgIHRoaXMucG9ydHNPdXQgPSBbXTtcbiAgICB0aGlzLnBvcnRzSW4gPSBbXTtcbiAgICB0aGlzLnBvcnRzSW5EYXRhID0gW107IC8vIG9yaWdpbmFsIGxvYWRlZCBwYXRjaCBkYXRhXG4gICAgdGhpcy5vcElkID0gXCJcIjsgLy8gdW5pcXVlIG9wIGlkXG4gICAgdGhpcy51aUF0dHJpYnMgPSB7fTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucGF0Y2ggPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5uYW1lID0gYXJndW1lbnRzWzFdO1xuXG4gICAgdGhpcy5fbGlua1RpbWVSdWxlcyA9IHtcbiAgICAgICAgXCJuZWVkc0xpbmtlZFRvV29ya1wiOiBbXSxcbiAgICAgICAgXCJuZWVkc1BhcmVudE9wXCI6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5zaG91bGRXb3JrID0ge307XG4gICAgdGhpcy5oYXNVaUVycm9ycyA9IGZhbHNlO1xuICAgIHRoaXMuX3VpRXJyb3JzID0ge307XG4gICAgdGhpcy5faGFzQW5pbVBvcnQgPSBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHNbMV0pXG4gICAge1xuICAgICAgICB0aGlzLl9zaG9ydE9wTmFtZSA9IENBQkxFUy5nZXRTaG9ydE9wTmFtZShhcmd1bWVudHNbMV0pO1xuICAgICAgICB0aGlzLmdldFRpdGxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9IGFyZ3VtZW50c1syXSB8fCBzaG9ydElkKCk7IC8vIGluc3RhbmNlIGlkXG4gICAgdGhpcy5vbkFkZFBvcnQgPSBudWxsO1xuICAgIHRoaXMub25DcmVhdGUgPSBudWxsO1xuICAgIHRoaXMub25SZXNpemUgPSBudWxsO1xuICAgIHRoaXMub25Mb2FkZWQgPSBudWxsO1xuICAgIHRoaXMub25EZWxldGUgPSBudWxsO1xuICAgIHRoaXMub25VaUF0dHJDaGFuZ2UgPSBudWxsO1xuICAgIHRoaXMub25FcnJvciA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnN0YW5jZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogb3ZlcndyaXRlIHRoaXMgdG8gcHJlcmVuZGVyIHNoYWRlciBhbmQgbWVzaGVzIC8gd2lsbCBiZSBjYWxsZWQgYnkgb3AgYGxvYWRpbmdTdGF0dXNgXG4gICAgICogQGZ1bmN0aW9uIHByZVJlbmRlclxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucHJlUmVuZGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIG92ZXJ3cml0ZSB0aGlzIHRvIGluaXRpYWxpemUgeW91ciBvcFxuICAgICAqIEBmdW5jdGlvbiBpbml0XG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5pbml0ID0gbnVsbDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9iak5hbWVcIiwgeyBnZXQoKSB7IHJldHVybiB0aGlzLl9vYmpOYW1lOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TmFtZVwiLCB7IGdldCgpIHsgcmV0dXJuIHRoaXMuX3Nob3J0T3BOYW1lOyB9IH0pO1xuXG4gICAgaWYgKHRoaXMuaW5pdFVpKSB0aGlzLmluaXRVaSgpO1xufTtcblxue1xuICAgIE9wLnByb3RvdHlwZS5jbGVhclVpQXR0cmliID0gZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLm5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnVpQXR0cmliKG9iaik7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5jaGVja01haW5sb29wRXhpc3RzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICghQ0FCTEVTLlVJKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jZ2wubWFpbmxvb3BPcCkgdGhpcy5zZXRVaUVycm9yKFwibm9tYWlubG9vcFwiLCBcInBhdGNoIHNob3VsZCBoYXZlIGEgbWFpbmxvb3AgdG8gdXNlIHRoaXMgb3BcIik7XG4gICAgICAgIGVsc2UgdGhpcy5zZXRVaUVycm9yKFwibm9tYWlubG9vcFwiLCBudWxsKTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy51aUF0dHJpYnMpIHJldHVybiBcIm5vdWlhdHRyaWJzXCIgKyB0aGlzLm5hbWU7XG5cbiAgICAgICAgaWYgKCh0aGlzLnVpQXR0cmlicy50aXRsZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudWlBdHRyaWJzLnRpdGxlID09PSBcIlwiKSAmJiB0aGlzLm9iak5hbWUuaW5kZXhPZihcIk9wcy5VaS5cIikgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLnVpQXR0cmlicy50aXRsZSA9IHRoaXMuX3Nob3J0T3BOYW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSA9PT0gdW5kZWZpbmVkKSB0aGlzLnVpQXR0cmlicy50aXRsZSA9IHRoaXMuX3Nob3J0T3BOYW1lO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVpQXR0cmlicy50aXRsZTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICBjb25zdCBkb0VtaXRFdmVudCA9IHRoaXMubmFtZSAhPSBuYW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSAhPSBuYW1lKSB0aGlzLnVpQXR0cih7IFwidGl0bGVcIjogbmFtZSB9KTtcbiAgICAgICAgaWYgKGRvRW1pdEV2ZW50KSB0aGlzLmVtaXRFdmVudChcIm9uVGl0bGVDaGFuZ2VcIiwgbmFtZSk7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5zZXRTdG9yYWdlID0gZnVuY3Rpb24gKG5ld0F0dHJpYnMpXG4gICAge1xuICAgICAgICBpZiAoIW5ld0F0dHJpYnMpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gdGhpcy5zdG9yYWdlIHx8IHt9O1xuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcCBpbiBuZXdBdHRyaWJzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlW3BdICE9IG5ld0F0dHJpYnNbcF0pIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlW3BdID0gbmV3QXR0cmlic1twXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkKSB0aGlzLmVtaXRFdmVudChcIm9uU3RvcmFnZUNoYW5nZVwiLCBuZXdBdHRyaWJzKTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmlzU3ViUGF0Y2hPcCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSByZXR1cm4gKHRoaXMuc3RvcmFnZS5zdWJQYXRjaFZlciB8fCAwKTtcbiAgICB9O1xuXG5cbiAgICAvLyBPcC5pc1N1YlBhdGNoT3BOYW1lID0gZnVuY3Rpb24gKG5hbWUpXG4gICAgLy8ge1xuICAgIC8vICAgICByZXR1cm4gbmFtZSA9PSBcIk9wcy5VaS5QYXRjaFwiIHx8IG5hbWUgPT0gXCJPcHMuVWkuU3ViUGF0Y2hcIjtcbiAgICAvLyB9O1xuXG5cbiAgICBjb25zdCBfc2V0VWlBdHRyaWIgPSBmdW5jdGlvbiAobmV3QXR0cmlicylcbiAgICB7XG4gICAgICAgIGlmICghbmV3QXR0cmlicykgcmV0dXJuO1xuXG4gICAgICAgIGlmIChuZXdBdHRyaWJzLmVycm9yIHx8IG5ld0F0dHJpYnMud2FybmluZyB8fCBuZXdBdHRyaWJzLmhpbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwib2xkIHVpIGVycm9yL3dhcm5pbmcgYXR0cmlidXRlIGluIFwiICsgdGhpcy5uYW1lICsgXCIsIHVzZSBvcC5zZXRVaUVycm9yICFcIiwgbmV3QXR0cmlicyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAobmV3QXR0cmlicy53YXJuaW5nKSB0aGlzLl9sb2cud2FybihcIm9sZCB1aSB3YXJuaW5nIGF0dHJpYnV0ZSBpbiBcIiArIHRoaXMubmFtZSArIFwiLCB1c2Ugb3Auc2V0VWlFcnJvciAhXCIpO1xuICAgICAgICAvLyBpZiAobmV3QXR0cmlicy5oaW50KSB0aGlzLl9sb2cud2FybihcIm9sZCB1aSBoaW50IGF0dHJpYnV0ZSBpbiBcIiArIHRoaXMubmFtZSArIFwiLCB1c2Ugb3Auc2V0VWlFcnJvciAhXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3QXR0cmlicyAhPSBcIm9iamVjdFwiKSB0aGlzLl9sb2cuZXJyb3IoXCJvcC51aUF0dHJpYiBhdHRyaWJzIGFyZSBub3Qgb2YgdHlwZSBvYmplY3RcIik7XG4gICAgICAgIGlmICghdGhpcy51aUF0dHJpYnMpIHRoaXMudWlBdHRyaWJzID0ge307XG5cblxuICAgICAgICBsZXQgZW1pdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgQ0FCTEVTLlVJICYmXG4gICAgICAgICAgICBuZXdBdHRyaWJzLmhhc093blByb3BlcnR5KFwidHJhbnNsYXRlXCIpICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgIXRoaXMudWlBdHRyaWJzLnRyYW5zbGF0ZSB8fFxuICAgICAgICAgICAgICAgIHRoaXMudWlBdHRyaWJzLnRyYW5zbGF0ZS54ICE9IG5ld0F0dHJpYnMudHJhbnNsYXRlLnggfHxcbiAgICAgICAgICAgICAgICB0aGlzLnVpQXR0cmlicy50cmFuc2xhdGUueSAhPSBuZXdBdHRyaWJzLnRyYW5zbGF0ZS55XG4gICAgICAgICAgICApKSBlbWl0TW92ZSA9IHRydWU7XG5cblxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHAgaW4gbmV3QXR0cmlicylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMudWlBdHRyaWJzW3BdICE9IG5ld0F0dHJpYnNbcF0pIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51aUF0dHJpYnNbcF0gPSBuZXdBdHRyaWJzW3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudWlBdHRyaWJzLmhhc093blByb3BlcnR5KFwic2VsZWN0ZWRcIikgJiYgdGhpcy51aUF0dHJpYnMuc2VsZWN0ZWQgPT0gZmFsc2UpIGRlbGV0ZSB0aGlzLnVpQXR0cmlicy5zZWxlY3RlZDtcbiAgICAgICAgaWYgKG5ld0F0dHJpYnMudGl0bGUgJiYgbmV3QXR0cmlicy50aXRsZSAhPSB0aGlzLm5hbWUpIHRoaXMuc2V0VGl0bGUobmV3QXR0cmlicy50aXRsZSk7XG5cbiAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25VaUF0dHJpYnNDaGFuZ2VcIiwgbmV3QXR0cmlicyk7XG4gICAgICAgICAgICB0aGlzLnBhdGNoLmVtaXRFdmVudChcIm9uVWlBdHRyaWJzQ2hhbmdlXCIsIHRoaXMsIG5ld0F0dHJpYnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVtaXRNb3ZlKSB0aGlzLmVtaXRFdmVudChcIm1vdmVcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRVaUF0dHJpYlxuICAgICAqIHBvc3NpYmxlIHZhbHVlczpcbiAgICAgKiA8cHJlPlxuICAgICAqIHdhcm5pbmcgLSB3YXJuaW5nIG1lc3NhZ2UgLSBzaG93aW5nIHVwIGluIG9wIHBhcmFtZXRlciBwYW5lbFxuICAgICAqIGVycm9yIC0gZXJyb3IgbWVzc2FnZSAtIHNob3dpbmcgdXAgaW4gb3AgcGFyYW1ldGVyIHBhbmVsXG4gICAgICogZXh0ZW5kVGl0bGUgLSBvcCB0aXRsZSBleHRlbnNpb24sIGUuZy4gWyArIF1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBAZnVuY3Rpb24gc2V0VWlBdHRyaWJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3QXR0cmlicywgZS5nLiB7XCJhdHRyaWJcIjp2YWx1ZX1cbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG9wLnNldFVpQXR0cmliKHtcImV4dGVuZFRpdGxlXCI6c3RyfSk7XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnNldFVpQXR0cmlicyA9IE9wLnByb3RvdHlwZS5zZXRVaUF0dHJpYiA9IE9wLnByb3RvdHlwZS51aUF0dHIgPSBfc2V0VWlBdHRyaWI7XG5cbiAgICBPcC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnMubmFtZSkgcmV0dXJuIHRoaXMudWlBdHRyaWJzLm5hbWU7XG5cblxuICAgICAgICAvLyByZXR1cm4gdGhpcy5vYmpOYW1lLnNwbGl0KFwiLlwiKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuYWRkT3V0UG9ydCA9IGZ1bmN0aW9uIChwKVxuICAgIHtcbiAgICAgICAgcC5kaXJlY3Rpb24gPSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9PVVQ7XG4gICAgICAgIHAuX29wID0gdGhpcztcbiAgICAgICAgdGhpcy5wb3J0c091dC5wdXNoKHApO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uUG9ydEFkZFwiLCBwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8vIE9wLnByb3RvdHlwZS5oYXNQb3J0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIC8vICAgICBmb3IgKHZhciBpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAvLyAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baV0uZ2V0TmFtZSgpID09IG5hbWUpIHJldHVybiB0cnVlO1xuICAgIC8vICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gfTtcblxuICAgIE9wLnByb3RvdHlwZS5oYXNEeW5hbWljUG9ydCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baV0udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNJbltpXS5nZXROYW1lKCkgPT0gXCJkeW5cIikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucG9ydHNPdXQubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzT3V0W2ldLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzT3V0W2ldLmdldE5hbWUoKSA9PSBcImR5blwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmFkZEluUG9ydCA9IGZ1bmN0aW9uIChwKVxuICAgIHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIFBvcnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyYW1ldGVyIGlzIG5vdCBhIHBvcnQhXCIpO1xuXG5cbiAgICAgICAgcC5kaXJlY3Rpb24gPSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTjtcbiAgICAgICAgcC5fb3AgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMucG9ydHNJbi5wdXNoKHApO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uUG9ydEFkZFwiLCBwKTtcblxuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSB0cmlnZ2VyIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5UcmlnZ2VyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKlxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pbkZ1bmN0aW9uID0gT3AucHJvdG90eXBlLmluVHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04pKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgbXVsdGlwbGUgVUkgdHJpZ2dlciBidXR0b25zXG4gICAgICogQGZ1bmN0aW9uIGluVHJpZ2dlckJ1dHRvblxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gbmFtZXNcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5GdW5jdGlvbkJ1dHRvbiA9IE9wLnByb3RvdHlwZS5pblRyaWdnZXJCdXR0b24gPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04sIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJidXR0b25cIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuaW5GdW5jdGlvbkJ1dHRvbiA9IE9wLnByb3RvdHlwZS5pblVpVHJpZ2dlckJ1dHRvbnMgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04sIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJidXR0b25zXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbnVtYmVyIHZhbHVlIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5GbG9hdFxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVGbG9hdCA9IE9wLnByb3RvdHlwZS5pblZhbHVlID0gT3AucHJvdG90eXBlLmluRmxvYXQgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFKSk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAuc2V0KHYpO1xuICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBib29sZWFuIGlucHV0IHBvcnQsIGRpc3BsYXllZCBhcyBhIGNoZWNrYm94XG4gICAgICogQGZ1bmN0aW9uIGluQm9vbFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pblZhbHVlQm9vbCA9IE9wLnByb3RvdHlwZS5pbkJvb2wgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYm9vbFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gcC5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgU3RyaW5nIHZhbHVlIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5TdHJpbmdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVTdHJpbmcgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcC52YWx1ZSA9IFwiXCI7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAuc2V0KHYpO1xuICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvLyBuZXcgc3RyaW5nXG4gICAgT3AucHJvdG90eXBlLmluU3RyaW5nID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORywge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB2ID0gdiB8fCBcIlwiO1xuICAgICAgICBwLnZhbHVlID0gdjtcbiAgICAgICAgcC5zZXQodik7XG4gICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIFN0cmluZyB2YWx1ZSBpbnB1dCBwb3J0IGRpc3BsYXllZCBhcyBUZXh0QXJlYVxuICAgICAqIEBmdW5jdGlvbiBpblZhbHVlVGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5WYWx1ZVRleHQgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJ0ZXh0XCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHAudmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmluVGV4dGFyZWEgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfU1RSSU5HLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwidGV4dFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBwLnZhbHVlID0gXCJcIjtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIFN0cmluZyB2YWx1ZSBpbnB1dCBwb3J0IGRpc3BsYXllZCBhcyBlZGl0b3JcbiAgICAgKiBAZnVuY3Rpb24gaW5TdHJpbmdFZGl0b3JcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgLy8gbmV3IHN0cmluZ1xuICAgIE9wLnByb3RvdHlwZS5pblN0cmluZ0VkaXRvciA9IGZ1bmN0aW9uIChuYW1lLCB2LCBzeW50YXgsIGhpZGVGb3JtYXRCdXR0b24gPSB0cnVlKVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcsIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJlZGl0b3JcIixcbiAgICAgICAgICAgICAgICBcImVkaXRTaG9ydGN1dFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZWRpdG9yU3ludGF4XCI6IHN5bnRheCxcbiAgICAgICAgICAgICAgICBcImhpZGVGb3JtYXRCdXR0b25cIjogaGlkZUZvcm1hdEJ1dHRvblxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIHAudmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLy8gb2xkXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVFZGl0b3IgPSBmdW5jdGlvbiAobmFtZSwgdiwgc3ludGF4LCBoaWRlRm9ybWF0QnV0dG9uID0gdHJ1ZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJlZGl0b3JcIixcbiAgICAgICAgICAgICAgICBcImVkaXRvclN5bnRheFwiOiBzeW50YXgsXG4gICAgICAgICAgICAgICAgXCJoaWRlRm9ybWF0QnV0dG9uXCI6IGhpZGVGb3JtYXRCdXR0b25cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHAudmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgc3RyaW5nIHNlbGVjdCBib3hcbiAgICAgKiBAZnVuY3Rpb24gaW5Ecm9wRG93blxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5WYWx1ZVNlbGVjdCA9IE9wLnByb3RvdHlwZS5pbkRyb3BEb3duID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlcywgdiwgbm9pbmRleClcbiAgICB7XG4gICAgICAgIGxldCBwID0gbnVsbDtcbiAgICAgICAgaWYgKCFub2luZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbmRleFBvcnQgPSBuZXcgUG9ydCh0aGlzLCBuYW1lICsgXCIgaW5kZXhcIiwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiaW5jcmVtZW50XCI6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIFwiaGlkZVBhcmFtXCI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuYWRkSW5Qb3J0KGluZGV4UG9ydCk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB2YWx1ZXNbaV0gPSBTdHJpbmcodmFsdWVzW2ldKTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWVQb3J0ID0gbmV3IFZhbHVlU2VsZWN0UG9ydChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZVBvcnRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVzXCI6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFsdWVQb3J0LmluZGV4UG9ydCA9IGluZGV4UG9ydDtcblxuICAgICAgICAgICAgaW5kZXhQb3J0Lm9uTGlua0NoYW5nZWQgPSBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlUG9ydC5zZXRVaUF0dHJpYnMoeyBcImdyZXlvdXRcIjogaW5kZXhQb3J0LmlzTGlua2VkKCkgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwID0gdGhpcy5hZGRJblBvcnQodmFsdWVQb3J0KTtcblxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5maW5kSW5kZXgoKGl0ZW0pID0+IHsgcmV0dXJuIGl0ZW0gPT0gdjsgfSk7XG4gICAgICAgICAgICAgICAgbi5zZXRWYWx1ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgIG4uZGVmYXVsdFZhbHVlID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVBvcnQgPSBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZHJvcGRvd25cIixcbiAgICAgICAgICAgICAgICBcImhpZGVQb3J0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcCA9IHRoaXMuYWRkSW5Qb3J0KHZhbHVlUG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgc3RyaW5nIHN3aXRjaCBib3hcbiAgICAgKiBAZnVuY3Rpb24gaW5Td2l0Y2hcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluU3dpdGNoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlcywgdiwgbm9pbmRleClcbiAgICB7XG4gICAgICAgIGxldCBwID0gbnVsbDtcbiAgICAgICAgaWYgKCFub2luZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXYpdiA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4UG9ydCA9IG5ldyBQb3J0KHRoaXMsIG5hbWUgKyBcIiBpbmRleFwiLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJpbmNyZW1lbnRcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgXCJoaWRlUGFyYW1cIjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuID0gdGhpcy5hZGRJblBvcnQoaW5kZXhQb3J0KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlcykgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHZhbHVlc1tpXSA9IFN0cmluZyh2YWx1ZXNbaV0pO1xuXG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hQb3J0ID0gbmV3IFN3aXRjaFBvcnQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfU1RSSU5HLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZVBvcnRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVzXCI6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaW5kZXhQb3J0Lm9uTGlua0NoYW5nZWQgPSBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN3aXRjaFBvcnQuc2V0VWlBdHRyaWJzKHsgXCJncmV5b3V0XCI6IGluZGV4UG9ydC5pc0xpbmtlZCgpIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHAgPSB0aGlzLmFkZEluUG9ydChzd2l0Y2hQb3J0KTtcblxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5maW5kSW5kZXgoKGl0ZW0pID0+IHsgcmV0dXJuIGl0ZW0gPT0gdjsgfSk7XG4gICAgICAgICAgICAgICAgbi5zZXRWYWx1ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgIG4uZGVmYXVsdFZhbHVlID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hQb3J0ID0gbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcsIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJzd2l0Y2hcIixcbiAgICAgICAgICAgICAgICBcImhpZGVQb3J0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZXNcIjogdmFsdWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHAgPSB0aGlzLmFkZEluUG9ydChzd2l0Y2hQb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBpbnRlZ2VyIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5JbnRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVJbnQgPSBPcC5wcm90b3R5cGUuaW5JbnQgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJpbmNyZW1lbnRcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAuc2V0KHYpO1xuICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBmaWxlL1VSTCBpbnB1dCBwb3J0XG4gICAgICogQGZ1bmN0aW9uIGluVVJMXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5GaWxlID0gZnVuY3Rpb24gKG5hbWUsIGZpbHRlciwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJmaWx0ZXJcIjogZmlsdGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmluVXJsID0gZnVuY3Rpb24gKG5hbWUsIGZpbHRlciwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfU1RSSU5HLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZmlsdGVyXCI6IGZpbHRlclxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHRleHR1cmUgaW5wdXQgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBpblRleHR1cmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pblRleHR1cmUgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNULCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwidGV4dHVyZVwiLFxuICAgICAgICAgICAgICAgIFwib2JqVHlwZVwiOiBcInRleHR1cmVcIixcbiAgICAgICAgICAgICAgICBcInByZXZpZXdcIjogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcC5pZ25vcmVWYWx1ZVNlcmlhbGl6ZSA9IHRydWU7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBvYmplY3QgaW5wdXQgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBpbk9iamVjdFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluT2JqZWN0ID0gZnVuY3Rpb24gKG5hbWUsIHYsIG9ialR5cGUpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQobmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QsIHsgXCJvYmpUeXBlXCI6IG9ialR5cGUgfSkpO1xuICAgICAgICBwLmlnbm9yZVZhbHVlU2VyaWFsaXplID0gdHJ1ZTtcblxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5pbkdyYWRpZW50ID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZ3JhZGllbnRcIixcbiAgICAgICAgICAgICAgICBcImhpZGVQb3J0XCI6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgYXJyYXkgaW5wdXQgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBpbkFycmF5XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5BcnJheSA9IGZ1bmN0aW9uIChuYW1lLCB2LCBzdHJpZGUpXG4gICAge1xuICAgICAgICBpZiAoIXN0cmlkZSAmJiBDQUJMRVMuVVRJTFMuaXNOdW1lcmljKHYpKXN0cmlkZSA9IHY7XG5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfQVJSQVksIHsgXCJzdHJpZGVcIjogc3RyaWRlIH0pKTtcblxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmIChBcnJheS5pc0FycmF5KHYpIHx8IHYgPT0gbnVsbCkpIHAuc2V0KHYpO1xuXG4gICAgICAgIC8vIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgdmFsdWUgc2xpZGVyIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5GbG9hdFNsaWRlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHR2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVTbGlkZXIgPSBPcC5wcm90b3R5cGUuaW5GbG9hdFNsaWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2LCBtaW4sIG1heClcbiAgICB7XG4gICAgICAgIGNvbnN0IHVpYXR0cmlicyA9IHsgXCJkaXNwbGF5XCI6IFwicmFuZ2VcIiB9O1xuXG4gICAgICAgIGlmIChtaW4gIT0gdW5kZWZpbmVkICYmIG1heCAhPSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVpYXR0cmlicy5taW4gPSBtaW47XG4gICAgICAgICAgICB1aWF0dHJpYnMubWF4ID0gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHVpYXR0cmlicykpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIG91dHB1dCB0cmlnZ2VyIHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0VHJpZ2dlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLm91dEZ1bmN0aW9uID0gT3AucHJvdG90eXBlLm91dFRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04pKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IHZhbHVlIHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0TnVtYmVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5vdXRWYWx1ZSA9IE9wLnByb3RvdHlwZS5vdXROdW1iZXIgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUpKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IGJvb2xlYW4gcG9ydFxuICAgICAqIEBmdW5jdGlvbiBvdXRCb29sXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0VmFsdWVCb29sID0gT3AucHJvdG90eXBlLm91dEJvb2wgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJvb2xcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIGVsc2UgcC5zZXQoMCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IGJvb2xlYW4gcG9ydCx2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCB0byAwIG9yIDFcbiAgICAgKiBAZnVuY3Rpb24gb3V0Qm9vbFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLm91dEJvb2xOdW0gPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZE91dFBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYm9vbG51bVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHAuc2V0ID0gZnVuY3Rpb24gKGIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoYiA/IDEgOiAwKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYm9vbCBzZXRcIiwgYiwgdGhpcy5nZXQoKSk7XG4gICAgICAgIH0uYmluZChwKTtcblxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgZWxzZSBwLnNldCgwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBvdXRwdXQgc3RyaW5nIHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0U3RyaW5nXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0VmFsdWVTdHJpbmcgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZE91dFBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIE9wLnByb3RvdHlwZS5vdXRTdHJpbmcgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZE91dFBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORywge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgZWxzZSBwLnNldChcIlwiKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBvdXRwdXQgb2JqZWN0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0T2JqZWN0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0T2JqZWN0ID0gZnVuY3Rpb24gKG5hbWUsIHYsIG9ialR5cGUpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNULCB7IFwib2JqVHlwZVwiOiBvYmpUeXBlIHx8IG51bGwgfSkpO1xuICAgICAgICBwLnNldCh2IHx8IG51bGwpO1xuICAgICAgICBwLmlnbm9yZVZhbHVlU2VyaWFsaXplID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBvdXRwdXQgYXJyYXkgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBvdXRBcnJheVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLm91dEFycmF5ID0gZnVuY3Rpb24gKG5hbWUsIHYsIHN0cmlkZSlcbiAgICB7XG4gICAgICAgIGlmICghc3RyaWRlICYmIENBQkxFUy5VVElMUy5pc051bWVyaWModikpc3RyaWRlID0gdjtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkT3V0UG9ydChuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZLCB7IFwic3RyaWRlXCI6IHN0cmlkZSB9KSk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgKEFycmF5LmlzQXJyYXkodikgfHwgdiA9PSBudWxsKSkgcC5zZXQodik7XG5cbiAgICAgICAgcC5pZ25vcmVWYWx1ZVNlcmlhbGl6ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IHRleHR1cmUgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBvdXRUZXh0dXJlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0VGV4dHVyZSA9IGZ1bmN0aW9uIChuYW1lLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkT3V0UG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNULCB7XG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJvYmpUeXBlXCI6IFwidGV4dHVyZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2IHx8IENHTC5UZXh0dXJlLmdldEVtcHR5VGV4dHVyZSh0aGlzLnBhdGNoLmNnbCkpO1xuXG4gICAgICAgIHAuaWdub3JlVmFsdWVTZXJpYWxpemUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmluRHluYW1pYyA9IGZ1bmN0aW9uIChuYW1lLCBmaWx0ZXIsIG9wdGlvbnMsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDLCBvcHRpb25zKTtcblxuICAgICAgICBwLnNob3VsZExpbmsgPSBmdW5jdGlvbiAocDEsIHAyKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyICYmIFVUSUxTLmlzQXJyYXkoZmlsdGVyKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwMSA9PSB0aGlzICYmIHAyLnR5cGUgPT09IGZpbHRlcltpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwMiA9PSB0aGlzICYmIHAxLnR5cGUgPT09IGZpbHRlcltpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdHlwZXMgZG8gbm90IG1hdGNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbm8gZmlsdGVyIHNldFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkSW5Qb3J0KHApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnJlbW92ZUxpbmtzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaSsrKSB0aGlzLnBvcnRzSW5baV0ucmVtb3ZlTGlua3MoKTtcbiAgICAgICAgZm9yIChsZXQgaXBvID0gMDsgaXBvIDwgdGhpcy5wb3J0c091dC5sZW5ndGg7IGlwbysrKSB0aGlzLnBvcnRzT3V0W2lwb10ucmVtb3ZlTGlua3MoKTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmdldFNlcmlhbGl6ZWQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc3Qgb3AgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5vcElkKSBvcC5vcElkID0gdGhpcy5vcElkO1xuICAgICAgICBpZiAodGhpcy5wYXRjaC5zdG9yZU9iak5hbWVzKSBvcC5vYmpOYW1lID0gdGhpcy5vYmpOYW1lO1xuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKW9wLmRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICBvcC5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIG9wLnVpQXR0cmlicyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy51aUF0dHJpYnMpKSB8fCB7fTtcblxuICAgICAgICBpZiAodGhpcy5zdG9yYWdlICYmIE9iamVjdC5rZXlzKHRoaXMuc3RvcmFnZSkubGVuZ3RoID4gMCkgb3Auc3RvcmFnZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5zdG9yYWdlKSk7XG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicy5oYXNPd25Qcm9wZXJ0eShcIndvcmtpbmdcIikgJiYgdGhpcy51aUF0dHJpYnMud29ya2luZyA9PSB0cnVlKSBkZWxldGUgdGhpcy51aUF0dHJpYnMud29ya2luZztcbiAgICAgICAgaWYgKG9wLnVpQXR0cmlicy5oYXNPd25Qcm9wZXJ0eShcInVpZXJyb3JzXCIpKSBkZWxldGUgb3AudWlBdHRyaWJzLnVpZXJyb3JzO1xuXG4gICAgICAgIGlmIChvcC51aUF0dHJpYnMudGl0bGUgPT0gdGhpcy5fc2hvcnRPcE5hbWUpIGRlbGV0ZSBvcC51aUF0dHJpYnMudGl0bGU7XG5cbiAgICAgICAgb3AucG9ydHNJbiA9IFtdO1xuICAgICAgICBvcC5wb3J0c091dCA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5wb3J0c0luW2ldLmdldFNlcmlhbGl6ZWQoKTtcbiAgICAgICAgICAgIGlmIChzKW9wLnBvcnRzSW4ucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlwbyBpbiB0aGlzLnBvcnRzT3V0KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5wb3J0c091dFtpcG9dLmdldFNlcmlhbGl6ZWQoKTtcbiAgICAgICAgICAgIGlmIChzKW9wLnBvcnRzT3V0LnB1c2gocyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3AucG9ydHNJbi5sZW5ndGggPT0gMCkgZGVsZXRlIG9wLnBvcnRzSW47XG4gICAgICAgIGlmIChvcC5wb3J0c091dC5sZW5ndGggPT0gMCkgZGVsZXRlIG9wLnBvcnRzT3V0O1xuICAgICAgICBjbGVhbkpzb24ob3ApO1xuXG4gICAgICAgIHJldHVybiBvcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmdldEZpcnN0T3V0UG9ydEJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKVxuICAgIHtcbiAgICAgICAgZm9yIChjb25zdCBpcG8gaW4gdGhpcy5wb3J0c091dCkgaWYgKHRoaXMucG9ydHNPdXRbaXBvXS50eXBlID09IHR5cGUpIHJldHVybiB0aGlzLnBvcnRzT3V0W2lwb107XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5nZXRGaXJzdEluUG9ydEJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKVxuICAgIHtcbiAgICAgICAgZm9yIChjb25zdCBpcG8gaW4gdGhpcy5wb3J0c0luKSBpZiAodGhpcy5wb3J0c0luW2lwb10udHlwZSA9PSB0eXBlKSByZXR1cm4gdGhpcy5wb3J0c0luW2lwb107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBwb3J0IGJ5IHRoZSBuYW1lIHBvcnROYW1lXG4gICAgICogQGZ1bmN0aW9uIGdldFBvcnRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9ydE5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fVxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5nZXRQb3J0ID0gT3AucHJvdG90eXBlLmdldFBvcnRCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgbG93ZXJDYXNlKVxuICAgIHtcbiAgICAgICAgaWYgKGxvd2VyQ2FzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaXBpID0gMDsgaXBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaXBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNJbltpcGldLmdldE5hbWUoKS50b0xvd2VyQ2FzZSgpID09IG5hbWUgfHwgdGhpcy5wb3J0c0luW2lwaV0uaWQudG9Mb3dlckNhc2UoKSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3J0c0luW2lwaV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlwbyA9IDA7IGlwbyA8IHRoaXMucG9ydHNPdXQubGVuZ3RoOyBpcG8rKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3J0c091dFtpcG9dLmdldE5hbWUoKS50b0xvd2VyQ2FzZSgpID09IG5hbWUgfHwgdGhpcy5wb3J0c091dFtpcG9dLmlkLnRvTG93ZXJDYXNlKCkgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9ydHNPdXRbaXBvXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlwaSA9IDA7IGlwaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGlwaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baXBpXS5nZXROYW1lKCkgPT0gbmFtZSB8fCB0aGlzLnBvcnRzSW5baXBpXS5pZCA9PSBuYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3J0c0luW2lwaV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlwbyA9IDA7IGlwbyA8IHRoaXMucG9ydHNPdXQubGVuZ3RoOyBpcG8rKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3J0c091dFtpcG9dLmdldE5hbWUoKSA9PSBuYW1lIHx8IHRoaXMucG9ydHNPdXRbaXBvXS5pZCA9PSBuYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3J0c091dFtpcG9dO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHBvcnQgYnkgdGhlIG5hbWUgaWRcbiAgICAgKiBAZnVuY3Rpb24gZ2V0UG9ydEJ5SWRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJuIHtQb3J0fVxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5nZXRQb3J0QnlJZCA9IGZ1bmN0aW9uIChpZClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGlwaSA9IDA7IGlwaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGlwaSsrKSBpZiAodGhpcy5wb3J0c0luW2lwaV0uaWQgPT0gaWQpIHJldHVybiB0aGlzLnBvcnRzSW5baXBpXTtcbiAgICAgICAgZm9yIChsZXQgaXBvID0gMDsgaXBvIDwgdGhpcy5wb3J0c091dC5sZW5ndGg7IGlwbysrKSBpZiAodGhpcy5wb3J0c091dFtpcG9dLmlkID09IGlkKSByZXR1cm4gdGhpcy5wb3J0c091dFtpcG9dO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUudXBkYXRlQW5pbXMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0FuaW1Qb3J0KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpKyspIHRoaXMucG9ydHNJbltpXS51cGRhdGVBbmltKCk7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc3QgaW5pdGlhdG9yID0gXCJvcCBcIiArIHRoaXMub2JqTmFtZTtcbiAgICAgICAgaWYgKENBQkxFUy5VSSAmJiAhQ0FCTEVTLlVJLmxvZ0ZpbHRlci5zaG91bGRQcmludChpbml0aWF0b3IsIC4uLmFyZ3VtZW50cykpIHJldHVybjtcbiAgICAgICAgaWYgKCFDQUJMRVMuVUkgJiYgdGhpcy5wYXRjaC5zaWxlbnQpIHJldHVybjtcblxuICAgICAgICBjb25zdCBhcmdzID0gW1wiW29wIFwiICsgQ0FCTEVTLmdldFNob3J0T3BOYW1lKHRoaXMub2JqTmFtZSkgKyBcIl1cIl07XG4gICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmdzXSk7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuZXJyb3IgPSBPcC5wcm90b3R5cGUubG9nRXJyb3IgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIHRoaXMuLi4hISFcIik7XG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmICh0aGlzLnBhdGNoLnNpbGVudCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcmdzID0gW1wiW29wIFwiICsgQ0FCTEVTLmdldFNob3J0T3BOYW1lKHRoaXMub2JqTmFtZSkgKyBcIl1cIl07XG4gICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5lcnJvciwgW2NvbnNvbGUsIGFyZ3NdKTsvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmICh3aW5kb3cuZ3VpKSB3aW5kb3cuZ3VpLmVtaXRFdmVudChcIm9wTG9nRXZlbnRcIiwgdGhpcy5vYmpOYW1lLCBcImVycm9yXCIsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS53YXJuID0gT3AucHJvdG90eXBlLmxvZ1dhcm4gPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gaWYgKHRoaXMucGF0Y2guc2lsZW50KSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXCJbb3AgXCIgKyBDQUJMRVMuZ2V0U2hvcnRPcE5hbWUodGhpcy5vYmpOYW1lKSArIFwiXVwiXTtcbiAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLndhcm4sIFtjb25zb2xlLCBhcmdzXSk7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUudmVyYm9zZSA9IE9wLnByb3RvdHlwZS5sb2dWZXJib3NlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGluaXRpYXRvciA9IFwib3AgXCIgKyBDQUJMRVMuZ2V0U2hvcnRPcE5hbWUodGhpcy5vYmpOYW1lKTtcbiAgICAgICAgaWYgKENBQkxFUy5VSSAmJiAhQ0FCTEVTLlVJLmxvZ0ZpbHRlci5zaG91bGRQcmludChpbml0aWF0b3IsIC4uLmFyZ3VtZW50cykpIHJldHVybjtcblxuICAgICAgICBpZiAoIUNBQkxFUy5VSSAmJiB0aGlzLnBhdGNoLnNpbGVudCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXCJbXCIgKyBpbml0aWF0b3IgKyBcIl1cIl07XG4gICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5pbmZvLCBbY29uc29sZSwgYXJnc10pOy8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9O1xuXG5cbiAgICBPcC5wcm90b3R5cGUucHJvZmlsZSA9IGZ1bmN0aW9uIChlbmFibGUpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0uX29uVHJpZ2dlcmVkID0gdGhpcy5wb3J0c0luW2lwaV0uX29uVHJpZ2dlcmVkUHJvZmlsaW5nO1xuICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0uc2V0ID0gdGhpcy5wb3J0c0luW2lwaV0uX29uU2V0UHJvZmlsaW5nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5maW5kUGFyZW50ID0gZnVuY3Rpb24gKG9iak5hbWUpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNJbltpcGldLmlzTGlua2VkKCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNJbltpcGldLmxpbmtzWzBdLnBvcnRPdXQucGFyZW50Lm9iak5hbWUgPT0gb2JqTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9ydHNJbltpcGldLmxpbmtzWzBdLnBvcnRPdXQucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMucG9ydHNJbltpcGldLmxpbmtzWzBdLnBvcnRPdXQucGFyZW50LmZpbmRQYXJlbnQob2JqTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgLy8gdG9kbzogY2hlY2sgaW5zdGFuY2luZyBzdHVmZj9cbiAgICBPcC5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2VzKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2luc3RhbmNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2VzW2ldLm9uRGVsZXRlKSB0aGlzLl9pbnN0YW5jZXNbaV0ub25EZWxldGUoKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wb3J0c0luW2ldLnNldEFuaW1hdGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uQW5pbUZyYW1lKSB0aGlzLnBhdGNoLnJlbW92ZU9uQW5pbUZyYW1lKHRoaXMpO1xuICAgIH07XG5cbiAgICAvLyB0b2RvOiBjaGVjayBpbnN0YW5jaW5nIHN0dWZmP1xuICAgIE9wLnByb3RvdHlwZS5pbnN0YW5jZWQgPSBmdW5jdGlvbiAodHJpZ2dlclBvcnQpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcImluc3RhbmNlZFwiLCB0aGlzLnBhdGNoLmluc3RhbmNpbmcubnVtQ3ljbGVzKCkpO1xuICAgICAgICBpZiAodGhpcy5wYXRjaC5pbnN0YW5jaW5nLm51bUN5Y2xlcygpID09PSAwKSByZXR1cm4gZmFsc2U7XG5cblxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBpcGkgPSAwO1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlcyB8fCB0aGlzLl9pbnN0YW5jZXMubGVuZ3RoICE9IHRoaXMucGF0Y2guaW5zdGFuY2luZy5udW1DeWNsZXMoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZXMpIHRoaXMuX2luc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fLmxvZyhcImNyZWF0aW5nIGluc3RhbmNlcyBvZiBcIiwgdGhpcy5vYmpOYW1lLCB0aGlzLnBhdGNoLmluc3RhbmNpbmcubnVtQ3ljbGVzKCksIHRoaXMuX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzLmxlbmd0aCA9IHRoaXMucGF0Y2guaW5zdGFuY2luZy5udW1DeWNsZXMoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2luc3RhbmNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNbaV0gPSB0aGlzLnBhdGNoLmNyZWF0ZU9wKHRoaXMub2JqTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzW2ldLmluc3RhbmNlZCA9IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNbaV0udWlBdHRyKHRoaXMudWlBdHRyaWJzKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlwbyA9IDA7IGlwbyA8IHRoaXMucG9ydHNPdXQubGVuZ3RoOyBpcG8rKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzT3V0W2lwb10udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNbaV0uZ2V0UG9ydEJ5TmFtZSh0aGlzLnBvcnRzT3V0W2lwb10ubmFtZSkudHJpZ2dlciA9IHRoaXMucG9ydHNPdXRbaXBvXS50cmlnZ2VyLmJpbmQodGhpcy5wb3J0c091dFtpcG9dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnRzSW5baXBpXS5vbkNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0ub25WYWx1ZUNoYW5nZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhlVHJpZ2dlclBvcnQgPSBudWxsO1xuICAgICAgICBmb3IgKGlwaSA9IDA7IGlwaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGlwaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZXG4gICAgICAgICAgICApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzW3RoaXMucGF0Y2guaW5zdGFuY2luZy5pbmRleCgpXS5wb3J0c0luW2lwaV0uc2V0KHRoaXMucG9ydHNJbltpcGldLmdldCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baXBpXS50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gaWYodGhpcy5faW5zdGFuY2VzWyB0aGlzLnBhdGNoLmluc3RhbmNpbmcuaW5kZXgoKSBdLnBvcnRzSW5baXBpXS5uYW1lPT10cmlnZ2VyUG9ydC5uYW1lKVxuICAgICAgICAgICAgICAgIC8vIHRoZVRyaWdnZXJQb3J0PXRoaXMuX2luc3RhbmNlc1sgdGhpcy5wYXRjaC5pbnN0YW5jaW5nLmluZGV4KCkgXS5wb3J0c0luW2lwaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlVHJpZ2dlclBvcnQpIHRoZVRyaWdnZXJQb3J0Lm9uVHJpZ2dlcmVkKCk7XG5cbiAgICAgICAgZm9yIChpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzT3V0Lmxlbmd0aDsgaXBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzT3V0W2lwaV0udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydHNPdXRbaXBpXS5zZXQodGhpcy5faW5zdGFuY2VzW3RoaXMucGF0Y2guaW5zdGFuY2luZy5pbmRleCgpXS5wb3J0c091dFtpcGldLmdldCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyB0b2RvOiBjaGVjayBpbnN0YW5jaW5nIHN0dWZmP1xuICAgIE9wLnByb3RvdHlwZS5pbml0SW5zdGFuY2FibGUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gICAgICAgICBpZih0aGlzLmlzSW5zdGFuY2VkKVxuICAgICAgICAvLyAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgY29uc29sZS5sb2coJ2NhbmNlbCBpbnN0YW5jaW5nJyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5faW5zdGFuY2VzPVtdO1xuICAgICAgICAvLyAgICAgICAgIGZvcih2YXIgaXBpPTA7aXBpPHRoaXMucG9ydHNJbi5sZW5ndGg7aXBpKyspXG4gICAgICAgIC8vICAgICAgICAge1xuICAgICAgICAvLyAgICAgICAgICAgICBpZih0aGlzLnBvcnRzSW5baXBpXS50eXBlPT1DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFKVxuICAgICAgICAvLyAgICAgICAgICAgICB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICAgICAgaWYodGhpcy5wb3J0c0luW2lwaV0udHlwZT09Q09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTilcbiAgICAgICAgLy8gICAgICAgICAgICAge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgLy8gdmFyIHBpSW5kZXg9aXBpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0ub25UcmlnZ2VyZWQ9ZnVuY3Rpb24ocGlJbmRleClcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB2YXIgaT0wO1xuICAgICAgICAvLyAvLyBjb25zb2xlLmxvZygndHJpZ2dlcicsdGhpcy5faW5zdGFuY2VzLmxlbmd0aCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyxpcGkgKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICAgICAgfVxuICAgICAgICAvLyB9O1xuICAgICAgICAvLyB0aGlzLl9pbnN0YW5jZXM9bnVsbDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uIChvYmopXG4gICAge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gb2JqKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5nZXRQb3J0QnlOYW1lKGkpO1xuICAgICAgICAgICAgaWYgKHBvcnQpIHBvcnQuc2V0KG9ialtpXSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMuX2xvZy53YXJuKFwib3Auc2V0VmFsdWVzOiBwb3J0IG5vdCBmb3VuZDpcIiwgaSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgb3AgaGFzIHRoaXMgZXJyb3IgbWVzc2FnZSBpZFxuICAgICAqIEBmdW5jdGlvbiBoYXNVaUVycm9yXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtpZH0gZXJyb3IgaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBoYXMgaWRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaGFzVWlFcnJvciA9IGZ1bmN0aW9uIChpZClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl91aUVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgdGhpcy5fdWlFcnJvcnNbaWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaG93IG9wIGVycm9yIG1lc3NhZ2UgLSBzZXQgbWVzc2FnZSB0byBudWxsIHRvIHJlbW92ZSBlcnJvciBtZXNzYWdlXG4gICAgICogQGZ1bmN0aW9uIHNldFVpRXJyb3JcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge2lkfSBlcnJvciBpZFxuICAgICAqIEBwYXJhbSB7dHh0fSB0ZXh0IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2xldmVsfSBsZXZlbFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5zZXRVaUVycm9yID0gZnVuY3Rpb24gKGlkLCB0eHQsIGxldmVsKVxuICAgIHtcbiAgICAgICAgaWYgKCF0eHQgJiYgIXRoaXMuaGFzVWlFcnJvcnMpIHJldHVybjtcbiAgICAgICAgaWYgKCF0eHQgJiYgIXRoaXMuX3VpRXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fdWlFcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpICYmIHRoaXMuX3VpRXJyb3JzW2lkXS50eHQgPT0gdHh0KSByZXR1cm47XG5cbiAgICAgICAgaWYgKGlkLmluZGV4T2YoXCIgXCIpID4gLTEpIHRoaXMuX2xvZy53YXJuKFwic2V0dWllcnJvciBpZCBjYW50IGhhdmUgc3BhY2VzISBcIiwgaWQpO1xuICAgICAgICBpZCA9IGlkLnJlcGxhY2VBbGwoXCIgXCIsIFwiX1wiKTtcblxuICAgICAgICBpZiAoIXR4dCAmJiB0aGlzLl91aUVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIGRlbGV0ZSB0aGlzLl91aUVycm9yc1tpZF07XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR4dCAmJiAoIXRoaXMuX3VpRXJyb3JzLmhhc093blByb3BlcnR5KGlkKSB8fCB0aGlzLl91aUVycm9yc1tpZF0udHh0ICE9IHR4dCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09IHVuZGVmaW5lZCkgbGV2ZWwgPSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VpRXJyb3JzW2lkXSA9IHsgXCJ0eHRcIjogdHh0LCBcImxldmVsXCI6IGxldmVsLCBcImlkXCI6IGlkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvckFyciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fdWlFcnJvcnMpIGVycm9yQXJyLnB1c2godGhpcy5fdWlFcnJvcnNbaV0pO1xuXG4gICAgICAgIHRoaXMudWlBdHRyKHsgXCJ1aWVycm9yc1wiOiBlcnJvckFyciB9KTtcbiAgICAgICAgdGhpcy5oYXNVaUVycm9ycyA9IE9iamVjdC5rZXlzKHRoaXMuX3VpRXJyb3JzKS5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJ1aUVycm9yQ2hhbmdlXCIpO1xuICAgIH07XG5cbiAgICAvLyB0b2RvOiByZW1vdmVcbiAgICBPcC5wcm90b3R5cGUuc2V0RXJyb3IgPSBmdW5jdGlvbiAoaWQsIHR4dClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwib2xkIGVycm9yIG1lc3NhZ2Ugb3AuZXJyb3IoKSAtIHVzZSBvcC5zZXRVaUVycm9yKClcIik7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogZW5hYmxlL2Rpc2FibGUgb3BcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiAoYilcbiAgICB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGI7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25FbmFibGVkQ2hhbmdlXCIsIGIpO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgdGhpcy5zZXRVaUVycm9yKFwiX2Rpc2FibGVkXCIsIFwiT3AgaXMgZGlzYWJsZWRcIiwgMCk7XG4gICAgICAgIGVsc2UgdGhpcy5zZXRVaUVycm9yKFwiX2Rpc2FibGVkXCIsIG51bGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBvcmdhbml6ZSBwb3J0cyBpbnRvIGEgZ3JvdXBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvcnRzXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnNldFBvcnRHcm91cCA9IGZ1bmN0aW9uIChuYW1lLCBwb3J0cylcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9ydHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwb3J0c1tpXSlcbiAgICAgICAgICAgICAgICBpZiAocG9ydHNbaV0uc2V0VWlBdHRyaWJzKSBwb3J0c1tpXS5zZXRVaUF0dHJpYnMoeyBcImdyb3VwXCI6IG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwic2V0UG9ydEdyb3VwOiBpbnZhbGlkIHBvcnQhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB2aXN1YWxseSBpbmRpY2F0ZSBwb3J0cyB0aGF0IHRoZXkgYXJlIGNvb3JkaW5hdGUgaW5wdXRzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0WFxuICAgICAqIEBwYXJhbSB7UG9ydH0gcG9ydFlcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnRaXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnNldFVpQXhpc1BvcnRzID0gZnVuY3Rpb24gKHB4LCBweSwgcHopXG4gICAge1xuICAgICAgICBpZiAocHgpIHB4LnNldFVpQXR0cmlicyh7IFwiYXhpc1wiOiBcIlhcIiB9KTtcbiAgICAgICAgaWYgKHB5KSBweS5zZXRVaUF0dHJpYnMoeyBcImF4aXNcIjogXCJZXCIgfSk7XG4gICAgICAgIGlmIChweikgcHouc2V0VWlBdHRyaWJzKHsgXCJheGlzXCI6IFwiWlwiIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgcG9ydCBmcm9tIG9wXG4gICAgICogQGZ1bmN0aW9uIHJlbW92ZVBvcnRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnJlbW92ZVBvcnQgPSBmdW5jdGlvbiAocG9ydClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGlwaSA9IDA7IGlwaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGlwaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0c0luW2lwaV0gPT0gcG9ydClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnRzSW4uc3BsaWNlKGlwaSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvblVpQXR0cmlic0NoYW5nZVwiLCB7fSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvblBvcnRSZW1vdmVkXCIsIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLl9jaGVja0xpbmtzTmVlZGVkVG9Xb3JrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBzaG93IGEgd2FybmluZyBvZiB0aGlzIG9wIGlzIG5vdCBhIGNoaWxkIG9mIHBhcmVudE9wTmFtZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRPcE5hbWVcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUudG9Xb3JrTmVlZHNQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50T3BOYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhdGNoLmlzRWRpdG9yTW9kZSgpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fbGlua1RpbWVSdWxlcy5uZWVkc1BhcmVudE9wID0gcGFyZW50T3BOYW1lO1xuICAgIH07XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiBzaG93IGEgd2FybmluZyBvZiB0aGlzIG9wIGlzIGEgY2hpbGQgb2YgcGFyZW50T3BOYW1lXG4gICAgLy8gICogQGZ1bmN0aW9uXG4gICAgLy8gICogQGluc3RhbmNlXG4gICAgLy8gICogQG1lbWJlcm9mIE9wXG4gICAgLy8gICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudE9wTmFtZVxuICAgIC8vICAqL1xuICAgIE9wLnByb3RvdHlwZS50b1dvcmtTaG91bGROb3RCZUNoaWxkID0gZnVuY3Rpb24gKHBhcmVudE9wTmFtZSwgdHlwZSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5pc0VkaXRvck1vZGUoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9saW5rVGltZVJ1bGVzLmZvcmJpZGRlblBhcmVudCA9IHBhcmVudE9wTmFtZTtcbiAgICAgICAgaWYgKHR5cGUgIT0gdW5kZWZpbmVkKSB0aGlzLl9saW5rVGltZVJ1bGVzLmZvcmJpZGRlblBhcmVudFR5cGUgPSB0eXBlO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIHNob3cgYSBzbWFsbCBYIHRvIGluZGljYXRlIG9wIGlzIG5vdCB3b3JraW5nIHdoZW4gZ2l2ZW4gcG9ydHMgYXJlIG5vdCBsaW5rZWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnQxXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0MlxuICAgICAqIEBwYXJhbSB7UG9ydH0gcG9ydDNcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUudG9Xb3JrUG9ydHNOZWVkVG9CZUxpbmtlZCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkpIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5fbGlua1RpbWVSdWxlcy5uZWVkc0xpbmtlZFRvV29yay5pbmRleE9mKGFyZ3VtZW50c1tpXSkgPT0gLTEpIHRoaXMuX2xpbmtUaW1lUnVsZXMubmVlZHNMaW5rZWRUb1dvcmsucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH07XG4gICAgT3AucHJvdG90eXBlLnRvV29ya1BvcnRzTmVlZFRvQmVMaW5rZWRSZXNldCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGlua1RpbWVSdWxlcy5uZWVkc0xpbmtlZFRvV29yay5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5jaGVja0xpbmtUaW1lV2FybmluZ3MpIHRoaXMuY2hlY2tMaW5rVGltZVdhcm5pbmdzKCk7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5pbml0VmFyUG9ydHMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baV0uZ2V0VmFyaWFibGVOYW1lKCkpIHRoaXMucG9ydHNJbltpXS5zZXRWYXJpYWJsZSh0aGlzLnBvcnRzSW5baV0uZ2V0VmFyaWFibGVOYW1lKCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlZnJlc2ggb3AgcGFyYW1ldGVycywgaWYgY3VycmVudCBvcCBpcyBzZWxlY3RlZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5yZWZyZXNoUGFyYW1zID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnBhdGNoICYmIHRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkgJiYgdGhpcy5pc0N1cnJlbnRVaU9wKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGd1aS5vcFBhcmFtcy5zaG93KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvcCBpcyBzZWxlY3RlZCBhbmQgcGFyYW1ldGVyIGFyZSBzaG93biBpbiB0aGUgZWRpdG9yLCBjYW4gb25seSByZXR1cm4gdHJ1ZSBpZiBpbiBlZGl0b3IvdWlcbiAgICAgKiBAZnVuY3Rpb24gaXNDdXJyZW50VWlPcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSAtIGlzIGN1cnJlbnQgdWkgb3BcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaXNDdXJyZW50VWlPcCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wYXRjaC5pc0VkaXRvck1vZGUoKSkgcmV0dXJuIGd1aS5wYXRjaFZpZXcuaXNDdXJyZW50T3AodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byByZW5kZXIgMmQgY2FudmFzIGJhc2VkIGdyYXBoaWNzIGZyb20gaW4gYW4gb3BcbiAgICAgKiBAZnVuY3Rpb24gaXNDdXJyZW50VWlPcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7Y3R4fSBjb250ZXh0IG9mIGNhbnZhcyAyZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBpbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyLnggeCBwb3NpdGlvbiBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXIueSB5IHBvc2l0aW9uIG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllci53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXIuaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXIuc2NhbGUgY3VycmVudCBzY2FsaW5nIG9mIHBhdGNoZmllbGQgdmlld1xuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5yZW5kZXJWaXpMYXllciA9IG51bGw7IC8vIG9wdGlvbmFseSBkZWZpbmVkIGluIG9wIGluc3RhbmNlXG59XG5cbmV4cG9ydCB7IE9wIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/core_op.js\n");

/***/ }),

/***/ "./src/core/core_patch.js":
/*!********************************!*\
  !*** ./src/core/core_patch.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.js\");\n/* harmony import */ var _loadingstatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadingstatus */ \"./src/core/loadingstatus.js\");\n/* harmony import */ var _instancing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instancing */ \"./src/core/instancing.js\");\n/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./timer */ \"./src/core/timer.js\");\n/* harmony import */ var _core_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core_link */ \"./src/core/core_link.js\");\n/* harmony import */ var _core_profiler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core_profiler */ \"./src/core/core_profiler.js\");\n/* harmony import */ var _cgl_cgl_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cgl/cgl_state */ \"./src/core/cgl/cgl_state.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _core_variable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core_variable */ \"./src/core/core_variable.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Patch class, contains all operators,values,links etc. manages loading and running of the whole patch\n *\n * see {@link PatchConfig}\n *\n * @external CABLES\n * @namespace Patch\n * @hideconstructor\n * @param {PatchConfig} config The configuration object.\n * @class\n * @example\n * CABLES.patch=new CABLES.Patch(\n * {\n *     patch:pStr,\n *     glCanvasId:'glcanvas',\n *     glCanvasResizeToWindow:true,\n *     canvas:{powerPreference:\"high-performance\"},\n *     prefixAssetPath:'/assets/',\n *     prefixJsPath:'/js/',\n *     onError:function(e){console.log(e);}\n *     glslPrecision:'highp'\n * });\n */\n\nconst Patch = function (cfg)\n{\n    _eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_9__[\"default\"](\"core_patch\");\n    this.ops = [];\n    this.settings = {};\n    this.config = cfg ||\n        {\n            \"glCanvasResizeToWindow\": false,\n            \"prefixAssetPath\": \"\",\n            \"prefixJsPath\": \"\",\n            \"silent\": true,\n            \"onError\": null,\n            \"onFinishedLoading\": null,\n            \"onFirstFrameRendered\": null,\n            \"onPatchLoaded\": null,\n            \"fpsLimit\": 0,\n        };\n    this.timer = new _timer__WEBPACK_IMPORTED_MODULE_4__.Timer();\n    this.freeTimer = new _timer__WEBPACK_IMPORTED_MODULE_4__.Timer();\n    this.animFrameOps = [];\n    this.animFrameCallbacks = [];\n    this.gui = false;\n    CABLES.logSilent = this.silent = true;\n    this.profiler = null;\n    this.aborted = false;\n    this._crashedOps = [];\n    this._renderOneFrame = false;\n    this._animReq = null;\n    this._opIdCache = {};\n    this._triggerStack = [];\n    this.storeObjNames = false; // remove after may release\n\n    this.loading = new _loadingstatus__WEBPACK_IMPORTED_MODULE_2__.LoadingStatus(this);\n\n    this._volumeListeners = [];\n    this._paused = false;\n    this._frameNum = 0;\n    this.instancing = new _instancing__WEBPACK_IMPORTED_MODULE_3__.Instancing();\n    this.onOneFrameRendered = null;\n    this.namedTriggers = {};\n\n    this._origData = null;\n    this._frameNext = 0;\n    this._frameInterval = 0;\n    this._lastFrameTime = 0;\n    this._frameWasdelayed = true;\n    this.frameStore = {};\n    this.deSerialized = false;\n    this._lastReqAnimTimeStamp = 0;\n\n    this.cgCanvas = null;\n\n    if (!(function () { return !this; }())) console.log(\"not in strict mode: core patch\");\n\n    this._isLocal = document.location.href.indexOf(\"file:\") === 0;\n\n    if (this.config.hasOwnProperty(\"silent\")) this.silent = CABLES.logSilent = this.config.silent;\n    if (!this.config.hasOwnProperty(\"doRequestAnimation\")) this.config.doRequestAnimation = true;\n\n    if (!this.config.prefixAssetPath) this.config.prefixAssetPath = \"\";\n    if (!this.config.prefixJsPath) this.config.prefixJsPath = \"\";\n    if (!this.config.masterVolume) this.config.masterVolume = 1.0;\n\n    this._variables = {};\n    this._variableListeners = [];\n    this.vars = {};\n    if (cfg && cfg.vars) this.vars = cfg.vars; // vars is old!\n\n    this.cgl = new _cgl_cgl_state__WEBPACK_IMPORTED_MODULE_7__.Context(this);\n    this.cgp = null;\n\n    this._subpatchOpCache = {};\n\n    this.cgl.setCanvas(this.config.glCanvasId || this.config.glCanvas || \"glcanvas\");\n    if (this.config.glCanvasResizeToWindow === true) this.cgl.setAutoResize(\"window\");\n    if (this.config.glCanvasResizeToParent === true) this.cgl.setAutoResize(\"parent\");\n    this.loading.setOnFinishedLoading(this.config.onFinishedLoading);\n\n    if (this.cgl.aborted) this.aborted = true;\n    if (this.cgl.silent) this.silent = true;\n\n    this.freeTimer.play();\n    this.exec();\n\n    if (!this.aborted)\n    {\n        if (this.config.patch)\n        {\n            this.deSerialize(this.config.patch);\n        }\n        else if (this.config.patchFile)\n        {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.ajax)(\n                this.config.patchFile,\n                (err, _data) =>\n                {\n                    const data = JSON.parse(_data);\n                    if (err)\n                    {\n                        const txt = \"\";\n                        this._log.error(\"err\", err);\n                        this._log.error(\"data\", data);\n                        this._log.error(\"data\", data.msg);\n                        return;\n                    }\n                    this.deSerialize(data);\n                }\n            );\n        }\n        this.timer.play();\n    }\n\n    console.log(\"made with https://cables.gl\"); // eslint-disable-line\n};\n\nPatch.prototype.isPlaying = function ()\n{\n    return !this._paused;\n};\n\nPatch.prototype.isRenderingOneFrame = function ()\n{\n    return this._renderOneFrame;\n};\n\n\nPatch.prototype.renderOneFrame = function ()\n{\n    this._paused = true;\n    this._renderOneFrame = true;\n    this.exec();\n    this._renderOneFrame = false;\n};\n\n/**\n * current number of frames per second\n * @function getFPS\n * @memberof Patch\n * @instance\n * @return {Number} fps\n */\nPatch.prototype.getFPS = function ()\n{\n    console.log(\"deprecated getfps\");\n    return 0;\n};\n\n/**\n * returns true if patch is opened in editor/gui mode\n * @function isEditorMode\n * @memberof Patch\n * @instance\n * @return {Boolean} editor mode\n */\nPatch.prototype.isEditorMode = function ()\n{\n    return this.config.editorMode === true;\n};\n\n/**\n * pauses patch execution\n * @function pause\n * @memberof Patch\n * @instance\n */\nPatch.prototype.pause = function ()\n{\n    cancelAnimationFrame(this._animReq);\n    this.emitEvent(\"pause\");\n    this._animReq = null;\n    this._paused = true;\n    this.freeTimer.pause();\n};\n\n/**\n * resumes patch execution\n * @function resume\n * @memberof Patch\n * @instance\n */\nPatch.prototype.resume = function ()\n{\n    if (this._paused)\n    {\n        cancelAnimationFrame(this._animReq);\n        this._paused = false;\n        this.freeTimer.play();\n        this.emitEvent(\"resume\");\n        this.exec();\n    }\n};\n\n/**\n * set volume [0-1]\n * @function setVolume\n * @param {Number} volume\n * @memberof Patch\n * @instance\n */\nPatch.prototype.setVolume = function (v)\n{\n    this.config.masterVolume = v;\n    for (let i = 0; i < this._volumeListeners.length; i++) this._volumeListeners[i].onMasterVolumeChanged(v);\n};\n\n\n/**\n * get asset path\n * @function getAssetPath\n * @memberof Patch\n * @instance\n */\nPatch.prototype.getAssetPath = function (patchId = null)\n{\n    if (this.isEditorMode())\n    {\n        let id = patchId || gui.project()._id;\n        return \"/assets/\" + id + \"/\";\n    }\n    else if (document.location.href.indexOf(\"cables.gl\") > 0 || document.location.href.indexOf(\"cables.local\") > 0)\n    {\n        const parts = document.location.pathname.split(\"/\");\n        let id = patchId || parts[parts.length - 1];\n        return \"/assets/\" + id + \"/\";\n    }\n    else if (this.config.hasOwnProperty(\"assetPath\"))\n    {\n        return this.config.assetPath;\n    }\n    else\n    {\n        return \"assets/\";\n    }\n};\n\n/**\n * get js path\n * @function getJsPath\n * @memberof Patch\n * @instance\n */\nPatch.prototype.getJsPath = function ()\n{\n    if (this.config.hasOwnProperty(\"jsPath\"))\n    {\n        return this.config.jsPath;\n    }\n    else\n    {\n        return \"js/\";\n    }\n};\n\n/**\n * get url/filepath for a filename\n * this uses prefixAssetpath in exported patches\n * @function getFilePath\n * @memberof Patch\n * @instance\n * @param {String} filename\n * @return {String} url\n */\nPatch.prototype.getFilePath = function (filename)\n{\n    if (!filename) return filename;\n    filename = String(filename);\n    if (filename.indexOf(\"https:\") === 0 || filename.indexOf(\"http:\") === 0) return filename;\n    if (filename.indexOf(\"data:\") === 0) return filename;\n    if (filename.indexOf(\"file:\") === 0) return filename;\n\n    filename = filename.replace(\"//\", \"/\");\n    return this.config.prefixAssetPath + filename + (this.config.suffixAssetPath || \"\");\n};\n\nPatch.prototype.clear = function ()\n{\n    this.emitEvent(\"patchClearStart\");\n    this.cgl.TextureEffectMesh = null;\n    this.animFrameOps.length = 0;\n    this.timer = new _timer__WEBPACK_IMPORTED_MODULE_4__.Timer();\n    while (this.ops.length > 0) this.deleteOp(this.ops[0].id);\n    this.emitEvent(\"patchClearEnd\");\n};\n\nPatch.getOpClass = function (objName)\n{\n    const parts = objName.split(\".\");\n    let opObj = null;\n\n    try\n    {\n        if (parts.length == 2) opObj = window[parts[0]][parts[1]];\n        else if (parts.length == 3) opObj = window[parts[0]][parts[1]][parts[2]];\n        else if (parts.length == 4) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];\n        else if (parts.length == 5) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];\n        else if (parts.length == 6) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];\n        else if (parts.length == 7) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]];\n        else if (parts.length == 8) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]];\n        else if (parts.length == 9) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]];\n        else if (parts.length == 10) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]];\n        return opObj;\n    }\n    catch (e)\n    {\n        return null;\n    }\n};\n\nPatch.prototype.createOp = function (identifier, id, opName = null)\n{\n    let op = null;\n    let objName = \"\";\n\n    try\n    {\n        if (!identifier)\n        {\n            console.error(\"createop identifier false\", identifier);\n            console.log((new Error()).stack);\n            return;\n        }\n        if (identifier.indexOf(\"Ops.\") === -1)\n        {\n            // this should be a uuid, not a namespace\n            // creating ops by id should be the default way from now on!\n            const opId = identifier;\n\n\n\n            if (CABLES.OPS[opId])\n            {\n                objName = CABLES.OPS[opId].objName;\n                op = new CABLES.OPS[opId].f(this, objName, id, opId);\n                op.opId = opId;\n            }\n            else\n            {\n                if (opName)\n                {\n                    identifier = opName;\n                    console.log(\"could not find op by id: \" + opId);\n                }\n                else\n                {\n                    throw new Error(\"could not find op by id: \" + opId);\n                }\n            }\n        }\n\n        if (!op)\n        {\n            // fallback: create by objname!\n            objName = identifier;\n            const parts = identifier.split(\".\");\n            const opObj = Patch.getOpClass(objName);\n\n            if (!opObj)\n            {\n                this.emitEvent(\"criticalError\", { \"title\": \"unknown op\" + objName, \"text\": \"unknown op: \" + objName });\n\n                this._log.error(\"unknown op: \" + objName);\n                throw new Error(\"unknown op: \" + objName);\n            }\n            else\n            {\n                if (parts.length == 2) op = new window[parts[0]][parts[1]](this, objName, id);\n                else if (parts.length == 3) op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);\n                else if (parts.length == 4) op = new window[parts[0]][parts[1]][parts[2]][parts[3]](this, objName, id);\n                else if (parts.length == 5) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](this, objName, id);\n                else if (parts.length == 6) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]](this, objName, id);\n                else if (parts.length == 7) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]](this, objName, id);\n                else if (parts.length == 8) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]](this, objName, id);\n                else if (parts.length == 9) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]](this, objName, id);\n                else if (parts.length == 10) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);\n                else console.log(\"parts.length\", parts.length);\n            }\n\n            if (op)\n            {\n                op.opId = null;\n                for (const i in CABLES.OPS)\n                {\n                    if (CABLES.OPS[i].objName == objName) op.opId = i;\n                }\n            }\n        }\n    }\n    catch (e)\n    {\n        this._crashedOps.push(objName);\n\n        this.emitEvent(\"exceptionOp\", e, objName, op);\n\n        if (!this.isEditorMode())\n        {\n            this._log.error(e);\n            this._log.error(\"[instancing error] \" + objName, e);\n\n            if (CABLES.api) CABLES.api.sendErrorReport(e);\n            this.exitError(\"INSTANCE_ERR\", \"Instancing Error 1\" + objName, e);\n            throw new Error(\"instancing error 1\" + objName);\n        }\n    }\n\n    if (op)\n    {\n        op._objName = objName;\n        op.patch = this;\n    }\n    else\n    {\n        this._log.log(\"no op was created!?\", identifier, id);\n    }\n    return op;\n};\n\n/**\n * create a new op in patch\n * @function addOp\n * @memberof Patch\n * @instance\n * @param {String} opIdentifier, uuid or name, e.g. Ops.Math.Sum\n * @param {Object} uiAttribs Attributes\n * @param {String} id\n * @param {boolean} fromDeserialize\n * @param {String} opName, e.g. Ops.Math.Sum\n * @example\n * // add invisible op\n * patch.addOp('Ops.Math.Sum', { showUiAttribs: false });\n */\nPatch.prototype.addOp = function (opIdentifier, uiAttribs, id, fromDeserialize, opName)\n{\n    const op = this.createOp(opIdentifier, id, opName);\n\n    if (op)\n    {\n        uiAttribs = uiAttribs || {};\n        if (uiAttribs.hasOwnProperty(\"errors\")) delete uiAttribs.errors;\n        if (uiAttribs.hasOwnProperty(\"error\")) delete uiAttribs.error;\n        uiAttribs.subPatch = uiAttribs.subPatch || 0;\n\n        op.setUiAttribs(uiAttribs);\n        if (op.onCreate) op.onCreate();\n\n        if (op.hasOwnProperty(\"onAnimFrame\")) this.addOnAnimFrame(op);\n        if (op.hasOwnProperty(\"onMasterVolumeChanged\")) this._volumeListeners.push(op);\n\n        if (this._opIdCache[op.id])\n        {\n            console.log(\"opid with id \" + op.id + \" already exists in patch!\");\n            // op.id += \"_double\";\n            return;\n        }\n\n        this.ops.push(op);\n        this._opIdCache[op.id] = op;\n\n        if (this._subPatchCacheAdd) this._subPatchCacheAdd(uiAttribs.subPatch, op);\n        this.emitEvent(\"onOpAdd\", op, fromDeserialize);\n\n\n        if (op.init)\n        {\n            op.init();\n        }\n        op.emitEvent(\"init\", fromDeserialize);\n    }\n    else\n    {\n        this._log.error(\"addop: no op.....\");\n    }\n\n    return op;\n};\n\nPatch.prototype.addOnAnimFrame = function (op)\n{\n    for (let i = 0; i < this.animFrameOps.length; i++) if (this.animFrameOps[i] == op) { return; }\n\n    this.animFrameOps.push(op);\n};\n\nPatch.prototype.removeOnAnimFrame = function (op)\n{\n    for (let i = 0; i < this.animFrameOps.length; i++)\n    {\n        if (this.animFrameOps[i] == op)\n        {\n            this.animFrameOps.splice(i, 1);\n            return;\n        }\n    }\n};\n\nPatch.prototype.addOnAnimFrameCallback = function (cb)\n{\n    this.animFrameCallbacks.push(cb);\n};\n\nPatch.prototype.removeOnAnimCallback = function (cb)\n{\n    for (let i = 0; i < this.animFrameCallbacks.length; i++)\n    {\n        if (this.animFrameCallbacks[i] == cb)\n        {\n            this.animFrameCallbacks.splice(i, 1);\n            return;\n        }\n    }\n};\n\nPatch.prototype.deleteOp = function (opid, tryRelink, reloadingOp)\n{\n    let found = false;\n    for (const i in this.ops)\n    {\n        if (this.ops[i].id == opid)\n        {\n            const op = this.ops[i];\n            let reLinkP1 = null;\n            let reLinkP2 = null;\n\n            if (op)\n            {\n                found = true;\n                if (tryRelink)\n                {\n                    if (op.portsIn.length > 0 && op.portsIn[0].isLinked() && (op.portsOut.length > 0 && op.portsOut[0].isLinked()))\n                    {\n                        if (op.portsIn[0].getType() == op.portsOut[0].getType() && op.portsIn[0].links[0])\n                        {\n                            reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);\n                            reLinkP2 = op.portsOut[0].links[0].getOtherPort(op.portsOut[0]);\n                        }\n                    }\n                }\n\n                const opToDelete = this.ops[i];\n                opToDelete.removeLinks();\n\n                if (this.onDelete)\n                {\n                    // todo: remove\n                    console.log(\"deprecated this.onDelete\", this.onDelete);\n                    this.onDelete(opToDelete);\n                }\n\n                this.ops.splice(i, 1);\n                opToDelete.emitEvent(\"delete\", this.ops[i]);\n                this.emitEvent(\"onOpDelete\", opToDelete, reloadingOp);\n\n                if (this.clearSubPatchCache) this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);\n\n                if (opToDelete.onDelete) opToDelete.onDelete(reloadingOp);\n                opToDelete.cleanUp();\n\n                if (reLinkP1 !== null && reLinkP2 !== null)\n                {\n                    this.link(reLinkP1.op, reLinkP1.getName(), reLinkP2.op, reLinkP2.getName());\n                }\n\n                delete this._opIdCache[opid];\n                break;\n            }\n        }\n    }\n\n    if (!found) console.log(\"core patch deleteop: not found...\", opid);\n};\n\nPatch.prototype.getFrameNum = function ()\n{\n    return this._frameNum;\n};\n\nPatch.prototype.emitOnAnimFrameEvent = function (time, delta)\n{\n    time = time || this.timer.getTime();\n\n    for (let i = 0; i < this.animFrameCallbacks.length; ++i)\n    {\n        if (this.animFrameCallbacks[i]) this.animFrameCallbacks[i](time, this._frameNum, delta);\n    }\n\n    for (let i = 0; i < this.animFrameOps.length; ++i)\n    {\n        if (this.animFrameOps[i].onAnimFrame)\n        {\n            this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);\n        }\n    }\n};\n\nPatch.prototype.renderFrame = function (timestamp)\n{\n    // console.log(\"renderframe\", this._paused, this._frameNum);\n\n    this.timer.update();\n    this.freeTimer.update();\n    const time = this.timer.getTime();\n    const startTime = performance.now();\n    this.cgl.frameStartTime = this.timer.getTime();\n\n    const delta = timestamp - this._lastReqAnimTimeStamp || timestamp;\n\n    this.emitOnAnimFrameEvent(null, delta);\n\n    this.cgl.profileData.profileFrameDelta = delta;\n    this._lastReqAnimTimeStamp = timestamp;\n    this.cgl.profileData.profileOnAnimFrameOps = performance.now() - startTime;\n\n    this.emitEvent(\"onRenderFrame\", time);\n\n    this._frameNum++;\n    if (this._frameNum == 1)\n    {\n        if (this.config.onFirstFrameRendered) this.config.onFirstFrameRendered();\n    }\n};\n\nPatch.prototype.exec = function (timestamp)\n{\n    if (!this._renderOneFrame && (this._paused || this.aborted)) return;\n    this.emitEvent(\"reqAnimFrame\");\n    cancelAnimationFrame(this._animReq);\n\n    this.config.fpsLimit = this.config.fpsLimit || 0;\n    if (this.config.fpsLimit)\n    {\n        this._frameInterval = 1000 / this.config.fpsLimit;\n    }\n\n    const now = CABLES.now();\n    const frameDelta = now - this._frameNext;\n\n\n\n    if (this.isEditorMode())\n    {\n        if (!this._renderOneFrame)\n        {\n            if (now - this._lastFrameTime >= 500 && this._lastFrameTime !== 0 && !this._frameWasdelayed)\n            {\n                this._lastFrameTime = 0;\n                setTimeout(this.exec.bind(this), 500);\n                this.emitEvent(\"renderDelayStart\");\n                this._frameWasdelayed = true;\n                return;\n            }\n        }\n    }\n\n    if (this._renderOneFrame || this.config.fpsLimit === 0 || frameDelta > this._frameInterval || this._frameWasdelayed)\n    {\n        this.renderFrame(timestamp);\n\n        if (this._frameInterval) this._frameNext = now - (frameDelta % this._frameInterval);\n    }\n\n    if (this._frameWasdelayed)\n    {\n        this.emitEvent(\"renderDelayEnd\");\n        this._frameWasdelayed = false;\n    }\n\n    if (this._renderOneFrame)\n    {\n        if (this.onOneFrameRendered) this.onOneFrameRendered(); // todo remove everywhere and use propper event...\n        this.emitEvent(\"renderedOneFrame\");\n        this._renderOneFrame = false;\n    }\n\n\n    if (this.config.doRequestAnimation) this._animReq = this.cgl.canvas.ownerDocument.defaultView.requestAnimationFrame(this.exec.bind(this));\n};\n\n// Patch.prototype.linkPorts = function (port1, port2)\n// {\n//     this.link(port1.parent, port1.id, port2.parent, port2.id);\n// };\n\n/**\n * link two ops/ports\n * @function link\n * @memberof Patch\n * @instance\n * @param {Op} op1\n * @param {String} portName1\n * @param {Op} op2\n * @param {String} portName2\n */\nPatch.prototype.link = function (op1, port1Name, op2, port2Name, lowerCase, fromDeserialize)\n{\n    if (!op1)\n    {\n        console.warn(\"link: op1 is null \");\n        return;\n    }\n    if (!op2)\n    {\n        console.warn(\"link: op2 is null\");\n        return;\n    }\n\n    const port1 = op1.getPort(port1Name, lowerCase);\n    const port2 = op2.getPort(port2Name, lowerCase);\n\n    if (!port1)\n    {\n        console.warn(\"port1 not found! \" + port1Name + \"(\" + op1.objName + \")\");\n        return;\n    }\n\n    if (!port2)\n    {\n        console.warn(\"port2 not found! \" + port2Name + \" of \" + op2.name + \"(\" + op2.objName + \")\", op2);\n        return;\n    }\n\n    if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2))\n    {\n        return false;\n    }\n\n    if (_core_link__WEBPACK_IMPORTED_MODULE_5__.Link.canLink(port1, port2))\n    {\n        const link = new _core_link__WEBPACK_IMPORTED_MODULE_5__.Link(this);\n        link.link(port1, port2);\n\n        this.emitEvent(\"onLink\", port1, port2, link, fromDeserialize);\n        return link;\n    }\n};\n\nPatch.prototype.serialize = function (options)\n{\n    const obj = {};\n\n    options = options || {};\n    obj.ops = [];\n    obj.settings = this.settings;\n    for (const i in this.ops)\n    {\n        const op = this.ops[i];\n        obj.ops.push(op.getSerialized());\n    }\n\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cleanJson)(obj);\n\n    if (options.asObject) return obj;\n    return JSON.stringify(obj);\n};\n\nPatch.prototype.getOpsByRefId = function (refId)\n{\n    const perf = CABLES.UI.uiProfiler.start(\"[corepatchetend] getOpsByRefId\");\n    const refOps = [];\n    const ops = gui.corePatch().ops;\n    for (let i = 0; i < ops.length; i++)\n        if (ops[i].storage && ops[i].storage.ref == refId) refOps.push(ops[i]);\n    perf.finish();\n    return refOps;\n};\n\n\nPatch.prototype.getOpById = function (opid)\n{\n    return this._opIdCache[opid];\n    // this.timeNeededGetOpById = this.timeNeededGetOpById || 0;\n\n    // const startTime = performance.now();\n    // for (const i in this.ops)\n    // {\n    //     if (this.ops[i].id == opid)\n    //     {\n    //         this.timeNeededGetOpById += (performance.now() - startTime);\n    //         return this.ops[i];\n    //     }\n    // }\n};\n\n// Patch.prototype.getOpsById = function (opIds)\n// {\n//     const ops = [];\n//     for (const i in this.ops)\n//         for (let j = 0; j < opIds.length; j++)\n//             if (this.ops[i].id === opIds[j])\n//             {\n//                 ops.push(this.ops[i]);\n//                 break;\n//             }\n//     return ops;\n// };\n\nPatch.prototype.getOpsByName = function (name)\n{\n    // TODO: is this still needed ? unclear behaviour....\n    const arr = [];\n    for (const i in this.ops)\n        if (this.ops[i].name == name) arr.push(this.ops[i]);\n    return arr;\n};\n\nPatch.prototype.getOpsByObjName = function (name)\n{\n    const arr = [];\n    for (const i in this.ops)\n        if (this.ops[i].objName == name) arr.push(this.ops[i]);\n    return arr;\n};\n\nPatch.prototype.getOpsByOpId = function (opid)\n{\n    const arr = [];\n    for (const i in this.ops)\n        if (this.ops[i].opId == opid) arr.push(this.ops[i]);\n    return arr;\n};\n\nPatch.prototype.loadLib = function (which)\n{\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.ajaxSync)(\n        \"/ui/libs/\" + which + \".js\",\n        (err, res) =>\n        {\n            const se = document.createElement(\"script\");\n            se.type = \"text/javascript\";\n            se.text = res;\n            document.getElementsByTagName(\"head\")[0].appendChild(se);\n        },\n        \"GET\",\n    );\n    // open and send a synchronous request\n    // xhrObj.open('GET', '/ui/libs/'+which+'.js', false);\n    // xhrObj.send('');\n    // add the returned content to a newly created script tag\n};\n\n\nPatch.prototype.getSubPatchOp = function (patchId, objName)\n{\n    for (const i in this.ops)\n        if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)\n            return this.ops[i];\n    return false;\n};\n\n// Patch.prototype.getSubPatchOuterOp = function (subPatchId) // remove !! moved to extend class\n// {\n//     const ops = this.ops;\n//     for (let i = 0; i < ops.length; i++)\n//     {\n//         const op = ops[i];\n//         if (op.isSubPatchOp() && op.patchId.get() == subPatchId) return op;\n//     }\n// };\n\n\n\n\n\nPatch.prototype._addLink = function (opinid, opoutid, inName, outName)\n{\n    this.link(this.getOpById(opinid), inName, this.getOpById(opoutid), outName, false, true);\n};\n\nPatch.prototype.deSerialize = function (obj, options)\n{\n    options = options || { \"genIds\": false, \"createRef\": false };\n    if (this.aborted) return;\n    const newOps = [];\n    const loadingId = this.loading.start(\"core\", \"deserialize\");\n\n    this.namespace = obj.namespace || \"\";\n    this.name = obj.name || \"\";\n\n    if (typeof obj === \"string\") obj = JSON.parse(obj);\n\n    this.settings = obj.settings;\n\n    this.emitEvent(\"patchLoadStart\");\n\n    if (window.logStartup)logStartup(\"add \" + obj.ops.length + \" ops... \");\n\n    const addedOps = [];\n    // add ops...\n    for (let iop = 0; iop < obj.ops.length; iop++)\n    {\n        const start = CABLES.now();\n        const opData = obj.ops[iop];\n        let op = null;\n\n        try\n        {\n            if (opData.opId) op = this.addOp(opData.opId, opData.uiAttribs, opData.id, true, opData.objName);\n            else op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);\n        }\n        catch (e)\n        {\n            console.log(\"[instancing error] op data:\", opData, e);\n            throw new Error(\"could not create op by id: <b>\" + (opData.objName || opData.opId) + \"</b> (\" + opData.id + \")\");\n        }\n\n        if (op)\n        {\n            addedOps.push(op);\n            if (options.genIds) op.id = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.shortId)();\n            op.portsInData = opData.portsIn;\n            op._origData = JSON.parse(JSON.stringify(opData));\n            op.storage = opData.storage;\n            if (opData.hasOwnProperty(\"disabled\"))op.setEnabled(!opData.disabled);\n\n            for (const ipi in opData.portsIn)\n            {\n                const objPort = opData.portsIn[ipi];\n                if (objPort && objPort.hasOwnProperty(\"name\"))\n                {\n                    const port = op.getPort(objPort.name);\n\n                    if (port && (port.uiAttribs.display == \"bool\" || port.uiAttribs.type == \"bool\") && !isNaN(objPort.value)) objPort.value = objPort.value === true;\n                    if (port && objPort.value !== undefined && port.type != _constants__WEBPACK_IMPORTED_MODULE_8__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE) port.set(objPort.value);\n\n                    if (port) port.deSerializeSettings(objPort);\n                }\n            }\n\n            for (const ipo in opData.portsOut)\n            {\n                const objPort = opData.portsOut[ipo];\n                if (objPort && objPort.hasOwnProperty(\"name\"))\n                {\n                    const port2 = op.getPort(objPort.name);\n                    if (port2 && port2.type != _constants__WEBPACK_IMPORTED_MODULE_8__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE && objPort.hasOwnProperty(\"value\"))\n                        port2.set(obj.ops[iop].portsOut[ipo].value);\n\n                    if (port2 && objPort.expose) port2.setUiAttribs({ \"expose\": true });\n                }\n            }\n            newOps.push(op);\n        }\n\n        const timeused = Math.round(100 * (CABLES.now() - start)) / 100;\n        if (!this.silent && timeused > 5) console.log(\"long op init \", obj.ops[iop].objName, timeused);\n    }\n    if (window.logStartup)logStartup(\"add ops done\");\n\n    for (const i in this.ops)\n    {\n        if (this.ops[i].onLoadedValueSet)\n        {\n            this.ops[i].onLoadedValueSet(this.ops[i]._origData);\n            this.ops[i].onLoadedValueSet = null;\n            this.ops[i]._origData = null;\n        }\n        this.ops[i].emitEvent(\"loadedValueSet\");\n    }\n\n    if (window.logStartup)logStartup(\"creating links\");\n\n    if (options.opsCreated)options.opsCreated(addedOps);\n\n    // create links...\n    if (obj.ops)\n    {\n        for (let iop = 0; iop < obj.ops.length; iop++)\n        {\n            if (obj.ops[iop].portsIn)\n            {\n                for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++)\n                {\n                    if (obj.ops[iop].portsIn[ipi2] && obj.ops[iop].portsIn[ipi2].links)\n                    {\n                        for (let ili = 0; ili < obj.ops[iop].portsIn[ipi2].links.length; ili++)\n                        {\n                            let found = false;\n\n                            this._addLink(\n                                obj.ops[iop].portsIn[ipi2].links[ili].objIn,\n                                obj.ops[iop].portsIn[ipi2].links[ili].objOut,\n                                obj.ops[iop].portsIn[ipi2].links[ili].portIn,\n                                obj.ops[iop].portsIn[ipi2].links[ili].portOut);\n\n                            // const took = performance.now - startTime;\n                            // if (took > 100)console.log(obj().ops[iop].portsIn[ipi2].links[ili].objIn, obj.ops[iop].portsIn[ipi2].links[ili].objOut, took);\n                        }\n                    }\n                }\n            }\n            if (obj.ops[iop].portsOut)\n                for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)\n                    if (obj.ops[iop].portsOut[ipi2] && obj.ops[iop].portsOut[ipi2].links)\n                    {\n                        for (let ili = 0; ili < obj.ops[iop].portsOut[ipi2].links.length; ili++)\n                        {\n                            if (obj.ops[iop].portsOut[ipi2].links[ili])\n                            {\n                                if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef)\n                                {\n                                    // lost link\n                                    const outOp = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);\n                                    let dstOp = null;\n                                    let theSubPatch = 0;\n\n                                    for (let i = 0; i < this.ops.length; i++)\n                                    {\n                                        if (\n                                            this.ops[i].storage &&\n                                            this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].subOpRef &&\n                                            outOp.uiAttribs.subPatch == this.ops[i].uiAttribs.subPatch\n                                        )\n                                        {\n                                            theSubPatch = this.ops[i].patchId.get();\n                                            break;\n                                        }\n                                    }\n\n                                    for (let i = 0; i < this.ops.length; i++)\n                                    {\n                                        if (\n                                            this.ops[i].storage &&\n                                            this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].refOp &&\n                                            this.ops[i].uiAttribs.subPatch == theSubPatch)\n                                        {\n                                            dstOp = this.ops[i];\n                                            break;\n                                        }\n                                    }\n\n                                    if (!dstOp) this._log.warn(\"could not find op for lost link\");\n                                    else\n                                        this._addLink(\n                                            dstOp.id,\n                                            obj.ops[iop].portsOut[ipi2].links[ili].objOut,\n\n                                            obj.ops[iop].portsOut[ipi2].links[ili].portIn,\n                                            obj.ops[iop].portsOut[ipi2].links[ili].portOut);\n                                }\n                                else\n                                {\n                                    this._addLink(obj.ops[iop].portsOut[ipi2].links[ili].objIn, obj.ops[iop].portsOut[ipi2].links[ili].objOut, obj.ops[iop].portsOut[ipi2].links[ili].portIn, obj.ops[iop].portsOut[ipi2].links[ili].portOut);\n                                }\n                            }\n                        }\n                    }\n        }\n    }\n\n    if (window.logStartup)logStartup(\"calling ops onloaded\");\n\n    for (const i in this.ops)\n    {\n        if (this.ops[i].onLoaded)\n        {\n            // TODO: deprecate!!!\n            this.ops[i].onLoaded();\n            this.ops[i].onLoaded = null;\n        }\n    }\n\n    if (window.logStartup)logStartup(\"initializing ops...\");\n    for (const i in this.ops)\n    {\n        if (this.ops[i].init)\n        {\n            this.ops[i].init();\n            this.ops[i].init = null;\n        }\n    }\n\n    if (window.logStartup)logStartup(\"initializing vars...\");\n\n    if (this.config.variables)\n        for (const varName in this.config.variables)\n            this.setVarValue(varName, this.config.variables[varName]);\n\n    if (window.logStartup)logStartup(\"initializing var ports\");\n\n    for (const i in this.ops)\n    {\n        this.ops[i].initVarPorts();\n        delete this.ops[i].uiAttribs.pasted;\n    }\n\n    setTimeout(() => { this.loading.finished(loadingId); }, 100);\n\n    if (window.logStartup)logStartup(\"calling onPatchLoaded/patchLoadEnd\");\n\n    if (this.config.onPatchLoaded) this.config.onPatchLoaded(this);\n\n    this.deSerialized = true;\n    this.emitEvent(\"patchLoadEnd\", newOps, obj, options.genIds);\n};\n\nPatch.prototype.profile = function (enable)\n{\n    this.profiler = new _core_profiler__WEBPACK_IMPORTED_MODULE_6__.Profiler(this);\n    for (const i in this.ops)\n    {\n        this.ops[i].profile(enable);\n    }\n};\n\n// ----------------------\n\n/**\n * set variable value\n * @function setVariable\n * @memberof Patch\n * @instance\n * @param {String} name of variable\n * @param {Number|String|Boolean} value\n */\nPatch.prototype.setVariable = function (name, val)\n{\n    // if (this._variables.hasOwnProperty(name))\n    if (this._variables[name] !== undefined)\n    {\n        this._variables[name].setValue(val);\n    }\n    else\n    {\n        console.log(\"variable \" + name + \" not found!\");\n    }\n};\n\nPatch.prototype._sortVars = function ()\n{\n    if (!this.isEditorMode()) return;\n    const ordered = {};\n    Object.keys(this._variables).sort(\n        (a, b) =>\n        { return a.localeCompare(b, \"en\", { \"sensitivity\": \"base\" }); }\n    ).forEach((key) =>\n    {\n        ordered[key] = this._variables[key];\n    });\n    this._variables = ordered;\n};\n\n/**\n * has variable\n * @function hasVariable\n * @memberof Patch\n * @instance\n * @param {String} name of variable\n */\nPatch.prototype.hasVar = function (name)\n{\n    return this._variables[name] !== undefined;\n\n    // return this._variables.hasOwnProperty(name);\n};\n\n// used internally\nPatch.prototype.setVarValue = function (name, val, type)\n{\n    if (this.hasVar(name))\n    {\n        this._variables[name].setValue(val);\n    }\n    else\n    {\n        this._variables[name] = new _core_variable__WEBPACK_IMPORTED_MODULE_10__[\"default\"](name, val, type);\n        this._sortVars();\n        this.emitEvent(\"variablesChanged\");\n    }\n    return this._variables[name];\n};\n// old?\nPatch.prototype.getVarValue = function (name, val)\n{\n    if (this._variables.hasOwnProperty(name)) return this._variables[name].getValue();\n};\n\n/**\n * @function getVar\n * @memberof Patch\n * @instance\n * @param {String} name\n * @return {Variable} variable\n */\nPatch.prototype.getVar = function (name)\n{\n    if (this._variables.hasOwnProperty(name)) return this._variables[name];\n};\n\n\nPatch.prototype.deleteVar = function (name)\n{\n    for (let i = 0; i < this.ops.length; i++)\n        for (let j = 0; j < this.ops[i].portsIn.length; j++)\n            if (this.ops[i].portsIn[j].getVariableName() == name)\n                this.ops[i].portsIn[j].setVariable(null);\n\n    delete this._variables[name];\n    this.emitEvent(\"variableDeleted\", name);\n    this.emitEvent(\"variablesChanged\");\n};\n\n/**\n * @function getVars\n * @memberof Patch\n * @instance\n * @return {Array<Variable>} variables\n * @function\n */\nPatch.prototype.getVars = function (t)\n{\n    if (t === undefined) return this._variables;\n\n    const vars = [];\n    if (t == CABLES.OP_PORT_TYPE_STRING) t = \"string\";\n    if (t == CABLES.OP_PORT_TYPE_VALUE) t = \"number\";\n    if (t == CABLES.OP_PORT_TYPE_ARRAY) t = \"array\";\n    if (t == CABLES.OP_PORT_TYPE_OBJECT) t = \"object\";\n\n    for (const i in this._variables)\n    {\n        if (!this._variables[i].type || this._variables[i].type == t) vars.push(this._variables[i]);\n    }\n    return vars;\n};\n\n/**\n * @function exitError\n * @memberof Patch\n * @instance\n * @description cancel patch execution and quit showing an errormessage\n * @function\n */\nPatch.prototype.exitError = function (errorId, errorMessage, ex)\n{\n    this.aborted = true;\n\n    if (this && this.config && this.config.onError)\n    {\n        this.config.onError(errorId, errorMessage);\n    }\n    else\n    {\n        if (!this.isEditorMode())\n        {\n            const newDiv = document.createElement(\"div\");\n\n            const rect = this.cgl.canvas.getBoundingClientRect();\n\n            newDiv.setAttribute(\"style\", \"position:absolute;border:5px solid red;padding:15px;background-color:black;color:white;font-family:monospace;\");\n            newDiv.style.top = rect.top + \"px\";\n            newDiv.style.left = rect.left + \"px\";\n            let str = \"cables - An error occured:<br/>\";\n            str += \"[\" + errorId + \"] - \" + errorMessage;\n            if (ex)str += \"<br/>Exception: \" + ex.message;\n            newDiv.innerHTML = str;\n\n            const pe = this.cgl.canvas.parentElement;\n\n            while (pe.hasChildNodes()) pe.removeChild(pe.lastChild);\n\n            document.body.appendChild(newDiv);\n        }\n    }\n};\n\n/**\n * @function preRenderOps\n * @memberof Patch\n * @instance\n * @description invoke pre rendering of ops\n * @function\n */\nPatch.prototype.preRenderOps = function ()\n{\n    this._log.log(\"prerendering...\");\n\n    for (let i = 0; i < this.ops.length; i++)\n    {\n        if (this.ops[i].preRender)\n        {\n            this.ops[i].preRender();\n            this._log.log(\"prerender \" + this.ops[i].objName);\n        }\n    }\n};\n\n/**\n * @function dispose\n * @memberof Patch\n * @instance\n * @description stop, dispose and cleanup patch\n */\nPatch.prototype.dispose = function ()\n{\n    this.pause();\n    this.clear();\n    this.cgl.dispose();\n};\n\nPatch.prototype.pushTriggerStack = function (p)\n{\n    this._triggerStack.push(p);\n};\n\nPatch.prototype.popTriggerStack = function ()\n{\n    this._triggerStack.pop();\n};\n\nPatch.prototype.printTriggerStack = function ()\n{\n    if (this._triggerStack.length == 0)\n    {\n        // console.log(\"stack length\", this._triggerStack.length); // eslint-disable-line\n        return;\n    }\n    console.groupCollapsed( // eslint-disable-line\n        \"trigger port stack \" + this._triggerStack[this._triggerStack.length - 1].op.name + \".\" + this._triggerStack[this._triggerStack.length - 1].name,\n    );\n\n    const rows = [];\n    for (let i = 0; i < this._triggerStack.length; i++)\n    {\n        rows.push(i + \". \" + this._triggerStack[i].op.name + \" \" + this._triggerStack[i].name);\n    }\n\n    console.table(rows); // eslint-disable-line\n    console.groupEnd(); // eslint-disable-line\n};\n\n/**\n * returns document object of the patch could be != global document object when opening canvas ina popout window\n * @function getDocument\n * @memberof Patch\n * @instance\n * @return {Object} document\n */\nPatch.prototype.getDocument = function ()\n{\n    return this.cgl.canvas.ownerDocument;\n};\n\nPatch.replaceOpIds = function (json, options)\n{\n    const opids = {};\n    for (const i in json.ops)\n    {\n        opids[json.ops[i].id] = json.ops[i];\n    }\n\n    for (const j in json.ops)\n    {\n        for (const k in json.ops[j].portsOut)\n        {\n            const links = json.ops[j].portsOut[k].links;\n            if (links)\n            {\n                let l = links.length;\n\n                while (l--)\n                {\n                    if (links[l] && (!opids[links[l].objIn] || !opids[links[l].objOut]))\n                    {\n                        if (!options.doNotUnlinkLostLinks)\n                        {\n                            links.splice(l, 1);\n                        }\n                        else\n                        {\n                            if (options.fixLostLinks)\n                            {\n                                // console.log(\"lost link...?\", links[l]);\n                                const op = gui.corePatch().getOpById(links[l].objIn);\n                                if (!op) console.log(\"op not found!\");\n                                else\n                                {\n                                    const outerOp = gui.patchView.getSubPatchOuterOp(op.uiAttribs.subPatch);\n                                    if (outerOp)\n                                    {\n                                        op.storage = op.storage || {};\n                                        op.storage.ref = op.storage.ref || CABLES.shortId();\n                                        links[l].refOp = op.storage.ref;\n                                        links[l].subOpRef = outerOp.storage.ref;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n\n    for (const i in json.ops)\n    {\n        const op = json.ops[i];\n        const oldId = op.id;\n        let newId = CABLES.shortId();\n\n        if (options.prefixHash) newId = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.prefixedHash)(options.prefixHash + oldId);\n\n        else if (options.prefixId) newId = options.prefixId + oldId;\n        else if (options.refAsId) // when saving json\n        {\n            if (op.storage && op.storage.ref)\n            {\n                newId = op.storage.ref;\n                delete op.storage.ref;\n            }\n            else\n            {\n                op.storage = op.storage || {};\n                op.storage.ref = newId = CABLES.shortId();\n            }\n        }\n\n        const newID = op.id = newId;\n\n        if (options.oldIdAsRef) // when loading json\n        {\n            op.storage = op.storage || {};\n            op.storage.ref = oldId;\n        }\n\n        for (const j in json.ops)\n        {\n            if (json.ops[j].portsIn)\n                for (const k in json.ops[j].portsIn)\n                {\n                    if (json.ops[j].portsIn[k].links)\n                    {\n                        let l = json.ops[j].portsIn[k].links.length;\n\n                        while (l--) if (json.ops[j].portsIn[k].links[l] === null) json.ops[j].portsIn[k].links.splice(l, 1);\n\n                        for (l in json.ops[j].portsIn[k].links)\n                        {\n                            if (json.ops[j].portsIn[k].links[l].objIn === oldId) json.ops[j].portsIn[k].links[l].objIn = newID;\n                            if (json.ops[j].portsIn[k].links[l].objOut === oldId) json.ops[j].portsIn[k].links[l].objOut = newID;\n                        }\n                    }\n                }\n\n            if (json.ops[j].portsOut)\n                for (const k in json.ops[j].portsOut)\n                {\n                    if (json.ops[j].portsOut[k].links)\n                    {\n                        let l = json.ops[j].portsOut[k].links.length;\n\n                        while (l--) if (json.ops[j].portsOut[k].links[l] === null) json.ops[j].portsOut[k].links.splice(l, 1);\n\n                        for (l in json.ops[j].portsOut[k].links)\n                        {\n                            if (json.ops[j].portsOut[k].links[l].objIn === oldId) json.ops[j].portsOut[k].links[l].objIn = newID;\n                            if (json.ops[j].portsOut[k].links[l].objOut === oldId) json.ops[j].portsOut[k].links[l].objOut = newID;\n                        }\n                    }\n                }\n        }\n    }\n\n    // set correct subpatch\n    const subpatchIds = [];\n    const fixedSubPatches = [];\n\n    for (let i = 0; i < json.ops.length; i++)\n    {\n        // if (CABLES.Op.isSubPatchOpName(json.ops[i].objName))\n        if (json.ops[i].storage && json.ops[i].storage.subPatchVer)\n        {\n            for (const k in json.ops[i].portsIn)\n            {\n                if (json.ops[i].portsIn[k].name === \"patchId\")\n                {\n                    let newId = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.shortId)();\n\n                    if (options.prefixHash) newId = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.prefixedHash)(options.prefixHash + json.ops[i].portsIn[k].value);\n\n                    const oldSubPatchId = json.ops[i].portsIn[k].value;\n                    const newSubPatchId = json.ops[i].portsIn[k].value = newId;\n\n                    subpatchIds.push(newSubPatchId);\n\n                    for (let j = 0; j < json.ops.length; j++)\n                    {\n                        // op has no uiAttribs in export, we don't care about subpatches in export though\n                        if (json.ops[j].uiAttribs)\n                        {\n                            if (json.ops[j].uiAttribs.subPatch === oldSubPatchId)\n                            {\n                                json.ops[j].uiAttribs.subPatch = newSubPatchId;\n                                fixedSubPatches.push(json.ops[j].id);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (const kk in json.ops)\n    {\n        let found = false;\n        for (let j = 0; j < fixedSubPatches.length; j++)\n        {\n            if (json.ops[kk].id === fixedSubPatches[j])\n            {\n                found = true;\n                break;\n            }\n        }\n        // op has no uiAttribs in export, we don't care about subpatches in export though\n        if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)\n            json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;\n    }\n\n    return json;\n};\n\n/**\n * remove an eventlistener\n * @instance\n * @function addEventListener\n * @param {String} name of event\n * @param {function} callback\n */\n\n/**\n * remove an eventlistener\n * @instance\n * @function removeEventListener\n * @param {String} name of event\n * @param {function} callback\n */\n\n/**\n * op added to patch event\n * @event onOpAdd\n *\n * @memberof Patch\n * @type {Object}\n * @property {Op} op new op\n */\n\n/**\n * op deleted from patch\n * @event onOpDelete\n * @memberof Patch\n * @type {Object}\n * @property {Op} op that will be deleted\n */\n\n/**\n * link event - two ports will be linked\n * @event onLink\n * @memberof Patch\n * @type {Object}\n * @property {Port} port1\n * @property {Port} port2\n */\n\n/**\n * unlink event - a link was deleted\n * @event onUnLink\n * @memberof Patch\n * @type {Object}\n */\n\n/**\n * variables has been changed / a variable has been added to the patch\n * @event variablesChanged\n * @memberof Patch\n * @type {Object}\n * @property {Port} port1\n * @property {Port} port2\n */\n\n/**\n * configuration object for loading a patch\n * @typedef {Object} PatchConfig\n * @hideconstructor\n * @property {String} [prefixAssetPath=''] prefix for path to assets\n * @property {String} [assetPath=''] path to assets\n * @property {String} [jsPath=''] path to javascript files\n * @property {String} [glCanvasId='glcanvas'] dom element id of canvas element\n * @property {Function} [onError=null] called when an error occurs\n * @property {Function} [onFinishedLoading=null] called when patch finished loading all assets\n * @property {Function} [onFirstFrameRendered=null] called when patch rendered it's first frame\n * @property {Boolean} [glCanvasResizeToWindow=false] resize canvas automatically to window size\n * @property {Boolean} [doRequestAnimation=true] do requestAnimationFrame set to false if you want to trigger exec() from outside (only do if you know what you are doing)\n * @property {Boolean} [clearCanvasColor=true] clear canvas in transparent color every frame\n * @property {Boolean} [clearCanvasDepth=true] clear depth every frame\n * @property {Boolean} [glValidateShader=true] enable/disable validation of shaders *\n * @property {Boolean} [silent=false]\n * @property {Number} [fpsLimit=0] 0 for maximum possible frames per second\n * @property {String} [glslPrecision='mediump'] default precision for glsl shader\n *\n */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Patch);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BhdGNoLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NvcmVfcGF0Y2guanM/MzlmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50dGFyZ2V0XCI7XG5pbXBvcnQgeyBhamF4LCBhamF4U3luYywgcHJlZml4ZWRIYXNoLCBjbGVhbkpzb24sIHNob3J0SWQgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgTG9hZGluZ1N0YXR1cyB9IGZyb20gXCIuL2xvYWRpbmdzdGF0dXNcIjtcbmltcG9ydCB7IEluc3RhbmNpbmcgfSBmcm9tIFwiLi9pbnN0YW5jaW5nXCI7XG5pbXBvcnQgeyBUaW1lciB9IGZyb20gXCIuL3RpbWVyXCI7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSBcIi4vY29yZV9saW5rXCI7XG5pbXBvcnQgeyBQcm9maWxlciB9IGZyb20gXCIuL2NvcmVfcHJvZmlsZXJcIjtcbmltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwiLi9jZ2wvY2dsX3N0YXRlXCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4vY29yZV9sb2dnZXJcIjtcbmltcG9ydCBQYXRjaFZhcmlhYmxlIGZyb20gXCIuL2NvcmVfdmFyaWFibGVcIjtcblxuXG4vKipcbiAqIFBhdGNoIGNsYXNzLCBjb250YWlucyBhbGwgb3BlcmF0b3JzLHZhbHVlcyxsaW5rcyBldGMuIG1hbmFnZXMgbG9hZGluZyBhbmQgcnVubmluZyBvZiB0aGUgd2hvbGUgcGF0Y2hcbiAqXG4gKiBzZWUge0BsaW5rIFBhdGNoQ29uZmlnfVxuICpcbiAqIEBleHRlcm5hbCBDQUJMRVNcbiAqIEBuYW1lc3BhY2UgUGF0Y2hcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UGF0Y2hDb25maWd9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAY2xhc3NcbiAqIEBleGFtcGxlXG4gKiBDQUJMRVMucGF0Y2g9bmV3IENBQkxFUy5QYXRjaChcbiAqIHtcbiAqICAgICBwYXRjaDpwU3RyLFxuICogICAgIGdsQ2FudmFzSWQ6J2dsY2FudmFzJyxcbiAqICAgICBnbENhbnZhc1Jlc2l6ZVRvV2luZG93OnRydWUsXG4gKiAgICAgY2FudmFzOntwb3dlclByZWZlcmVuY2U6XCJoaWdoLXBlcmZvcm1hbmNlXCJ9LFxuICogICAgIHByZWZpeEFzc2V0UGF0aDonL2Fzc2V0cy8nLFxuICogICAgIHByZWZpeEpzUGF0aDonL2pzLycsXG4gKiAgICAgb25FcnJvcjpmdW5jdGlvbihlKXtjb25zb2xlLmxvZyhlKTt9XG4gKiAgICAgZ2xzbFByZWNpc2lvbjonaGlnaHAnXG4gKiB9KTtcbiAqL1xuXG5jb25zdCBQYXRjaCA9IGZ1bmN0aW9uIChjZmcpXG57XG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY29yZV9wYXRjaFwiKTtcbiAgICB0aGlzLm9wcyA9IFtdO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICB0aGlzLmNvbmZpZyA9IGNmZyB8fFxuICAgICAgICB7XG4gICAgICAgICAgICBcImdsQ2FudmFzUmVzaXplVG9XaW5kb3dcIjogZmFsc2UsXG4gICAgICAgICAgICBcInByZWZpeEFzc2V0UGF0aFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwcmVmaXhKc1BhdGhcIjogXCJcIixcbiAgICAgICAgICAgIFwic2lsZW50XCI6IHRydWUsXG4gICAgICAgICAgICBcIm9uRXJyb3JcIjogbnVsbCxcbiAgICAgICAgICAgIFwib25GaW5pc2hlZExvYWRpbmdcIjogbnVsbCxcbiAgICAgICAgICAgIFwib25GaXJzdEZyYW1lUmVuZGVyZWRcIjogbnVsbCxcbiAgICAgICAgICAgIFwib25QYXRjaExvYWRlZFwiOiBudWxsLFxuICAgICAgICAgICAgXCJmcHNMaW1pdFwiOiAwLFxuICAgICAgICB9O1xuICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIoKTtcbiAgICB0aGlzLmZyZWVUaW1lciA9IG5ldyBUaW1lcigpO1xuICAgIHRoaXMuYW5pbUZyYW1lT3BzID0gW107XG4gICAgdGhpcy5hbmltRnJhbWVDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmd1aSA9IGZhbHNlO1xuICAgIENBQkxFUy5sb2dTaWxlbnQgPSB0aGlzLnNpbGVudCA9IHRydWU7XG4gICAgdGhpcy5wcm9maWxlciA9IG51bGw7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY3Jhc2hlZE9wcyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlck9uZUZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbVJlcSA9IG51bGw7XG4gICAgdGhpcy5fb3BJZENhY2hlID0ge307XG4gICAgdGhpcy5fdHJpZ2dlclN0YWNrID0gW107XG4gICAgdGhpcy5zdG9yZU9iak5hbWVzID0gZmFsc2U7IC8vIHJlbW92ZSBhZnRlciBtYXkgcmVsZWFzZVxuXG4gICAgdGhpcy5sb2FkaW5nID0gbmV3IExvYWRpbmdTdGF0dXModGhpcyk7XG5cbiAgICB0aGlzLl92b2x1bWVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9mcmFtZU51bSA9IDA7XG4gICAgdGhpcy5pbnN0YW5jaW5nID0gbmV3IEluc3RhbmNpbmcoKTtcbiAgICB0aGlzLm9uT25lRnJhbWVSZW5kZXJlZCA9IG51bGw7XG4gICAgdGhpcy5uYW1lZFRyaWdnZXJzID0ge307XG5cbiAgICB0aGlzLl9vcmlnRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVOZXh0ID0gMDtcbiAgICB0aGlzLl9mcmFtZUludGVydmFsID0gMDtcbiAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gMDtcbiAgICB0aGlzLl9mcmFtZVdhc2RlbGF5ZWQgPSB0cnVlO1xuICAgIHRoaXMuZnJhbWVTdG9yZSA9IHt9O1xuICAgIHRoaXMuZGVTZXJpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdFJlcUFuaW1UaW1lU3RhbXAgPSAwO1xuXG4gICAgdGhpcy5jZ0NhbnZhcyA9IG51bGw7XG5cbiAgICBpZiAoIShmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpczsgfSgpKSkgY29uc29sZS5sb2coXCJub3QgaW4gc3RyaWN0IG1vZGU6IGNvcmUgcGF0Y2hcIik7XG5cbiAgICB0aGlzLl9pc0xvY2FsID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlsZTpcIikgPT09IDA7XG5cbiAgICBpZiAodGhpcy5jb25maWcuaGFzT3duUHJvcGVydHkoXCJzaWxlbnRcIikpIHRoaXMuc2lsZW50ID0gQ0FCTEVTLmxvZ1NpbGVudCA9IHRoaXMuY29uZmlnLnNpbGVudDtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KFwiZG9SZXF1ZXN0QW5pbWF0aW9uXCIpKSB0aGlzLmNvbmZpZy5kb1JlcXVlc3RBbmltYXRpb24gPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5wcmVmaXhBc3NldFBhdGgpIHRoaXMuY29uZmlnLnByZWZpeEFzc2V0UGF0aCA9IFwiXCI7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5wcmVmaXhKc1BhdGgpIHRoaXMuY29uZmlnLnByZWZpeEpzUGF0aCA9IFwiXCI7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5tYXN0ZXJWb2x1bWUpIHRoaXMuY29uZmlnLm1hc3RlclZvbHVtZSA9IDEuMDtcblxuICAgIHRoaXMuX3ZhcmlhYmxlcyA9IHt9O1xuICAgIHRoaXMuX3ZhcmlhYmxlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy52YXJzID0ge307XG4gICAgaWYgKGNmZyAmJiBjZmcudmFycykgdGhpcy52YXJzID0gY2ZnLnZhcnM7IC8vIHZhcnMgaXMgb2xkIVxuXG4gICAgdGhpcy5jZ2wgPSBuZXcgQ29udGV4dCh0aGlzKTtcbiAgICB0aGlzLmNncCA9IG51bGw7XG5cbiAgICB0aGlzLl9zdWJwYXRjaE9wQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuY2dsLnNldENhbnZhcyh0aGlzLmNvbmZpZy5nbENhbnZhc0lkIHx8IHRoaXMuY29uZmlnLmdsQ2FudmFzIHx8IFwiZ2xjYW52YXNcIik7XG4gICAgaWYgKHRoaXMuY29uZmlnLmdsQ2FudmFzUmVzaXplVG9XaW5kb3cgPT09IHRydWUpIHRoaXMuY2dsLnNldEF1dG9SZXNpemUoXCJ3aW5kb3dcIik7XG4gICAgaWYgKHRoaXMuY29uZmlnLmdsQ2FudmFzUmVzaXplVG9QYXJlbnQgPT09IHRydWUpIHRoaXMuY2dsLnNldEF1dG9SZXNpemUoXCJwYXJlbnRcIik7XG4gICAgdGhpcy5sb2FkaW5nLnNldE9uRmluaXNoZWRMb2FkaW5nKHRoaXMuY29uZmlnLm9uRmluaXNoZWRMb2FkaW5nKTtcblxuICAgIGlmICh0aGlzLmNnbC5hYm9ydGVkKSB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNnbC5zaWxlbnQpIHRoaXMuc2lsZW50ID0gdHJ1ZTtcblxuICAgIHRoaXMuZnJlZVRpbWVyLnBsYXkoKTtcbiAgICB0aGlzLmV4ZWMoKTtcblxuICAgIGlmICghdGhpcy5hYm9ydGVkKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnBhdGNoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRlU2VyaWFsaXplKHRoaXMuY29uZmlnLnBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy5wYXRjaEZpbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFqYXgoXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcucGF0Y2hGaWxlLFxuICAgICAgICAgICAgICAgIChlcnIsIF9kYXRhKSA9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiZXJyXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiZGF0YVwiLCBkYXRhLm1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZVNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXIucGxheSgpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwibWFkZSB3aXRoIGh0dHBzOi8vY2FibGVzLmdsXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG5QYXRjaC5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5pc1JlbmRlcmluZ09uZUZyYW1lID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyT25lRnJhbWU7XG59O1xuXG5cblBhdGNoLnByb3RvdHlwZS5yZW5kZXJPbmVGcmFtZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW5kZXJPbmVGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5leGVjKCk7XG4gICAgdGhpcy5fcmVuZGVyT25lRnJhbWUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogY3VycmVudCBudW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmRcbiAqIEBmdW5jdGlvbiBnZXRGUFNcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGZwc1xuICovXG5QYXRjaC5wcm90b3R5cGUuZ2V0RlBTID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zb2xlLmxvZyhcImRlcHJlY2F0ZWQgZ2V0ZnBzXCIpO1xuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgcGF0Y2ggaXMgb3BlbmVkIGluIGVkaXRvci9ndWkgbW9kZVxuICogQGZ1bmN0aW9uIGlzRWRpdG9yTW9kZVxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVkaXRvciBtb2RlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5pc0VkaXRvck1vZGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5lZGl0b3JNb2RlID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBwYXVzZXMgcGF0Y2ggZXhlY3V0aW9uXG4gKiBAZnVuY3Rpb24gcGF1c2VcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbVJlcSk7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJwYXVzZVwiKTtcbiAgICB0aGlzLl9hbmltUmVxID0gbnVsbDtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZnJlZVRpbWVyLnBhdXNlKCk7XG59O1xuXG4vKipcbiAqIHJlc3VtZXMgcGF0Y2ggZXhlY3V0aW9uXG4gKiBAZnVuY3Rpb24gcmVzdW1lXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICovXG5QYXRjaC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcGF1c2VkKVxuICAgIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbVJlcSk7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZWVUaW1lci5wbGF5KCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicmVzdW1lXCIpO1xuICAgICAgICB0aGlzLmV4ZWMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHNldCB2b2x1bWUgWzAtMV1cbiAqIEBmdW5jdGlvbiBzZXRWb2x1bWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB2b2x1bWVcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodilcbntcbiAgICB0aGlzLmNvbmZpZy5tYXN0ZXJWb2x1bWUgPSB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdm9sdW1lTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB0aGlzLl92b2x1bWVMaXN0ZW5lcnNbaV0ub25NYXN0ZXJWb2x1bWVDaGFuZ2VkKHYpO1xufTtcblxuXG4vKipcbiAqIGdldCBhc3NldCBwYXRoXG4gKiBAZnVuY3Rpb24gZ2V0QXNzZXRQYXRoXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICovXG5QYXRjaC5wcm90b3R5cGUuZ2V0QXNzZXRQYXRoID0gZnVuY3Rpb24gKHBhdGNoSWQgPSBudWxsKVxue1xuICAgIGlmICh0aGlzLmlzRWRpdG9yTW9kZSgpKVxuICAgIHtcbiAgICAgICAgbGV0IGlkID0gcGF0Y2hJZCB8fCBndWkucHJvamVjdCgpLl9pZDtcbiAgICAgICAgcmV0dXJuIFwiL2Fzc2V0cy9cIiArIGlkICsgXCIvXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImNhYmxlcy5nbFwiKSA+IDAgfHwgZG9jdW1lbnQubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiY2FibGVzLmxvY2FsXCIpID4gMClcbiAgICB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgaWQgPSBwYXRjaElkIHx8IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gXCIvYXNzZXRzL1wiICsgaWQgKyBcIi9cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jb25maWcuaGFzT3duUHJvcGVydHkoXCJhc3NldFBhdGhcIikpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuYXNzZXRQYXRoO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gXCJhc3NldHMvXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBnZXQganMgcGF0aFxuICogQGZ1bmN0aW9uIGdldEpzUGF0aFxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmdldEpzUGF0aCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KFwianNQYXRoXCIpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmpzUGF0aDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwianMvXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBnZXQgdXJsL2ZpbGVwYXRoIGZvciBhIGZpbGVuYW1lXG4gKiB0aGlzIHVzZXMgcHJlZml4QXNzZXRwYXRoIGluIGV4cG9ydGVkIHBhdGNoZXNcbiAqIEBmdW5jdGlvbiBnZXRGaWxlUGF0aFxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSB1cmxcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmdldEZpbGVQYXRoID0gZnVuY3Rpb24gKGZpbGVuYW1lKVxue1xuICAgIGlmICghZmlsZW5hbWUpIHJldHVybiBmaWxlbmFtZTtcbiAgICBmaWxlbmFtZSA9IFN0cmluZyhmaWxlbmFtZSk7XG4gICAgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCJodHRwczpcIikgPT09IDAgfHwgZmlsZW5hbWUuaW5kZXhPZihcImh0dHA6XCIpID09PSAwKSByZXR1cm4gZmlsZW5hbWU7XG4gICAgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCJkYXRhOlwiKSA9PT0gMCkgcmV0dXJuIGZpbGVuYW1lO1xuICAgIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiZmlsZTpcIikgPT09IDApIHJldHVybiBmaWxlbmFtZTtcblxuICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZShcIi8vXCIsIFwiL1wiKTtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucHJlZml4QXNzZXRQYXRoICsgZmlsZW5hbWUgKyAodGhpcy5jb25maWcuc3VmZml4QXNzZXRQYXRoIHx8IFwiXCIpO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmVtaXRFdmVudChcInBhdGNoQ2xlYXJTdGFydFwiKTtcbiAgICB0aGlzLmNnbC5UZXh0dXJlRWZmZWN0TWVzaCA9IG51bGw7XG4gICAgdGhpcy5hbmltRnJhbWVPcHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKCk7XG4gICAgd2hpbGUgKHRoaXMub3BzLmxlbmd0aCA+IDApIHRoaXMuZGVsZXRlT3AodGhpcy5vcHNbMF0uaWQpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicGF0Y2hDbGVhckVuZFwiKTtcbn07XG5cblBhdGNoLmdldE9wQ2xhc3MgPSBmdW5jdGlvbiAob2JqTmFtZSlcbntcbiAgICBjb25zdCBwYXJ0cyA9IG9iak5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBvcE9iaiA9IG51bGw7XG5cbiAgICB0cnlcbiAgICB7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMikgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXTtcbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09IDMpIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNCkgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNSkgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXTtcbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09IDYpIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNykgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gOCkgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dW3BhcnRzWzddXTtcbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09IDkpIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV1bcGFydHNbOF1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gMTApIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV1bcGFydHNbOF1dW3BhcnRzWzldXTtcbiAgICAgICAgcmV0dXJuIG9wT2JqO1xuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cblBhdGNoLnByb3RvdHlwZS5jcmVhdGVPcCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBpZCwgb3BOYW1lID0gbnVsbClcbntcbiAgICBsZXQgb3AgPSBudWxsO1xuICAgIGxldCBvYmpOYW1lID0gXCJcIjtcblxuICAgIHRyeVxuICAgIHtcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY3JlYXRlb3AgaWRlbnRpZmllciBmYWxzZVwiLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoXCJPcHMuXCIpID09PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgYSB1dWlkLCBub3QgYSBuYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIGNyZWF0aW5nIG9wcyBieSBpZCBzaG91bGQgYmUgdGhlIGRlZmF1bHQgd2F5IGZyb20gbm93IG9uIVxuICAgICAgICAgICAgY29uc3Qgb3BJZCA9IGlkZW50aWZpZXI7XG5cblxuXG4gICAgICAgICAgICBpZiAoQ0FCTEVTLk9QU1tvcElkXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvYmpOYW1lID0gQ0FCTEVTLk9QU1tvcElkXS5vYmpOYW1lO1xuICAgICAgICAgICAgICAgIG9wID0gbmV3IENBQkxFUy5PUFNbb3BJZF0uZih0aGlzLCBvYmpOYW1lLCBpZCwgb3BJZCk7XG4gICAgICAgICAgICAgICAgb3Aub3BJZCA9IG9wSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG9wTmFtZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBvcE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY291bGQgbm90IGZpbmQgb3AgYnkgaWQ6IFwiICsgb3BJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBmaW5kIG9wIGJ5IGlkOiBcIiArIG9wSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3ApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrOiBjcmVhdGUgYnkgb2JqbmFtZSFcbiAgICAgICAgICAgIG9iak5hbWUgPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBpZGVudGlmaWVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IG9wT2JqID0gUGF0Y2guZ2V0T3BDbGFzcyhvYmpOYW1lKTtcblxuICAgICAgICAgICAgaWYgKCFvcE9iailcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcImNyaXRpY2FsRXJyb3JcIiwgeyBcInRpdGxlXCI6IFwidW5rbm93biBvcFwiICsgb2JqTmFtZSwgXCJ0ZXh0XCI6IFwidW5rbm93biBvcDogXCIgKyBvYmpOYW1lIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwidW5rbm93biBvcDogXCIgKyBvYmpOYW1lKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG9wOiBcIiArIG9iak5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMikgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSAzKSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA0KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dKHRoaXMsIG9iak5hbWUsIGlkKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNSkgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA2KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA3KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dKHRoaXMsIG9iak5hbWUsIGlkKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gOCkgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA5KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dW3BhcnRzWzddXVtwYXJ0c1s4XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSAxMCkgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV1bcGFydHNbOF1dW3BhcnRzWzldXSh0aGlzLCBvYmpOYW1lLCBpZCk7XG4gICAgICAgICAgICAgICAgZWxzZSBjb25zb2xlLmxvZyhcInBhcnRzLmxlbmd0aFwiLCBwYXJ0cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3ApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3Aub3BJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIENBQkxFUy5PUFMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ0FCTEVTLk9QU1tpXS5vYmpOYW1lID09IG9iak5hbWUpIG9wLm9wSWQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NyYXNoZWRPcHMucHVzaChvYmpOYW1lKTtcblxuICAgICAgICB0aGlzLmVtaXRFdmVudChcImV4Y2VwdGlvbk9wXCIsIGUsIG9iak5hbWUsIG9wKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0b3JNb2RlKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltpbnN0YW5jaW5nIGVycm9yXSBcIiArIG9iak5hbWUsIGUpO1xuXG4gICAgICAgICAgICBpZiAoQ0FCTEVTLmFwaSkgQ0FCTEVTLmFwaS5zZW5kRXJyb3JSZXBvcnQoZSk7XG4gICAgICAgICAgICB0aGlzLmV4aXRFcnJvcihcIklOU1RBTkNFX0VSUlwiLCBcIkluc3RhbmNpbmcgRXJyb3IgMVwiICsgb2JqTmFtZSwgZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnN0YW5jaW5nIGVycm9yIDFcIiArIG9iak5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wKVxuICAgIHtcbiAgICAgICAgb3AuX29iak5hbWUgPSBvYmpOYW1lO1xuICAgICAgICBvcC5wYXRjaCA9IHRoaXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5sb2coXCJubyBvcCB3YXMgY3JlYXRlZCE/XCIsIGlkZW50aWZpZXIsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgYSBuZXcgb3AgaW4gcGF0Y2hcbiAqIEBmdW5jdGlvbiBhZGRPcFxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcElkZW50aWZpZXIsIHV1aWQgb3IgbmFtZSwgZS5nLiBPcHMuTWF0aC5TdW1cbiAqIEBwYXJhbSB7T2JqZWN0fSB1aUF0dHJpYnMgQXR0cmlidXRlc1xuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21EZXNlcmlhbGl6ZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wTmFtZSwgZS5nLiBPcHMuTWF0aC5TdW1cbiAqIEBleGFtcGxlXG4gKiAvLyBhZGQgaW52aXNpYmxlIG9wXG4gKiBwYXRjaC5hZGRPcCgnT3BzLk1hdGguU3VtJywgeyBzaG93VWlBdHRyaWJzOiBmYWxzZSB9KTtcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmFkZE9wID0gZnVuY3Rpb24gKG9wSWRlbnRpZmllciwgdWlBdHRyaWJzLCBpZCwgZnJvbURlc2VyaWFsaXplLCBvcE5hbWUpXG57XG4gICAgY29uc3Qgb3AgPSB0aGlzLmNyZWF0ZU9wKG9wSWRlbnRpZmllciwgaWQsIG9wTmFtZSk7XG5cbiAgICBpZiAob3ApXG4gICAge1xuICAgICAgICB1aUF0dHJpYnMgPSB1aUF0dHJpYnMgfHwge307XG4gICAgICAgIGlmICh1aUF0dHJpYnMuaGFzT3duUHJvcGVydHkoXCJlcnJvcnNcIikpIGRlbGV0ZSB1aUF0dHJpYnMuZXJyb3JzO1xuICAgICAgICBpZiAodWlBdHRyaWJzLmhhc093blByb3BlcnR5KFwiZXJyb3JcIikpIGRlbGV0ZSB1aUF0dHJpYnMuZXJyb3I7XG4gICAgICAgIHVpQXR0cmlicy5zdWJQYXRjaCA9IHVpQXR0cmlicy5zdWJQYXRjaCB8fCAwO1xuXG4gICAgICAgIG9wLnNldFVpQXR0cmlicyh1aUF0dHJpYnMpO1xuICAgICAgICBpZiAob3Aub25DcmVhdGUpIG9wLm9uQ3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKG9wLmhhc093blByb3BlcnR5KFwib25BbmltRnJhbWVcIikpIHRoaXMuYWRkT25BbmltRnJhbWUob3ApO1xuICAgICAgICBpZiAob3AuaGFzT3duUHJvcGVydHkoXCJvbk1hc3RlclZvbHVtZUNoYW5nZWRcIikpIHRoaXMuX3ZvbHVtZUxpc3RlbmVycy5wdXNoKG9wKTtcblxuICAgICAgICBpZiAodGhpcy5fb3BJZENhY2hlW29wLmlkXSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvcGlkIHdpdGggaWQgXCIgKyBvcC5pZCArIFwiIGFscmVhZHkgZXhpc3RzIGluIHBhdGNoIVwiKTtcbiAgICAgICAgICAgIC8vIG9wLmlkICs9IFwiX2RvdWJsZVwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHMucHVzaChvcCk7XG4gICAgICAgIHRoaXMuX29wSWRDYWNoZVtvcC5pZF0gPSBvcDtcblxuICAgICAgICBpZiAodGhpcy5fc3ViUGF0Y2hDYWNoZUFkZCkgdGhpcy5fc3ViUGF0Y2hDYWNoZUFkZCh1aUF0dHJpYnMuc3ViUGF0Y2gsIG9wKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvbk9wQWRkXCIsIG9wLCBmcm9tRGVzZXJpYWxpemUpO1xuXG5cbiAgICAgICAgaWYgKG9wLmluaXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBvcC5lbWl0RXZlbnQoXCJpbml0XCIsIGZyb21EZXNlcmlhbGl6ZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcImFkZG9wOiBubyBvcC4uLi4uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBvcDtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5hZGRPbkFuaW1GcmFtZSA9IGZ1bmN0aW9uIChvcClcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbUZyYW1lT3BzLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5hbmltRnJhbWVPcHNbaV0gPT0gb3ApIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmFuaW1GcmFtZU9wcy5wdXNoKG9wKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5yZW1vdmVPbkFuaW1GcmFtZSA9IGZ1bmN0aW9uIChvcClcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbUZyYW1lT3BzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbUZyYW1lT3BzW2ldID09IG9wKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFuaW1GcmFtZU9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuYWRkT25BbmltRnJhbWVDYWxsYmFjayA9IGZ1bmN0aW9uIChjYilcbntcbiAgICB0aGlzLmFuaW1GcmFtZUNhbGxiYWNrcy5wdXNoKGNiKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5yZW1vdmVPbkFuaW1DYWxsYmFjayA9IGZ1bmN0aW9uIChjYilcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbUZyYW1lQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbUZyYW1lQ2FsbGJhY2tzW2ldID09IGNiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFuaW1GcmFtZUNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuZGVsZXRlT3AgPSBmdW5jdGlvbiAob3BpZCwgdHJ5UmVsaW5rLCByZWxvYWRpbmdPcClcbntcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5vcHNbaV0uaWQgPT0gb3BpZClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB0aGlzLm9wc1tpXTtcbiAgICAgICAgICAgIGxldCByZUxpbmtQMSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcmVMaW5rUDIgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAob3ApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cnlSZWxpbmspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AucG9ydHNJbi5sZW5ndGggPiAwICYmIG9wLnBvcnRzSW5bMF0uaXNMaW5rZWQoKSAmJiAob3AucG9ydHNPdXQubGVuZ3RoID4gMCAmJiBvcC5wb3J0c091dFswXS5pc0xpbmtlZCgpKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnBvcnRzSW5bMF0uZ2V0VHlwZSgpID09IG9wLnBvcnRzT3V0WzBdLmdldFR5cGUoKSAmJiBvcC5wb3J0c0luWzBdLmxpbmtzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlTGlua1AxID0gb3AucG9ydHNJblswXS5saW5rc1swXS5nZXRPdGhlclBvcnQob3AucG9ydHNJblswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVMaW5rUDIgPSBvcC5wb3J0c091dFswXS5saW5rc1swXS5nZXRPdGhlclBvcnQob3AucG9ydHNPdXRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3BUb0RlbGV0ZSA9IHRoaXMub3BzW2ldO1xuICAgICAgICAgICAgICAgIG9wVG9EZWxldGUucmVtb3ZlTGlua3MoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uRGVsZXRlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVwcmVjYXRlZCB0aGlzLm9uRGVsZXRlXCIsIHRoaXMub25EZWxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGVsZXRlKG9wVG9EZWxldGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub3BzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBvcFRvRGVsZXRlLmVtaXRFdmVudChcImRlbGV0ZVwiLCB0aGlzLm9wc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvbk9wRGVsZXRlXCIsIG9wVG9EZWxldGUsIHJlbG9hZGluZ09wKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsZWFyU3ViUGF0Y2hDYWNoZSkgdGhpcy5jbGVhclN1YlBhdGNoQ2FjaGUob3BUb0RlbGV0ZS51aUF0dHJpYnMuc3ViUGF0Y2gpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wVG9EZWxldGUub25EZWxldGUpIG9wVG9EZWxldGUub25EZWxldGUocmVsb2FkaW5nT3ApO1xuICAgICAgICAgICAgICAgIG9wVG9EZWxldGUuY2xlYW5VcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlTGlua1AxICE9PSBudWxsICYmIHJlTGlua1AyICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rKHJlTGlua1AxLm9wLCByZUxpbmtQMS5nZXROYW1lKCksIHJlTGlua1AyLm9wLCByZUxpbmtQMi5nZXROYW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vcElkQ2FjaGVbb3BpZF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvdW5kKSBjb25zb2xlLmxvZyhcImNvcmUgcGF0Y2ggZGVsZXRlb3A6IG5vdCBmb3VuZC4uLlwiLCBvcGlkKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5nZXRGcmFtZU51bSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lTnVtO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLmVtaXRPbkFuaW1GcmFtZUV2ZW50ID0gZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxue1xuICAgIHRpbWUgPSB0aW1lIHx8IHRoaXMudGltZXIuZ2V0VGltZSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1GcmFtZUNhbGxiYWNrcy5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1GcmFtZUNhbGxiYWNrc1tpXSkgdGhpcy5hbmltRnJhbWVDYWxsYmFja3NbaV0odGltZSwgdGhpcy5fZnJhbWVOdW0sIGRlbHRhKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbUZyYW1lT3BzLmxlbmd0aDsgKytpKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbUZyYW1lT3BzW2ldLm9uQW5pbUZyYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFuaW1GcmFtZU9wc1tpXS5vbkFuaW1GcmFtZSh0aW1lLCB0aGlzLl9mcmFtZU51bSwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUGF0Y2gucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcbntcbiAgICAvLyBjb25zb2xlLmxvZyhcInJlbmRlcmZyYW1lXCIsIHRoaXMuX3BhdXNlZCwgdGhpcy5fZnJhbWVOdW0pO1xuXG4gICAgdGhpcy50aW1lci51cGRhdGUoKTtcbiAgICB0aGlzLmZyZWVUaW1lci51cGRhdGUoKTtcbiAgICBjb25zdCB0aW1lID0gdGhpcy50aW1lci5nZXRUaW1lKCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5jZ2wuZnJhbWVTdGFydFRpbWUgPSB0aGlzLnRpbWVyLmdldFRpbWUoKTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gdGhpcy5fbGFzdFJlcUFuaW1UaW1lU3RhbXAgfHwgdGltZXN0YW1wO1xuXG4gICAgdGhpcy5lbWl0T25BbmltRnJhbWVFdmVudChudWxsLCBkZWx0YSk7XG5cbiAgICB0aGlzLmNnbC5wcm9maWxlRGF0YS5wcm9maWxlRnJhbWVEZWx0YSA9IGRlbHRhO1xuICAgIHRoaXMuX2xhc3RSZXFBbmltVGltZVN0YW1wID0gdGltZXN0YW1wO1xuICAgIHRoaXMuY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVPbkFuaW1GcmFtZU9wcyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgdGhpcy5lbWl0RXZlbnQoXCJvblJlbmRlckZyYW1lXCIsIHRpbWUpO1xuXG4gICAgdGhpcy5fZnJhbWVOdW0rKztcbiAgICBpZiAodGhpcy5fZnJhbWVOdW0gPT0gMSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5vbkZpcnN0RnJhbWVSZW5kZXJlZCkgdGhpcy5jb25maWcub25GaXJzdEZyYW1lUmVuZGVyZWQoKTtcbiAgICB9XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uICh0aW1lc3RhbXApXG57XG4gICAgaWYgKCF0aGlzLl9yZW5kZXJPbmVGcmFtZSAmJiAodGhpcy5fcGF1c2VkIHx8IHRoaXMuYWJvcnRlZCkpIHJldHVybjtcbiAgICB0aGlzLmVtaXRFdmVudChcInJlcUFuaW1GcmFtZVwiKTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltUmVxKTtcblxuICAgIHRoaXMuY29uZmlnLmZwc0xpbWl0ID0gdGhpcy5jb25maWcuZnBzTGltaXQgfHwgMDtcbiAgICBpZiAodGhpcy5jb25maWcuZnBzTGltaXQpXG4gICAge1xuICAgICAgICB0aGlzLl9mcmFtZUludGVydmFsID0gMTAwMCAvIHRoaXMuY29uZmlnLmZwc0xpbWl0O1xuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IENBQkxFUy5ub3coKTtcbiAgICBjb25zdCBmcmFtZURlbHRhID0gbm93IC0gdGhpcy5fZnJhbWVOZXh0O1xuXG5cblxuICAgIGlmICh0aGlzLmlzRWRpdG9yTW9kZSgpKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJPbmVGcmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5vdyAtIHRoaXMuX2xhc3RGcmFtZVRpbWUgPj0gNTAwICYmIHRoaXMuX2xhc3RGcmFtZVRpbWUgIT09IDAgJiYgIXRoaXMuX2ZyYW1lV2FzZGVsYXllZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZXhlYy5iaW5kKHRoaXMpLCA1MDApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicmVuZGVyRGVsYXlTdGFydFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZVdhc2RlbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJPbmVGcmFtZSB8fCB0aGlzLmNvbmZpZy5mcHNMaW1pdCA9PT0gMCB8fCBmcmFtZURlbHRhID4gdGhpcy5fZnJhbWVJbnRlcnZhbCB8fCB0aGlzLl9mcmFtZVdhc2RlbGF5ZWQpXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlckZyYW1lKHRpbWVzdGFtcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lSW50ZXJ2YWwpIHRoaXMuX2ZyYW1lTmV4dCA9IG5vdyAtIChmcmFtZURlbHRhICUgdGhpcy5fZnJhbWVJbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZyYW1lV2FzZGVsYXllZClcbiAgICB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicmVuZGVyRGVsYXlFbmRcIik7XG4gICAgICAgIHRoaXMuX2ZyYW1lV2FzZGVsYXllZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJPbmVGcmFtZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm9uT25lRnJhbWVSZW5kZXJlZCkgdGhpcy5vbk9uZUZyYW1lUmVuZGVyZWQoKTsgLy8gdG9kbyByZW1vdmUgZXZlcnl3aGVyZSBhbmQgdXNlIHByb3BwZXIgZXZlbnQuLi5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJyZW5kZXJlZE9uZUZyYW1lXCIpO1xuICAgICAgICB0aGlzLl9yZW5kZXJPbmVGcmFtZSA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmRvUmVxdWVzdEFuaW1hdGlvbikgdGhpcy5fYW5pbVJlcSA9IHRoaXMuY2dsLmNhbnZhcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmV4ZWMuYmluZCh0aGlzKSk7XG59O1xuXG4vLyBQYXRjaC5wcm90b3R5cGUubGlua1BvcnRzID0gZnVuY3Rpb24gKHBvcnQxLCBwb3J0Milcbi8vIHtcbi8vICAgICB0aGlzLmxpbmsocG9ydDEucGFyZW50LCBwb3J0MS5pZCwgcG9ydDIucGFyZW50LCBwb3J0Mi5pZCk7XG4vLyB9O1xuXG4vKipcbiAqIGxpbmsgdHdvIG9wcy9wb3J0c1xuICogQGZ1bmN0aW9uIGxpbmtcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09wfSBvcDFcbiAqIEBwYXJhbSB7U3RyaW5nfSBwb3J0TmFtZTFcbiAqIEBwYXJhbSB7T3B9IG9wMlxuICogQHBhcmFtIHtTdHJpbmd9IHBvcnROYW1lMlxuICovXG5QYXRjaC5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uIChvcDEsIHBvcnQxTmFtZSwgb3AyLCBwb3J0Mk5hbWUsIGxvd2VyQ2FzZSwgZnJvbURlc2VyaWFsaXplKVxue1xuICAgIGlmICghb3AxKVxuICAgIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwibGluazogb3AxIGlzIG51bGwgXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3AyKVxuICAgIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwibGluazogb3AyIGlzIG51bGxcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0MSA9IG9wMS5nZXRQb3J0KHBvcnQxTmFtZSwgbG93ZXJDYXNlKTtcbiAgICBjb25zdCBwb3J0MiA9IG9wMi5nZXRQb3J0KHBvcnQyTmFtZSwgbG93ZXJDYXNlKTtcblxuICAgIGlmICghcG9ydDEpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJwb3J0MSBub3QgZm91bmQhIFwiICsgcG9ydDFOYW1lICsgXCIoXCIgKyBvcDEub2JqTmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghcG9ydDIpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJwb3J0MiBub3QgZm91bmQhIFwiICsgcG9ydDJOYW1lICsgXCIgb2YgXCIgKyBvcDIubmFtZSArIFwiKFwiICsgb3AyLm9iak5hbWUgKyBcIilcIiwgb3AyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghcG9ydDEuc2hvdWxkTGluayhwb3J0MSwgcG9ydDIpIHx8ICFwb3J0Mi5zaG91bGRMaW5rKHBvcnQxLCBwb3J0MikpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKExpbmsuY2FuTGluayhwb3J0MSwgcG9ydDIpKVxuICAgIHtcbiAgICAgICAgY29uc3QgbGluayA9IG5ldyBMaW5rKHRoaXMpO1xuICAgICAgICBsaW5rLmxpbmsocG9ydDEsIHBvcnQyKTtcblxuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uTGlua1wiLCBwb3J0MSwgcG9ydDIsIGxpbmssIGZyb21EZXNlcmlhbGl6ZSk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH1cbn07XG5cblBhdGNoLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucylcbntcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9iai5vcHMgPSBbXTtcbiAgICBvYmouc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICB7XG4gICAgICAgIGNvbnN0IG9wID0gdGhpcy5vcHNbaV07XG4gICAgICAgIG9iai5vcHMucHVzaChvcC5nZXRTZXJpYWxpemVkKCkpO1xuICAgIH1cblxuICAgIGNsZWFuSnNvbihvYmopO1xuXG4gICAgaWYgKG9wdGlvbnMuYXNPYmplY3QpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuZ2V0T3BzQnlSZWZJZCA9IGZ1bmN0aW9uIChyZWZJZClcbntcbiAgICBjb25zdCBwZXJmID0gQ0FCTEVTLlVJLnVpUHJvZmlsZXIuc3RhcnQoXCJbY29yZXBhdGNoZXRlbmRdIGdldE9wc0J5UmVmSWRcIik7XG4gICAgY29uc3QgcmVmT3BzID0gW107XG4gICAgY29uc3Qgb3BzID0gZ3VpLmNvcmVQYXRjaCgpLm9wcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKG9wc1tpXS5zdG9yYWdlICYmIG9wc1tpXS5zdG9yYWdlLnJlZiA9PSByZWZJZCkgcmVmT3BzLnB1c2gob3BzW2ldKTtcbiAgICBwZXJmLmZpbmlzaCgpO1xuICAgIHJldHVybiByZWZPcHM7XG59O1xuXG5cblBhdGNoLnByb3RvdHlwZS5nZXRPcEJ5SWQgPSBmdW5jdGlvbiAob3BpZClcbntcbiAgICByZXR1cm4gdGhpcy5fb3BJZENhY2hlW29waWRdO1xuICAgIC8vIHRoaXMudGltZU5lZWRlZEdldE9wQnlJZCA9IHRoaXMudGltZU5lZWRlZEdldE9wQnlJZCB8fCAwO1xuXG4gICAgLy8gY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIC8vIHtcbiAgICAvLyAgICAgaWYgKHRoaXMub3BzW2ldLmlkID09IG9waWQpXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgIHRoaXMudGltZU5lZWRlZEdldE9wQnlJZCArPSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUpO1xuICAgIC8vICAgICAgICAgcmV0dXJuIHRoaXMub3BzW2ldO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxufTtcblxuLy8gUGF0Y2gucHJvdG90eXBlLmdldE9wc0J5SWQgPSBmdW5jdGlvbiAob3BJZHMpXG4vLyB7XG4vLyAgICAgY29uc3Qgb3BzID0gW107XG4vLyAgICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuLy8gICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9wSWRzLmxlbmd0aDsgaisrKVxuLy8gICAgICAgICAgICAgaWYgKHRoaXMub3BzW2ldLmlkID09PSBvcElkc1tqXSlcbi8vICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICBvcHMucHVzaCh0aGlzLm9wc1tpXSk7XG4vLyAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgcmV0dXJuIG9wcztcbi8vIH07XG5cblBhdGNoLnByb3RvdHlwZS5nZXRPcHNCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICAvLyBUT0RPOiBpcyB0aGlzIHN0aWxsIG5lZWRlZCA/IHVuY2xlYXIgYmVoYXZpb3VyLi4uLlxuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLm5hbWUgPT0gbmFtZSkgYXJyLnB1c2godGhpcy5vcHNbaV0pO1xuICAgIHJldHVybiBhcnI7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuZ2V0T3BzQnlPYmpOYW1lID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgICAgICBpZiAodGhpcy5vcHNbaV0ub2JqTmFtZSA9PSBuYW1lKSBhcnIucHVzaCh0aGlzLm9wc1tpXSk7XG4gICAgcmV0dXJuIGFycjtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5nZXRPcHNCeU9wSWQgPSBmdW5jdGlvbiAob3BpZClcbntcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4gICAgICAgIGlmICh0aGlzLm9wc1tpXS5vcElkID09IG9waWQpIGFyci5wdXNoKHRoaXMub3BzW2ldKTtcbiAgICByZXR1cm4gYXJyO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLmxvYWRMaWIgPSBmdW5jdGlvbiAod2hpY2gpXG57XG4gICAgYWpheFN5bmMoXG4gICAgICAgIFwiL3VpL2xpYnMvXCIgKyB3aGljaCArIFwiLmpzXCIsXG4gICAgICAgIChlcnIsIHJlcykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2UudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICBzZS50ZXh0ID0gcmVzO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJHRVRcIixcbiAgICApO1xuICAgIC8vIG9wZW4gYW5kIHNlbmQgYSBzeW5jaHJvbm91cyByZXF1ZXN0XG4gICAgLy8geGhyT2JqLm9wZW4oJ0dFVCcsICcvdWkvbGlicy8nK3doaWNoKycuanMnLCBmYWxzZSk7XG4gICAgLy8geGhyT2JqLnNlbmQoJycpO1xuICAgIC8vIGFkZCB0aGUgcmV0dXJuZWQgY29udGVudCB0byBhIG5ld2x5IGNyZWF0ZWQgc2NyaXB0IHRhZ1xufTtcblxuXG5QYXRjaC5wcm90b3R5cGUuZ2V0U3ViUGF0Y2hPcCA9IGZ1bmN0aW9uIChwYXRjaElkLCBvYmpOYW1lKVxue1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLnVpQXR0cmlicyAmJiB0aGlzLm9wc1tpXS51aUF0dHJpYnMuc3ViUGF0Y2ggPT0gcGF0Y2hJZCAmJiB0aGlzLm9wc1tpXS5vYmpOYW1lID09IG9iak5hbWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHNbaV07XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUGF0Y2gucHJvdG90eXBlLmdldFN1YlBhdGNoT3V0ZXJPcCA9IGZ1bmN0aW9uIChzdWJQYXRjaElkKSAvLyByZW1vdmUgISEgbW92ZWQgdG8gZXh0ZW5kIGNsYXNzXG4vLyB7XG4vLyAgICAgY29uc3Qgb3BzID0gdGhpcy5vcHM7XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspXG4vLyAgICAge1xuLy8gICAgICAgICBjb25zdCBvcCA9IG9wc1tpXTtcbi8vICAgICAgICAgaWYgKG9wLmlzU3ViUGF0Y2hPcCgpICYmIG9wLnBhdGNoSWQuZ2V0KCkgPT0gc3ViUGF0Y2hJZCkgcmV0dXJuIG9wO1xuLy8gICAgIH1cbi8vIH07XG5cblxuXG5cblxuUGF0Y2gucHJvdG90eXBlLl9hZGRMaW5rID0gZnVuY3Rpb24gKG9waW5pZCwgb3BvdXRpZCwgaW5OYW1lLCBvdXROYW1lKVxue1xuICAgIHRoaXMubGluayh0aGlzLmdldE9wQnlJZChvcGluaWQpLCBpbk5hbWUsIHRoaXMuZ2V0T3BCeUlkKG9wb3V0aWQpLCBvdXROYW1lLCBmYWxzZSwgdHJ1ZSk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuZGVTZXJpYWxpemUgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgXCJnZW5JZHNcIjogZmFsc2UsIFwiY3JlYXRlUmVmXCI6IGZhbHNlIH07XG4gICAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld09wcyA9IFtdO1xuICAgIGNvbnN0IGxvYWRpbmdJZCA9IHRoaXMubG9hZGluZy5zdGFydChcImNvcmVcIiwgXCJkZXNlcmlhbGl6ZVwiKTtcblxuICAgIHRoaXMubmFtZXNwYWNlID0gb2JqLm5hbWVzcGFjZSB8fCBcIlwiO1xuICAgIHRoaXMubmFtZSA9IG9iai5uYW1lIHx8IFwiXCI7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuXG4gICAgdGhpcy5zZXR0aW5ncyA9IG9iai5zZXR0aW5ncztcblxuICAgIHRoaXMuZW1pdEV2ZW50KFwicGF0Y2hMb2FkU3RhcnRcIik7XG5cbiAgICBpZiAod2luZG93LmxvZ1N0YXJ0dXApbG9nU3RhcnR1cChcImFkZCBcIiArIG9iai5vcHMubGVuZ3RoICsgXCIgb3BzLi4uIFwiKTtcblxuICAgIGNvbnN0IGFkZGVkT3BzID0gW107XG4gICAgLy8gYWRkIG9wcy4uLlxuICAgIGZvciAobGV0IGlvcCA9IDA7IGlvcCA8IG9iai5vcHMubGVuZ3RoOyBpb3ArKylcbiAgICB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gQ0FCTEVTLm5vdygpO1xuICAgICAgICBjb25zdCBvcERhdGEgPSBvYmoub3BzW2lvcF07XG4gICAgICAgIGxldCBvcCA9IG51bGw7XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChvcERhdGEub3BJZCkgb3AgPSB0aGlzLmFkZE9wKG9wRGF0YS5vcElkLCBvcERhdGEudWlBdHRyaWJzLCBvcERhdGEuaWQsIHRydWUsIG9wRGF0YS5vYmpOYW1lKTtcbiAgICAgICAgICAgIGVsc2Ugb3AgPSB0aGlzLmFkZE9wKG9wRGF0YS5vYmpOYW1lLCBvcERhdGEudWlBdHRyaWJzLCBvcERhdGEuaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltpbnN0YW5jaW5nIGVycm9yXSBvcCBkYXRhOlwiLCBvcERhdGEsIGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGQgbm90IGNyZWF0ZSBvcCBieSBpZDogPGI+XCIgKyAob3BEYXRhLm9iak5hbWUgfHwgb3BEYXRhLm9wSWQpICsgXCI8L2I+IChcIiArIG9wRGF0YS5pZCArIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcClcbiAgICAgICAge1xuICAgICAgICAgICAgYWRkZWRPcHMucHVzaChvcCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5nZW5JZHMpIG9wLmlkID0gc2hvcnRJZCgpO1xuICAgICAgICAgICAgb3AucG9ydHNJbkRhdGEgPSBvcERhdGEucG9ydHNJbjtcbiAgICAgICAgICAgIG9wLl9vcmlnRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3BEYXRhKSk7XG4gICAgICAgICAgICBvcC5zdG9yYWdlID0gb3BEYXRhLnN0b3JhZ2U7XG4gICAgICAgICAgICBpZiAob3BEYXRhLmhhc093blByb3BlcnR5KFwiZGlzYWJsZWRcIikpb3Auc2V0RW5hYmxlZCghb3BEYXRhLmRpc2FibGVkKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpcGkgaW4gb3BEYXRhLnBvcnRzSW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqUG9ydCA9IG9wRGF0YS5wb3J0c0luW2lwaV07XG4gICAgICAgICAgICAgICAgaWYgKG9ialBvcnQgJiYgb2JqUG9ydC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3J0ID0gb3AuZ2V0UG9ydChvYmpQb3J0Lm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3J0ICYmIChwb3J0LnVpQXR0cmlicy5kaXNwbGF5ID09IFwiYm9vbFwiIHx8IHBvcnQudWlBdHRyaWJzLnR5cGUgPT0gXCJib29sXCIpICYmICFpc05hTihvYmpQb3J0LnZhbHVlKSkgb2JqUG9ydC52YWx1ZSA9IG9ialBvcnQudmFsdWUgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3J0ICYmIG9ialBvcnQudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwb3J0LnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9URVhUVVJFKSBwb3J0LnNldChvYmpQb3J0LnZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocG9ydCkgcG9ydC5kZVNlcmlhbGl6ZVNldHRpbmdzKG9ialBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBpcG8gaW4gb3BEYXRhLnBvcnRzT3V0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialBvcnQgPSBvcERhdGEucG9ydHNPdXRbaXBvXTtcbiAgICAgICAgICAgICAgICBpZiAob2JqUG9ydCAmJiBvYmpQb3J0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcnQyID0gb3AuZ2V0UG9ydChvYmpQb3J0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9ydDIgJiYgcG9ydDIudHlwZSAhPSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1RFWFRVUkUgJiYgb2JqUG9ydC5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDIuc2V0KG9iai5vcHNbaW9wXS5wb3J0c091dFtpcG9dLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocG9ydDIgJiYgb2JqUG9ydC5leHBvc2UpIHBvcnQyLnNldFVpQXR0cmlicyh7IFwiZXhwb3NlXCI6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T3BzLnB1c2gob3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXVzZWQgPSBNYXRoLnJvdW5kKDEwMCAqIChDQUJMRVMubm93KCkgLSBzdGFydCkpIC8gMTAwO1xuICAgICAgICBpZiAoIXRoaXMuc2lsZW50ICYmIHRpbWV1c2VkID4gNSkgY29uc29sZS5sb2coXCJsb25nIG9wIGluaXQgXCIsIG9iai5vcHNbaW9wXS5vYmpOYW1lLCB0aW1ldXNlZCk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cubG9nU3RhcnR1cClsb2dTdGFydHVwKFwiYWRkIG9wcyBkb25lXCIpO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLm9uTG9hZGVkVmFsdWVTZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLm9uTG9hZGVkVmFsdWVTZXQodGhpcy5vcHNbaV0uX29yaWdEYXRhKTtcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLm9uTG9hZGVkVmFsdWVTZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcHNbaV0uX29yaWdEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wc1tpXS5lbWl0RXZlbnQoXCJsb2FkZWRWYWx1ZVNldFwiKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LmxvZ1N0YXJ0dXApbG9nU3RhcnR1cChcImNyZWF0aW5nIGxpbmtzXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMub3BzQ3JlYXRlZClvcHRpb25zLm9wc0NyZWF0ZWQoYWRkZWRPcHMpO1xuXG4gICAgLy8gY3JlYXRlIGxpbmtzLi4uXG4gICAgaWYgKG9iai5vcHMpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpb3AgPSAwOyBpb3AgPCBvYmoub3BzLmxlbmd0aDsgaW9wKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChvYmoub3BzW2lvcF0ucG9ydHNJbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpcGkyID0gMDsgaXBpMiA8IG9iai5vcHNbaW9wXS5wb3J0c0luLmxlbmd0aDsgaXBpMisrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5vcHNbaW9wXS5wb3J0c0luW2lwaTJdICYmIG9iai5vcHNbaW9wXS5wb3J0c0luW2lwaTJdLmxpbmtzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbGkgPSAwOyBpbGkgPCBvYmoub3BzW2lvcF0ucG9ydHNJbltpcGkyXS5saW5rcy5sZW5ndGg7IGlsaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm9wc1tpb3BdLnBvcnRzSW5baXBpMl0ubGlua3NbaWxpXS5vYmpJbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm9wc1tpb3BdLnBvcnRzSW5baXBpMl0ubGlua3NbaWxpXS5vYmpPdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vcHNbaW9wXS5wb3J0c0luW2lwaTJdLmxpbmtzW2lsaV0ucG9ydEluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub3BzW2lvcF0ucG9ydHNJbltpcGkyXS5saW5rc1tpbGldLnBvcnRPdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgdG9vayA9IHBlcmZvcm1hbmNlLm5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodG9vayA+IDEwMCljb25zb2xlLmxvZyhvYmooKS5vcHNbaW9wXS5wb3J0c0luW2lwaTJdLmxpbmtzW2lsaV0ub2JqSW4sIG9iai5vcHNbaW9wXS5wb3J0c0luW2lwaTJdLmxpbmtzW2lsaV0ub2JqT3V0LCB0b29rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoub3BzW2lvcF0ucG9ydHNPdXQpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXBpMiA9IDA7IGlwaTIgPCBvYmoub3BzW2lvcF0ucG9ydHNPdXQubGVuZ3RoOyBpcGkyKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0gJiYgb2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbGkgPSAwOyBpbGkgPCBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3MubGVuZ3RoOyBpbGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0uc3ViT3BSZWYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvc3QgbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0T3AgPSB0aGlzLmdldE9wQnlJZChvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5vYmpPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRzdE9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aGVTdWJQYXRjaCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpXS5zdG9yYWdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2ldLnN0b3JhZ2UucmVmID09IG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLnN1Yk9wUmVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dE9wLnVpQXR0cmlicy5zdWJQYXRjaCA9PSB0aGlzLm9wc1tpXS51aUF0dHJpYnMuc3ViUGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTdWJQYXRjaCA9IHRoaXMub3BzW2ldLnBhdGNoSWQuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2ldLnN0b3JhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHNbaV0uc3RvcmFnZS5yZWYgPT0gb2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0ucmVmT3AgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHNbaV0udWlBdHRyaWJzLnN1YlBhdGNoID09IHRoZVN1YlBhdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0T3AgPSB0aGlzLm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRzdE9wKSB0aGlzLl9sb2cud2FybihcImNvdWxkIG5vdCBmaW5kIG9wIGZvciBsb3N0IGxpbmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0T3AuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLm9iak91dCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5wb3J0SW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLnBvcnRPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTGluayhvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5vYmpJbiwgb2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0ub2JqT3V0LCBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5wb3J0SW4sIG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLnBvcnRPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LmxvZ1N0YXJ0dXApbG9nU3RhcnR1cChcImNhbGxpbmcgb3BzIG9ubG9hZGVkXCIpO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLm9uTG9hZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGUhISFcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLm9uTG9hZGVkKCk7XG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5vbkxvYWRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LmxvZ1N0YXJ0dXApbG9nU3RhcnR1cChcImluaXRpYWxpemluZyBvcHMuLi5cIik7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLmluaXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLmluaXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5sb2dTdGFydHVwKWxvZ1N0YXJ0dXAoXCJpbml0aWFsaXppbmcgdmFycy4uLlwiKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy52YXJpYWJsZXMpXG4gICAgICAgIGZvciAoY29uc3QgdmFyTmFtZSBpbiB0aGlzLmNvbmZpZy52YXJpYWJsZXMpXG4gICAgICAgICAgICB0aGlzLnNldFZhclZhbHVlKHZhck5hbWUsIHRoaXMuY29uZmlnLnZhcmlhYmxlc1t2YXJOYW1lXSk7XG5cbiAgICBpZiAod2luZG93LmxvZ1N0YXJ0dXApbG9nU3RhcnR1cChcImluaXRpYWxpemluZyB2YXIgcG9ydHNcIik7XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4gICAge1xuICAgICAgICB0aGlzLm9wc1tpXS5pbml0VmFyUG9ydHMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMub3BzW2ldLnVpQXR0cmlicy5wYXN0ZWQ7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMubG9hZGluZy5maW5pc2hlZChsb2FkaW5nSWQpOyB9LCAxMDApO1xuXG4gICAgaWYgKHdpbmRvdy5sb2dTdGFydHVwKWxvZ1N0YXJ0dXAoXCJjYWxsaW5nIG9uUGF0Y2hMb2FkZWQvcGF0Y2hMb2FkRW5kXCIpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLm9uUGF0Y2hMb2FkZWQpIHRoaXMuY29uZmlnLm9uUGF0Y2hMb2FkZWQodGhpcyk7XG5cbiAgICB0aGlzLmRlU2VyaWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJwYXRjaExvYWRFbmRcIiwgbmV3T3BzLCBvYmosIG9wdGlvbnMuZ2VuSWRzKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5wcm9maWxlID0gZnVuY3Rpb24gKGVuYWJsZSlcbntcbiAgICB0aGlzLnByb2ZpbGVyID0gbmV3IFByb2ZpbGVyKHRoaXMpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICB7XG4gICAgICAgIHRoaXMub3BzW2ldLnByb2ZpbGUoZW5hYmxlKTtcbiAgICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogc2V0IHZhcmlhYmxlIHZhbHVlXG4gKiBAZnVuY3Rpb24gc2V0VmFyaWFibGVcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB2YXJpYWJsZVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJvb2xlYW59IHZhbHVlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpXG57XG4gICAgLy8gaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICBpZiAodGhpcy5fdmFyaWFibGVzW25hbWVdICE9PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICB0aGlzLl92YXJpYWJsZXNbbmFtZV0uc2V0VmFsdWUodmFsKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ2YXJpYWJsZSBcIiArIG5hbWUgKyBcIiBub3QgZm91bmQhXCIpO1xuICAgIH1cbn07XG5cblBhdGNoLnByb3RvdHlwZS5fc29ydFZhcnMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5pc0VkaXRvck1vZGUoKSkgcmV0dXJuO1xuICAgIGNvbnN0IG9yZGVyZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl92YXJpYWJsZXMpLnNvcnQoXG4gICAgICAgIChhLCBiKSA9PlxuICAgICAgICB7IHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYiwgXCJlblwiLCB7IFwic2Vuc2l0aXZpdHlcIjogXCJiYXNlXCIgfSk7IH1cbiAgICApLmZvckVhY2goKGtleSkgPT5cbiAgICB7XG4gICAgICAgIG9yZGVyZWRba2V5XSA9IHRoaXMuX3ZhcmlhYmxlc1trZXldO1xuICAgIH0pO1xuICAgIHRoaXMuX3ZhcmlhYmxlcyA9IG9yZGVyZWQ7XG59O1xuXG4vKipcbiAqIGhhcyB2YXJpYWJsZVxuICogQGZ1bmN0aW9uIGhhc1ZhcmlhYmxlXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdmFyaWFibGVcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmhhc1ZhciA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXNbbmFtZV0gIT09IHVuZGVmaW5lZDtcblxuICAgIC8vIHJldHVybiB0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSk7XG59O1xuXG4vLyB1c2VkIGludGVybmFsbHlcblBhdGNoLnByb3RvdHlwZS5zZXRWYXJWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWwsIHR5cGUpXG57XG4gICAgaWYgKHRoaXMuaGFzVmFyKG5hbWUpKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzW25hbWVdLnNldFZhbHVlKHZhbCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IG5ldyBQYXRjaFZhcmlhYmxlKG5hbWUsIHZhbCwgdHlwZSk7XG4gICAgICAgIHRoaXMuX3NvcnRWYXJzKCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwidmFyaWFibGVzQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbn07XG4vLyBvbGQ/XG5QYXRjaC5wcm90b3R5cGUuZ2V0VmFyVmFsdWUgPSBmdW5jdGlvbiAobmFtZSwgdmFsKVxue1xuICAgIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHJldHVybiB0aGlzLl92YXJpYWJsZXNbbmFtZV0uZ2V0VmFsdWUoKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldFZhclxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtWYXJpYWJsZX0gdmFyaWFibGVcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmdldFZhciA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHJldHVybiB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG59O1xuXG5cblBhdGNoLnByb3RvdHlwZS5kZWxldGVWYXIgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3BzLmxlbmd0aDsgaSsrKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMub3BzW2ldLnBvcnRzSW4ubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBpZiAodGhpcy5vcHNbaV0ucG9ydHNJbltqXS5nZXRWYXJpYWJsZU5hbWUoKSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMub3BzW2ldLnBvcnRzSW5bal0uc2V0VmFyaWFibGUobnVsbCk7XG5cbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwidmFyaWFibGVEZWxldGVkXCIsIG5hbWUpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwidmFyaWFibGVzQ2hhbmdlZFwiKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldFZhcnNcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBcnJheTxWYXJpYWJsZT59IHZhcmlhYmxlc1xuICogQGZ1bmN0aW9uXG4gKi9cblBhdGNoLnByb3RvdHlwZS5nZXRWYXJzID0gZnVuY3Rpb24gKHQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlcztcblxuICAgIGNvbnN0IHZhcnMgPSBbXTtcbiAgICBpZiAodCA9PSBDQUJMRVMuT1BfUE9SVF9UWVBFX1NUUklORykgdCA9IFwic3RyaW5nXCI7XG4gICAgaWYgKHQgPT0gQ0FCTEVTLk9QX1BPUlRfVFlQRV9WQUxVRSkgdCA9IFwibnVtYmVyXCI7XG4gICAgaWYgKHQgPT0gQ0FCTEVTLk9QX1BPUlRfVFlQRV9BUlJBWSkgdCA9IFwiYXJyYXlcIjtcbiAgICBpZiAodCA9PSBDQUJMRVMuT1BfUE9SVF9UWVBFX09CSkVDVCkgdCA9IFwib2JqZWN0XCI7XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fdmFyaWFibGVzKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl92YXJpYWJsZXNbaV0udHlwZSB8fCB0aGlzLl92YXJpYWJsZXNbaV0udHlwZSA9PSB0KSB2YXJzLnB1c2godGhpcy5fdmFyaWFibGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcnM7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBleGl0RXJyb3JcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gY2FuY2VsIHBhdGNoIGV4ZWN1dGlvbiBhbmQgcXVpdCBzaG93aW5nIGFuIGVycm9ybWVzc2FnZVxuICogQGZ1bmN0aW9uXG4gKi9cblBhdGNoLnByb3RvdHlwZS5leGl0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JJZCwgZXJyb3JNZXNzYWdlLCBleClcbntcbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMgJiYgdGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcub25FcnJvcilcbiAgICB7XG4gICAgICAgIHRoaXMuY29uZmlnLm9uRXJyb3IoZXJyb3JJZCwgZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRpdG9yTW9kZSgpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuZXdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5jZ2wuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBuZXdEaXYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6NXB4IHNvbGlkIHJlZDtwYWRkaW5nOjE1cHg7YmFja2dyb3VuZC1jb2xvcjpibGFjaztjb2xvcjp3aGl0ZTtmb250LWZhbWlseTptb25vc3BhY2U7XCIpO1xuICAgICAgICAgICAgbmV3RGl2LnN0eWxlLnRvcCA9IHJlY3QudG9wICsgXCJweFwiO1xuICAgICAgICAgICAgbmV3RGl2LnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICBsZXQgc3RyID0gXCJjYWJsZXMgLSBBbiBlcnJvciBvY2N1cmVkOjxici8+XCI7XG4gICAgICAgICAgICBzdHIgKz0gXCJbXCIgKyBlcnJvcklkICsgXCJdIC0gXCIgKyBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoZXgpc3RyICs9IFwiPGJyLz5FeGNlcHRpb246IFwiICsgZXgubWVzc2FnZTtcbiAgICAgICAgICAgIG5ld0Rpdi5pbm5lckhUTUwgPSBzdHI7XG5cbiAgICAgICAgICAgIGNvbnN0IHBlID0gdGhpcy5jZ2wuY2FudmFzLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChwZS5oYXNDaGlsZE5vZGVzKCkpIHBlLnJlbW92ZUNoaWxkKHBlLmxhc3RDaGlsZCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3RGl2KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHByZVJlbmRlck9wc1xuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiBpbnZva2UgcHJlIHJlbmRlcmluZyBvZiBvcHNcbiAqIEBmdW5jdGlvblxuICovXG5QYXRjaC5wcm90b3R5cGUucHJlUmVuZGVyT3BzID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cubG9nKFwicHJlcmVuZGVyaW5nLi4uXCIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm9wc1tpXS5wcmVSZW5kZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLnByZVJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5fbG9nLmxvZyhcInByZXJlbmRlciBcIiArIHRoaXMub3BzW2ldLm9iak5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZGlzcG9zZVxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiBzdG9wLCBkaXNwb3NlIGFuZCBjbGVhbnVwIHBhdGNoXG4gKi9cblBhdGNoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnBhdXNlKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY2dsLmRpc3Bvc2UoKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5wdXNoVHJpZ2dlclN0YWNrID0gZnVuY3Rpb24gKHApXG57XG4gICAgdGhpcy5fdHJpZ2dlclN0YWNrLnB1c2gocCk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucG9wVHJpZ2dlclN0YWNrID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl90cmlnZ2VyU3RhY2sucG9wKCk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucHJpbnRUcmlnZ2VyU3RhY2sgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl90cmlnZ2VyU3RhY2subGVuZ3RoID09IDApXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInN0YWNrIGxlbmd0aFwiLCB0aGlzLl90cmlnZ2VyU3RhY2subGVuZ3RoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgXCJ0cmlnZ2VyIHBvcnQgc3RhY2sgXCIgKyB0aGlzLl90cmlnZ2VyU3RhY2tbdGhpcy5fdHJpZ2dlclN0YWNrLmxlbmd0aCAtIDFdLm9wLm5hbWUgKyBcIi5cIiArIHRoaXMuX3RyaWdnZXJTdGFja1t0aGlzLl90cmlnZ2VyU3RhY2subGVuZ3RoIC0gMV0ubmFtZSxcbiAgICApO1xuXG4gICAgY29uc3Qgcm93cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHJpZ2dlclN0YWNrLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgcm93cy5wdXNoKGkgKyBcIi4gXCIgKyB0aGlzLl90cmlnZ2VyU3RhY2tbaV0ub3AubmFtZSArIFwiIFwiICsgdGhpcy5fdHJpZ2dlclN0YWNrW2ldLm5hbWUpO1xuICAgIH1cblxuICAgIGNvbnNvbGUudGFibGUocm93cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn07XG5cbi8qKlxuICogcmV0dXJucyBkb2N1bWVudCBvYmplY3Qgb2YgdGhlIHBhdGNoIGNvdWxkIGJlICE9IGdsb2JhbCBkb2N1bWVudCBvYmplY3Qgd2hlbiBvcGVuaW5nIGNhbnZhcyBpbmEgcG9wb3V0IHdpbmRvd1xuICogQGZ1bmN0aW9uIGdldERvY3VtZW50XG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSBkb2N1bWVudFxuICovXG5QYXRjaC5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmNnbC5jYW52YXMub3duZXJEb2N1bWVudDtcbn07XG5cblBhdGNoLnJlcGxhY2VPcElkcyA9IGZ1bmN0aW9uIChqc29uLCBvcHRpb25zKVxue1xuICAgIGNvbnN0IG9waWRzID0ge307XG4gICAgZm9yIChjb25zdCBpIGluIGpzb24ub3BzKVxuICAgIHtcbiAgICAgICAgb3BpZHNbanNvbi5vcHNbaV0uaWRdID0ganNvbi5vcHNbaV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBqIGluIGpzb24ub3BzKVxuICAgIHtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIGpzb24ub3BzW2pdLnBvcnRzT3V0KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzO1xuICAgICAgICAgICAgaWYgKGxpbmtzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBsID0gbGlua3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGwtLSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rc1tsXSAmJiAoIW9waWRzW2xpbmtzW2xdLm9iakluXSB8fCAhb3BpZHNbbGlua3NbbF0ub2JqT3V0XSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kb05vdFVubGlua0xvc3RMaW5rcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5zcGxpY2UobCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZml4TG9zdExpbmtzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJsb3N0IGxpbmsuLi4/XCIsIGxpbmtzW2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBndWkuY29yZVBhdGNoKCkuZ2V0T3BCeUlkKGxpbmtzW2xdLm9iakluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcCkgY29uc29sZS5sb2coXCJvcCBub3QgZm91bmQhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGVyT3AgPSBndWkucGF0Y2hWaWV3LmdldFN1YlBhdGNoT3V0ZXJPcChvcC51aUF0dHJpYnMuc3ViUGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVyT3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Auc3RvcmFnZSA9IG9wLnN0b3JhZ2UgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Auc3RvcmFnZS5yZWYgPSBvcC5zdG9yYWdlLnJlZiB8fCBDQUJMRVMuc2hvcnRJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzW2xdLnJlZk9wID0gb3Auc3RvcmFnZS5yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3NbbF0uc3ViT3BSZWYgPSBvdXRlck9wLnN0b3JhZ2UucmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIGZvciAoY29uc3QgaSBpbiBqc29uLm9wcylcbiAgICB7XG4gICAgICAgIGNvbnN0IG9wID0ganNvbi5vcHNbaV07XG4gICAgICAgIGNvbnN0IG9sZElkID0gb3AuaWQ7XG4gICAgICAgIGxldCBuZXdJZCA9IENBQkxFUy5zaG9ydElkKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucHJlZml4SGFzaCkgbmV3SWQgPSBwcmVmaXhlZEhhc2gob3B0aW9ucy5wcmVmaXhIYXNoICsgb2xkSWQpO1xuXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucHJlZml4SWQpIG5ld0lkID0gb3B0aW9ucy5wcmVmaXhJZCArIG9sZElkO1xuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnJlZkFzSWQpIC8vIHdoZW4gc2F2aW5nIGpzb25cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKG9wLnN0b3JhZ2UgJiYgb3Auc3RvcmFnZS5yZWYpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3SWQgPSBvcC5zdG9yYWdlLnJlZjtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3Auc3RvcmFnZS5yZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3Auc3RvcmFnZSA9IG9wLnN0b3JhZ2UgfHwge307XG4gICAgICAgICAgICAgICAgb3Auc3RvcmFnZS5yZWYgPSBuZXdJZCA9IENBQkxFUy5zaG9ydElkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdJRCA9IG9wLmlkID0gbmV3SWQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub2xkSWRBc1JlZikgLy8gd2hlbiBsb2FkaW5nIGpzb25cbiAgICAgICAge1xuICAgICAgICAgICAgb3Auc3RvcmFnZSA9IG9wLnN0b3JhZ2UgfHwge307XG4gICAgICAgICAgICBvcC5zdG9yYWdlLnJlZiA9IG9sZElkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBqIGluIGpzb24ub3BzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNJbilcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ganNvbi5vcHNbal0ucG9ydHNJbilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS5wb3J0c0luW2tdLmxpbmtzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IGpzb24ub3BzW2pdLnBvcnRzSW5ba10ubGlua3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobC0tKSBpZiAoanNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rc1tsXSA9PT0gbnVsbCkganNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rcy5zcGxpY2UobCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCBpbiBqc29uLm9wc1tqXS5wb3J0c0luW2tdLmxpbmtzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS5wb3J0c0luW2tdLmxpbmtzW2xdLm9iakluID09PSBvbGRJZCkganNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rc1tsXS5vYmpJbiA9IG5ld0lEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS5wb3J0c0luW2tdLmxpbmtzW2xdLm9iak91dCA9PT0gb2xkSWQpIGpzb24ub3BzW2pdLnBvcnRzSW5ba10ubGlua3NbbF0ub2JqT3V0ID0gbmV3SUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS5wb3J0c091dClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ganNvbi5vcHNbal0ucG9ydHNPdXQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNPdXRba10ubGlua3MpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsID0ganNvbi5vcHNbal0ucG9ydHNPdXRba10ubGlua3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobC0tKSBpZiAoanNvbi5vcHNbal0ucG9ydHNPdXRba10ubGlua3NbbF0gPT09IG51bGwpIGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzLnNwbGljZShsLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsIGluIGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rc1tsXS5vYmpJbiA9PT0gb2xkSWQpIGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzW2xdLm9iakluID0gbmV3SUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzW2xdLm9iak91dCA9PT0gb2xkSWQpIGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzW2xdLm9iak91dCA9IG5ld0lEO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IGNvcnJlY3Qgc3VicGF0Y2hcbiAgICBjb25zdCBzdWJwYXRjaElkcyA9IFtdO1xuICAgIGNvbnN0IGZpeGVkU3ViUGF0Y2hlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLm9wcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGlmIChDQUJMRVMuT3AuaXNTdWJQYXRjaE9wTmFtZShqc29uLm9wc1tpXS5vYmpOYW1lKSlcbiAgICAgICAgaWYgKGpzb24ub3BzW2ldLnN0b3JhZ2UgJiYganNvbi5vcHNbaV0uc3RvcmFnZS5zdWJQYXRjaFZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGpzb24ub3BzW2ldLnBvcnRzSW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24ub3BzW2ldLnBvcnRzSW5ba10ubmFtZSA9PT0gXCJwYXRjaElkXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SWQgPSBzaG9ydElkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJlZml4SGFzaCkgbmV3SWQgPSBwcmVmaXhlZEhhc2gob3B0aW9ucy5wcmVmaXhIYXNoICsganNvbi5vcHNbaV0ucG9ydHNJbltrXS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkU3ViUGF0Y2hJZCA9IGpzb24ub3BzW2ldLnBvcnRzSW5ba10udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N1YlBhdGNoSWQgPSBqc29uLm9wc1tpXS5wb3J0c0luW2tdLnZhbHVlID0gbmV3SWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgc3VicGF0Y2hJZHMucHVzaChuZXdTdWJQYXRjaElkKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpzb24ub3BzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcCBoYXMgbm8gdWlBdHRyaWJzIGluIGV4cG9ydCwgd2UgZG9uJ3QgY2FyZSBhYm91dCBzdWJwYXRjaGVzIGluIGV4cG9ydCB0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS51aUF0dHJpYnMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24ub3BzW2pdLnVpQXR0cmlicy5zdWJQYXRjaCA9PT0gb2xkU3ViUGF0Y2hJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ub3BzW2pdLnVpQXR0cmlicy5zdWJQYXRjaCA9IG5ld1N1YlBhdGNoSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVkU3ViUGF0Y2hlcy5wdXNoKGpzb24ub3BzW2pdLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtrIGluIGpzb24ub3BzKVxuICAgIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZml4ZWRTdWJQYXRjaGVzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoanNvbi5vcHNba2tdLmlkID09PSBmaXhlZFN1YlBhdGNoZXNbal0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG9wIGhhcyBubyB1aUF0dHJpYnMgaW4gZXhwb3J0LCB3ZSBkb24ndCBjYXJlIGFib3V0IHN1YnBhdGNoZXMgaW4gZXhwb3J0IHRob3VnaFxuICAgICAgICBpZiAoIWZvdW5kICYmIGpzb24ub3BzW2trXS51aUF0dHJpYnMgJiYgb3B0aW9ucy5wYXJlbnRTdWJQYXRjaElkICE9IG51bGwpXG4gICAgICAgICAgICBqc29uLm9wc1tra10udWlBdHRyaWJzLnN1YlBhdGNoID0gb3B0aW9ucy5wYXJlbnRTdWJQYXRjaElkO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xufTtcblxuLyoqXG4gKiByZW1vdmUgYW4gZXZlbnRsaXN0ZW5lclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiByZW1vdmUgYW4gZXZlbnRsaXN0ZW5lclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBvcCBhZGRlZCB0byBwYXRjaCBldmVudFxuICogQGV2ZW50IG9uT3BBZGRcbiAqXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge09wfSBvcCBuZXcgb3BcbiAqL1xuXG4vKipcbiAqIG9wIGRlbGV0ZWQgZnJvbSBwYXRjaFxuICogQGV2ZW50IG9uT3BEZWxldGVcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T3B9IG9wIHRoYXQgd2lsbCBiZSBkZWxldGVkXG4gKi9cblxuLyoqXG4gKiBsaW5rIGV2ZW50IC0gdHdvIHBvcnRzIHdpbGwgYmUgbGlua2VkXG4gKiBAZXZlbnQgb25MaW5rXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1BvcnR9IHBvcnQxXG4gKiBAcHJvcGVydHkge1BvcnR9IHBvcnQyXG4gKi9cblxuLyoqXG4gKiB1bmxpbmsgZXZlbnQgLSBhIGxpbmsgd2FzIGRlbGV0ZWRcbiAqIEBldmVudCBvblVuTGlua1xuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbi8qKlxuICogdmFyaWFibGVzIGhhcyBiZWVuIGNoYW5nZWQgLyBhIHZhcmlhYmxlIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBwYXRjaFxuICogQGV2ZW50IHZhcmlhYmxlc0NoYW5nZWRcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7UG9ydH0gcG9ydDFcbiAqIEBwcm9wZXJ0eSB7UG9ydH0gcG9ydDJcbiAqL1xuXG4vKipcbiAqIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBsb2FkaW5nIGEgcGF0Y2hcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhdGNoQ29uZmlnXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3ByZWZpeEFzc2V0UGF0aD0nJ10gcHJlZml4IGZvciBwYXRoIHRvIGFzc2V0c1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFthc3NldFBhdGg9JyddIHBhdGggdG8gYXNzZXRzXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW2pzUGF0aD0nJ10gcGF0aCB0byBqYXZhc2NyaXB0IGZpbGVzXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW2dsQ2FudmFzSWQ9J2dsY2FudmFzJ10gZG9tIGVsZW1lbnQgaWQgb2YgY2FudmFzIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvbkVycm9yPW51bGxdIGNhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29uRmluaXNoZWRMb2FkaW5nPW51bGxdIGNhbGxlZCB3aGVuIHBhdGNoIGZpbmlzaGVkIGxvYWRpbmcgYWxsIGFzc2V0c1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29uRmlyc3RGcmFtZVJlbmRlcmVkPW51bGxdIGNhbGxlZCB3aGVuIHBhdGNoIHJlbmRlcmVkIGl0J3MgZmlyc3QgZnJhbWVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dsQ2FudmFzUmVzaXplVG9XaW5kb3c9ZmFsc2VdIHJlc2l6ZSBjYW52YXMgYXV0b21hdGljYWxseSB0byB3aW5kb3cgc2l6ZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9SZXF1ZXN0QW5pbWF0aW9uPXRydWVdIGRvIHJlcXVlc3RBbmltYXRpb25GcmFtZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciBleGVjKCkgZnJvbSBvdXRzaWRlIChvbmx5IGRvIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZylcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NsZWFyQ2FudmFzQ29sb3I9dHJ1ZV0gY2xlYXIgY2FudmFzIGluIHRyYW5zcGFyZW50IGNvbG9yIGV2ZXJ5IGZyYW1lXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjbGVhckNhbnZhc0RlcHRoPXRydWVdIGNsZWFyIGRlcHRoIGV2ZXJ5IGZyYW1lXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnbFZhbGlkYXRlU2hhZGVyPXRydWVdIGVuYWJsZS9kaXNhYmxlIHZhbGlkYXRpb24gb2Ygc2hhZGVycyAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2Zwc0xpbWl0PTBdIDAgZm9yIG1heGltdW0gcG9zc2libGUgZnJhbWVzIHBlciBzZWNvbmRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2xzbFByZWNpc2lvbj0nbWVkaXVtcCddIGRlZmF1bHQgcHJlY2lzaW9uIGZvciBnbHNsIHNoYWRlclxuICpcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBQYXRjaDtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_patch.js\n");

/***/ }),

/***/ "./src/core/core_port.js":
/*!*******************************!*\
  !*** ./src/core/core_port.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Port\": () => (/* binding */ Port)\n/* harmony export */ });\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _anim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./anim */ \"./src/core/anim.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core_logger */ \"./src/core/core_logger.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.js\");\n\n\n\n\n\n\n\n/**\n * data is coming into and out of ops through input and output ports\n * @external CABLES\n * @namespace Port\n * @class\n * @hideconstructor\n * @example\n * const myPort=op.inString(\"String Port\");\n */\nconst Port = function (___op, name, type, uiAttribs)\n{\n    _eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"core_port\");\n    /**\n     * @type {Number}\n     * @name direction\n     * @instance\n     * @memberof Port\n     * @description direction of port (input(0) or output(1))\n     */\n    this.direction = _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN;\n    this.id = String(CABLES.simpleId());\n    this._op = ___op;\n\n    /**\n     * @type {Array<Link>}\n     * @name links\n     * @instance\n     * @memberof Port\n     * @description links of port\n     */\n    this.links = [];\n    this.value = 0.0;\n    this.name = name;\n    this.type = type || _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE;\n    this.uiAttribs = uiAttribs || {};\n    this.anim = null;\n    this._oldAnimVal = -5711;\n    this.defaultValue = null;\n\n\n    this._uiActiveState = true;\n    this.ignoreValueSerialize = false;\n    this.onLinkChanged = null;\n    this.crashed = false;\n\n    this._valueBeforeLink = null;\n    this._lastAnimFrame = -1;\n    this._animated = false;\n\n    this.onValueChanged = null;\n    this.onTriggered = null;\n    this.onUiActiveStateChange = null;\n    this.changeAlways = false;\n    this.forceRefChange = false;\n\n    this._useVariableName = null;\n\n    this.activityCounter = 0;\n    this.apf = 0;\n    this.activityCounterStartFrame = 0;\n\n    this._tempLastUiValue = null;\n\n    Object.defineProperty(this, \"title\", {\n        get()\n        {\n            return this.uiAttribs.title || this.name;\n        } });\n\n\n    Object.defineProperty(this, \"parent\", {\n        get()\n        {\n            this._log.stack(\"use port.op, not .parent\");\n            return this._op;\n        } });\n\n\n\n    Object.defineProperty(this, \"op\", {\n        get()\n        {\n            return this._op;\n        } });\n\n\n    Object.defineProperty(this, \"val\", {\n        get()\n        {\n            this._log.warn(\"val getter deprecated!\", this);\n            this._log.stack(\"val getter deprecated\");\n            return this.get();\n        },\n        set(v)\n        {\n            this._log.warn(\"val setter deprecated!\", this);\n            this._log.stack(\"val setter deprecated\");\n            this.setValue(v);\n        }\n    });\n};\n\n\n/**\n * copy over a uiattrib from an external connected port to another port\n * @function copyLinkedUiAttrib\n * @memberof Port\n * @param {which} attrib name\n * @param {Port} source port\n * @instance\n * @example\n\ninArray.onLinkChanged=()=>\n{\n    if(inArray) inArray.copyLinkedUiAttrib(\"stride\", outArray);\n};\n\n */\nPort.prototype.copyLinkedUiAttrib = function (which, port)\n{\n    if (!CABLES.UI) return;\n    if (!this.isLinked()) return;\n\n    const attr = {};\n    attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);\n    port.setUiAttribs(attr);\n};\n\n\n// TODO make extend class for ports, like for ops only for ui\nPort.prototype.getValueForDisplay = function ()\n{\n    let str = this.value;\n\n    if (typeof this.value === \"string\" || this.value instanceof String)\n    {\n        if (str.length > 1000)\n        {\n            str = str.substring(0, 999);\n            str += \"...\";\n        }\n        if (this.uiAttribs && (this.uiAttribs.display == \"boolnum\"))\n        {\n            str += \" - \";\n\n            if (!this.value) str += \"false\";\n            else str += \"true\";\n        }\n\n        // str = str.replace(/(<([^>]+)>)/ig, \"\");\n\n        str = str.replace(/[\\u00A0-\\u9999<>\\&]/g, function (i)\n        {\n            return \"&#\" + i.charCodeAt(0) + \";\";\n        });\n\n\n        if (str.length > 100) str = str.substring(0, 100);\n    }\n    else\n    {\n        str = this.value;\n    }\n    return str;\n};\n\n/**\n * change listener for input value ports, overwrite to react to changes\n * @function onChange\n * @memberof Port\n * @instance\n * @example\n * const myPort=op.inString(\"MyPort\");\n * myPort.onChange=function()\n * {\n *   console.log(\"was changed to: \",myPort.get());\n * }\n *\n */\n\nPort.prototype.onAnimToggle = function () {};\nPort.prototype._onAnimToggle = function ()\n{\n    this.onAnimToggle();\n};\n\n\n/**\n * @function remove\n * @memberof Port\n * @instance\n * @description remove port\n */\nPort.prototype.remove = function ()\n{\n    // this.setUiAttribs({hidePort:true});\n    this.removeLinks();\n    this._op.removePort(this);\n};\n\n/**\n * set ui attributes\n * @function setUiAttribs\n * @memberof Port\n * @instance\n * @param {Object} newAttribs\n * <pre>\n * title - overwrite title of port (by default this is portname)\n * greyout - port paramater will appear greyed out, can not be\n * hidePort - port will be hidden from op\n * hideParam - port params will be hidden from parameter panel\n * showIndex - only for dropdowns - show value index (e.g. `0 - normal` )\n * editorSyntax - set syntax highlighting theme for editor port\n * ignoreObjTypeErrors - do not auto check object types\n * </pre>\n * @example\n * myPort.setUiAttribs({greyout:true});\n */\nPort.prototype.setUiAttribs = function (newAttribs)\n{\n    let changed = false;\n    if (!this.uiAttribs) this.uiAttribs = {};\n\n    for (const p in newAttribs)\n    {\n        if (this.uiAttribs[p] != newAttribs[p]) changed = true;\n        this.uiAttribs[p] = newAttribs[p];\n\n        if (p == \"group\" && this.indexPort) this.indexPort.setUiAttribs({ \"group\": newAttribs[p] });\n    }\n\n    if (newAttribs.hasOwnProperty(\"expose\")) this._op.patch.emitEvent(\"subpatchExpose\", this._op.uiAttribs.subPatch);\n\n    if (changed) this.emitEvent(\"onUiAttrChange\", newAttribs, this);\n};\n\n/**\n * get ui attributes\n * @function getUiAttribs\n * @memberof Port\n * @example\n * myPort.getUiAttribs();\n */\nPort.prototype.getUiAttribs = function ()\n{\n    return this.uiAttribs;\n};\n\n/**\n * get ui attribute\n * @function getUiAttrib\n * @memberof Port\n * @instance\n * @param {String} attribName\n * <pre>\n * attribName - return value of the ui-attribute, or null on unknown attribute\n * </pre>\n * @example\n * myPort.setUiAttribs(\"values\");\n */\nPort.prototype.getUiAttrib = function (attribName)\n{\n    if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName))\n    {\n        return null;\n    }\n    return this.uiAttribs[attribName];\n};\n\n/**\n * @function get\n * @memberof Port\n * @instance\n * @description get value of port\n */\nPort.prototype.get = function ()\n{\n    if (this._animated && this._lastAnimFrame != this._op.patch.getFrameNum())\n    {\n        this._lastAnimFrame = this._op.patch.getFrameNum();\n        this.value = this.anim.getValue(this._op.patch.timer.getTime());\n\n        this._oldAnimVal = this.value;\n        this.forceChange();\n    }\n\n    return this.value;\n};\n\nPort.prototype.setRef = function (v)\n{\n    this.forceRefChange = true;\n    this.set(v);\n};\n\n/**\n * @function setValue\n * @memberof Port\n * @instance\n * @description set value of port / will send value to all linked ports (only for output ports)\n */\nPort.prototype.set = Port.prototype.setValue = function (v)\n{\n    if (v === undefined) v = null;\n\n    if (this._op.enabled && !this.crashed)\n    {\n        if (v !== this.value || this.changeAlways || this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE || this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY)\n        {\n            if (this._animated)\n            {\n                this.anim.setValue(this._op.patch.timer.getTime(), v);\n            }\n            else\n            {\n                try\n                {\n                    this.value = v;\n                    this.forceChange();\n                }\n                catch (ex)\n                {\n                    this.crashed = true;\n                    this.op.crashed = true;\n                    console.log(\"crash\", this.op.objName);\n                    this.setValue = function (_v) {};\n                    this.onTriggered = function () {};\n\n                    this._log.error(\"onvaluechanged exception cought\", ex);\n                    this._log.error(ex.stack);\n                    this._log.warn(\"exception in: \" + this._op.name);\n\n                    if (this._op.patch.isEditorMode()) gui.showOpCrash(this._op);\n\n                    this._op.patch.emitEvent(\"exception\", ex, this._op);\n                    if (this._op.onError) this._op.onError(ex);\n                }\n\n                if (this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE) gui.texturePreview().updateTexturePort(this);\n            }\n\n            if (this.direction == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_OUT) for (let i = 0; i < this.links.length; ++i) this.links[i].setValue();\n        }\n    }\n};\n\nPort.prototype.updateAnim = function ()\n{\n    if (this._animated)\n    {\n        this.value = this.get();\n\n        if (this._oldAnimVal != this.value || this.changeAlways)\n        {\n            this._oldAnimVal = this.value;\n            this.forceChange();\n        }\n        this._oldAnimVal = this.value;\n    }\n};\n\nPort.args = function (func)\n{\n    return (func + \"\")\n        .replace(/[/][/].*$/gm, \"\") // strip single-line comments\n        .replace(/\\s+/g, \"\") // strip white space\n        .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments\n        .split(\"){\", 1)[0]\n        .replace(/^[^(]*[(]/, \"\") // extract the parameters\n        .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n        .split(\",\")\n        .filter(Boolean); // split & filter [\"\"]\n};\n\nPort.prototype.forceChange = function ()\n{\n    if (this.onValueChanged || this.onChange)\n    {\n        // very temporary: deprecated warning!!!!!!!!!\n        // var params=Port.args(this.onValueChanged||this.onChange)\n        // if(params.length>0) this._log.warn('TOM: port has onchange params!',this._op.objName,this.name);\n    }\n    this._activity();\n    this.emitEvent(\"change\", this.value, this);\n\n    if (this.onChange) this.onChange(this, this.value);\n    else if (this.onValueChanged) this.onValueChanged(this, this.value); // deprecated\n};\n\n/**\n * @function getTypeString\n * @memberof Port\n * @instance\n * @description get port type as string, e.g. \"Function\",\"Value\"...\n * @return {String} type\n */\nPort.prototype.getTypeString = function ()\n{\n    if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE) return \"Number\";\n    if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return \"Trigger\";\n    if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return \"Object\";\n    if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return \"Dynamic\";\n    if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return \"Array\";\n    if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING) return \"String\";\n    return \"Unknown\";\n};\n\nPort.prototype.deSerializeSettings = function (objPort)\n{\n    if (!objPort) return;\n    if (objPort.animated) this.setAnimated(objPort.animated);\n    if (objPort.useVariable) this.setVariableName(objPort.useVariable);\n    if (objPort.title) this.setUiAttribs({ \"title\": objPort.title });\n    if (objPort.expose) this.setUiAttribs({ \"expose\": true });\n    if (objPort.order) this.setUiAttribs({ \"order\": objPort.order });\n    if (objPort.anim)\n    {\n        if (!this.anim) this.anim = new _anim__WEBPACK_IMPORTED_MODULE_1__.Anim({ \"name\": \"port \" + this.name });\n        this._op._hasAnimPort = true;\n        this.anim.addEventListener(\"onChange\", () =>\n        {\n            this._op.patch.emitEvent(\"portAnimUpdated\", this._op, this, this.anim);\n        });\n        if (objPort.anim.loop) this.anim.loop = objPort.anim.loop;\n        for (const ani in objPort.anim.keys)\n        {\n            this.anim.keys.push(new _anim__WEBPACK_IMPORTED_MODULE_1__.ANIM.Key(objPort.anim.keys[ani]));\n        }\n        this.anim.sortKeys();\n    }\n};\n\nPort.prototype.getSerialized = function ()\n{\n    let obj = {};\n    obj.name = this.getName();\n\n    if (!this.ignoreValueSerialize && this.links.length === 0)\n    {\n        if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT && this.value && this.value.tex)\n        {\n        }\n        else obj.value = this.value;\n    }\n    if (this._useVariableName) obj.useVariable = this._useVariableName;\n    if (this._animated) obj.animated = true;\n    if (this.anim) obj.anim = this.anim.getSerialized();\n    if (this.uiAttribs.display == \"file\") obj.display = this.uiAttribs.display;\n    if (this.uiAttribs.expose)\n    {\n        obj.expose = true;\n        if (this.uiAttribs.hasOwnProperty(\"order\")) obj.order = this.uiAttribs.order;\n    }\n    if (this.uiAttribs.title) obj.title = this.uiAttribs.title;\n    if (this.direction == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_OUT && this.links.length > 0)\n    {\n        obj.links = [];\n        for (const i in this.links)\n        {\n            if (!this.links[i].ignoreInSerialize && (this.links[i].portIn && this.links[i].portOut)) obj.links.push(this.links[i].getSerialized());\n        }\n    }\n\n    if (this.direction == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN && this.links.length > 0)\n    {\n        for (const i in this.links)\n        {\n            if (!this.links[i].portIn || !this.links[i].portOut) continue;\n\n            const otherp = this.links[i].getOtherPort(this);\n            if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2())\n            {\n                obj.links = obj.links || [];\n                obj.links.push(this.links[i].getSerialized());\n            }\n        }\n    }\n\n    if (obj.links && obj.links.length == 0) delete obj.links;\n    if (this.type === _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) delete obj.value;\n    if (this.type === _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION && this.links.length == 0) obj = null;\n    if (obj && Object.keys(obj).length == 1 && obj.name)obj = null;\n    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.cleanJson)(obj);\n\n    return obj;\n};\n\nPort.prototype.shouldLink = function ()\n{\n    return true;\n};\n\n/**\n * @function removeLinks\n * @memberof Port\n * @instance\n * @description remove all links from port\n */\nPort.prototype.removeLinks = function ()\n{\n    let count = 0;\n    while (this.links.length > 0)\n    {\n        count++;\n        if (count > 5000)\n        {\n            this._log.warn(\"could not delete links... / infinite loop\");\n            this.links.length = 0;\n            break;\n        }\n        this.links[0].remove();\n    }\n};\n\n/**\n * @function removeLink\n * @memberof Port\n * @instance\n * @description remove all link from port\n * @param {CABLES.Link} link\n */\nPort.prototype.removeLink = function (link)\n{\n    for (const i in this.links)\n        if (this.links[i] == link)\n            this.links.splice(i, 1);\n\n    if (this.direction == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN)\n    {\n        if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE) this.setValue(this._valueBeforeLink || 0);\n        else this.setValue(this._valueBeforeLink || null);\n    }\n\n    if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();\n\n    if (this.onLinkChanged) this.onLinkChanged();\n    this.emitEvent(\"onLinkChanged\");\n    this._op.emitEvent(\"onLinkChanged\");\n};\n\n/**\n * @function getName\n * @memberof Port\n * @instance\n * @description return port name\n */\nPort.prototype.getName = function ()\n{\n    return this.name;\n};\n\n/**\n * @function getTitle\n * @memberof Port\n * @instance\n * @description return port name or title\n */\nPort.prototype.getTitle = function ()\n{\n    if (this.uiAttribs.title) return this.uiAttribs.title;\n    return this.name;\n};\n\nPort.prototype.addLink = function (l)\n{\n    this._valueBeforeLink = this.value;\n    this.links.push(l);\n    if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();\n\n    if (this.onLinkChanged) this.onLinkChanged();\n    this.emitEvent(\"onLinkChanged\");\n    this._op.emitEvent(\"onLinkChanged\");\n};\n\n/**\n * @function getLinkTo\n * @memberof Port\n * @instance\n * @param {Port} otherPort\n * @description return link, which is linked to otherPort\n */\nPort.prototype.getLinkTo = function (p2)\n{\n    for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return this.links[i];\n};\n\n/**\n * @function removeLinkTo\n * @memberof Port\n * @instance\n * @param {Port} otherPort\n * @description removes link, which is linked to otherPort\n */\nPort.prototype.removeLinkTo = function (p2)\n{\n    for (const i in this.links)\n    {\n        if (this.links[i].portIn == p2 || this.links[i].portOut == p2)\n        {\n            this.links[i].remove();\n            if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();\n\n            if (this.onLinkChanged) this.onLinkChanged();\n            this.emitEvent(\"onLinkChanged\");\n            return;\n        }\n    }\n};\n\n/**\n * @function isLinkedTo\n * @memberof Port\n * @instance\n * @param {Port} otherPort\n * @description returns true if port is linked to otherPort\n */\nPort.prototype.isLinkedTo = function (p2)\n{\n    for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return true;\n\n    return false;\n};\n\nPort.prototype._activity = function ()\n{\n    this.activityCounter++;\n};\n\n/**\n * @function trigger\n * @memberof Port\n * @instance\n * @description trigger the linked port (usually invoked on an output function port)\n */\nPort.prototype.trigger = function ()\n{\n    const linksLength = this.links.length;\n\n    this._activity();\n    if (linksLength === 0) return;\n    if (!this._op.enabled) return;\n\n    let portTriggered = null;\n    try\n    {\n        for (let i = 0; i < linksLength; ++i)\n        {\n            if (this.links[i].portIn)\n            {\n                portTriggered = this.links[i].portIn;\n\n                portTriggered.op.patch.pushTriggerStack(portTriggered);\n                portTriggered._onTriggered();\n\n                portTriggered.op.patch.popTriggerStack();\n            }\n            if (this.links[i]) this.links[i].activity();\n        }\n    }\n    catch (ex)\n    {\n        portTriggered.op.enabled = false;\n\n        if (this._op.patch.isEditorMode())\n        {\n            this._op.patch.emitEvent(\"exception\", ex, portTriggered.op);\n            this._op.patch.emitEvent(\"opcrash\", portTriggered);\n            console.log(\"crash\", portTriggered.op.objName);\n\n            if (portTriggered.op.onError) portTriggered.op.onError(ex);\n        }\n        this._log.warn(\"exception!\");\n        this._log.error(\"ontriggered exception caught\", ex);\n        this._log.error(ex.stack);\n        this._log.warn(\"exception in: \" + portTriggered.op.name);\n    }\n};\n\nPort.prototype.call = function ()\n{\n    this._log.warn(\"call deprecated - use trigger() \");\n    this.trigger();\n};\n\nPort.prototype.execute = function ()\n{\n    this._log.warn(\"### execute port: \" + this.getName(), this.goals.length);\n};\n\nPort.prototype.setVariableName = function (n)\n{\n    this._useVariableName = n;\n\n\n    this._op.patch.on(\"variableRename\", (oldname, newname) =>\n    {\n        if (oldname != this._useVariableName) return;\n        this._useVariableName = newname;\n    });\n};\n\nPort.prototype.getVariableName = function ()\n{\n    return this._useVariableName;\n};\n\nPort.prototype.setVariable = function (v)\n{\n    this.setAnimated(false);\n    const attr = { \"useVariable\": false };\n\n    if (this._variableIn && this._varChangeListenerId)\n    {\n        this._variableIn.off(this._varChangeListenerId);\n        this._variableIn = null;\n    }\n\n    if (v)\n    {\n        this._variableIn = this._op.patch.getVar(v);\n\n        if (!this._variableIn)\n        {\n            this._log.warn(\"PORT VAR NOT FOUND!!!\", v);\n        }\n        else\n        {\n            if (this.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT)\n            {\n                this._varChangeListenerId = this._variableIn.on(\"change\", () => { this.set(null); this.set(this._variableIn.getValue()); });\n            }\n            else\n            {\n                this._varChangeListenerId = this._variableIn.on(\"change\", this.set.bind(this));\n            }\n            this.set(this._variableIn.getValue());\n        }\n        this._useVariableName = v;\n        attr.useVariable = true;\n        attr.variableName = this._useVariableName;\n    }\n    else\n    {\n        attr.variableName = this._useVariableName = null;\n        attr.useVariable = false;\n    }\n\n    this.setUiAttribs(attr);\n    this._op.patch.emitEvent(\"portSetVariable\", this._op, this, v);\n};\n\nPort.prototype._handleNoTriggerOpAnimUpdates = function (a)\n{\n    let hasTriggerPort = false;\n    for (let i = 0; i < this._op.portsIn.length; i++)\n    {\n        if (this._op.portsIn.type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n        {\n            hasTriggerPort = true;\n            break;\n        }\n    }\n\n    if (!hasTriggerPort)\n    {\n        if (a) this._notriggerAnimUpdate = this._op.patch.on(\"onRenderFrame\",\n            () =>\n            {\n                this.updateAnim();\n            });\n        else this._op.patch.removeEventListener(this._notriggerAnimUpdate);\n    }\n};\n\nPort.prototype.setAnimated = function (a)\n{\n    if (this._animated != a)\n    {\n        this._animated = a;\n        this._op._hasAnimPort = true;\n\n        if (this._animated && !this.anim)\n        {\n            this.anim = new _anim__WEBPACK_IMPORTED_MODULE_1__.Anim({ \"name\": \"port \" + this.name });\n            this.anim.addEventListener(\"onChange\", () =>\n            {\n                this._op.patch.emitEvent(\"portAnimUpdated\", this._op, this, this.anim);\n            });\n        }\n        this._onAnimToggle();\n    }\n\n    this._handleNoTriggerOpAnimUpdates(a);\n    if (!a)\n    {\n        this.anim = null;\n    }\n\n    this.setUiAttribs({ \"isAnimated\": this._animated });\n};\n\nPort.prototype.toggleAnim = function ()\n{\n    this._animated = !this._animated;\n    if (this._animated && !this.anim)\n    {\n        this.anim = new _anim__WEBPACK_IMPORTED_MODULE_1__.Anim({ \"name\": \"port \" + this.name });\n        this.anim.addEventListener(\"onChange\", () =>\n        {\n            this._op.patch.emitEvent(\"portAnimUpdated\", this._op, this, this.anim);\n        });\n    }\n    this.setAnimated(this._animated);\n    this._onAnimToggle();\n    this.setUiAttribs({ \"isAnimated\": this._animated });\n};\n\n/**\n * <pre>\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_VALUE = 0;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION = 1;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT = 2;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE = 2;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_ARRAY = 3;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC = 4;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_STRING = 5;\n * </pre>\n * @function getType\n * @memberof Port\n * @instance\n * @return {Number} type of port\n */\nPort.prototype.getType = function ()\n{\n    return this.type;\n};\n\n/**\n * @function isLinked\n * @memberof Port\n * @instance\n * @return {Boolean} true if port is linked\n */\nPort.prototype.isLinked = function ()\n{\n    return this.links.length > 0 || this._animated || this._useVariableName != null;\n};\n\nPort.prototype.isBoundToVar = function ()\n{\n    const b = this._useVariableName != null;\n    this.uiAttribs.boundToVar = b;\n    return b;\n};\n/**\n * @function isAnimated\n * @memberof Port\n * @instance\n * @return {Boolean} true if port is animated\n */\nPort.prototype.isAnimated = function ()\n{\n    return this._animated;\n};\n\n/**\n * @function isHidden\n * @memberof Port\n * @instance\n * @return {Boolean} true if port is hidden\n */\nPort.prototype.isHidden = function ()\n{\n    return this.uiAttribs.hidePort;\n};\n\n/**\n * @function onTriggered\n * @memberof Port\n * @instance\n * @param {onTriggeredCallback} callback\n * @description set callback, which will be executed when port was triggered (usually output port)\n */\nPort.prototype._onTriggered = function (a)\n{\n    this._activity();\n    this._op.updateAnims();\n    if (this._op.enabled && this.onTriggered) this.onTriggered(a);\n};\n\nPort.prototype._onSetProfiling = function (v)\n{\n    this._op.patch.profiler.add(\"port\", this);\n    this.setValue(v);\n    // if (this._op.enabled && this.onTriggered) this.onTriggered();\n    this._op.patch.profiler.add(\"port\", null);\n};\n\nPort.prototype._onTriggeredProfiling = function ()\n{\n    // this._op.updateAnims();\n\n    if (this._op.enabled && this.onTriggered)\n    {\n        this._op.patch.profiler.add(\"port\", this);\n        this.onTriggered();\n        this._op.patch.profiler.add(\"port\", null);\n    }\n};\n\nPort.prototype.onValueChange = function (cb)\n{\n    // deprecated\n    this.onChange = cb;\n};\n\nPort.prototype.getUiActiveState = function ()\n{\n    return this._uiActiveState;\n};\n\nPort.prototype.setUiActiveState = function (onoff)\n{\n    this._uiActiveState = onoff;\n    if (this.onUiActiveStateChange) this.onUiActiveStateChange();\n};\n\nPort.prototype.hidePort = function ()\n{\n    this._log.warn(\"op.hideport() is deprecated, do not use it!\");\n};\n\n\n/**\n * Returns the port type string, e.g. \"value\" based on the port type number\n * @function portTypeNumberToString\n * @instance\n * @memberof Port\n * @param {Number} type - The port type number\n * @returns {String} - The port type as string\n */\nPort.portTypeNumberToString = function (type)\n{\n    if (type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE) return \"value\";\n    if (type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return \"function\";\n    if (type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return \"object\";\n    if (type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return \"array\";\n    if (type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING) return \"string\";\n    if (type == _constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return \"dynamic\";\n    return \"unknown\";\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BvcnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9wb3J0LmpzPzgwNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudHRhcmdldFwiO1xuaW1wb3J0IHsgQW5pbSwgQU5JTSB9IGZyb20gXCIuL2FuaW1cIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi9jb3JlX2xvZ2dlclwiO1xuaW1wb3J0IHsgY2xlYW5Kc29uIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuXG4vKipcbiAqIGRhdGEgaXMgY29taW5nIGludG8gYW5kIG91dCBvZiBvcHMgdGhyb3VnaCBpbnB1dCBhbmQgb3V0cHV0IHBvcnRzXG4gKiBAZXh0ZXJuYWwgQ0FCTEVTXG4gKiBAbmFtZXNwYWNlIFBvcnRcbiAqIEBjbGFzc1xuICogQGhpZGVjb25zdHJ1Y3RvclxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG15UG9ydD1vcC5pblN0cmluZyhcIlN0cmluZyBQb3J0XCIpO1xuICovXG5jb25zdCBQb3J0ID0gZnVuY3Rpb24gKF9fX29wLCBuYW1lLCB0eXBlLCB1aUF0dHJpYnMpXG57XG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLmRhdGEgPSB7fTsgLy8gVU5VU0VELCBERVBSRUNBVEVELCBvbmx5IGxlZnQgaW4gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdXNlcm9wc1xuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjb3JlX3BvcnRcIik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBkaXJlY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9ydFxuICAgICAqIEBkZXNjcmlwdGlvbiBkaXJlY3Rpb24gb2YgcG9ydCAoaW5wdXQoMCkgb3Igb3V0cHV0KDEpKVxuICAgICAqL1xuICAgIHRoaXMuZGlyZWN0aW9uID0gQ09OU1RBTlRTLlBPUlQuUE9SVF9ESVJfSU47XG4gICAgdGhpcy5pZCA9IFN0cmluZyhDQUJMRVMuc2ltcGxlSWQoKSk7XG4gICAgdGhpcy5fb3AgPSBfX19vcDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxMaW5rPn1cbiAgICAgKiBAbmFtZSBsaW5rc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBQb3J0XG4gICAgICogQGRlc2NyaXB0aW9uIGxpbmtzIG9mIHBvcnRcbiAgICAgKi9cbiAgICB0aGlzLmxpbmtzID0gW107XG4gICAgdGhpcy52YWx1ZSA9IDAuMDtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRTtcbiAgICB0aGlzLnVpQXR0cmlicyA9IHVpQXR0cmlicyB8fCB7fTtcbiAgICB0aGlzLmFuaW0gPSBudWxsO1xuICAgIHRoaXMuX29sZEFuaW1WYWwgPSAtNTcxMTtcbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cblxuICAgIHRoaXMuX3VpQWN0aXZlU3RhdGUgPSB0cnVlO1xuICAgIHRoaXMuaWdub3JlVmFsdWVTZXJpYWxpemUgPSBmYWxzZTtcbiAgICB0aGlzLm9uTGlua0NoYW5nZWQgPSBudWxsO1xuICAgIHRoaXMuY3Jhc2hlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdmFsdWVCZWZvcmVMaW5rID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0QW5pbUZyYW1lID0gLTE7XG4gICAgdGhpcy5fYW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMub25WYWx1ZUNoYW5nZWQgPSBudWxsO1xuICAgIHRoaXMub25UcmlnZ2VyZWQgPSBudWxsO1xuICAgIHRoaXMub25VaUFjdGl2ZVN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLmNoYW5nZUFsd2F5cyA9IGZhbHNlO1xuICAgIHRoaXMuZm9yY2VSZWZDaGFuZ2UgPSBmYWxzZTtcblxuICAgIHRoaXMuX3VzZVZhcmlhYmxlTmFtZSA9IG51bGw7XG5cbiAgICB0aGlzLmFjdGl2aXR5Q291bnRlciA9IDA7XG4gICAgdGhpcy5hcGYgPSAwO1xuICAgIHRoaXMuYWN0aXZpdHlDb3VudGVyU3RhcnRGcmFtZSA9IDA7XG5cbiAgICB0aGlzLl90ZW1wTGFzdFVpVmFsdWUgPSBudWxsO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGl0bGVcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51aUF0dHJpYnMudGl0bGUgfHwgdGhpcy5uYW1lO1xuICAgICAgICB9IH0pO1xuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuc3RhY2soXCJ1c2UgcG9ydC5vcCwgbm90IC5wYXJlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3A7XG4gICAgICAgIH0gfSk7XG5cblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3A7XG4gICAgICAgIH0gfSk7XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbFwiLCB7XG4gICAgICAgIGdldCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwidmFsIGdldHRlciBkZXByZWNhdGVkIVwiLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5zdGFjayhcInZhbCBnZXR0ZXIgZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJ2YWwgc2V0dGVyIGRlcHJlY2F0ZWQhXCIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwidmFsIHNldHRlciBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIGNvcHkgb3ZlciBhIHVpYXR0cmliIGZyb20gYW4gZXh0ZXJuYWwgY29ubmVjdGVkIHBvcnQgdG8gYW5vdGhlciBwb3J0XG4gKiBAZnVuY3Rpb24gY29weUxpbmtlZFVpQXR0cmliXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQHBhcmFtIHt3aGljaH0gYXR0cmliIG5hbWVcbiAqIEBwYXJhbSB7UG9ydH0gc291cmNlIHBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGV4YW1wbGVcblxuaW5BcnJheS5vbkxpbmtDaGFuZ2VkPSgpPT5cbntcbiAgICBpZihpbkFycmF5KSBpbkFycmF5LmNvcHlMaW5rZWRVaUF0dHJpYihcInN0cmlkZVwiLCBvdXRBcnJheSk7XG59O1xuXG4gKi9cblBvcnQucHJvdG90eXBlLmNvcHlMaW5rZWRVaUF0dHJpYiA9IGZ1bmN0aW9uICh3aGljaCwgcG9ydClcbntcbiAgICBpZiAoIUNBQkxFUy5VSSkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5pc0xpbmtlZCgpKSByZXR1cm47XG5cbiAgICBjb25zdCBhdHRyID0ge307XG4gICAgYXR0clt3aGljaF0gPSB0aGlzLmxpbmtzWzBdLmdldE90aGVyUG9ydCh0aGlzKS5nZXRVaUF0dHJpYih3aGljaCk7XG4gICAgcG9ydC5zZXRVaUF0dHJpYnMoYXR0cik7XG59O1xuXG5cbi8vIFRPRE8gbWFrZSBleHRlbmQgY2xhc3MgZm9yIHBvcnRzLCBsaWtlIGZvciBvcHMgb25seSBmb3IgdWlcblBvcnQucHJvdG90eXBlLmdldFZhbHVlRm9yRGlzcGxheSA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IHN0ciA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdGhpcy52YWx1ZSBpbnN0YW5jZW9mIFN0cmluZylcbiAgICB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMTAwMClcbiAgICAgICAge1xuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCA5OTkpO1xuICAgICAgICAgICAgc3RyICs9IFwiLi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudWlBdHRyaWJzICYmICh0aGlzLnVpQXR0cmlicy5kaXNwbGF5ID09IFwiYm9vbG51bVwiKSlcbiAgICAgICAge1xuICAgICAgICAgICAgc3RyICs9IFwiIC0gXCI7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy52YWx1ZSkgc3RyICs9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGVsc2Ugc3RyICs9IFwidHJ1ZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RyID0gc3RyLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCBcIlwiKTtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcdTAwQTAtXFx1OTk5OTw+XFwmXS9nLCBmdW5jdGlvbiAoaSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFwiJiNcIiArIGkuY2hhckNvZGVBdCgwKSArIFwiO1wiO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMTAwKSBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIDEwMCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHN0ciA9IHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIGNoYW5nZSBsaXN0ZW5lciBmb3IgaW5wdXQgdmFsdWUgcG9ydHMsIG92ZXJ3cml0ZSB0byByZWFjdCB0byBjaGFuZ2VzXG4gKiBAZnVuY3Rpb24gb25DaGFuZ2VcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBteVBvcnQ9b3AuaW5TdHJpbmcoXCJNeVBvcnRcIik7XG4gKiBteVBvcnQub25DaGFuZ2U9ZnVuY3Rpb24oKVxuICoge1xuICogICBjb25zb2xlLmxvZyhcIndhcyBjaGFuZ2VkIHRvOiBcIixteVBvcnQuZ2V0KCkpO1xuICogfVxuICpcbiAqL1xuXG5Qb3J0LnByb3RvdHlwZS5vbkFuaW1Ub2dnbGUgPSBmdW5jdGlvbiAoKSB7fTtcblBvcnQucHJvdG90eXBlLl9vbkFuaW1Ub2dnbGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMub25BbmltVG9nZ2xlKCk7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZVxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJlbW92ZSBwb3J0XG4gKi9cblBvcnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gdGhpcy5zZXRVaUF0dHJpYnMoe2hpZGVQb3J0OnRydWV9KTtcbiAgICB0aGlzLnJlbW92ZUxpbmtzKCk7XG4gICAgdGhpcy5fb3AucmVtb3ZlUG9ydCh0aGlzKTtcbn07XG5cbi8qKlxuICogc2V0IHVpIGF0dHJpYnV0ZXNcbiAqIEBmdW5jdGlvbiBzZXRVaUF0dHJpYnNcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdBdHRyaWJzXG4gKiA8cHJlPlxuICogdGl0bGUgLSBvdmVyd3JpdGUgdGl0bGUgb2YgcG9ydCAoYnkgZGVmYXVsdCB0aGlzIGlzIHBvcnRuYW1lKVxuICogZ3JleW91dCAtIHBvcnQgcGFyYW1hdGVyIHdpbGwgYXBwZWFyIGdyZXllZCBvdXQsIGNhbiBub3QgYmVcbiAqIGhpZGVQb3J0IC0gcG9ydCB3aWxsIGJlIGhpZGRlbiBmcm9tIG9wXG4gKiBoaWRlUGFyYW0gLSBwb3J0IHBhcmFtcyB3aWxsIGJlIGhpZGRlbiBmcm9tIHBhcmFtZXRlciBwYW5lbFxuICogc2hvd0luZGV4IC0gb25seSBmb3IgZHJvcGRvd25zIC0gc2hvdyB2YWx1ZSBpbmRleCAoZS5nLiBgMCAtIG5vcm1hbGAgKVxuICogZWRpdG9yU3ludGF4IC0gc2V0IHN5bnRheCBoaWdobGlnaHRpbmcgdGhlbWUgZm9yIGVkaXRvciBwb3J0XG4gKiBpZ25vcmVPYmpUeXBlRXJyb3JzIC0gZG8gbm90IGF1dG8gY2hlY2sgb2JqZWN0IHR5cGVzXG4gKiA8L3ByZT5cbiAqIEBleGFtcGxlXG4gKiBteVBvcnQuc2V0VWlBdHRyaWJzKHtncmV5b3V0OnRydWV9KTtcbiAqL1xuUG9ydC5wcm90b3R5cGUuc2V0VWlBdHRyaWJzID0gZnVuY3Rpb24gKG5ld0F0dHJpYnMpXG57XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMudWlBdHRyaWJzKSB0aGlzLnVpQXR0cmlicyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBwIGluIG5ld0F0dHJpYnMpXG4gICAge1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnNbcF0gIT0gbmV3QXR0cmlic1twXSkgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudWlBdHRyaWJzW3BdID0gbmV3QXR0cmlic1twXTtcblxuICAgICAgICBpZiAocCA9PSBcImdyb3VwXCIgJiYgdGhpcy5pbmRleFBvcnQpIHRoaXMuaW5kZXhQb3J0LnNldFVpQXR0cmlicyh7IFwiZ3JvdXBcIjogbmV3QXR0cmlic1twXSB9KTtcbiAgICB9XG5cbiAgICBpZiAobmV3QXR0cmlicy5oYXNPd25Qcm9wZXJ0eShcImV4cG9zZVwiKSkgdGhpcy5fb3AucGF0Y2guZW1pdEV2ZW50KFwic3VicGF0Y2hFeHBvc2VcIiwgdGhpcy5fb3AudWlBdHRyaWJzLnN1YlBhdGNoKTtcblxuICAgIGlmIChjaGFuZ2VkKSB0aGlzLmVtaXRFdmVudChcIm9uVWlBdHRyQ2hhbmdlXCIsIG5ld0F0dHJpYnMsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBnZXQgdWkgYXR0cmlidXRlc1xuICogQGZ1bmN0aW9uIGdldFVpQXR0cmlic1xuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBleGFtcGxlXG4gKiBteVBvcnQuZ2V0VWlBdHRyaWJzKCk7XG4gKi9cblBvcnQucHJvdG90eXBlLmdldFVpQXR0cmlicyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMudWlBdHRyaWJzO1xufTtcblxuLyoqXG4gKiBnZXQgdWkgYXR0cmlidXRlXG4gKiBAZnVuY3Rpb24gZ2V0VWlBdHRyaWJcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJOYW1lXG4gKiA8cHJlPlxuICogYXR0cmliTmFtZSAtIHJldHVybiB2YWx1ZSBvZiB0aGUgdWktYXR0cmlidXRlLCBvciBudWxsIG9uIHVua25vd24gYXR0cmlidXRlXG4gKiA8L3ByZT5cbiAqIEBleGFtcGxlXG4gKiBteVBvcnQuc2V0VWlBdHRyaWJzKFwidmFsdWVzXCIpO1xuICovXG5Qb3J0LnByb3RvdHlwZS5nZXRVaUF0dHJpYiA9IGZ1bmN0aW9uIChhdHRyaWJOYW1lKVxue1xuICAgIGlmICghdGhpcy51aUF0dHJpYnMgfHwgIXRoaXMudWlBdHRyaWJzLmhhc093blByb3BlcnR5KGF0dHJpYk5hbWUpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpQXR0cmlic1thdHRyaWJOYW1lXTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldFxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGdldCB2YWx1ZSBvZiBwb3J0XG4gKi9cblBvcnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVkICYmIHRoaXMuX2xhc3RBbmltRnJhbWUgIT0gdGhpcy5fb3AucGF0Y2guZ2V0RnJhbWVOdW0oKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xhc3RBbmltRnJhbWUgPSB0aGlzLl9vcC5wYXRjaC5nZXRGcmFtZU51bSgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5hbmltLmdldFZhbHVlKHRoaXMuX29wLnBhdGNoLnRpbWVyLmdldFRpbWUoKSk7XG5cbiAgICAgICAgdGhpcy5fb2xkQW5pbVZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMuZm9yY2VDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblBvcnQucHJvdG90eXBlLnNldFJlZiA9IGZ1bmN0aW9uICh2KVxue1xuICAgIHRoaXMuZm9yY2VSZWZDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuc2V0KHYpO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0VmFsdWVcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiBzZXQgdmFsdWUgb2YgcG9ydCAvIHdpbGwgc2VuZCB2YWx1ZSB0byBhbGwgbGlua2VkIHBvcnRzIChvbmx5IGZvciBvdXRwdXQgcG9ydHMpXG4gKi9cblBvcnQucHJvdG90eXBlLnNldCA9IFBvcnQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpXG57XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fb3AuZW5hYmxlZCAmJiAhdGhpcy5jcmFzaGVkKVxuICAgIHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMudmFsdWUgfHwgdGhpcy5jaGFuZ2VBbHdheXMgfHwgdGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVEVYVFVSRSB8fCB0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9BUlJBWSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbS5zZXRWYWx1ZSh0aGlzLl9vcC5wYXRjaC50aW1lci5nZXRUaW1lKCksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcC5jcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjcmFzaFwiLCB0aGlzLm9wLm9iak5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gKF92KSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRyaWdnZXJlZCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIm9udmFsdWVjaGFuZ2VkIGV4Y2VwdGlvbiBjb3VnaHRcIiwgZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoZXguc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybihcImV4Y2VwdGlvbiBpbjogXCIgKyB0aGlzLl9vcC5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3AucGF0Y2guaXNFZGl0b3JNb2RlKCkpIGd1aS5zaG93T3BDcmFzaCh0aGlzLl9vcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3AucGF0Y2guZW1pdEV2ZW50KFwiZXhjZXB0aW9uXCIsIGV4LCB0aGlzLl9vcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcC5vbkVycm9yKSB0aGlzLl9vcC5vbkVycm9yKGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3AgJiYgdGhpcy5fb3AucGF0Y2ggJiYgdGhpcy5fb3AucGF0Y2guaXNFZGl0b3JNb2RlKCkgJiYgdGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVEVYVFVSRSkgZ3VpLnRleHR1cmVQcmV2aWV3KCkudXBkYXRlVGV4dHVyZVBvcnQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9PVVQpIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saW5rcy5sZW5ndGg7ICsraSkgdGhpcy5saW5rc1tpXS5zZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUG9ydC5wcm90b3R5cGUudXBkYXRlQW5pbSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX29sZEFuaW1WYWwgIT0gdGhpcy52YWx1ZSB8fCB0aGlzLmNoYW5nZUFsd2F5cylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkQW5pbVZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcmNlQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2xkQW5pbVZhbCA9IHRoaXMudmFsdWU7XG4gICAgfVxufTtcblxuUG9ydC5hcmdzID0gZnVuY3Rpb24gKGZ1bmMpXG57XG4gICAgcmV0dXJuIChmdW5jICsgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL1svXVsvXS4qJC9nbSwgXCJcIikgLy8gc3RyaXAgc2luZ2xlLWxpbmUgY29tbWVudHNcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgXCJcIikgLy8gc3RyaXAgd2hpdGUgc3BhY2VcbiAgICAgICAgLnJlcGxhY2UoL1svXVsqXVteLypdKlsqXVsvXS9nLCBcIlwiKSAvLyBzdHJpcCBtdWx0aS1saW5lIGNvbW1lbnRzXG4gICAgICAgIC5zcGxpdChcIil7XCIsIDEpWzBdXG4gICAgICAgIC5yZXBsYWNlKC9eW14oXSpbKF0vLCBcIlwiKSAvLyBleHRyYWN0IHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIC5yZXBsYWNlKC89W14sXSsvZywgXCJcIikgLy8gc3RyaXAgYW55IEVTNiBkZWZhdWx0c1xuICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7IC8vIHNwbGl0ICYgZmlsdGVyIFtcIlwiXVxufTtcblxuUG9ydC5wcm90b3R5cGUuZm9yY2VDaGFuZ2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLm9uVmFsdWVDaGFuZ2VkIHx8IHRoaXMub25DaGFuZ2UpXG4gICAge1xuICAgICAgICAvLyB2ZXJ5IHRlbXBvcmFyeTogZGVwcmVjYXRlZCB3YXJuaW5nISEhISEhISEhXG4gICAgICAgIC8vIHZhciBwYXJhbXM9UG9ydC5hcmdzKHRoaXMub25WYWx1ZUNoYW5nZWR8fHRoaXMub25DaGFuZ2UpXG4gICAgICAgIC8vIGlmKHBhcmFtcy5sZW5ndGg+MCkgdGhpcy5fbG9nLndhcm4oJ1RPTTogcG9ydCBoYXMgb25jaGFuZ2UgcGFyYW1zIScsdGhpcy5fb3Aub2JqTmFtZSx0aGlzLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9hY3Rpdml0eSgpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwiY2hhbmdlXCIsIHRoaXMudmFsdWUsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMub25DaGFuZ2UpIHRoaXMub25DaGFuZ2UodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgZWxzZSBpZiAodGhpcy5vblZhbHVlQ2hhbmdlZCkgdGhpcy5vblZhbHVlQ2hhbmdlZCh0aGlzLCB0aGlzLnZhbHVlKTsgLy8gZGVwcmVjYXRlZFxufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0VHlwZVN0cmluZ1xuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGdldCBwb3J0IHR5cGUgYXMgc3RyaW5nLCBlLmcuIFwiRnVuY3Rpb25cIixcIlZhbHVlXCIuLi5cbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5Qb3J0LnByb3RvdHlwZS5nZXRUeXBlU3RyaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUpIHJldHVybiBcIk51bWJlclwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTikgcmV0dXJuIFwiVHJpZ2dlclwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QpIHJldHVybiBcIk9iamVjdFwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKSByZXR1cm4gXCJEeW5hbWljXCI7XG4gICAgaWYgKHRoaXMudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZKSByZXR1cm4gXCJBcnJheVwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcpIHJldHVybiBcIlN0cmluZ1wiO1xuICAgIHJldHVybiBcIlVua25vd25cIjtcbn07XG5cblBvcnQucHJvdG90eXBlLmRlU2VyaWFsaXplU2V0dGluZ3MgPSBmdW5jdGlvbiAob2JqUG9ydClcbntcbiAgICBpZiAoIW9ialBvcnQpIHJldHVybjtcbiAgICBpZiAob2JqUG9ydC5hbmltYXRlZCkgdGhpcy5zZXRBbmltYXRlZChvYmpQb3J0LmFuaW1hdGVkKTtcbiAgICBpZiAob2JqUG9ydC51c2VWYXJpYWJsZSkgdGhpcy5zZXRWYXJpYWJsZU5hbWUob2JqUG9ydC51c2VWYXJpYWJsZSk7XG4gICAgaWYgKG9ialBvcnQudGl0bGUpIHRoaXMuc2V0VWlBdHRyaWJzKHsgXCJ0aXRsZVwiOiBvYmpQb3J0LnRpdGxlIH0pO1xuICAgIGlmIChvYmpQb3J0LmV4cG9zZSkgdGhpcy5zZXRVaUF0dHJpYnMoeyBcImV4cG9zZVwiOiB0cnVlIH0pO1xuICAgIGlmIChvYmpQb3J0Lm9yZGVyKSB0aGlzLnNldFVpQXR0cmlicyh7IFwib3JkZXJcIjogb2JqUG9ydC5vcmRlciB9KTtcbiAgICBpZiAob2JqUG9ydC5hbmltKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW0pIHRoaXMuYW5pbSA9IG5ldyBBbmltKHsgXCJuYW1lXCI6IFwicG9ydCBcIiArIHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5fb3AuX2hhc0FuaW1Qb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltLmFkZEV2ZW50TGlzdGVuZXIoXCJvbkNoYW5nZVwiLCAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vcC5wYXRjaC5lbWl0RXZlbnQoXCJwb3J0QW5pbVVwZGF0ZWRcIiwgdGhpcy5fb3AsIHRoaXMsIHRoaXMuYW5pbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob2JqUG9ydC5hbmltLmxvb3ApIHRoaXMuYW5pbS5sb29wID0gb2JqUG9ydC5hbmltLmxvb3A7XG4gICAgICAgIGZvciAoY29uc3QgYW5pIGluIG9ialBvcnQuYW5pbS5rZXlzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFuaW0ua2V5cy5wdXNoKG5ldyBBTklNLktleShvYmpQb3J0LmFuaW0ua2V5c1thbmldKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltLnNvcnRLZXlzKCk7XG4gICAgfVxufTtcblxuUG9ydC5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IG9iaiA9IHt9O1xuICAgIG9iai5uYW1lID0gdGhpcy5nZXROYW1lKCk7XG5cbiAgICBpZiAoIXRoaXMuaWdub3JlVmFsdWVTZXJpYWxpemUgJiYgdGhpcy5saW5rcy5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUICYmIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS50ZXgpXG4gICAgICAgIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIG9iai52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl91c2VWYXJpYWJsZU5hbWUpIG9iai51c2VWYXJpYWJsZSA9IHRoaXMuX3VzZVZhcmlhYmxlTmFtZTtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZWQpIG9iai5hbmltYXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYW5pbSkgb2JqLmFuaW0gPSB0aGlzLmFuaW0uZ2V0U2VyaWFsaXplZCgpO1xuICAgIGlmICh0aGlzLnVpQXR0cmlicy5kaXNwbGF5ID09IFwiZmlsZVwiKSBvYmouZGlzcGxheSA9IHRoaXMudWlBdHRyaWJzLmRpc3BsYXk7XG4gICAgaWYgKHRoaXMudWlBdHRyaWJzLmV4cG9zZSlcbiAgICB7XG4gICAgICAgIG9iai5leHBvc2UgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnMuaGFzT3duUHJvcGVydHkoXCJvcmRlclwiKSkgb2JqLm9yZGVyID0gdGhpcy51aUF0dHJpYnMub3JkZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSkgb2JqLnRpdGxlID0gdGhpcy51aUF0dHJpYnMudGl0bGU7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX09VVCAmJiB0aGlzLmxpbmtzLmxlbmd0aCA+IDApXG4gICAge1xuICAgICAgICBvYmoubGlua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMubGlua3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5saW5rc1tpXS5pZ25vcmVJblNlcmlhbGl6ZSAmJiAodGhpcy5saW5rc1tpXS5wb3J0SW4gJiYgdGhpcy5saW5rc1tpXS5wb3J0T3V0KSkgb2JqLmxpbmtzLnB1c2godGhpcy5saW5rc1tpXS5nZXRTZXJpYWxpemVkKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOICYmIHRoaXMubGlua3MubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmxpbmtzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlua3NbaV0ucG9ydEluIHx8ICF0aGlzLmxpbmtzW2ldLnBvcnRPdXQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBvdGhlcnAgPSB0aGlzLmxpbmtzW2ldLmdldE90aGVyUG9ydCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnAub3AuaXNJbkJsdWVwcmludDIoKSAmJiAhdGhpcy5vcC5pc0luQmx1ZXByaW50MigpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iai5saW5rcyA9IG9iai5saW5rcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBvYmoubGlua3MucHVzaCh0aGlzLmxpbmtzW2ldLmdldFNlcmlhbGl6ZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2JqLmxpbmtzICYmIG9iai5saW5rcy5sZW5ndGggPT0gMCkgZGVsZXRlIG9iai5saW5rcztcbiAgICBpZiAodGhpcy50eXBlID09PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OKSBkZWxldGUgb2JqLnZhbHVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04gJiYgdGhpcy5saW5rcy5sZW5ndGggPT0gMCkgb2JqID0gbnVsbDtcbiAgICBpZiAob2JqICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09IDEgJiYgb2JqLm5hbWUpb2JqID0gbnVsbDtcbiAgICBjbGVhbkpzb24ob2JqKTtcblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5zaG91bGRMaW5rID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUxpbmtzXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmVtb3ZlIGFsbCBsaW5rcyBmcm9tIHBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUucmVtb3ZlTGlua3MgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgd2hpbGUgKHRoaXMubGlua3MubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChjb3VudCA+IDUwMDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiY291bGQgbm90IGRlbGV0ZSBsaW5rcy4uLiAvIGluZmluaXRlIGxvb3BcIik7XG4gICAgICAgICAgICB0aGlzLmxpbmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtzWzBdLnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUxpbmtcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiByZW1vdmUgYWxsIGxpbmsgZnJvbSBwb3J0XG4gKiBAcGFyYW0ge0NBQkxFUy5MaW5rfSBsaW5rXG4gKi9cblBvcnQucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbiAobGluaylcbntcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5saW5rcylcbiAgICAgICAgaWYgKHRoaXMubGlua3NbaV0gPT0gbGluaylcbiAgICAgICAgICAgIHRoaXMubGlua3Muc3BsaWNlKGksIDEpO1xuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFKSB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlQmVmb3JlTGluayB8fCAwKTtcbiAgICAgICAgZWxzZSB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlQmVmb3JlTGluayB8fCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoQ0FCTEVTLlVJICYmIHRoaXMuX29wLmNoZWNrTGlua1RpbWVXYXJuaW5ncykgdGhpcy5fb3AuY2hlY2tMaW5rVGltZVdhcm5pbmdzKCk7XG5cbiAgICBpZiAodGhpcy5vbkxpbmtDaGFuZ2VkKSB0aGlzLm9uTGlua0NoYW5nZWQoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcIm9uTGlua0NoYW5nZWRcIik7XG4gICAgdGhpcy5fb3AuZW1pdEV2ZW50KFwib25MaW5rQ2hhbmdlZFwiKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldE5hbWVcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm4gcG9ydCBuYW1lXG4gKi9cblBvcnQucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRUaXRsZVxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybiBwb3J0IG5hbWUgb3IgdGl0bGVcbiAqL1xuUG9ydC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSkgcmV0dXJuIHRoaXMudWlBdHRyaWJzLnRpdGxlO1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5hZGRMaW5rID0gZnVuY3Rpb24gKGwpXG57XG4gICAgdGhpcy5fdmFsdWVCZWZvcmVMaW5rID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLmxpbmtzLnB1c2gobCk7XG4gICAgaWYgKENBQkxFUy5VSSAmJiB0aGlzLl9vcC5jaGVja0xpbmtUaW1lV2FybmluZ3MpIHRoaXMuX29wLmNoZWNrTGlua1RpbWVXYXJuaW5ncygpO1xuXG4gICAgaWYgKHRoaXMub25MaW5rQ2hhbmdlZCkgdGhpcy5vbkxpbmtDaGFuZ2VkKCk7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJvbkxpbmtDaGFuZ2VkXCIpO1xuICAgIHRoaXMuX29wLmVtaXRFdmVudChcIm9uTGlua0NoYW5nZWRcIik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRMaW5rVG9cbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7UG9ydH0gb3RoZXJQb3J0XG4gKiBAZGVzY3JpcHRpb24gcmV0dXJuIGxpbmssIHdoaWNoIGlzIGxpbmtlZCB0byBvdGhlclBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUuZ2V0TGlua1RvID0gZnVuY3Rpb24gKHAyKVxue1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmxpbmtzKSBpZiAodGhpcy5saW5rc1tpXS5wb3J0SW4gPT0gcDIgfHwgdGhpcy5saW5rc1tpXS5wb3J0T3V0ID09IHAyKSByZXR1cm4gdGhpcy5saW5rc1tpXTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUxpbmtUb1xuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtQb3J0fSBvdGhlclBvcnRcbiAqIEBkZXNjcmlwdGlvbiByZW1vdmVzIGxpbmssIHdoaWNoIGlzIGxpbmtlZCB0byBvdGhlclBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUucmVtb3ZlTGlua1RvID0gZnVuY3Rpb24gKHAyKVxue1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmxpbmtzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubGlua3NbaV0ucG9ydEluID09IHAyIHx8IHRoaXMubGlua3NbaV0ucG9ydE91dCA9PSBwMilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5saW5rc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChDQUJMRVMuVUkgJiYgdGhpcy5fb3AuY2hlY2tMaW5rVGltZVdhcm5pbmdzKSB0aGlzLl9vcC5jaGVja0xpbmtUaW1lV2FybmluZ3MoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25MaW5rQ2hhbmdlZCkgdGhpcy5vbkxpbmtDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uTGlua0NoYW5nZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0xpbmtlZFRvXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1BvcnR9IG90aGVyUG9ydFxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgdHJ1ZSBpZiBwb3J0IGlzIGxpbmtlZCB0byBvdGhlclBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUuaXNMaW5rZWRUbyA9IGZ1bmN0aW9uIChwMilcbntcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5saW5rcykgaWYgKHRoaXMubGlua3NbaV0ucG9ydEluID09IHAyIHx8IHRoaXMubGlua3NbaV0ucG9ydE91dCA9PSBwMikgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5fYWN0aXZpdHkgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuYWN0aXZpdHlDb3VudGVyKys7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiB0cmlnZ2VyXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gdHJpZ2dlciB0aGUgbGlua2VkIHBvcnQgKHVzdWFsbHkgaW52b2tlZCBvbiBhbiBvdXRwdXQgZnVuY3Rpb24gcG9ydClcbiAqL1xuUG9ydC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3QgbGlua3NMZW5ndGggPSB0aGlzLmxpbmtzLmxlbmd0aDtcblxuICAgIHRoaXMuX2FjdGl2aXR5KCk7XG4gICAgaWYgKGxpbmtzTGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLl9vcC5lbmFibGVkKSByZXR1cm47XG5cbiAgICBsZXQgcG9ydFRyaWdnZXJlZCA9IG51bGw7XG4gICAgdHJ5XG4gICAge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzTGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmtzW2ldLnBvcnRJbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb3J0VHJpZ2dlcmVkID0gdGhpcy5saW5rc1tpXS5wb3J0SW47XG5cbiAgICAgICAgICAgICAgICBwb3J0VHJpZ2dlcmVkLm9wLnBhdGNoLnB1c2hUcmlnZ2VyU3RhY2socG9ydFRyaWdnZXJlZCk7XG4gICAgICAgICAgICAgICAgcG9ydFRyaWdnZXJlZC5fb25UcmlnZ2VyZWQoKTtcblxuICAgICAgICAgICAgICAgIHBvcnRUcmlnZ2VyZWQub3AucGF0Y2gucG9wVHJpZ2dlclN0YWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saW5rc1tpXSkgdGhpcy5saW5rc1tpXS5hY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChleClcbiAgICB7XG4gICAgICAgIHBvcnRUcmlnZ2VyZWQub3AuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9vcC5wYXRjaC5pc0VkaXRvck1vZGUoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb3AucGF0Y2guZW1pdEV2ZW50KFwiZXhjZXB0aW9uXCIsIGV4LCBwb3J0VHJpZ2dlcmVkLm9wKTtcbiAgICAgICAgICAgIHRoaXMuX29wLnBhdGNoLmVtaXRFdmVudChcIm9wY3Jhc2hcIiwgcG9ydFRyaWdnZXJlZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNyYXNoXCIsIHBvcnRUcmlnZ2VyZWQub3Aub2JqTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwb3J0VHJpZ2dlcmVkLm9wLm9uRXJyb3IpIHBvcnRUcmlnZ2VyZWQub3Aub25FcnJvcihleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJleGNlcHRpb24hXCIpO1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJvbnRyaWdnZXJlZCBleGNlcHRpb24gY2F1Z2h0XCIsIGV4KTtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKGV4LnN0YWNrKTtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJleGNlcHRpb24gaW46IFwiICsgcG9ydFRyaWdnZXJlZC5vcC5uYW1lKTtcbiAgICB9XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cud2FybihcImNhbGwgZGVwcmVjYXRlZCAtIHVzZSB0cmlnZ2VyKCkgXCIpO1xuICAgIHRoaXMudHJpZ2dlcigpO1xufTtcblxuUG9ydC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbG9nLndhcm4oXCIjIyMgZXhlY3V0ZSBwb3J0OiBcIiArIHRoaXMuZ2V0TmFtZSgpLCB0aGlzLmdvYWxzLmxlbmd0aCk7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5zZXRWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiAobilcbntcbiAgICB0aGlzLl91c2VWYXJpYWJsZU5hbWUgPSBuO1xuXG5cbiAgICB0aGlzLl9vcC5wYXRjaC5vbihcInZhcmlhYmxlUmVuYW1lXCIsIChvbGRuYW1lLCBuZXduYW1lKSA9PlxuICAgIHtcbiAgICAgICAgaWYgKG9sZG5hbWUgIT0gdGhpcy5fdXNlVmFyaWFibGVOYW1lKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VzZVZhcmlhYmxlTmFtZSA9IG5ld25hbWU7XG4gICAgfSk7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5nZXRWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl91c2VWYXJpYWJsZU5hbWU7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2KVxue1xuICAgIHRoaXMuc2V0QW5pbWF0ZWQoZmFsc2UpO1xuICAgIGNvbnN0IGF0dHIgPSB7IFwidXNlVmFyaWFibGVcIjogZmFsc2UgfTtcblxuICAgIGlmICh0aGlzLl92YXJpYWJsZUluICYmIHRoaXMuX3ZhckNoYW5nZUxpc3RlbmVySWQpXG4gICAge1xuICAgICAgICB0aGlzLl92YXJpYWJsZUluLm9mZih0aGlzLl92YXJDaGFuZ2VMaXN0ZW5lcklkKTtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVJbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHYpXG4gICAge1xuICAgICAgICB0aGlzLl92YXJpYWJsZUluID0gdGhpcy5fb3AucGF0Y2guZ2V0VmFyKHYpO1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFyaWFibGVJbilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJQT1JUIFZBUiBOT1QgRk9VTkQhISFcIiwgdik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhckNoYW5nZUxpc3RlbmVySWQgPSB0aGlzLl92YXJpYWJsZUluLm9uKFwiY2hhbmdlXCIsICgpID0+IHsgdGhpcy5zZXQobnVsbCk7IHRoaXMuc2V0KHRoaXMuX3ZhcmlhYmxlSW4uZ2V0VmFsdWUoKSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhckNoYW5nZUxpc3RlbmVySWQgPSB0aGlzLl92YXJpYWJsZUluLm9uKFwiY2hhbmdlXCIsIHRoaXMuc2V0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXQodGhpcy5fdmFyaWFibGVJbi5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91c2VWYXJpYWJsZU5hbWUgPSB2O1xuICAgICAgICBhdHRyLnVzZVZhcmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgYXR0ci52YXJpYWJsZU5hbWUgPSB0aGlzLl91c2VWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGF0dHIudmFyaWFibGVOYW1lID0gdGhpcy5fdXNlVmFyaWFibGVOYW1lID0gbnVsbDtcbiAgICAgICAgYXR0ci51c2VWYXJpYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VWlBdHRyaWJzKGF0dHIpO1xuICAgIHRoaXMuX29wLnBhdGNoLmVtaXRFdmVudChcInBvcnRTZXRWYXJpYWJsZVwiLCB0aGlzLl9vcCwgdGhpcywgdik7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5faGFuZGxlTm9UcmlnZ2VyT3BBbmltVXBkYXRlcyA9IGZ1bmN0aW9uIChhKVxue1xuICAgIGxldCBoYXNUcmlnZ2VyUG9ydCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb3AucG9ydHNJbi5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9vcC5wb3J0c0luLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTilcbiAgICAgICAge1xuICAgICAgICAgICAgaGFzVHJpZ2dlclBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc1RyaWdnZXJQb3J0KVxuICAgIHtcbiAgICAgICAgaWYgKGEpIHRoaXMuX25vdHJpZ2dlckFuaW1VcGRhdGUgPSB0aGlzLl9vcC5wYXRjaC5vbihcIm9uUmVuZGVyRnJhbWVcIixcbiAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBbmltKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB0aGlzLl9vcC5wYXRjaC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX25vdHJpZ2dlckFuaW1VcGRhdGUpO1xuICAgIH1cbn07XG5cblBvcnQucHJvdG90eXBlLnNldEFuaW1hdGVkID0gZnVuY3Rpb24gKGEpXG57XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVkICE9IGEpXG4gICAge1xuICAgICAgICB0aGlzLl9hbmltYXRlZCA9IGE7XG4gICAgICAgIHRoaXMuX29wLl9oYXNBbmltUG9ydCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGVkICYmICF0aGlzLmFuaW0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltKHsgXCJuYW1lXCI6IFwicG9ydCBcIiArIHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5hZGRFdmVudExpc3RlbmVyKFwib25DaGFuZ2VcIiwgKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcC5wYXRjaC5lbWl0RXZlbnQoXCJwb3J0QW5pbVVwZGF0ZWRcIiwgdGhpcy5fb3AsIHRoaXMsIHRoaXMuYW5pbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkFuaW1Ub2dnbGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVOb1RyaWdnZXJPcEFuaW1VcGRhdGVzKGEpO1xuICAgIGlmICghYSlcbiAgICB7XG4gICAgICAgIHRoaXMuYW5pbSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRVaUF0dHJpYnMoeyBcImlzQW5pbWF0ZWRcIjogdGhpcy5fYW5pbWF0ZWQgfSk7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS50b2dnbGVBbmltID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9hbmltYXRlZCA9ICF0aGlzLl9hbmltYXRlZDtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZWQgJiYgIXRoaXMuYW5pbSlcbiAgICB7XG4gICAgICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltKHsgXCJuYW1lXCI6IFwicG9ydCBcIiArIHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5hbmltLmFkZEV2ZW50TGlzdGVuZXIoXCJvbkNoYW5nZVwiLCAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vcC5wYXRjaC5lbWl0RXZlbnQoXCJwb3J0QW5pbVVwZGF0ZWRcIiwgdGhpcy5fb3AsIHRoaXMsIHRoaXMuYW5pbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnNldEFuaW1hdGVkKHRoaXMuX2FuaW1hdGVkKTtcbiAgICB0aGlzLl9vbkFuaW1Ub2dnbGUoKTtcbiAgICB0aGlzLnNldFVpQXR0cmlicyh7IFwiaXNBbmltYXRlZFwiOiB0aGlzLl9hbmltYXRlZCB9KTtcbn07XG5cbi8qKlxuICogPHByZT5cbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFID0gMDtcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OID0gMTtcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCA9IDI7XG4gKiBDQUJMRVMuQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9URVhUVVJFID0gMjtcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZID0gMztcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMgPSA0O1xuICogQ0FCTEVTLkNPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfU1RSSU5HID0gNTtcbiAqIDwvcHJlPlxuICogQGZ1bmN0aW9uIGdldFR5cGVcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge051bWJlcn0gdHlwZSBvZiBwb3J0XG4gKi9cblBvcnQucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0xpbmtlZFxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb3J0IGlzIGxpbmtlZFxuICovXG5Qb3J0LnByb3RvdHlwZS5pc0xpbmtlZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMubGlua3MubGVuZ3RoID4gMCB8fCB0aGlzLl9hbmltYXRlZCB8fCB0aGlzLl91c2VWYXJpYWJsZU5hbWUgIT0gbnVsbDtcbn07XG5cblBvcnQucHJvdG90eXBlLmlzQm91bmRUb1ZhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3QgYiA9IHRoaXMuX3VzZVZhcmlhYmxlTmFtZSAhPSBudWxsO1xuICAgIHRoaXMudWlBdHRyaWJzLmJvdW5kVG9WYXIgPSBiO1xuICAgIHJldHVybiBiO1xufTtcbi8qKlxuICogQGZ1bmN0aW9uIGlzQW5pbWF0ZWRcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9ydCBpcyBhbmltYXRlZFxuICovXG5Qb3J0LnByb3RvdHlwZS5pc0FuaW1hdGVkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZWQ7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0hpZGRlblxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb3J0IGlzIGhpZGRlblxuICovXG5Qb3J0LnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMudWlBdHRyaWJzLmhpZGVQb3J0O1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gb25UcmlnZ2VyZWRcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7b25UcmlnZ2VyZWRDYWxsYmFja30gY2FsbGJhY2tcbiAqIEBkZXNjcmlwdGlvbiBzZXQgY2FsbGJhY2ssIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBwb3J0IHdhcyB0cmlnZ2VyZWQgKHVzdWFsbHkgb3V0cHV0IHBvcnQpXG4gKi9cblBvcnQucHJvdG90eXBlLl9vblRyaWdnZXJlZCA9IGZ1bmN0aW9uIChhKVxue1xuICAgIHRoaXMuX2FjdGl2aXR5KCk7XG4gICAgdGhpcy5fb3AudXBkYXRlQW5pbXMoKTtcbiAgICBpZiAodGhpcy5fb3AuZW5hYmxlZCAmJiB0aGlzLm9uVHJpZ2dlcmVkKSB0aGlzLm9uVHJpZ2dlcmVkKGEpO1xufTtcblxuUG9ydC5wcm90b3R5cGUuX29uU2V0UHJvZmlsaW5nID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdGhpcy5fb3AucGF0Y2gucHJvZmlsZXIuYWRkKFwicG9ydFwiLCB0aGlzKTtcbiAgICB0aGlzLnNldFZhbHVlKHYpO1xuICAgIC8vIGlmICh0aGlzLl9vcC5lbmFibGVkICYmIHRoaXMub25UcmlnZ2VyZWQpIHRoaXMub25UcmlnZ2VyZWQoKTtcbiAgICB0aGlzLl9vcC5wYXRjaC5wcm9maWxlci5hZGQoXCJwb3J0XCIsIG51bGwpO1xufTtcblxuUG9ydC5wcm90b3R5cGUuX29uVHJpZ2dlcmVkUHJvZmlsaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyB0aGlzLl9vcC51cGRhdGVBbmltcygpO1xuXG4gICAgaWYgKHRoaXMuX29wLmVuYWJsZWQgJiYgdGhpcy5vblRyaWdnZXJlZClcbiAgICB7XG4gICAgICAgIHRoaXMuX29wLnBhdGNoLnByb2ZpbGVyLmFkZChcInBvcnRcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMub25UcmlnZ2VyZWQoKTtcbiAgICAgICAgdGhpcy5fb3AucGF0Y2gucHJvZmlsZXIuYWRkKFwicG9ydFwiLCBudWxsKTtcbiAgICB9XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGNiKVxue1xuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICB0aGlzLm9uQ2hhbmdlID0gY2I7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5nZXRVaUFjdGl2ZVN0YXRlID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fdWlBY3RpdmVTdGF0ZTtcbn07XG5cblBvcnQucHJvdG90eXBlLnNldFVpQWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAob25vZmYpXG57XG4gICAgdGhpcy5fdWlBY3RpdmVTdGF0ZSA9IG9ub2ZmO1xuICAgIGlmICh0aGlzLm9uVWlBY3RpdmVTdGF0ZUNoYW5nZSkgdGhpcy5vblVpQWN0aXZlU3RhdGVDaGFuZ2UoKTtcbn07XG5cblBvcnQucHJvdG90eXBlLmhpZGVQb3J0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cud2FybihcIm9wLmhpZGVwb3J0KCkgaXMgZGVwcmVjYXRlZCwgZG8gbm90IHVzZSBpdCFcIik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9ydCB0eXBlIHN0cmluZywgZS5nLiBcInZhbHVlXCIgYmFzZWQgb24gdGhlIHBvcnQgdHlwZSBudW1iZXJcbiAqIEBmdW5jdGlvbiBwb3J0VHlwZU51bWJlclRvU3RyaW5nXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIFRoZSBwb3J0IHR5cGUgbnVtYmVyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIFRoZSBwb3J0IHR5cGUgYXMgc3RyaW5nXG4gKi9cblBvcnQucG9ydFR5cGVOdW1iZXJUb1N0cmluZyA9IGZ1bmN0aW9uICh0eXBlKVxue1xuICAgIGlmICh0eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUpIHJldHVybiBcInZhbHVlXCI7XG4gICAgaWYgKHR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTikgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCkgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgaWYgKHR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9BUlJBWSkgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAodHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORykgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgaWYgKHR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKSByZXR1cm4gXCJkeW5hbWljXCI7XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xufTtcblxuZXhwb3J0IHsgUG9ydCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_port.js\n");

/***/ }),

/***/ "./src/core/core_port_select.js":
/*!**************************************!*\
  !*** ./src/core/core_port_select.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValueSelectPort\": () => (/* binding */ ValueSelectPort)\n/* harmony export */ });\n/* harmony import */ var _core_port_switch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core_port_switch */ \"./src/core/core_port_switch.js\");\n\n\n\n\nclass ValueSelectPort extends _core_port_switch__WEBPACK_IMPORTED_MODULE_0__.SwitchPort\n{\n    setUiAttribs(newAttribs)\n    {\n        // never unhide valuePort when indexPort is linked\n        if (this.indexPort.isLinked())\n        {\n            for (const p in newAttribs)\n            {\n                if (p == \"greyout\" && !newAttribs[p]) newAttribs[p] = \"true\";\n            }\n        }\n        super.setUiAttribs(newAttribs);\n    }\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BvcnRfc2VsZWN0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NvcmVfcG9ydF9zZWxlY3QuanM/Y2FiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFN3aXRjaFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnRfc3dpdGNoXCI7XG5cblxuY2xhc3MgVmFsdWVTZWxlY3RQb3J0IGV4dGVuZHMgU3dpdGNoUG9ydFxue1xuICAgIHNldFVpQXR0cmlicyhuZXdBdHRyaWJzKVxuICAgIHtcbiAgICAgICAgLy8gbmV2ZXIgdW5oaWRlIHZhbHVlUG9ydCB3aGVuIGluZGV4UG9ydCBpcyBsaW5rZWRcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhQb3J0LmlzTGlua2VkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBuZXdBdHRyaWJzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwID09IFwiZ3JleW91dFwiICYmICFuZXdBdHRyaWJzW3BdKSBuZXdBdHRyaWJzW3BdID0gXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2V0VWlBdHRyaWJzKG5ld0F0dHJpYnMpO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCB7IFZhbHVlU2VsZWN0UG9ydCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_port_select.js\n");

/***/ }),

/***/ "./src/core/core_port_switch.js":
/*!**************************************!*\
  !*** ./src/core/core_port_switch.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SwitchPort\": () => (/* binding */ SwitchPort)\n/* harmony export */ });\n/* harmony import */ var _core_port__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core_port */ \"./src/core/core_port.js\");\n\n\n\n\nclass SwitchPort extends _core_port__WEBPACK_IMPORTED_MODULE_0__.Port\n{\n    constructor(__parent, name, type, uiAttribs, indexPort)\n    {\n        super(__parent, name, type, uiAttribs);\n\n        this.get = () =>\n        {\n            let s = super.get();\n\n            if (CABLES.UI)\n            {\n                if (\n                    s === \"\" ||\n                    s === null ||\n                    s === undefined ||\n                    (uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1)\n                )\n                {\n                    this.op.setUiError(\"invalidswitch\", \"Invalid Value [\" + this.name + \"]: \\\"\" + s + \"\\\"\");\n                }\n                else this.op.setUiError(\"invalidswitch\", null);\n            }\n\n            if (s === null || s === undefined)s = \"\";\n\n            return s;\n        };\n\n        this.indexPort = indexPort;\n        this.indexPort.set = (value) =>\n        {\n            const values = uiAttribs.values;\n\n            if (!values)\n            {\n                // console.log(\"switch port has no values\", this);\n                return;\n            }\n\n            let intValue = Math.floor(value);\n\n            intValue = Math.min(intValue, values.length - 1);\n            intValue = Math.max(intValue, 0);\n\n            this.indexPort.setValue(intValue);\n            this.set(values[intValue]);\n\n            if (this.op.patch.isEditorMode() && window.gui && gui.patchView.isCurrentOp(this.op)) gui.opParams.show(this.op);\n        };\n    }\n\n    setUiAttribs(attribs)\n    {\n        const hidePort = attribs.hidePort;\n        attribs.hidePort = true;\n        super.setUiAttribs(attribs);\n        if (typeof hidePort !== \"undefined\")\n        {\n            this.indexPort.setUiAttribs({ hidePort });\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BvcnRfc3dpdGNoLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9wb3J0X3N3aXRjaC5qcz82NTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgUG9ydCB9IGZyb20gXCIuL2NvcmVfcG9ydFwiO1xuXG5cbmNsYXNzIFN3aXRjaFBvcnQgZXh0ZW5kcyBQb3J0XG57XG4gICAgY29uc3RydWN0b3IoX19wYXJlbnQsIG5hbWUsIHR5cGUsIHVpQXR0cmlicywgaW5kZXhQb3J0KVxuICAgIHtcbiAgICAgICAgc3VwZXIoX19wYXJlbnQsIG5hbWUsIHR5cGUsIHVpQXR0cmlicyk7XG5cbiAgICAgICAgdGhpcy5nZXQgPSAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcyA9IHN1cGVyLmdldCgpO1xuXG4gICAgICAgICAgICBpZiAoQ0FCTEVTLlVJKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcyA9PT0gXCJcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAodWlBdHRyaWJzLnZhbHVlcyAmJiB1aUF0dHJpYnMudmFsdWVzLmluZGV4T2YoU3RyaW5nKHMpKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcC5zZXRVaUVycm9yKFwiaW52YWxpZHN3aXRjaFwiLCBcIkludmFsaWQgVmFsdWUgW1wiICsgdGhpcy5uYW1lICsgXCJdOiBcXFwiXCIgKyBzICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMub3Auc2V0VWlFcnJvcihcImludmFsaWRzd2l0Y2hcIiwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZClzID0gXCJcIjtcblxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pbmRleFBvcnQgPSBpbmRleFBvcnQ7XG4gICAgICAgIHRoaXMuaW5kZXhQb3J0LnNldCA9ICh2YWx1ZSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdWlBdHRyaWJzLnZhbHVlcztcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZXMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzd2l0Y2ggcG9ydCBoYXMgbm8gdmFsdWVzXCIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGludFZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG5cbiAgICAgICAgICAgIGludFZhbHVlID0gTWF0aC5taW4oaW50VmFsdWUsIHZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGludFZhbHVlID0gTWF0aC5tYXgoaW50VmFsdWUsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmluZGV4UG9ydC5zZXRWYWx1ZShpbnRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldCh2YWx1ZXNbaW50VmFsdWVdKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3AucGF0Y2guaXNFZGl0b3JNb2RlKCkgJiYgd2luZG93Lmd1aSAmJiBndWkucGF0Y2hWaWV3LmlzQ3VycmVudE9wKHRoaXMub3ApKSBndWkub3BQYXJhbXMuc2hvdyh0aGlzLm9wKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRVaUF0dHJpYnMoYXR0cmlicylcbiAgICB7XG4gICAgICAgIGNvbnN0IGhpZGVQb3J0ID0gYXR0cmlicy5oaWRlUG9ydDtcbiAgICAgICAgYXR0cmlicy5oaWRlUG9ydCA9IHRydWU7XG4gICAgICAgIHN1cGVyLnNldFVpQXR0cmlicyhhdHRyaWJzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoaWRlUG9ydCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbmRleFBvcnQuc2V0VWlBdHRyaWJzKHsgaGlkZVBvcnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFN3aXRjaFBvcnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/core_port_switch.js\n");

/***/ }),

/***/ "./src/core/core_profiler.js":
/*!***********************************!*\
  !*** ./src/core/core_profiler.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Profiler\": () => (/* binding */ Profiler)\n/* harmony export */ });\n/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ \"./src/core/timer.js\");\n\n\nclass Profiler\n{\n    constructor(patch)\n    {\n        this.startFrame = patch.getFrameNum();\n        this.items = {};\n        this.currentId = null;\n        this.currentStart = 0;\n        this._patch = patch;\n    }\n\n    getItems()\n    {\n        return this.items;\n    }\n\n    clear()\n    {\n        if (this.paused) return;\n        this.items = {};\n    }\n\n    togglePause()\n    {\n        this.paused = !this.paused;\n        if (!this.paused)\n        {\n            this.items = {};\n            this.currentStart = performance.now();\n        }\n    }\n\n    add(type, object)\n    {\n        if (this.paused) return;\n\n        if (this.currentId !== null)\n        {\n            if (!object || object.id != this.currentId)\n            {\n                if (this.items[this.currentId])\n                {\n                    this.items[this.currentId].timeUsed += performance.now() - this.currentStart;\n\n                    if (!this.items[this.currentId].peakTime || (0,_timer__WEBPACK_IMPORTED_MODULE_0__.now)() - this.items[this.currentId].peakTime > 5000)\n                    {\n                        this.items[this.currentId].peak = 0;\n                        this.items[this.currentId].peakTime = (0,_timer__WEBPACK_IMPORTED_MODULE_0__.now)();\n                    }\n                    this.items[this.currentId].peak = Math.max(this.items[this.currentId].peak, performance.now() - this.currentStart);\n                }\n            }\n        }\n\n        if (object !== null)\n        {\n            if (!this.items[object.id])\n            {\n                this.items[object.id] = {\n                    \"numTriggers\": 0,\n                    \"timeUsed\": 0,\n                };\n            }\n\n            if (this.items[object.id].lastFrame != this._patch.getFrameNum()) this.items[object.id].numTriggers = 0;\n\n            this.items[object.id].lastFrame = this._patch.getFrameNum();\n            this.items[object.id].numTriggers++;\n            this.items[object.id].opid = object.op.id;\n            this.items[object.id].title = object.op.name + \".\" + object.name;\n            this.items[object.id].subPatch = object.op.uiAttribs.subPatch;\n\n            this.currentId = object.id;\n            this.currentStart = performance.now();\n        }\n        else\n        {\n            this.currentId = null;\n        }\n    }\n\n    print()\n    {\n        console.log(\"--------\");\n        for (const i in this.items)\n        {\n            console.log(this.items[i].title + \": \" + this.items[i].numTriggers + \" / \" + this.items[i].timeUsed);\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3Byb2ZpbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jb3JlX3Byb2ZpbGVyLmpzP2FiMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm93IH0gZnJvbSBcIi4vdGltZXJcIjtcblxuY2xhc3MgUHJvZmlsZXJcbntcbiAgICBjb25zdHJ1Y3RvcihwYXRjaClcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFtZSA9IHBhdGNoLmdldEZyYW1lTnVtKCk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX3BhdGNoID0gcGF0Y2g7XG4gICAgfVxuXG4gICAgZ2V0SXRlbXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXM7XG4gICAgfVxuXG4gICAgY2xlYXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB9XG5cbiAgICB0b2dnbGVQYXVzZSgpXG4gICAge1xuICAgICAgICB0aGlzLnBhdXNlZCA9ICF0aGlzLnBhdXNlZDtcbiAgICAgICAgaWYgKCF0aGlzLnBhdXNlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZCh0eXBlLCBvYmplY3QpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50SWQgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0IHx8IG9iamVjdC5pZCAhPSB0aGlzLmN1cnJlbnRJZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRJZF0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXS50aW1lVXNlZCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuY3VycmVudFN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRJZF0ucGVha1RpbWUgfHwgbm93KCkgLSB0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXS5wZWFrVGltZSA+IDUwMDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50SWRdLnBlYWsgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRJZF0ucGVha1RpbWUgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXS5wZWFrID0gTWF0aC5tYXgodGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRJZF0ucGVhaywgcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmN1cnJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLml0ZW1zW29iamVjdC5pZF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tvYmplY3QuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBcIm51bVRyaWdnZXJzXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZVVzZWRcIjogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tvYmplY3QuaWRdLmxhc3RGcmFtZSAhPSB0aGlzLl9wYXRjaC5nZXRGcmFtZU51bSgpKSB0aGlzLml0ZW1zW29iamVjdC5pZF0ubnVtVHJpZ2dlcnMgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLml0ZW1zW29iamVjdC5pZF0ubGFzdEZyYW1lID0gdGhpcy5fcGF0Y2guZ2V0RnJhbWVOdW0oKTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbb2JqZWN0LmlkXS5udW1UcmlnZ2VycysrO1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tvYmplY3QuaWRdLm9waWQgPSBvYmplY3Qub3AuaWQ7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW29iamVjdC5pZF0udGl0bGUgPSBvYmplY3Qub3AubmFtZSArIFwiLlwiICsgb2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW29iamVjdC5pZF0uc3ViUGF0Y2ggPSBvYmplY3Qub3AudWlBdHRyaWJzLnN1YlBhdGNoO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJZCA9IG9iamVjdC5pZDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcmludCgpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5pdGVtcylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5pdGVtc1tpXS50aXRsZSArIFwiOiBcIiArIHRoaXMuaXRlbXNbaV0ubnVtVHJpZ2dlcnMgKyBcIiAvIFwiICsgdGhpcy5pdGVtc1tpXS50aW1lVXNlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFByb2ZpbGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/core_profiler.js\n");

/***/ }),

/***/ "./src/core/core_variable.js":
/*!***********************************!*\
  !*** ./src/core/core_variable.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n\n\n/**\n * @type {Object}\n * @name Variable\n * @param {String} name\n * @param {String|Number} value\n * @memberof Patch\n * @constructor\n */\nclass PatchVariable extends _eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget\n{\n    constructor(name, val, type)\n    {\n        super();\n        this._name = name;\n        this.type = type;\n        this.setValue(val);\n    }\n\n    /**\n     * keeping this for backwards compatibility in older\n     * exports before using eventtarget\n     *\n     * @param cb\n     */\n    addListener(cb)\n    {\n        this.on(\"change\", cb, \"var\");\n    }\n\n    /**\n     * @function Variable.getValue\n     * @memberof Variable\n     * @returns {String|Number|Boolean}\n     */\n\n    getValue()\n    {\n        return this._v;\n    }\n\n    /**\n     * @function getName\n     * @memberof Variable\n     * @instance\n     * @returns {String|Number|Boolean}\n     * @function\n     */\n    getName()\n    {\n        return this._name;\n    }\n\n    /**\n     * @function setValue\n     * @memberof Variable\n     * @instance\n     * @returns {String|Number|Boolean}\n     * @function\n     */\n    setValue(v)\n    {\n        this._v = v;\n        this.emitEvent(\"change\", v, this);\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PatchVariable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3ZhcmlhYmxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV92YXJpYWJsZS5qcz85YzViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50VGFyZ2V0IH0gZnJvbSBcIi4vZXZlbnR0YXJnZXRcIjtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQG5hbWUgVmFyaWFibGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbHVlXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQYXRjaFZhcmlhYmxlIGV4dGVuZHMgRXZlbnRUYXJnZXRcbntcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwsIHR5cGUpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGtlZXBpbmcgdGhpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gb2xkZXJcbiAgICAgKiBleHBvcnRzIGJlZm9yZSB1c2luZyBldmVudHRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIGNiXG4gICAgICovXG4gICAgYWRkTGlzdGVuZXIoY2IpXG4gICAge1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlXCIsIGNiLCBcInZhclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gVmFyaWFibGUuZ2V0VmFsdWVcbiAgICAgKiBAbWVtYmVyb2YgVmFyaWFibGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcnxCb29sZWFufVxuICAgICAqL1xuXG4gICAgZ2V0VmFsdWUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Y7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGdldE5hbWVcbiAgICAgKiBAbWVtYmVyb2YgVmFyaWFibGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcnxCb29sZWFufVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldE5hbWUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNldFZhbHVlXG4gICAgICogQG1lbWJlcm9mIFZhcmlhYmxlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ8Qm9vbGVhbn1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZXRWYWx1ZSh2KVxuICAgIHtcbiAgICAgICAgdGhpcy5fdiA9IHY7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiY2hhbmdlXCIsIHYsIHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGF0Y2hWYXJpYWJsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/core_variable.js\n");

/***/ }),

/***/ "./src/core/embedding.js":
/*!*******************************!*\
  !*** ./src/core/embedding.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMBED\": () => (/* binding */ EMBED)\n/* harmony export */ });\n/* harmony import */ var _core_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core_patch */ \"./src/core/core_patch.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.js\");\n\n\n\nconst EMBED = {};\n\n/**\n * add patch into html element (will create canvas and set size to fill containerElement)\n * @name CABLES.EMBED#addPatch\n * @param {object|string} containerElement dom element or id of element\n * @param {options} patch options\n * @function\n */\nEMBED.addPatch = function (_element, options)\n{\n    let el = _element;\n    let id = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.generateUUID)();\n    if (typeof _element == \"string\")\n    {\n        id = _element;\n        el = document.getElementById(id);\n\n        if (!el)\n        {\n            console.error(id + \" Polyshape Container Element not found!\");\n            return;\n        }\n    }\n\n    const canvEl = document.createElement(\"canvas\");\n    canvEl.id = \"glcanvas_\" + id;\n    canvEl.width = el.clientWidth;\n    canvEl.height = el.clientHeight;\n\n    window.addEventListener(\n        \"resize\",\n        function ()\n        {\n            this.setAttribute(\"width\", el.clientWidth);\n            this.height = el.clientHeight;\n        }.bind(canvEl),\n    );\n\n    el.appendChild(canvEl);\n\n    options = options || {};\n    options.glCanvasId = canvEl.id;\n\n    if (!options.onError)\n    {\n        options.onError = function (err)\n        {\n            console.error(err);\n        };\n    }\n\n    CABLES.patch = new _core_patch__WEBPACK_IMPORTED_MODULE_0__[\"default\"](options);\n    return canvEl;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9lbWJlZGRpbmcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvZW1iZWRkaW5nLmpzP2YwZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhdGNoIGZyb20gXCIuL2NvcmVfcGF0Y2hcIjtcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IEVNQkVEID0ge307XG5cbi8qKlxuICogYWRkIHBhdGNoIGludG8gaHRtbCBlbGVtZW50ICh3aWxsIGNyZWF0ZSBjYW52YXMgYW5kIHNldCBzaXplIHRvIGZpbGwgY29udGFpbmVyRWxlbWVudClcbiAqIEBuYW1lIENBQkxFUy5FTUJFRCNhZGRQYXRjaFxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBjb250YWluZXJFbGVtZW50IGRvbSBlbGVtZW50IG9yIGlkIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7b3B0aW9uc30gcGF0Y2ggb3B0aW9uc1xuICogQGZ1bmN0aW9uXG4gKi9cbkVNQkVELmFkZFBhdGNoID0gZnVuY3Rpb24gKF9lbGVtZW50LCBvcHRpb25zKVxue1xuICAgIGxldCBlbCA9IF9lbGVtZW50O1xuICAgIGxldCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgIGlmICh0eXBlb2YgX2VsZW1lbnQgPT0gXCJzdHJpbmdcIilcbiAgICB7XG4gICAgICAgIGlkID0gX2VsZW1lbnQ7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgIGlmICghZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoaWQgKyBcIiBQb2x5c2hhcGUgQ29udGFpbmVyIEVsZW1lbnQgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNhbnZFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudkVsLmlkID0gXCJnbGNhbnZhc19cIiArIGlkO1xuICAgIGNhbnZFbC53aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgIGNhbnZFbC5oZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJyZXNpemVcIixcbiAgICAgICAgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBlbC5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgfS5iaW5kKGNhbnZFbCksXG4gICAgKTtcblxuICAgIGVsLmFwcGVuZENoaWxkKGNhbnZFbCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmdsQ2FudmFzSWQgPSBjYW52RWwuaWQ7XG5cbiAgICBpZiAoIW9wdGlvbnMub25FcnJvcilcbiAgICB7XG4gICAgICAgIG9wdGlvbnMub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBDQUJMRVMucGF0Y2ggPSBuZXcgUGF0Y2gob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNhbnZFbDtcbn07XG5cbmV4cG9ydCB7IEVNQkVEIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/embedding.js\n");

/***/ }),

/***/ "./src/core/eventtarget.js":
/*!*********************************!*\
  !*** ./src/core/eventtarget.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventTarget\": () => (/* binding */ EventTarget)\n/* harmony export */ });\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core_logger */ \"./src/core/core_logger.js\");\n\n\nconst EventTarget = function ()\n{\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"eventtarget\");\n    this._eventCallbacks = {};\n    this._logName = \"\";\n    this._logEvents = false;\n    this._listeners = {};\n    CABLES.eventTargetProfile = CABLES.eventTargetProfile || {};\n\n    this.addEventListener = this.on = function (which, cb, idPrefix)\n    {\n        const event =\n        {\n            \"id\": (idPrefix || \"\") + CABLES.simpleId(),\n            \"name\": which,\n            \"cb\": cb,\n        };\n        if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];\n        else this._eventCallbacks[which].push(event);\n\n        this._listeners[event.id] = event;\n\n        return event.id;\n    };\n\n    this.hasEventListener = function (which, cb)\n    {\n        if (which && !cb)\n        {\n            // check by id\n            if (this._listeners[which]) return true;\n            else return false;\n        }\n        else\n        {\n            this._log.warn(\"old eventtarget function haseventlistener!\");\n            if (which && cb)\n            {\n                if (this._eventCallbacks[which])\n                {\n                    const idx = this._eventCallbacks[which].indexOf(cb);\n                    if (idx == -1) return false;\n                    return true;\n                }\n            }\n        }\n    };\n\n    this.removeEventListener = this.off = function (which, cb)\n    {\n        if (which === null || which === undefined) return;\n\n        if (!cb) // new style, remove by id, not by name/callback\n        {\n            const event = this._listeners[which];\n            if (!event)\n            {\n                console.log(\"could not find event...\");\n                return;\n            }\n\n            let found = true;\n            while (found)\n            {\n                found = false;\n                let index = -1;\n                for (let i = 0; i < this._eventCallbacks[event.name].length; i++)\n                {\n                    if (this._eventCallbacks[event.name][i].id.indexOf(which) === 0) // this._eventCallbacks[event.name][i].id == which ||\n                    {\n                        found = true;\n                        index = i;\n                    }\n                }\n\n                if (index !== -1)\n                {\n                    this._eventCallbacks[event.name].splice(index, 1);\n                    delete this._listeners[which];\n                }\n            }\n\n\n            return;\n        }\n\n        this._log.stack(\" old function signature: removeEventListener! use listener id\");\n\n        let index = null;\n        for (let i = 0; i < this._eventCallbacks[which].length; i++)\n            if (this._eventCallbacks[which][i].cb == cb)\n                index = i;\n\n        if (index !== null)\n        {\n            delete this._eventCallbacks[index];\n        }\n        else this._log.warn(\"removeEventListener not found \" + which);\n    };\n\n    this.logEvents = function (enabled, name)\n    {\n        this._logEvents = enabled;\n        this._logName = name;\n    };\n\n    this.emitEvent = function (which, param1, param2, param3, param4, param5, param6)\n    {\n        if (this._logEvents) console.log(\"[event] \", this._logName, which, this._eventCallbacks); // eslint-disable-line\n\n        if (this._eventCallbacks[which])\n        {\n            const execCallbacks = [];\n            for (let i = 0; i < this._eventCallbacks[which].length; i++)\n            {\n                if (!execCallbacks[which]) execCallbacks[which] = [];\n                execCallbacks[which].push(this._eventCallbacks[which][i]);\n            }\n\n            if (execCallbacks[which])\n            {\n                for (let i = 0; i < execCallbacks[which].length; i++)\n                {\n                    if (execCallbacks[which][i])\n                    {\n                        const evName = this.constructor.name + \" \" + which;\n                        CABLES.eventTargetProfile[evName] = (CABLES.eventTargetProfile[evName] || { \"name\": this.constructor.name, \"event\": which, \"count\": 0 });\n                        CABLES.eventTargetProfile[evName].active = this._eventCallbacks[which].length;\n                        CABLES.eventTargetProfile[evName].count++;\n\n                        execCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);\n                    }\n                }\n            }\n        }\n        else\n        {\n            if (this._logEvents) console.log(\"[event] has no event callback\", which, this._eventCallbacks); // eslint-disable-line\n        }\n    };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9ldmVudHRhcmdldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvZXZlbnR0YXJnZXQuanM/YWY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2VyIGZyb20gXCIuL2NvcmVfbG9nZ2VyXCI7XG5cbmNvbnN0IEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiZXZlbnR0YXJnZXRcIik7XG4gICAgdGhpcy5fZXZlbnRDYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLl9sb2dOYW1lID0gXCJcIjtcbiAgICB0aGlzLl9sb2dFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICBDQUJMRVMuZXZlbnRUYXJnZXRQcm9maWxlID0gQ0FCTEVTLmV2ZW50VGFyZ2V0UHJvZmlsZSB8fCB7fTtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IHRoaXMub24gPSBmdW5jdGlvbiAod2hpY2gsIGNiLCBpZFByZWZpeClcbiAgICB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID1cbiAgICAgICAge1xuICAgICAgICAgICAgXCJpZFwiOiAoaWRQcmVmaXggfHwgXCJcIikgKyBDQUJMRVMuc2ltcGxlSWQoKSxcbiAgICAgICAgICAgIFwibmFtZVwiOiB3aGljaCxcbiAgICAgICAgICAgIFwiY2JcIjogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdKSB0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF0gPSBbZXZlbnRdO1xuICAgICAgICBlbHNlIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5wdXNoKGV2ZW50KTtcblxuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnQuaWRdID0gZXZlbnQ7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50LmlkO1xuICAgIH07XG5cbiAgICB0aGlzLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAod2hpY2gsIGNiKVxuICAgIHtcbiAgICAgICAgaWYgKHdoaWNoICYmICFjYilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY2hlY2sgYnkgaWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbd2hpY2hdKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJvbGQgZXZlbnR0YXJnZXQgZnVuY3Rpb24gaGFzZXZlbnRsaXN0ZW5lciFcIik7XG4gICAgICAgICAgICBpZiAod2hpY2ggJiYgY2IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5pbmRleE9mKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gdGhpcy5vZmYgPSBmdW5jdGlvbiAod2hpY2gsIGNiKVxuICAgIHtcbiAgICAgICAgaWYgKHdoaWNoID09PSBudWxsIHx8IHdoaWNoID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoIWNiKSAvLyBuZXcgc3R5bGUsIHJlbW92ZSBieSBpZCwgbm90IGJ5IG5hbWUvY2FsbGJhY2tcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9saXN0ZW5lcnNbd2hpY2hdO1xuICAgICAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvdWxkIG5vdCBmaW5kIGV2ZW50Li4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnQubmFtZV0ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnQubmFtZV1baV0uaWQuaW5kZXhPZih3aGljaCkgPT09IDApIC8vIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50Lm5hbWVdW2ldLmlkID09IHdoaWNoIHx8XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudC5uYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3doaWNoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwiIG9sZCBmdW5jdGlvbiBzaWduYXR1cmU6IHJlbW92ZUV2ZW50TGlzdGVuZXIhIHVzZSBsaXN0ZW5lciBpZFwiKTtcblxuICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF1baV0uY2IgPT0gY2IpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMuX2xvZy53YXJuKFwicmVtb3ZlRXZlbnRMaXN0ZW5lciBub3QgZm91bmQgXCIgKyB3aGljaCk7XG4gICAgfTtcblxuICAgIHRoaXMubG9nRXZlbnRzID0gZnVuY3Rpb24gKGVuYWJsZWQsIG5hbWUpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2dFdmVudHMgPSBlbmFibGVkO1xuICAgICAgICB0aGlzLl9sb2dOYW1lID0gbmFtZTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0RXZlbnQgPSBmdW5jdGlvbiAod2hpY2gsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01LCBwYXJhbTYpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fbG9nRXZlbnRzKSBjb25zb2xlLmxvZyhcIltldmVudF0gXCIsIHRoaXMuX2xvZ05hbWUsIHdoaWNoLCB0aGlzLl9ldmVudENhbGxiYWNrcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBleGVjQ2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNDYWxsYmFja3Nbd2hpY2hdKSBleGVjQ2FsbGJhY2tzW3doaWNoXSA9IFtdO1xuICAgICAgICAgICAgICAgIGV4ZWNDYWxsYmFja3Nbd2hpY2hdLnB1c2godGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4ZWNDYWxsYmFja3Nbd2hpY2hdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhlY0NhbGxiYWNrc1t3aGljaF0ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY0NhbGxiYWNrc1t3aGljaF1baV0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2TmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIFwiICsgd2hpY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDQUJMRVMuZXZlbnRUYXJnZXRQcm9maWxlW2V2TmFtZV0gPSAoQ0FCTEVTLmV2ZW50VGFyZ2V0UHJvZmlsZVtldk5hbWVdIHx8IHsgXCJuYW1lXCI6IHRoaXMuY29uc3RydWN0b3IubmFtZSwgXCJldmVudFwiOiB3aGljaCwgXCJjb3VudFwiOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ0FCTEVTLmV2ZW50VGFyZ2V0UHJvZmlsZVtldk5hbWVdLmFjdGl2ZSA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBDQUJMRVMuZXZlbnRUYXJnZXRQcm9maWxlW2V2TmFtZV0uY291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0NhbGxiYWNrc1t3aGljaF1baV0uY2IocGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUsIHBhcmFtNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9nRXZlbnRzKSBjb25zb2xlLmxvZyhcIltldmVudF0gaGFzIG5vIGV2ZW50IGNhbGxiYWNrXCIsIHdoaWNoLCB0aGlzLl9ldmVudENhbGxiYWNrcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnQgeyBFdmVudFRhcmdldCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/eventtarget.js\n");

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl */ \"./src/core/cgl/index.js\");\n/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64 */ \"./src/core/base64.js\");\n/* harmony import */ var _eventtarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eventtarget */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.js\");\n/* harmony import */ var _anim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anim */ \"./src/core/anim.js\");\n/* harmony import */ var _core_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core_link */ \"./src/core/core_link.js\");\n/* harmony import */ var _core_port__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core_port */ \"./src/core/core_port.js\");\n/* harmony import */ var _core_op__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core_op */ \"./src/core/core_op.js\");\n/* harmony import */ var _embedding__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./embedding */ \"./src/core/embedding.js\");\n/* harmony import */ var _core_profiler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core_profiler */ \"./src/core/core_profiler.js\");\n/* harmony import */ var _core_patch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core_patch */ \"./src/core/core_patch.js\");\n/* harmony import */ var _instancing__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./instancing */ \"./src/core/instancing.js\");\n/* harmony import */ var _loadingstatus__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./loadingstatus */ \"./src/core/loadingstatus.js\");\n/* harmony import */ var _webaudio__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./webaudio */ \"./src/core/webaudio.js\");\n/* harmony import */ var _sessionvar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sessionvar */ \"./src/core/sessionvar.js\");\n/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./timer */ \"./src/core/timer.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/* harmony import */ var _banchprofiler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./banchprofiler */ \"./src/core/banchprofiler.js\");\n/* harmony import */ var _cgp__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cgp */ \"./src/core/cgp/index.js\");\n/* harmony import */ var _cg_cg_constants__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./cg/cg_constants */ \"./src/core/cg/cg_constants.js\");\n // * if you remove this, the project wont build CGL properly.. wtf?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwindow.CABLES = window.CABLES || {};\n\nCABLES.CG = _cg_cg_constants__WEBPACK_IMPORTED_MODULE_19__.CG;\nCABLES.CGP = _cgp__WEBPACK_IMPORTED_MODULE_18__.CGP;\nCABLES.EventTarget = _eventtarget__WEBPACK_IMPORTED_MODULE_2__.EventTarget;\nCABLES.EMBED = _embedding__WEBPACK_IMPORTED_MODULE_8__.EMBED;\nCABLES.Link = _core_link__WEBPACK_IMPORTED_MODULE_5__.Link;\nCABLES.Port = _core_port__WEBPACK_IMPORTED_MODULE_6__.Port;\nCABLES.Op = _core_op__WEBPACK_IMPORTED_MODULE_7__.Op;\nCABLES.Profiler = _core_profiler__WEBPACK_IMPORTED_MODULE_9__.Profiler;\nCABLES.Patch = _core_patch__WEBPACK_IMPORTED_MODULE_10__[\"default\"];\nCABLES.Instancing = _instancing__WEBPACK_IMPORTED_MODULE_11__.Instancing;\nCABLES.Timer = _timer__WEBPACK_IMPORTED_MODULE_15__.Timer;\nCABLES.WEBAUDIO = _webaudio__WEBPACK_IMPORTED_MODULE_13__.WEBAUDIO;\nCABLES.Variable = _sessionvar__WEBPACK_IMPORTED_MODULE_14__.Variable;\nCABLES.LoadingStatus = _loadingstatus__WEBPACK_IMPORTED_MODULE_12__.LoadingStatus;\nCABLES.now = _timer__WEBPACK_IMPORTED_MODULE_15__.now;\nCABLES.internalNow = _timer__WEBPACK_IMPORTED_MODULE_15__.internalNow;\nCABLES.BranchStack = _banchprofiler__WEBPACK_IMPORTED_MODULE_17__.BranchStack;\nCABLES.Branch = _banchprofiler__WEBPACK_IMPORTED_MODULE_17__.Branch;\n\n\nCABLES = Object.assign(CABLES,\n    _base64__WEBPACK_IMPORTED_MODULE_1__,\n    _utils__WEBPACK_IMPORTED_MODULE_3__,\n    _anim__WEBPACK_IMPORTED_MODULE_4__,\n    _constants__WEBPACK_IMPORTED_MODULE_16__.CONSTANTS.PORT,\n    _constants__WEBPACK_IMPORTED_MODULE_16__.CONSTANTS.PACO,\n    _constants__WEBPACK_IMPORTED_MODULE_16__.CONSTANTS.ANIM,\n    _constants__WEBPACK_IMPORTED_MODULE_16__.CONSTANTS.OP\n);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CABLES);\n\nif (!(function () { return !this; }())) console.warn(\"not in strict mode: index core\"); // eslint-disable-line\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvaW5kZXguanM/YzdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDR0wgfSBmcm9tIFwiLi9jZ2xcIjsgLy8gKiBpZiB5b3UgcmVtb3ZlIHRoaXMsIHRoZSBwcm9qZWN0IHdvbnQgYnVpbGQgQ0dMIHByb3Blcmx5Li4gd3RmP1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gXCIuL2Jhc2U2NFwiO1xuaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudHRhcmdldFwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCAqIGFzIGFuaW0gZnJvbSBcIi4vYW5pbVwiO1xuaW1wb3J0IHsgTGluayB9IGZyb20gXCIuL2NvcmVfbGlua1wiO1xuaW1wb3J0IHsgUG9ydCB9IGZyb20gXCIuL2NvcmVfcG9ydFwiO1xuaW1wb3J0IHsgT3AgfSBmcm9tIFwiLi9jb3JlX29wXCI7XG5pbXBvcnQgeyBFTUJFRCB9IGZyb20gXCIuL2VtYmVkZGluZ1wiO1xuaW1wb3J0IHsgUHJvZmlsZXIgfSBmcm9tIFwiLi9jb3JlX3Byb2ZpbGVyXCI7XG5pbXBvcnQgUGF0Y2ggZnJvbSBcIi4vY29yZV9wYXRjaFwiO1xuaW1wb3J0IHsgSW5zdGFuY2luZyB9IGZyb20gXCIuL2luc3RhbmNpbmdcIjtcbmltcG9ydCB7IExvYWRpbmdTdGF0dXMgfSBmcm9tIFwiLi9sb2FkaW5nc3RhdHVzXCI7XG5pbXBvcnQgeyBXRUJBVURJTyB9IGZyb20gXCIuL3dlYmF1ZGlvXCI7XG5pbXBvcnQgeyBWYXJpYWJsZSB9IGZyb20gXCIuL3Nlc3Npb252YXJcIjtcbmltcG9ydCB7IFRpbWVyLCBub3csIGludGVybmFsTm93IH0gZnJvbSBcIi4vdGltZXJcIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQnJhbmNoU3RhY2ssIEJyYW5jaCB9IGZyb20gXCIuL2JhbmNocHJvZmlsZXJcIjtcbmltcG9ydCB7IENHUCB9IGZyb20gXCIuL2NncFwiO1xuaW1wb3J0IHsgQ0cgfSBmcm9tIFwiLi9jZy9jZ19jb25zdGFudHNcIjtcblxud2luZG93LkNBQkxFUyA9IHdpbmRvdy5DQUJMRVMgfHwge307XG5cbkNBQkxFUy5DRyA9IENHO1xuQ0FCTEVTLkNHUCA9IENHUDtcbkNBQkxFUy5FdmVudFRhcmdldCA9IEV2ZW50VGFyZ2V0O1xuQ0FCTEVTLkVNQkVEID0gRU1CRUQ7XG5DQUJMRVMuTGluayA9IExpbms7XG5DQUJMRVMuUG9ydCA9IFBvcnQ7XG5DQUJMRVMuT3AgPSBPcDtcbkNBQkxFUy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuQ0FCTEVTLlBhdGNoID0gUGF0Y2g7XG5DQUJMRVMuSW5zdGFuY2luZyA9IEluc3RhbmNpbmc7XG5DQUJMRVMuVGltZXIgPSBUaW1lcjtcbkNBQkxFUy5XRUJBVURJTyA9IFdFQkFVRElPO1xuQ0FCTEVTLlZhcmlhYmxlID0gVmFyaWFibGU7XG5DQUJMRVMuTG9hZGluZ1N0YXR1cyA9IExvYWRpbmdTdGF0dXM7XG5DQUJMRVMubm93ID0gbm93O1xuQ0FCTEVTLmludGVybmFsTm93ID0gaW50ZXJuYWxOb3c7XG5DQUJMRVMuQnJhbmNoU3RhY2sgPSBCcmFuY2hTdGFjaztcbkNBQkxFUy5CcmFuY2ggPSBCcmFuY2g7XG5cblxuQ0FCTEVTID0gT2JqZWN0LmFzc2lnbihDQUJMRVMsXG4gICAgYmFzZTY0LFxuICAgIHV0aWxzLFxuICAgIGFuaW0sXG4gICAgQ09OU1RBTlRTLlBPUlQsXG4gICAgQ09OU1RBTlRTLlBBQ08sXG4gICAgQ09OU1RBTlRTLkFOSU0sXG4gICAgQ09OU1RBTlRTLk9QXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBDQUJMRVM7XG5cbmlmICghKGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzOyB9KCkpKSBjb25zb2xlLndhcm4oXCJub3QgaW4gc3RyaWN0IG1vZGU6IGluZGV4IGNvcmVcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/index.js\n");

/***/ }),

/***/ "./src/core/instancing.js":
/*!********************************!*\
  !*** ./src/core/instancing.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Instancing\": () => (/* binding */ Instancing)\n/* harmony export */ });\n// todo: needs to be removed...\n\nconst Instancing = function ()\n{\n    this._loops = [];\n    this._indizes = [];\n    this._index = 0;\n};\n\nInstancing.prototype.pushLoop = function (maxNum)\n{\n    this._loops.push(Math.abs(Math.floor(maxNum)));\n    this._indizes.push(this._index);\n};\n\nInstancing.prototype.popLoop = function ()\n{\n    this._loops.pop();\n    // this._index--;\n    this._index = this._indizes.pop();\n    if (this._loops.length === 0) this._index = 0;\n};\n\nInstancing.prototype.numLoops = function ()\n{\n    return this._loops.length;\n};\n\nInstancing.prototype.numCycles = function ()\n{\n    if (this._loops.length === 0) return 0;\n    let num = this._loops[0];\n    for (let i = 1; i < this._loops.length; i++) num *= this._loops[i];\n\n    return num;\n};\n\nInstancing.prototype.inLoop = function ()\n{\n    return this._loops.length > 0;\n};\n\nInstancing.prototype.increment = function ()\n{\n    this._index++;\n};\n\nInstancing.prototype.index = function ()\n{\n    return this._index;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9pbnN0YW5jaW5nLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvaW5zdGFuY2luZy5qcz8xZTQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRvZG86IG5lZWRzIHRvIGJlIHJlbW92ZWQuLi5cblxuY29uc3QgSW5zdGFuY2luZyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbG9vcHMgPSBbXTtcbiAgICB0aGlzLl9pbmRpemVzID0gW107XG4gICAgdGhpcy5faW5kZXggPSAwO1xufTtcblxuSW5zdGFuY2luZy5wcm90b3R5cGUucHVzaExvb3AgPSBmdW5jdGlvbiAobWF4TnVtKVxue1xuICAgIHRoaXMuX2xvb3BzLnB1c2goTWF0aC5hYnMoTWF0aC5mbG9vcihtYXhOdW0pKSk7XG4gICAgdGhpcy5faW5kaXplcy5wdXNoKHRoaXMuX2luZGV4KTtcbn07XG5cbkluc3RhbmNpbmcucHJvdG90eXBlLnBvcExvb3AgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2xvb3BzLnBvcCgpO1xuICAgIC8vIHRoaXMuX2luZGV4LS07XG4gICAgdGhpcy5faW5kZXggPSB0aGlzLl9pbmRpemVzLnBvcCgpO1xuICAgIGlmICh0aGlzLl9sb29wcy5sZW5ndGggPT09IDApIHRoaXMuX2luZGV4ID0gMDtcbn07XG5cbkluc3RhbmNpbmcucHJvdG90eXBlLm51bUxvb3BzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fbG9vcHMubGVuZ3RoO1xufTtcblxuSW5zdGFuY2luZy5wcm90b3R5cGUubnVtQ3ljbGVzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fbG9vcHMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICBsZXQgbnVtID0gdGhpcy5fbG9vcHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9sb29wcy5sZW5ndGg7IGkrKykgbnVtICo9IHRoaXMuX2xvb3BzW2ldO1xuXG4gICAgcmV0dXJuIG51bTtcbn07XG5cbkluc3RhbmNpbmcucHJvdG90eXBlLmluTG9vcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2xvb3BzLmxlbmd0aCA+IDA7XG59O1xuXG5JbnN0YW5jaW5nLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2luZGV4Kys7XG59O1xuXG5JbnN0YW5jaW5nLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xufTtcblxuZXhwb3J0IHsgSW5zdGFuY2luZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/instancing.js\n");

/***/ }),

/***/ "./src/core/loadingstatus.js":
/*!***********************************!*\
  !*** ./src/core/loadingstatus.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoadingStatus\": () => (/* binding */ LoadingStatus)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.js\");\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core_logger */ \"./src/core/core_logger.js\");\n\n\n\n/**\n * LoadingStatus class, manages asynchronous loading jobs\n *\n * @external CABLES\n * @namespace LoadingStatus\n * @hideconstructor\n * @class\n */\nconst LoadingStatus = function (patch)\n{\n    CABLES.EventTarget.apply(this);\n\n    this._log = new _core_logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"LoadingStatus\");\n    this._loadingAssets = {};\n    this._cbFinished = [];\n    this._assetTasks = [];\n    this._percent = 0;\n    this._count = 0;\n    this._countFinished = 0;\n    this._order = 0;\n    this._startTime = 0;\n    this._patch = patch;\n    this._wasFinishedPrinted = false;\n    this._loadingAssetTaskCb = false;\n};\n\nLoadingStatus.prototype.setOnFinishedLoading = function (cb)\n{\n    this._cbFinished.push(cb);\n};\n\nLoadingStatus.prototype.getNumAssets = function ()\n{\n    return this._countFinished;\n};\n\nLoadingStatus.prototype.getProgress = function ()\n{\n    return this._percent;\n};\n\nLoadingStatus.prototype.checkStatus = function ()\n{\n    this._countFinished = 0;\n    this._count = 0;\n\n    for (const i in this._loadingAssets)\n    {\n        this._count++;\n        if (!this._loadingAssets[i].finished)\n        {\n            this._countFinished++;\n        }\n    }\n\n    this._percent = (this._count - this._countFinished) / this._count;\n\n    if (this._countFinished === 0)\n    {\n        for (let j = 0; j < this._cbFinished.length; j++)\n        {\n            if (this._cbFinished[j])\n            {\n                const cb = this._cbFinished[j];\n                setTimeout(() => { cb(this._patch); this.emitEvent(\"finishedAll\"); }, 100);\n            }\n        }\n\n        if (!this._wasFinishedPrinted)\n        {\n            this._wasFinishedPrinted = true;\n            this.print();\n        }\n        this.emitEvent(\"finishedAll\");\n    }\n};\n\nLoadingStatus.prototype.getList = function ()\n{\n    let arr = [];\n    for (const i in this._loadingAssets)\n    {\n        arr.push(this._loadingAssets[i]);\n    }\n\n    return arr;\n};\n\n\nLoadingStatus.prototype.getListJobs = function ()\n{\n    let arr = [];\n    for (const i in this._loadingAssets)\n    {\n        if (!this._loadingAssets[i].finished)arr.push(this._loadingAssets[i].name);\n    }\n\n    return arr;\n};\n\nLoadingStatus.prototype.print = function ()\n{\n    if (this._patch.config.silent) return;\n\n    const rows = [];\n\n    for (const i in this._loadingAssets)\n    {\n        rows.push([\n            this._loadingAssets[i].order,\n            this._loadingAssets[i].type,\n            this._loadingAssets[i].name,\n            (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) / 1000 + \"s\",\n        ]);\n    }\n\n    this._log.groupCollapsed(\n        \"finished loading \" + this._order + \" assets in \" + (Date.now() - this._startTime) / 1000 + \"s\",\n    );\n    this._log.table(rows);\n    this._log.groupEnd();\n};\n\nLoadingStatus.prototype.finished = function (id)\n{\n    const l = this._loadingAssets[id];\n    if (l)\n    {\n        if (l.finished) this._log.warn(\"loading job was already finished\", l);\n\n        if (l.op) l.op.setUiAttribs({ \"loading\": false });\n        l.finished = true;\n        l.timeEnd = Date.now();\n    }\n\n    this.checkStatus();\n    this.emitEvent(\"finishedTask\");\n};\n\nLoadingStatus.prototype._startAssetTasks = function ()\n{\n    for (let i = 0; i < this._assetTasks.length; i++) this._assetTasks[i]();\n    this._assetTasks.length = 0;\n};\n\n/**\n * delay an asset loading task, mainly to wait for ui to be finished loading and showing, and only then start loading assets\n * @function addAssetLoadingTask\n * @instance\n * @memberof Op\n * @param {function} callback\n */\nLoadingStatus.prototype.addAssetLoadingTask = function (cb)\n{\n    if (this._patch.isEditorMode() && !CABLES.UI.loaded)\n    {\n        this._assetTasks.push(cb);\n\n        if (!this._loadingAssetTaskCb)window.gui.addEventListener(\"uiloaded\", this._startAssetTasks.bind(this));\n        this._loadingAssetTaskCb = true;\n    }\n    else\n    {\n        cb();\n    }\n    this.emitEvent(\"addAssetTask\");\n};\n\nLoadingStatus.prototype.existByName = function (name)\n{\n    for (let i in this._loadingAssets)\n    {\n        if (this._loadingAssets[i].name == name && !this._loadingAssets[i].finished)\n        {\n            return true;\n        }\n    }\n};\n\nLoadingStatus.prototype.start = function (type, name, op)\n{\n    if (this._startTime == 0) this._startTime = Date.now();\n    const id = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateUUID)();\n\n    if (op)op.setUiAttribs({ \"loading\": true });\n\n    this._loadingAssets[id] = {\n        \"id\": id,\n        \"op\": op,\n        \"type\": type,\n        \"name\": name,\n        \"finished\": false,\n        \"timeStart\": Date.now(),\n        \"order\": this._order,\n    };\n    this._order++;\n\n    this.emitEvent(\"startTask\");\n\n    return id;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9sb2FkaW5nc3RhdHVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9sb2FkaW5nc3RhdHVzLmpzPzFiMzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2VuZXJhdGVVVUlEIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4vY29yZV9sb2dnZXJcIjtcblxuLyoqXG4gKiBMb2FkaW5nU3RhdHVzIGNsYXNzLCBtYW5hZ2VzIGFzeW5jaHJvbm91cyBsb2FkaW5nIGpvYnNcbiAqXG4gKiBAZXh0ZXJuYWwgQ0FCTEVTXG4gKiBAbmFtZXNwYWNlIExvYWRpbmdTdGF0dXNcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICovXG5jb25zdCBMb2FkaW5nU3RhdHVzID0gZnVuY3Rpb24gKHBhdGNoKVxue1xuICAgIENBQkxFUy5FdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJMb2FkaW5nU3RhdHVzXCIpO1xuICAgIHRoaXMuX2xvYWRpbmdBc3NldHMgPSB7fTtcbiAgICB0aGlzLl9jYkZpbmlzaGVkID0gW107XG4gICAgdGhpcy5fYXNzZXRUYXNrcyA9IFtdO1xuICAgIHRoaXMuX3BlcmNlbnQgPSAwO1xuICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICB0aGlzLl9jb3VudEZpbmlzaGVkID0gMDtcbiAgICB0aGlzLl9vcmRlciA9IDA7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLl9wYXRjaCA9IHBhdGNoO1xuICAgIHRoaXMuX3dhc0ZpbmlzaGVkUHJpbnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvYWRpbmdBc3NldFRhc2tDYiA9IGZhbHNlO1xufTtcblxuTG9hZGluZ1N0YXR1cy5wcm90b3R5cGUuc2V0T25GaW5pc2hlZExvYWRpbmcgPSBmdW5jdGlvbiAoY2IpXG57XG4gICAgdGhpcy5fY2JGaW5pc2hlZC5wdXNoKGNiKTtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLmdldE51bUFzc2V0cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50RmluaXNoZWQ7XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5nZXRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3BlcmNlbnQ7XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5jaGVja1N0YXR1cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY291bnRGaW5pc2hlZCA9IDA7XG4gICAgdGhpcy5fY291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2xvYWRpbmdBc3NldHMpXG4gICAge1xuICAgICAgICB0aGlzLl9jb3VudCsrO1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRpbmdBc3NldHNbaV0uZmluaXNoZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50RmluaXNoZWQrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BlcmNlbnQgPSAodGhpcy5fY291bnQgLSB0aGlzLl9jb3VudEZpbmlzaGVkKSAvIHRoaXMuX2NvdW50O1xuXG4gICAgaWYgKHRoaXMuX2NvdW50RmluaXNoZWQgPT09IDApXG4gICAge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2NiRmluaXNoZWQubGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYkZpbmlzaGVkW2pdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdGhpcy5fY2JGaW5pc2hlZFtqXTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgY2IodGhpcy5fcGF0Y2gpOyB0aGlzLmVtaXRFdmVudChcImZpbmlzaGVkQWxsXCIpOyB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93YXNGaW5pc2hlZFByaW50ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3dhc0ZpbmlzaGVkUHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJmaW5pc2hlZEFsbFwiKTtcbiAgICB9XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5nZXRMaXN0ID0gZnVuY3Rpb24gKClcbntcbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2xvYWRpbmdBc3NldHMpXG4gICAge1xuICAgICAgICBhcnIucHVzaCh0aGlzLl9sb2FkaW5nQXNzZXRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5nZXRMaXN0Sm9icyA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9sb2FkaW5nQXNzZXRzKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLmZpbmlzaGVkKWFyci5wdXNoKHRoaXMuX2xvYWRpbmdBc3NldHNbaV0ubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcGF0Y2guY29uZmlnLnNpbGVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2xvYWRpbmdBc3NldHMpXG4gICAge1xuICAgICAgICByb3dzLnB1c2goW1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0Fzc2V0c1tpXS5vcmRlcixcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdBc3NldHNbaV0udHlwZSxcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdBc3NldHNbaV0ubmFtZSxcbiAgICAgICAgICAgICh0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLnRpbWVFbmQgLSB0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLnRpbWVTdGFydCkgLyAxMDAwICsgXCJzXCIsXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHRoaXMuX2xvZy5ncm91cENvbGxhcHNlZChcbiAgICAgICAgXCJmaW5pc2hlZCBsb2FkaW5nIFwiICsgdGhpcy5fb3JkZXIgKyBcIiBhc3NldHMgaW4gXCIgKyAoRGF0ZS5ub3coKSAtIHRoaXMuX3N0YXJ0VGltZSkgLyAxMDAwICsgXCJzXCIsXG4gICAgKTtcbiAgICB0aGlzLl9sb2cudGFibGUocm93cyk7XG4gICAgdGhpcy5fbG9nLmdyb3VwRW5kKCk7XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uIChpZClcbntcbiAgICBjb25zdCBsID0gdGhpcy5fbG9hZGluZ0Fzc2V0c1tpZF07XG4gICAgaWYgKGwpXG4gICAge1xuICAgICAgICBpZiAobC5maW5pc2hlZCkgdGhpcy5fbG9nLndhcm4oXCJsb2FkaW5nIGpvYiB3YXMgYWxyZWFkeSBmaW5pc2hlZFwiLCBsKTtcblxuICAgICAgICBpZiAobC5vcCkgbC5vcC5zZXRVaUF0dHJpYnMoeyBcImxvYWRpbmdcIjogZmFsc2UgfSk7XG4gICAgICAgIGwuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBsLnRpbWVFbmQgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tTdGF0dXMoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcImZpbmlzaGVkVGFza1wiKTtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLl9zdGFydEFzc2V0VGFza3MgPSBmdW5jdGlvbiAoKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXNzZXRUYXNrcy5sZW5ndGg7IGkrKykgdGhpcy5fYXNzZXRUYXNrc1tpXSgpO1xuICAgIHRoaXMuX2Fzc2V0VGFza3MubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogZGVsYXkgYW4gYXNzZXQgbG9hZGluZyB0YXNrLCBtYWlubHkgdG8gd2FpdCBmb3IgdWkgdG8gYmUgZmluaXNoZWQgbG9hZGluZyBhbmQgc2hvd2luZywgYW5kIG9ubHkgdGhlbiBzdGFydCBsb2FkaW5nIGFzc2V0c1xuICogQGZ1bmN0aW9uIGFkZEFzc2V0TG9hZGluZ1Rhc2tcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIE9wXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5hZGRBc3NldExvYWRpbmdUYXNrID0gZnVuY3Rpb24gKGNiKVxue1xuICAgIGlmICh0aGlzLl9wYXRjaC5pc0VkaXRvck1vZGUoKSAmJiAhQ0FCTEVTLlVJLmxvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Fzc2V0VGFza3MucHVzaChjYik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nQXNzZXRUYXNrQ2Ipd2luZG93Lmd1aS5hZGRFdmVudExpc3RlbmVyKFwidWlsb2FkZWRcIiwgdGhpcy5fc3RhcnRBc3NldFRhc2tzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nQXNzZXRUYXNrQ2IgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBjYigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXRFdmVudChcImFkZEFzc2V0VGFza1wiKTtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLmV4aXN0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSBpbiB0aGlzLl9sb2FkaW5nQXNzZXRzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdBc3NldHNbaV0ubmFtZSA9PSBuYW1lICYmICF0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLmZpbmlzaGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIG9wKVxue1xuICAgIGlmICh0aGlzLl9zdGFydFRpbWUgPT0gMCkgdGhpcy5fc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG4gICAgaWYgKG9wKW9wLnNldFVpQXR0cmlicyh7IFwibG9hZGluZ1wiOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5fbG9hZGluZ0Fzc2V0c1tpZF0gPSB7XG4gICAgICAgIFwiaWRcIjogaWQsXG4gICAgICAgIFwib3BcIjogb3AsXG4gICAgICAgIFwidHlwZVwiOiB0eXBlLFxuICAgICAgICBcIm5hbWVcIjogbmFtZSxcbiAgICAgICAgXCJmaW5pc2hlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0aW1lU3RhcnRcIjogRGF0ZS5ub3coKSxcbiAgICAgICAgXCJvcmRlclwiOiB0aGlzLl9vcmRlcixcbiAgICB9O1xuICAgIHRoaXMuX29yZGVyKys7XG5cbiAgICB0aGlzLmVtaXRFdmVudChcInN0YXJ0VGFza1wiKTtcblxuICAgIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydCB7IExvYWRpbmdTdGF0dXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/loadingstatus.js\n");

/***/ }),

/***/ "./src/core/sessionvar.js":
/*!********************************!*\
  !*** ./src/core/sessionvar.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Variable\": () => (/* binding */ Variable)\n/* harmony export */ });\n// todo: old... remove this from ops...\n\nconst Variable = function ()\n{\n    let value = null;\n    const changedCallbacks = [];\n\n    this.onChanged = function (f)\n    {\n        changedCallbacks.push(f);\n    };\n\n    this.getValue = function ()\n    {\n        return value;\n    };\n\n    this.setValue = function (v)\n    {\n        value = v;\n        this.emitChanged();\n    };\n\n    this.emitChanged = function ()\n    {\n        for (let i = 0; i < changedCallbacks.length; i++)\n        {\n            changedCallbacks[i]();\n        }\n    };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9zZXNzaW9udmFyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9zZXNzaW9udmFyLmpzPzcwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdG9kbzogb2xkLi4uIHJlbW92ZSB0aGlzIGZyb20gb3BzLi4uXG5cbmNvbnN0IFZhcmlhYmxlID0gZnVuY3Rpb24gKClcbntcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGNvbnN0IGNoYW5nZWRDYWxsYmFja3MgPSBbXTtcblxuICAgIHRoaXMub25DaGFuZ2VkID0gZnVuY3Rpb24gKGYpXG4gICAge1xuICAgICAgICBjaGFuZ2VkQ2FsbGJhY2tzLnB1c2goZik7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpXG4gICAge1xuICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZWQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZWRDYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNoYW5nZWRDYWxsYmFja3NbaV0oKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnQgeyBWYXJpYWJsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/sessionvar.js\n");

/***/ }),

/***/ "./src/core/timer.js":
/*!***************************!*\
  !*** ./src/core/timer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Timer\": () => (/* binding */ Timer),\n/* harmony export */   \"internalNow\": () => (/* binding */ internalNow),\n/* harmony export */   \"now\": () => (/* binding */ now)\n/* harmony export */ });\n/** @namespace CABLES */\n\nconst internalNow = function ()\n{\n    return window.performance.now();\n};\n\n/**\n * current time in milliseconds\n * @memberof CABLES\n * @function now\n * @static\n */\nconst now = function ()\n{\n    return internalNow();\n};\n\n// ----------------------------\n\n/**\n * Measuring time\n * @external CABLES\n * @namespace Timer\n * @hideconstructor\n * @class\n */\nconst Timer = function ()\n{\n    CABLES.EventTarget.apply(this);\n\n    this._timeStart = internalNow();\n    this._timeOffset = 0;\n\n    this._currentTime = 0;\n    this._lastTime = 0;\n    this._paused = true;\n    this._delay = 0;\n    this.overwriteTime = -1;\n};\n\nTimer.prototype._getTime = function ()\n{\n    this._lastTime = (internalNow() - this._timeStart) / 1000;\n    return this._lastTime + this._timeOffset;\n};\n\nTimer.prototype.setDelay = function (d)\n{\n    this._delay = d;\n    this.emitEvent(\"timeChange\");\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @description returns true if timer is playing\n * @return {Boolean} value\n */\nTimer.prototype.isPlaying = function ()\n{\n    return !this._paused;\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @description update timer\n * @return {Number} time\n */\nTimer.prototype.update = function ()\n{\n    if (this._paused) return;\n    this._currentTime = this._getTime();\n\n    return this._currentTime;\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @return {Number} time in milliseconds\n */\nTimer.prototype.getMillis = function ()\n{\n    return this.get() * 1000;\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @return {Number} value time in seconds\n */\nTimer.prototype.get = Timer.prototype.getTime = function ()\n{\n    if (this.overwriteTime >= 0) return this.overwriteTime - this._delay;\n    return this._currentTime - this._delay;\n};\n\n/**\n * toggle between play/pause state\n * @function\n * @memberof Timer\n * @instance\n */\nTimer.prototype.togglePlay = function ()\n{\n    if (this._paused) this.play();\n    else this.pause();\n};\n\n/**\n * set current time\n * @function\n * @memberof Timer\n * @instance\n * @param {Number} t\n */\nTimer.prototype.setTime = function (t)\n{\n    if (isNaN(t) || t < 0) t = 0;\n    this._timeStart = internalNow();\n    this._timeOffset = t;\n    this._currentTime = t;\n    this.emitEvent(\"timeChange\");\n};\n\nTimer.prototype.setOffset = function (val)\n{\n    if (this._currentTime + val < 0)\n    {\n        this._timeStart = internalNow();\n        this._timeOffset = 0;\n        this._currentTime = 0;\n    }\n    else\n    {\n        this._timeOffset += val;\n        this._currentTime = this._lastTime + this._timeOffset;\n    }\n    this.emitEvent(\"timeChange\");\n};\n\n/**\n * (re)starts the timer\n * @function\n * @memberof Timer\n * @instance\n */\nTimer.prototype.play = function ()\n{\n    this._timeStart = internalNow();\n    this._paused = false;\n    this.emitEvent(\"playPause\");\n};\n\n/**\n * pauses the timer\n * @function\n * @memberof Timer\n * @instance\n */\nTimer.prototype.pause = function ()\n{\n    this._timeOffset = this._currentTime;\n    this._paused = true;\n    this.emitEvent(\"playPause\");\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS90aW1lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS90aW1lci5qcz85NGQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbmFtZXNwYWNlIENBQkxFUyAqL1xuXG5leHBvcnQgY29uc3QgaW50ZXJuYWxOb3cgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqIEBtZW1iZXJvZiBDQUJMRVNcbiAqIEBmdW5jdGlvbiBub3dcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IG5vdyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIGludGVybmFsTm93KCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogTWVhc3VyaW5nIHRpbWVcbiAqIEBleHRlcm5hbCBDQUJMRVNcbiAqIEBuYW1lc3BhY2UgVGltZXJcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICovXG5jb25zdCBUaW1lciA9IGZ1bmN0aW9uICgpXG57XG4gICAgQ0FCTEVTLkV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5fdGltZVN0YXJ0ID0gaW50ZXJuYWxOb3coKTtcbiAgICB0aGlzLl90aW1lT2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLl9sYXN0VGltZSA9IDA7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9kZWxheSA9IDA7XG4gICAgdGhpcy5vdmVyd3JpdGVUaW1lID0gLTE7XG59O1xuXG5UaW1lci5wcm90b3R5cGUuX2dldFRpbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2xhc3RUaW1lID0gKGludGVybmFsTm93KCkgLSB0aGlzLl90aW1lU3RhcnQpIC8gMTAwMDtcbiAgICByZXR1cm4gdGhpcy5fbGFzdFRpbWUgKyB0aGlzLl90aW1lT2Zmc2V0O1xufTtcblxuVGltZXIucHJvdG90eXBlLnNldERlbGF5ID0gZnVuY3Rpb24gKGQpXG57XG4gICAgdGhpcy5fZGVsYXkgPSBkO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwidGltZUNoYW5nZVwiKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgdHJ1ZSBpZiB0aW1lciBpcyBwbGF5aW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufSB2YWx1ZVxuICovXG5UaW1lci5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSB0aW1lclxuICogQHJldHVybiB7TnVtYmVyfSB0aW1lXG4gKi9cblRpbWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9wYXVzZWQpIHJldHVybjtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRoaXMuX2dldFRpbWUoKTtcblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGltZTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7TnVtYmVyfSB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICovXG5UaW1lci5wcm90b3R5cGUuZ2V0TWlsbGlzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5nZXQoKSAqIDEwMDA7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFRpbWVyXG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgdGltZSBpbiBzZWNvbmRzXG4gKi9cblRpbWVyLnByb3RvdHlwZS5nZXQgPSBUaW1lci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMub3ZlcndyaXRlVGltZSA+PSAwKSByZXR1cm4gdGhpcy5vdmVyd3JpdGVUaW1lIC0gdGhpcy5fZGVsYXk7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lIC0gdGhpcy5fZGVsYXk7XG59O1xuXG4vKipcbiAqIHRvZ2dsZSBiZXR3ZWVuIHBsYXkvcGF1c2Ugc3RhdGVcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFRpbWVyXG4gKiBAaW5zdGFuY2VcbiAqL1xuVGltZXIucHJvdG90eXBlLnRvZ2dsZVBsYXkgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9wYXVzZWQpIHRoaXMucGxheSgpO1xuICAgIGVsc2UgdGhpcy5wYXVzZSgpO1xufTtcblxuLyoqXG4gKiBzZXQgY3VycmVudCB0aW1lXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBUaW1lclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICovXG5UaW1lci5wcm90b3R5cGUuc2V0VGltZSA9IGZ1bmN0aW9uICh0KVxue1xuICAgIGlmIChpc05hTih0KSB8fCB0IDwgMCkgdCA9IDA7XG4gICAgdGhpcy5fdGltZVN0YXJ0ID0gaW50ZXJuYWxOb3coKTtcbiAgICB0aGlzLl90aW1lT2Zmc2V0ID0gdDtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IHQ7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJ0aW1lQ2hhbmdlXCIpO1xufTtcblxuVGltZXIucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uICh2YWwpXG57XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUaW1lICsgdmFsIDwgMClcbiAgICB7XG4gICAgICAgIHRoaXMuX3RpbWVTdGFydCA9IGludGVybmFsTm93KCk7XG4gICAgICAgIHRoaXMuX3RpbWVPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX3RpbWVPZmZzZXQgKz0gdmFsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRoaXMuX2xhc3RUaW1lICsgdGhpcy5fdGltZU9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJ0aW1lQ2hhbmdlXCIpO1xufTtcblxuLyoqXG4gKiAocmUpc3RhcnRzIHRoZSB0aW1lclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICovXG5UaW1lci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fdGltZVN0YXJ0ID0gaW50ZXJuYWxOb3coKTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXRFdmVudChcInBsYXlQYXVzZVwiKTtcbn07XG5cbi8qKlxuICogcGF1c2VzIHRoZSB0aW1lclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICovXG5UaW1lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3RpbWVPZmZzZXQgPSB0aGlzLl9jdXJyZW50VGltZTtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicGxheVBhdXNlXCIpO1xufTtcblxuZXhwb3J0IHsgVGltZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/timer.js\n");

/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UTILS\": () => (/* binding */ UTILS),\n/* harmony export */   \"ajax\": () => (/* binding */ ajax),\n/* harmony export */   \"ajaxSync\": () => (/* binding */ ajaxSync),\n/* harmony export */   \"basename\": () => (/* binding */ basename),\n/* harmony export */   \"cacheBust\": () => (/* binding */ cacheBust),\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"cleanJson\": () => (/* binding */ cleanJson),\n/* harmony export */   \"copyArray\": () => (/* binding */ copyArray),\n/* harmony export */   \"filename\": () => (/* binding */ filename),\n/* harmony export */   \"generateUUID\": () => (/* binding */ generateUUID),\n/* harmony export */   \"getShortOpName\": () => (/* binding */ getShortOpName),\n/* harmony export */   \"keyCodeToName\": () => (/* binding */ keyCodeToName),\n/* harmony export */   \"logStack\": () => (/* binding */ logStack),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"prefixedHash\": () => (/* binding */ prefixedHash),\n/* harmony export */   \"request\": () => (/* binding */ request),\n/* harmony export */   \"shortId\": () => (/* binding */ shortId),\n/* harmony export */   \"shuffleArray\": () => (/* binding */ shuffleArray),\n/* harmony export */   \"simpleId\": () => (/* binding */ simpleId),\n/* harmony export */   \"smoothStep\": () => (/* binding */ smoothStep),\n/* harmony export */   \"smootherStep\": () => (/* binding */ smootherStep),\n/* harmony export */   \"uuid\": () => (/* binding */ uuid)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n\n/**\n * @external CABLES\n * @namespace Utils\n */\n\n\n\nconst UTILS = {};\n/**\n * Merge two Float32Arrays.\n * @function float32Concat\n * @memberof Utils\n * @param {Float32Array} first Left-hand side array\n * @param {Float32Array} second Right-hand side array\n * @return {Float32Array}\n * @static\n */\nUTILS.float32Concat = function (first, second)\n{\n    if (!(first instanceof Float32Array)) first = new Float32Array(first);\n    if (!(second instanceof Float32Array)) second = new Float32Array(second);\n\n    const result = new Float32Array(first.length + second.length);\n\n    result.set(first);\n    result.set(second, first.length);\n\n    return result;\n};\n\n/**\n * get op shortname: only last part of fullname and without version\n * @function getShortOpName\n * @memberof CABLES\n * @param {String} full op name\n * @static\n */\nconst getShortOpName = function (fullname)\n{\n    let name = fullname.split(\".\")[fullname.split(\".\").length - 1];\n\n    if (name.indexOf(_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_VERSION_PREFIX) > 0)\n    {\n        const n = name.split(_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_VERSION_PREFIX)[1];\n        name = name.substring(0, name.length - (_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_VERSION_PREFIX + n).length);\n    }\n    return name;\n};\n\n/**\n * randomize order of an array\n * @function shuffleArray\n * @memberof Utils\n * @param {Array|Float32Array} array {Array} original\n * @return {Array|Float32Array} shuffled array\n * @static\n */\nconst shuffleArray = function (array)\n{\n    for (let i = array.length - 1; i > 0; i--)\n    {\n        const j = Math.floor(Math.seededRandom() * (i + 1));\n        const temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return array;\n};\n\n\n/**\n * generate a short \"relativly unique\" id\n * @function shortId\n * @memberof Utils\n * @return {String} generated ID\n * @static\n */\n\nconst _shortIds = {};\nconst _shortId = function ()\n{\n    let str = Math.random().toString(36).substr(2, 9);\n\n    if (_shortIds.hasOwnProperty(str)) str = _shortId();\n    _shortIds[str] = true;\n    return str;\n};\nconst shortId = _shortId;\n\n\n/**\n * generate a UUID\n * @function uuid\n * @memberof Utils\n * @return {String} generated UUID\n * @static\n */\nconst _uuid = function ()\n{\n    let d = new Date().getTime();\n    const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) =>\n    {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n    });\n    return uuid;\n};\nconst uuid = _uuid;\nconst generateUUID = _uuid;\n\n\n\nfunction cleanJson(obj)\n{\n    for (const i in obj)\n    {\n        if (obj[i] && typeof objValue === \"object\" && obj[i].constructor === Object) obj[i] = cleanJson(obj[i]);\n\n        if (obj[i] === null || obj[i] === undefined) delete obj[i];\n        else if (Array.isArray(obj[i]) && obj[i].length == 0) delete obj[i];\n    }\n\n    return obj;\n}\n\n\n/**\n * @see http://stackoverflow.com/q/7616461/940217\n * @return {string}\n */\nconst _prefixedHash = function (str, prefix = \"id\")\n{\n    let hash = 0;\n    if (Array.prototype.reduce)\n    {\n        hash = str.split(\"\").reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0);\n    }\n    else\n    {\n        if (str.length > 0)\n        {\n            for (let i = 0; i < str.length; i++)\n            {\n                let character = str.charCodeAt(i);\n                hash = ((hash << 5) - hash) + character;\n                hash &= hash; // Convert to 32bit integer\n            }\n        }\n    }\n    return prefix + \"\" + hash;\n};\nconst prefixedHash = _prefixedHash;\n\n/**\n * generate a simple ID\n * @function simpleId\n * @memberof Utils\n * @return {Number} new id\n * @static\n */\nlet simpleIdCounter = 0;\nconst simpleId = function ()\n{\n    simpleIdCounter++;\n    return simpleIdCounter;\n};\n\n/**\n * smoothStep a value\n * @function smoothStep\n * @memberof Utils\n * @function\n * @param {Number} value value to be smoothed [0-1]\n * @return {Number} smoothed value\n * @static\n */\nconst smoothStep = function (perc)\n{\n    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));\n    perc = x * x * (3 - 2 * x); // smoothstep\n    return perc;\n};\n\n/**\n * smootherstep a value\n * @function smootherStep\n * @memberof Utils\n * @param value {Number} value to be smoothed [0-1]\n * @return {Number} smoothed value\n * @static\n */\nconst smootherStep = function (perc)\n{\n    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));\n    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep\n    return perc;\n};\n\n\n/**\n * clamp number / make sure its between min/max\n * @function map\n * @memberof Utils\n * @param {Number} value value to be mapped\n * @param {Number} min minimum value\n * @param {Number} max maximum value\n * @static\n */\nconst clamp = function (value, min, max)\n{\n    return Math.min(Math.max(value, min), max);\n};\n\n/**\n * map a value in a range to a value in another range\n * @function map\n * @memberof Utils\n * @param {Number} value value to be mapped\n * @param {Number} oldMin old range minimum value\n * @param {Number} oldMax old range maximum value\n * @param {Number} newMin new range minimum value\n * @param {Number} newMax new range maximum value\n * @return {Number} mapped value\n * @static\n */\nconst map = function (x, _oldMin, _oldMax, _newMin, _newMax, _easing)\n{\n    if (x >= _oldMax) return _newMax;\n    if (x <= _oldMin) return _newMin;\n\n    let reverseInput = false;\n    const oldMin = Math.min(_oldMin, _oldMax);\n    const oldMax = Math.max(_oldMin, _oldMax);\n    if (oldMin != _oldMin) reverseInput = true;\n\n    let reverseOutput = false;\n    const newMin = Math.min(_newMin, _newMax);\n    const newMax = Math.max(_newMin, _newMax);\n    if (newMin != _newMin) reverseOutput = true;\n\n    let portion = 0;\n    let r = 0;\n\n    if (reverseInput) portion = ((oldMax - x) * (newMax - newMin)) / (oldMax - oldMin);\n    else portion = ((x - oldMin) * (newMax - newMin)) / (oldMax - oldMin);\n\n    if (reverseOutput) r = newMax - portion;\n    else r = portion + newMin;\n\n    if (!_easing) return r;\n    if (_easing == 1)\n    {\n        // smoothstep\n        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));\n        return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);\n    }\n    if (_easing == 2)\n    {\n        // smootherstep\n        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));\n        return _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin);\n    }\n\n    return r;\n};\n\n/**\n * @namespace Math\n */\n/**\n * set random seed for seededRandom()\n * @memberof Math\n * @type Number\n * @static\n */\nMath.randomSeed = 1;\n\n/**\n * generate a seeded random number\n * @function seededRandom\n * @memberof Math\n * @param {Number} max minimum possible random number\n * @param {Number} min maximum possible random number\n * @return {Number} random value\n * @static\n */\nMath.seededRandom = function (max, min)\n{\n    if (Math.randomSeed === 0) Math.randomSeed = Math.random() * 999;\n    max = max || 1;\n    min = min || 0;\n\n    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;\n    const rnd = Math.randomSeed / 233280.0;\n\n    return min + rnd * (max - min);\n};\n\n// ----------------------------------------------------------------\n\nUTILS.arrayWriteToEnd = function (arr, v)\n{\n    for (let i = 1; i < arr.length; i++) arr[i - 1] = arr[i];\n    arr[arr.length - 1] = v;\n};\n\n// ----------------------------------------------------------------\n\n/**\n * returns true if parameter is a number\n * @function isNumeric\n * @memberof Utils\n * @param {Any} value The value to check.\n * @return {Boolean}\n * @static\n */\nUTILS.isNumeric = function (n)\n{\n    return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n/**\n * returns true if parameter is array\n * @function isArray\n * @param {Any} value Value to check\n * @memberof Utils\n * @return {Boolean}\n * @static\n */\nUTILS.isArray = function (v)\n{\n    return Object.prototype.toString.call(v) === \"[object Array]\";\n};\n\n/**\n * @namespace String\n */\n\n/**\n * append a linebreak to a string\n * @function endl\n * @memberof String\n * @return {String} string with newline break appended ('\\n')\n */\nString.prototype.endl = function ()\n{\n    return this + \"\\n\";\n};\n\n/**\n * return true if string starts with prefix\n * @function startsWith\n * @memberof String\n * @param {String} prefix The prefix to check.\n * @return {Boolean}\n */\nString.prototype.startsWith = function (prefix)\n{\n    return this.indexOf(prefix) === 0;\n};\n\n/**\n * return true if string ends with suffix\n * @function endsWith\n * @memberof String\n * @param {String} suffix\n * @return {Boolean}\n */\nString.prototype.endsWith = String.prototype.endsWith || function (suffix)\n{\n    return this.match(suffix + \"$\") == suffix;\n};\n\n// ----------------------------------------------------------------\n\n/**\n * append a unique/random parameter to a url, so the browser is forced to reload the file, even if its cached\n * @function cacheBust\n * @static\n * @memberof Utils\n * @param {String} url The url to append the cachebuster parameter to.\n * @return {String} url with cachebuster parameter\n */\nconst cacheBust = function (url)\n{\n    if (url.indexOf(\"?\") > -1) url += \"&\";\n    else url += \"?\";\n    return url + \"cache=\" + CABLES.uuid();\n};\n\n/**\n * copy the content of an array\n * @function copyArray\n * @static\n * @memberof Utils\n * @param {Array} sourceArray\n * @param {Array} dst optional\n * @return {Array} dst\n */\nconst copyArray = function (src, dst)\n{\n    if (!src) return null;\n    dst = dst || [];\n    dst.length = src.length;\n    for (let i = 0; i < src.length; i++)\n    {\n        dst[i] = src[i];\n    }\n\n    return dst;\n};\n\n\n/**\n * return the filename part of a url without extension\n * @function basename\n * @static\n * @memberof Utils\n * @param {String} url\n * @return {String} just the filename\n */\nconst basename = function (url)\n{\n    let name = CABLES.filename(url);\n\n    const parts2 = name.split(\".\");\n    name = parts2[0];\n\n    return name;\n};\n\n/**\n * output a stacktrace to the console\n * @function logStack\n * @static\n * @memberof Utils\n */\nconst logStack = function ()\n{\n    console.log(\"logstack\", (new Error()).stack);\n};\n\n/**\n * return the filename part of a url\n * @function filename\n * @static\n * @memberof Utils\n * @param {String} url\n * @return {String} just the filename\n */\nconst filename = function (url)\n{\n    let name = \"\";\n    if (!url) return \"\";\n\n    if (url.indexOf(\"data:\") == 0 && url.indexOf(\":\") > -1)\n    {\n        const parts = url.split(\",\");\n        return parts[0];\n    }\n\n    const parts = (url + \"\").split(\"/\");\n    if (parts.length > 0)\n    {\n        const str = parts[parts.length - 1];\n        let parts2 = str.split(\"?\");\n        name = parts2[0];\n    }\n\n    return name || \"\";\n};\n\n\nconst ajaxSync = function (url, cb, method, post, contenttype)\n{\n    request({\n        url,\n        cb,\n        method,\n        \"data\": post,\n        contenttype,\n        \"sync\": true,\n    });\n};\n\n/**\n * make an ajax request\n * @function ajax\n * @static\n */\nconst ajax = function (url, cb, method, post, contenttype, jsonP, headers = {})\n{\n    request({\n        \"url\": url,\n        \"cb\": cb,\n        \"method\": method,\n        \"data\": post,\n        \"contenttype\": contenttype,\n        \"sync\": false,\n        \"jsonP\": jsonP,\n        \"headers\": headers,\n    });\n};\n\nconst request = function (options)\n{\n    if (!options.hasOwnProperty(\"asynch\")) options.asynch = true;\n\n    let xhr;\n    try\n    {\n        xhr = new XMLHttpRequest();\n    }\n    catch (e) {}\n\n    xhr.onreadystatechange = function ()\n    {\n        if (xhr.readyState != 4) return;\n\n        if (options.cb)\n        {\n            if (xhr.status == 200 || xhr.status == 0) options.cb(false, xhr.responseText, xhr);\n            else options.cb(true, xhr.responseText, xhr);\n        }\n    };\n\n    xhr.addEventListener(\"progress\", (ev) =>\n    {\n        // console.log('progress',ev.loaded/1024+' kb');\n        // if (ev.lengthComputable)\n        // {\n        //     var percentComplete = ev.loaded / ev.total;\n        //     console.log(url,percentComplete);\n        // }\n    });\n\n    try\n    {\n        xhr.open(options.method ? options.method.toUpperCase() : \"GET\", options.url, !options.sync);\n    }\n    catch (e)\n    {\n        if (options.cb) options.cb(true, e.msg, xhr);\n    }\n\n    if (typeof options.headers === \"object\")\n    {\n        const keys = Object.keys(options.headers);\n        for (let i = 0; i < keys.length; i++)\n        {\n            const name = keys[i];\n            const value = options.headers[name];\n            xhr.setRequestHeader(name, value);\n        }\n    }\n\n    try\n    {\n        if (!options.post && !options.data)\n        {\n            xhr.send();\n        }\n        else\n        {\n            xhr.setRequestHeader(\n                \"Content-type\",\n                options.contenttype ? options.contenttype : \"application/x-www-form-urlencoded\",\n            );\n            xhr.send(options.data || options.post);\n        }\n    }\n    catch (e)\n    {\n        if (options.cb) options.cb(true, e.msg, xhr);\n    }\n};\n\n\nconst keyCodeToName = function (keyCode)\n{\n    if (!keyCode && keyCode !== 0) return \"Unidentified\";\n    const keys = {\n        \"8\": \"Backspace\",\n        \"9\": \"Tab\",\n        \"12\": \"Clear\",\n        \"13\": \"Enter\",\n        \"16\": \"Shift\",\n        \"17\": \"Control\",\n        \"18\": \"Alt\",\n        \"19\": \"Pause\",\n        \"20\": \"CapsLock\",\n        \"27\": \"Escape\",\n        \"32\": \"Space\",\n        \"33\": \"PageUp\",\n        \"34\": \"PageDown\",\n        \"35\": \"End\",\n        \"36\": \"Home\",\n        \"37\": \"ArrowLeft\",\n        \"38\": \"ArrowUp\",\n        \"39\": \"ArrowRight\",\n        \"40\": \"ArrowDown\",\n        \"45\": \"Insert\",\n        \"46\": \"Delete\",\n        \"112\": \"F1\",\n        \"113\": \"F2\",\n        \"114\": \"F3\",\n        \"115\": \"F4\",\n        \"116\": \"F5\",\n        \"117\": \"F6\",\n        \"118\": \"F7\",\n        \"119\": \"F8\",\n        \"120\": \"F9\",\n        \"121\": \"F10\",\n        \"122\": \"F11\",\n        \"123\": \"F12\",\n        \"144\": \"NumLock\",\n        \"145\": \"ScrollLock\",\n        \"224\": \"Meta\"\n    };\n    if (keys[keyCode])\n    {\n        return keys[keyCode];\n    }\n    else\n    {\n        return String.fromCharCode(keyCode);\n    }\n};\n// ----------------------------------------------------------------\n\nwindow.performance = window.performance || {\n    \"offset\": Date.now(),\n    \"now\": function now()\n    {\n        return Date.now() - this.offset;\n    },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS91dGlscy5qcz9iMWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZXh0ZXJuYWwgQ0FCTEVTXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKi9cblxuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IFVUSUxTID0ge307XG4vKipcbiAqIE1lcmdlIHR3byBGbG9hdDMyQXJyYXlzLlxuICogQGZ1bmN0aW9uIGZsb2F0MzJDb25jYXRcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZpcnN0IExlZnQtaGFuZCBzaWRlIGFycmF5XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gc2Vjb25kIFJpZ2h0LWhhbmQgc2lkZSBhcnJheVxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fVxuICogQHN0YXRpY1xuICovXG5VVElMUy5mbG9hdDMyQ29uY2F0ID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpXG57XG4gICAgaWYgKCEoZmlyc3QgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSBmaXJzdCA9IG5ldyBGbG9hdDMyQXJyYXkoZmlyc3QpO1xuICAgIGlmICghKHNlY29uZCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHNlY29uZCA9IG5ldyBGbG9hdDMyQXJyYXkoc2Vjb25kKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoZmlyc3QubGVuZ3RoICsgc2Vjb25kLmxlbmd0aCk7XG5cbiAgICByZXN1bHQuc2V0KGZpcnN0KTtcbiAgICByZXN1bHQuc2V0KHNlY29uZCwgZmlyc3QubGVuZ3RoKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGdldCBvcCBzaG9ydG5hbWU6IG9ubHkgbGFzdCBwYXJ0IG9mIGZ1bGxuYW1lIGFuZCB3aXRob3V0IHZlcnNpb25cbiAqIEBmdW5jdGlvbiBnZXRTaG9ydE9wTmFtZVxuICogQG1lbWJlcm9mIENBQkxFU1xuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGwgb3AgbmFtZVxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0U2hvcnRPcE5hbWUgPSBmdW5jdGlvbiAoZnVsbG5hbWUpXG57XG4gICAgbGV0IG5hbWUgPSBmdWxsbmFtZS5zcGxpdChcIi5cIilbZnVsbG5hbWUuc3BsaXQoXCIuXCIpLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG5hbWUuaW5kZXhPZihDT05TVEFOVFMuT1AuT1BfVkVSU0lPTl9QUkVGSVgpID4gMClcbiAgICB7XG4gICAgICAgIGNvbnN0IG4gPSBuYW1lLnNwbGl0KENPTlNUQU5UUy5PUC5PUF9WRVJTSU9OX1BSRUZJWClbMV07XG4gICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIChDT05TVEFOVFMuT1AuT1BfVkVSU0lPTl9QUkVGSVggKyBuKS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cbi8qKlxuICogcmFuZG9taXplIG9yZGVyIG9mIGFuIGFycmF5XG4gKiBAZnVuY3Rpb24gc2h1ZmZsZUFycmF5XG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl8RmxvYXQzMkFycmF5fSBhcnJheSB7QXJyYXl9IG9yaWdpbmFsXG4gKiBAcmV0dXJuIHtBcnJheXxGbG9hdDMyQXJyYXl9IHNodWZmbGVkIGFycmF5XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydCBjb25zdCBzaHVmZmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpXG57XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXG4gICAge1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnNlZWRlZFJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgYXJyYXlbal0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8qKlxuICogZ2VuZXJhdGUgYSBzaG9ydCBcInJlbGF0aXZseSB1bmlxdWVcIiBpZFxuICogQGZ1bmN0aW9uIHNob3J0SWRcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHJldHVybiB7U3RyaW5nfSBnZW5lcmF0ZWQgSURcbiAqIEBzdGF0aWNcbiAqL1xuXG5jb25zdCBfc2hvcnRJZHMgPSB7fTtcbmNvbnN0IF9zaG9ydElkID0gZnVuY3Rpb24gKClcbntcbiAgICBsZXQgc3RyID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xuXG4gICAgaWYgKF9zaG9ydElkcy5oYXNPd25Qcm9wZXJ0eShzdHIpKSBzdHIgPSBfc2hvcnRJZCgpO1xuICAgIF9zaG9ydElkc1tzdHJdID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RyO1xufTtcbmV4cG9ydCBjb25zdCBzaG9ydElkID0gX3Nob3J0SWQ7XG5cblxuLyoqXG4gKiBnZW5lcmF0ZSBhIFVVSURcbiAqIEBmdW5jdGlvbiB1dWlkXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEByZXR1cm4ge1N0cmluZ30gZ2VuZXJhdGVkIFVVSURcbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgX3V1aWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdXVpZCA9IFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCAoYykgPT5cbiAgICB7XG4gICAgICAgIGNvbnN0IHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgICAgIHJldHVybiAoYyA9PSBcInhcIiA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdXVpZDtcbn07XG5leHBvcnQgY29uc3QgdXVpZCA9IF91dWlkO1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlVVVJRCA9IF91dWlkO1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuSnNvbihvYmopXG57XG4gICAgZm9yIChjb25zdCBpIGluIG9iailcbiAgICB7XG4gICAgICAgIGlmIChvYmpbaV0gJiYgdHlwZW9mIG9ialZhbHVlID09PSBcIm9iamVjdFwiICYmIG9ialtpXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSBvYmpbaV0gPSBjbGVhbkpzb24ob2JqW2ldKTtcblxuICAgICAgICBpZiAob2JqW2ldID09PSBudWxsIHx8IG9ialtpXSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgb2JqW2ldO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtpXSkgJiYgb2JqW2ldLmxlbmd0aCA9PSAwKSBkZWxldGUgb2JqW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzc2MTY0NjEvOTQwMjE3XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IF9wcmVmaXhlZEhhc2ggPSBmdW5jdGlvbiAoc3RyLCBwcmVmaXggPSBcImlkXCIpXG57XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUucmVkdWNlKVxuICAgIHtcbiAgICAgICAgaGFzaCA9IHN0ci5zcGxpdChcIlwiKS5yZWR1Y2UoKGEsIGIpID0+IHsgYSA9ICgoYSA8PCA1KSAtIGEpICsgYi5jaGFyQ29kZUF0KDApOyByZXR1cm4gYSAmIGE7IH0sIDApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBjaGFyYWN0ZXIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgaGFzaCAmPSBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZml4ICsgXCJcIiArIGhhc2g7XG59O1xuZXhwb3J0IGNvbnN0IHByZWZpeGVkSGFzaCA9IF9wcmVmaXhlZEhhc2g7XG5cbi8qKlxuICogZ2VuZXJhdGUgYSBzaW1wbGUgSURcbiAqIEBmdW5jdGlvbiBzaW1wbGVJZFxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG5ldyBpZFxuICogQHN0YXRpY1xuICovXG5sZXQgc2ltcGxlSWRDb3VudGVyID0gMDtcbmV4cG9ydCBjb25zdCBzaW1wbGVJZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgc2ltcGxlSWRDb3VudGVyKys7XG4gICAgcmV0dXJuIHNpbXBsZUlkQ291bnRlcjtcbn07XG5cbi8qKlxuICogc21vb3RoU3RlcCBhIHZhbHVlXG4gKiBAZnVuY3Rpb24gc21vb3RoU3RlcFxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBiZSBzbW9vdGhlZCBbMC0xXVxuICogQHJldHVybiB7TnVtYmVyfSBzbW9vdGhlZCB2YWx1ZVxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3Qgc21vb3RoU3RlcCA9IGZ1bmN0aW9uIChwZXJjKVxue1xuICAgIGNvbnN0IHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGVyYyAtIDApIC8gKDEgLSAwKSkpO1xuICAgIHBlcmMgPSB4ICogeCAqICgzIC0gMiAqIHgpOyAvLyBzbW9vdGhzdGVwXG4gICAgcmV0dXJuIHBlcmM7XG59O1xuXG4vKipcbiAqIHNtb290aGVyc3RlcCBhIHZhbHVlXG4gKiBAZnVuY3Rpb24gc21vb3RoZXJTdGVwXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfSB2YWx1ZSB0byBiZSBzbW9vdGhlZCBbMC0xXVxuICogQHJldHVybiB7TnVtYmVyfSBzbW9vdGhlZCB2YWx1ZVxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3Qgc21vb3RoZXJTdGVwID0gZnVuY3Rpb24gKHBlcmMpXG57XG4gICAgY29uc3QgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChwZXJjIC0gMCkgLyAoMSAtIDApKSk7XG4gICAgcGVyYyA9IHggKiB4ICogeCAqICh4ICogKHggKiA2IC0gMTUpICsgMTApOyAvLyBzbW9vdGhlcnN0ZXBcbiAgICByZXR1cm4gcGVyYztcbn07XG5cblxuLyoqXG4gKiBjbGFtcCBudW1iZXIgLyBtYWtlIHN1cmUgaXRzIGJldHdlZW4gbWluL21heFxuICogQGZ1bmN0aW9uIG1hcFxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gYmUgbWFwcGVkXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIG1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KVxue1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn07XG5cbi8qKlxuICogbWFwIGEgdmFsdWUgaW4gYSByYW5nZSB0byBhIHZhbHVlIGluIGFub3RoZXIgcmFuZ2VcbiAqIEBmdW5jdGlvbiBtYXBcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIGJlIG1hcHBlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9sZE1pbiBvbGQgcmFuZ2UgbWluaW11bSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG9sZE1heCBvbGQgcmFuZ2UgbWF4aW11bSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG5ld01pbiBuZXcgcmFuZ2UgbWluaW11bSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG5ld01heCBuZXcgcmFuZ2UgbWF4aW11bSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSBtYXBwZWQgdmFsdWVcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uICh4LCBfb2xkTWluLCBfb2xkTWF4LCBfbmV3TWluLCBfbmV3TWF4LCBfZWFzaW5nKVxue1xuICAgIGlmICh4ID49IF9vbGRNYXgpIHJldHVybiBfbmV3TWF4O1xuICAgIGlmICh4IDw9IF9vbGRNaW4pIHJldHVybiBfbmV3TWluO1xuXG4gICAgbGV0IHJldmVyc2VJbnB1dCA9IGZhbHNlO1xuICAgIGNvbnN0IG9sZE1pbiA9IE1hdGgubWluKF9vbGRNaW4sIF9vbGRNYXgpO1xuICAgIGNvbnN0IG9sZE1heCA9IE1hdGgubWF4KF9vbGRNaW4sIF9vbGRNYXgpO1xuICAgIGlmIChvbGRNaW4gIT0gX29sZE1pbikgcmV2ZXJzZUlucHV0ID0gdHJ1ZTtcblxuICAgIGxldCByZXZlcnNlT3V0cHV0ID0gZmFsc2U7XG4gICAgY29uc3QgbmV3TWluID0gTWF0aC5taW4oX25ld01pbiwgX25ld01heCk7XG4gICAgY29uc3QgbmV3TWF4ID0gTWF0aC5tYXgoX25ld01pbiwgX25ld01heCk7XG4gICAgaWYgKG5ld01pbiAhPSBfbmV3TWluKSByZXZlcnNlT3V0cHV0ID0gdHJ1ZTtcblxuICAgIGxldCBwb3J0aW9uID0gMDtcbiAgICBsZXQgciA9IDA7XG5cbiAgICBpZiAocmV2ZXJzZUlucHV0KSBwb3J0aW9uID0gKChvbGRNYXggLSB4KSAqIChuZXdNYXggLSBuZXdNaW4pKSAvIChvbGRNYXggLSBvbGRNaW4pO1xuICAgIGVsc2UgcG9ydGlvbiA9ICgoeCAtIG9sZE1pbikgKiAobmV3TWF4IC0gbmV3TWluKSkgLyAob2xkTWF4IC0gb2xkTWluKTtcblxuICAgIGlmIChyZXZlcnNlT3V0cHV0KSByID0gbmV3TWF4IC0gcG9ydGlvbjtcbiAgICBlbHNlIHIgPSBwb3J0aW9uICsgbmV3TWluO1xuXG4gICAgaWYgKCFfZWFzaW5nKSByZXR1cm4gcjtcbiAgICBpZiAoX2Vhc2luZyA9PSAxKVxuICAgIHtcbiAgICAgICAgLy8gc21vb3Roc3RlcFxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHIgLSBfbmV3TWluKSAvIChfbmV3TWF4IC0gX25ld01pbikpKTtcbiAgICAgICAgcmV0dXJuIF9uZXdNaW4gKyB4ICogeCAqICgzIC0gMiAqIHgpICogKF9uZXdNYXggLSBfbmV3TWluKTtcbiAgICB9XG4gICAgaWYgKF9lYXNpbmcgPT0gMilcbiAgICB7XG4gICAgICAgIC8vIHNtb290aGVyc3RlcFxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHIgLSBfbmV3TWluKSAvIChfbmV3TWF4IC0gX25ld01pbikpKTtcbiAgICAgICAgcmV0dXJuIF9uZXdNaW4gKyB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKSAqIChfbmV3TWF4IC0gX25ld01pbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgTWF0aFxuICovXG4vKipcbiAqIHNldCByYW5kb20gc2VlZCBmb3Igc2VlZGVkUmFuZG9tKClcbiAqIEBtZW1iZXJvZiBNYXRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aC5yYW5kb21TZWVkID0gMTtcblxuLyoqXG4gKiBnZW5lcmF0ZSBhIHNlZWRlZCByYW5kb20gbnVtYmVyXG4gKiBAZnVuY3Rpb24gc2VlZGVkUmFuZG9tXG4gKiBAbWVtYmVyb2YgTWF0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBtaW5pbXVtIHBvc3NpYmxlIHJhbmRvbSBudW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbWF4aW11bSBwb3NzaWJsZSByYW5kb20gbnVtYmVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJhbmRvbSB2YWx1ZVxuICogQHN0YXRpY1xuICovXG5NYXRoLnNlZWRlZFJhbmRvbSA9IGZ1bmN0aW9uIChtYXgsIG1pbilcbntcbiAgICBpZiAoTWF0aC5yYW5kb21TZWVkID09PSAwKSBNYXRoLnJhbmRvbVNlZWQgPSBNYXRoLnJhbmRvbSgpICogOTk5O1xuICAgIG1heCA9IG1heCB8fCAxO1xuICAgIG1pbiA9IG1pbiB8fCAwO1xuXG4gICAgTWF0aC5yYW5kb21TZWVkID0gKE1hdGgucmFuZG9tU2VlZCAqIDkzMDEgKyA0OTI5NykgJSAyMzMyODA7XG4gICAgY29uc3Qgcm5kID0gTWF0aC5yYW5kb21TZWVkIC8gMjMzMjgwLjA7XG5cbiAgICByZXR1cm4gbWluICsgcm5kICogKG1heCAtIG1pbik7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblVUSUxTLmFycmF5V3JpdGVUb0VuZCA9IGZ1bmN0aW9uIChhcnIsIHYpXG57XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycltpIC0gMV0gPSBhcnJbaV07XG4gICAgYXJyW2Fyci5sZW5ndGggLSAxXSA9IHY7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIHBhcmFtZXRlciBpcyBhIG51bWJlclxuICogQGZ1bmN0aW9uIGlzTnVtZXJpY1xuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzdGF0aWNcbiAqL1xuVVRJTFMuaXNOdW1lcmljID0gZnVuY3Rpb24gKG4pXG57XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIHBhcmFtZXRlciBpcyBhcnJheVxuICogQGZ1bmN0aW9uIGlzQXJyYXlcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHN0YXRpY1xuICovXG5VVElMUy5pc0FycmF5ID0gZnVuY3Rpb24gKHYpXG57XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIFN0cmluZ1xuICovXG5cbi8qKlxuICogYXBwZW5kIGEgbGluZWJyZWFrIHRvIGEgc3RyaW5nXG4gKiBAZnVuY3Rpb24gZW5kbFxuICogQG1lbWJlcm9mIFN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgd2l0aCBuZXdsaW5lIGJyZWFrIGFwcGVuZGVkICgnXFxuJylcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5lbmRsID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcyArIFwiXFxuXCI7XG59O1xuXG4vKipcbiAqIHJldHVybiB0cnVlIGlmIHN0cmluZyBzdGFydHMgd2l0aCBwcmVmaXhcbiAqIEBmdW5jdGlvbiBzdGFydHNXaXRoXG4gKiBAbWVtYmVyb2YgU3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAocHJlZml4KVxue1xuICAgIHJldHVybiB0aGlzLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgc3RyaW5nIGVuZHMgd2l0aCBzdWZmaXhcbiAqIEBmdW5jdGlvbiBlbmRzV2l0aFxuICogQG1lbWJlcm9mIFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN1ZmZpeFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggfHwgZnVuY3Rpb24gKHN1ZmZpeClcbntcbiAgICByZXR1cm4gdGhpcy5tYXRjaChzdWZmaXggKyBcIiRcIikgPT0gc3VmZml4O1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIGFwcGVuZCBhIHVuaXF1ZS9yYW5kb20gcGFyYW1ldGVyIHRvIGEgdXJsLCBzbyB0aGUgYnJvd3NlciBpcyBmb3JjZWQgdG8gcmVsb2FkIHRoZSBmaWxlLCBldmVuIGlmIGl0cyBjYWNoZWRcbiAqIEBmdW5jdGlvbiBjYWNoZUJ1c3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsIHRvIGFwcGVuZCB0aGUgY2FjaGVidXN0ZXIgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybiB7U3RyaW5nfSB1cmwgd2l0aCBjYWNoZWJ1c3RlciBwYXJhbWV0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNhY2hlQnVzdCA9IGZ1bmN0aW9uICh1cmwpXG57XG4gICAgaWYgKHVybC5pbmRleE9mKFwiP1wiKSA+IC0xKSB1cmwgKz0gXCImXCI7XG4gICAgZWxzZSB1cmwgKz0gXCI/XCI7XG4gICAgcmV0dXJuIHVybCArIFwiY2FjaGU9XCIgKyBDQUJMRVMudXVpZCgpO1xufTtcblxuLyoqXG4gKiBjb3B5IHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gKiBAZnVuY3Rpb24gY29weUFycmF5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZUFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBkc3Qgb3B0aW9uYWxcbiAqIEByZXR1cm4ge0FycmF5fSBkc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlBcnJheSA9IGZ1bmN0aW9uIChzcmMsIGRzdClcbntcbiAgICBpZiAoIXNyYykgcmV0dXJuIG51bGw7XG4gICAgZHN0ID0gZHN0IHx8IFtdO1xuICAgIGRzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBkc3Q7XG59O1xuXG5cbi8qKlxuICogcmV0dXJuIHRoZSBmaWxlbmFtZSBwYXJ0IG9mIGEgdXJsIHdpdGhvdXQgZXh0ZW5zaW9uXG4gKiBAZnVuY3Rpb24gYmFzZW5hbWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHJldHVybiB7U3RyaW5nfSBqdXN0IHRoZSBmaWxlbmFtZVxuICovXG5leHBvcnQgY29uc3QgYmFzZW5hbWUgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIGxldCBuYW1lID0gQ0FCTEVTLmZpbGVuYW1lKHVybCk7XG5cbiAgICBjb25zdCBwYXJ0czIgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBuYW1lID0gcGFydHMyWzBdO1xuXG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIG91dHB1dCBhIHN0YWNrdHJhY2UgdG8gdGhlIGNvbnNvbGVcbiAqIEBmdW5jdGlvbiBsb2dTdGFja1xuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFV0aWxzXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dTdGFjayA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc29sZS5sb2coXCJsb2dzdGFja1wiLCAobmV3IEVycm9yKCkpLnN0YWNrKTtcbn07XG5cbi8qKlxuICogcmV0dXJuIHRoZSBmaWxlbmFtZSBwYXJ0IG9mIGEgdXJsXG4gKiBAZnVuY3Rpb24gZmlsZW5hbWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHJldHVybiB7U3RyaW5nfSBqdXN0IHRoZSBmaWxlbmFtZVxuICovXG5leHBvcnQgY29uc3QgZmlsZW5hbWUgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIGxldCBuYW1lID0gXCJcIjtcbiAgICBpZiAoIXVybCkgcmV0dXJuIFwiXCI7XG5cbiAgICBpZiAodXJsLmluZGV4T2YoXCJkYXRhOlwiKSA9PSAwICYmIHVybC5pbmRleE9mKFwiOlwiKSA+IC0xKVxuICAgIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB1cmwuc3BsaXQoXCIsXCIpO1xuICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSAodXJsICsgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc3RyID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBwYXJ0czIgPSBzdHIuc3BsaXQoXCI/XCIpO1xuICAgICAgICBuYW1lID0gcGFydHMyWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lIHx8IFwiXCI7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBhamF4U3luYyA9IGZ1bmN0aW9uICh1cmwsIGNiLCBtZXRob2QsIHBvc3QsIGNvbnRlbnR0eXBlKVxue1xuICAgIHJlcXVlc3Qoe1xuICAgICAgICB1cmwsXG4gICAgICAgIGNiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIFwiZGF0YVwiOiBwb3N0LFxuICAgICAgICBjb250ZW50dHlwZSxcbiAgICAgICAgXCJzeW5jXCI6IHRydWUsXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIG1ha2UgYW4gYWpheCByZXF1ZXN0XG4gKiBAZnVuY3Rpb24gYWpheFxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgYWpheCA9IGZ1bmN0aW9uICh1cmwsIGNiLCBtZXRob2QsIHBvc3QsIGNvbnRlbnR0eXBlLCBqc29uUCwgaGVhZGVycyA9IHt9KVxue1xuICAgIHJlcXVlc3Qoe1xuICAgICAgICBcInVybFwiOiB1cmwsXG4gICAgICAgIFwiY2JcIjogY2IsXG4gICAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgICAgXCJkYXRhXCI6IHBvc3QsXG4gICAgICAgIFwiY29udGVudHR5cGVcIjogY29udGVudHR5cGUsXG4gICAgICAgIFwic3luY1wiOiBmYWxzZSxcbiAgICAgICAgXCJqc29uUFwiOiBqc29uUCxcbiAgICAgICAgXCJoZWFkZXJzXCI6IGhlYWRlcnMsXG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKVxue1xuICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImFzeW5jaFwiKSkgb3B0aW9ucy5hc3luY2ggPSB0cnVlO1xuXG4gICAgbGV0IHhocjtcbiAgICB0cnlcbiAgICB7XG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge31cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9IDQpIHJldHVybjtcblxuICAgICAgICBpZiAob3B0aW9ucy5jYilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCkgb3B0aW9ucy5jYihmYWxzZSwgeGhyLnJlc3BvbnNlVGV4dCwgeGhyKTtcbiAgICAgICAgICAgIGVsc2Ugb3B0aW9ucy5jYih0cnVlLCB4aHIucmVzcG9uc2VUZXh0LCB4aHIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKGV2KSA9PlxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Byb2dyZXNzJyxldi5sb2FkZWQvMTAyNCsnIGtiJyk7XG4gICAgICAgIC8vIGlmIChldi5sZW5ndGhDb21wdXRhYmxlKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICB2YXIgcGVyY2VudENvbXBsZXRlID0gZXYubG9hZGVkIC8gZXYudG90YWw7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyh1cmwscGVyY2VudENvbXBsZXRlKTtcbiAgICAgICAgLy8gfVxuICAgIH0pO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiLCBvcHRpb25zLnVybCwgIW9wdGlvbnMuc3luYyk7XG4gICAgfVxuICAgIGNhdGNoIChlKVxuICAgIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2IpIG9wdGlvbnMuY2IodHJ1ZSwgZS5tc2csIHhocik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlcnMgPT09IFwib2JqZWN0XCIpXG4gICAge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5oZWFkZXJzW25hbWVdO1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICBpZiAoIW9wdGlvbnMucG9zdCAmJiAhb3B0aW9ucy5kYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LXR5cGVcIixcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRlbnR0eXBlID8gb3B0aW9ucy5jb250ZW50dHlwZSA6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeGhyLnNlbmQob3B0aW9ucy5kYXRhIHx8IG9wdGlvbnMucG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpXG4gICAge1xuICAgICAgICBpZiAob3B0aW9ucy5jYikgb3B0aW9ucy5jYih0cnVlLCBlLm1zZywgeGhyKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydCBjb25zdCBrZXlDb2RlVG9OYW1lID0gZnVuY3Rpb24gKGtleUNvZGUpXG57XG4gICAgaWYgKCFrZXlDb2RlICYmIGtleUNvZGUgIT09IDApIHJldHVybiBcIlVuaWRlbnRpZmllZFwiO1xuICAgIGNvbnN0IGtleXMgPSB7XG4gICAgICAgIFwiOFwiOiBcIkJhY2tzcGFjZVwiLFxuICAgICAgICBcIjlcIjogXCJUYWJcIixcbiAgICAgICAgXCIxMlwiOiBcIkNsZWFyXCIsXG4gICAgICAgIFwiMTNcIjogXCJFbnRlclwiLFxuICAgICAgICBcIjE2XCI6IFwiU2hpZnRcIixcbiAgICAgICAgXCIxN1wiOiBcIkNvbnRyb2xcIixcbiAgICAgICAgXCIxOFwiOiBcIkFsdFwiLFxuICAgICAgICBcIjE5XCI6IFwiUGF1c2VcIixcbiAgICAgICAgXCIyMFwiOiBcIkNhcHNMb2NrXCIsXG4gICAgICAgIFwiMjdcIjogXCJFc2NhcGVcIixcbiAgICAgICAgXCIzMlwiOiBcIlNwYWNlXCIsXG4gICAgICAgIFwiMzNcIjogXCJQYWdlVXBcIixcbiAgICAgICAgXCIzNFwiOiBcIlBhZ2VEb3duXCIsXG4gICAgICAgIFwiMzVcIjogXCJFbmRcIixcbiAgICAgICAgXCIzNlwiOiBcIkhvbWVcIixcbiAgICAgICAgXCIzN1wiOiBcIkFycm93TGVmdFwiLFxuICAgICAgICBcIjM4XCI6IFwiQXJyb3dVcFwiLFxuICAgICAgICBcIjM5XCI6IFwiQXJyb3dSaWdodFwiLFxuICAgICAgICBcIjQwXCI6IFwiQXJyb3dEb3duXCIsXG4gICAgICAgIFwiNDVcIjogXCJJbnNlcnRcIixcbiAgICAgICAgXCI0NlwiOiBcIkRlbGV0ZVwiLFxuICAgICAgICBcIjExMlwiOiBcIkYxXCIsXG4gICAgICAgIFwiMTEzXCI6IFwiRjJcIixcbiAgICAgICAgXCIxMTRcIjogXCJGM1wiLFxuICAgICAgICBcIjExNVwiOiBcIkY0XCIsXG4gICAgICAgIFwiMTE2XCI6IFwiRjVcIixcbiAgICAgICAgXCIxMTdcIjogXCJGNlwiLFxuICAgICAgICBcIjExOFwiOiBcIkY3XCIsXG4gICAgICAgIFwiMTE5XCI6IFwiRjhcIixcbiAgICAgICAgXCIxMjBcIjogXCJGOVwiLFxuICAgICAgICBcIjEyMVwiOiBcIkYxMFwiLFxuICAgICAgICBcIjEyMlwiOiBcIkYxMVwiLFxuICAgICAgICBcIjEyM1wiOiBcIkYxMlwiLFxuICAgICAgICBcIjE0NFwiOiBcIk51bUxvY2tcIixcbiAgICAgICAgXCIxNDVcIjogXCJTY3JvbGxMb2NrXCIsXG4gICAgICAgIFwiMjI0XCI6IFwiTWV0YVwiXG4gICAgfTtcbiAgICBpZiAoa2V5c1trZXlDb2RlXSlcbiAgICB7XG4gICAgICAgIHJldHVybiBrZXlzW2tleUNvZGVdO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICB9XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG53aW5kb3cucGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwge1xuICAgIFwib2Zmc2V0XCI6IERhdGUubm93KCksXG4gICAgXCJub3dcIjogZnVuY3Rpb24gbm93KClcbiAgICB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5vZmZzZXQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IFVUSUxTIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/utils.js\n");

/***/ }),

/***/ "./src/core/webaudio.js":
/*!******************************!*\
  !*** ./src/core/webaudio.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WEBAUDIO\": () => (/* binding */ WEBAUDIO)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\n/** @namespace WEBAUDIO */\n\n\n\nconst WEBAUDIO = {};\n\nWEBAUDIO.toneJsInitialized = false;\n\n/*\n * External JSDoc definitions\n */\n\n/**\n * Part of the Web Audio API, the AudioBuffer interface represents a short audio asset residing in memory.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer}\n */\n\n/**\n * Part of the Web Audio API, the AudioNode interface is a generic interface for representing an audio processing module.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode}\n */\n\n/**\n * The AudioContext interface represents an audio-processing graph built from audio modules linked together\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}\n */\n\n/**\n * Checks if a global audio context has been created and creates\n * it if necessary. This audio context can be used for native Web Audio as well as Tone.js ops.\n * Associates the audio context with Tone.js if it is being used\n * @param {CABLES.Op} op - The operator which needs the Audio Context\n */\nWEBAUDIO.createAudioContext = function (op)\n{\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (window.AudioContext)\n    {\n        if (!window.audioContext)\n        {\n            window.audioContext = new AudioContext();\n        }\n        // check if tone.js lib is being used\n        if (window.Tone && !WEBAUDIO.toneJsInitialized)\n        {\n            // set current audio context in tone.js\n            Tone.setContext(window.audioContext);\n            WEBAUDIO.toneJsInitialized = true;\n        }\n    }\n    else\n    {\n        op.patch.config.onError(\"NO_WEBAUDIO\", \"Web Audio is not supported in this browser.\");\n        return;\n    }\n    return window.audioContext;\n};\n\n/**\n * Returns the audio context.\n * Before `createAudioContext` must have been called at least once.\n * It most cases you should use `createAudioContext`, which just returns the audio context\n * when it has been created already.\n */\nWEBAUDIO.getAudioContext = function ()\n{\n    return window.audioContext;\n};\n\n/**\n * Creates an audio in port for the op with name `portName`\n * When disconnected it will disconnect the previous connected audio node\n * from the op's audio node.\n * @param {CABLES.Op} op - The operator to create the audio port in\n * @param {string} portName - The name of the port\n * @param {AudioNode} audioNode - The audionode incoming connections should connect to\n * @param {number} [inputChannelIndex=0] - If the audio node has multiple inputs, this is the index of the input channel to connect to\n * @returns {CABLES.Port|undefined} - The newly created audio in port or `undefined` if there was an error\n */\nWEBAUDIO.createAudioInPort = function (op, portName, audioNode, inputChannelIndex)\n{\n    if (!op || !portName || !audioNode)\n    {\n        const msg = \"ERROR: createAudioInPort needs three parameters, op, portName and audioNode\";\n        op.log(msg);\n        throw new Error(msg);\n        // return;\n    }\n    if (!inputChannelIndex)\n    {\n        inputChannelIndex = 0;\n    }\n    op.webAudio = op.webAudio || {};\n    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];\n    const port = op.inObject(portName);\n    port.webAudio = {};\n    port.webAudio.previousAudioInNode = null;\n    port.webAudio.audioNode = audioNode;\n\n    op.webAudio.audioInPorts[portName] = port;\n\n    port.onChange = function ()\n    {\n        const audioInNode = port.get();\n        // when port disconnected, disconnect audio nodes\n        if (!audioInNode)\n        {\n            if (port.webAudio.previousAudioInNode)\n            {\n                try\n                {\n                    if (port.webAudio.previousAudioInNode.disconnect) port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode, 0, inputChannelIndex);\n                    op.setUiError(\"audioCtx\", null);\n                }\n                catch (e)\n                {\n                    try\n                    {\n                        port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode);\n                    }\n                    catch (er)\n                    {\n                        op.log(\n                            \"Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work \",\n                            e,\n                        );\n                        if (e.printStackTrace)\n                        {\n                            e.printStackTrace();\n                        }\n                        throw e;\n                    }\n                }\n            }\n        }\n        else\n        {\n            try\n            {\n                if (audioInNode.connect)\n                {\n                    audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);\n                    op.setUiError(\"audioCtx\", null);\n                }\n                else op.setUiError(\"audioCtx\", \"The passed input is not an audio context. Please make sure you connect an audio context to the input.\", 2);\n            }\n            catch (e)\n            {\n                op.log(\"Error: Failed to connect web audio node!\", e);\n                op.log(\"port.webAudio.audioNode\", port.webAudio.audioNode);\n                op.log(\"audioInNode: \", audioInNode);\n                op.log(\"inputChannelIndex:\", inputChannelIndex);\n                op.log(\"audioInNode.connect: \", audioInNode.connect);\n                throw e;\n            }\n        }\n        port.webAudio.previousAudioInNode = audioInNode;\n    };\n    // TODO: Maybe add subtype to audio-node-object?\n    return port;\n};\n\n/**\n * Sometimes it is necessary to replace a node of a port, if so all\n * connections to this node must be disconnected and connections to the new\n * node must be made.\n * Can be used for both Audio ports as well as AudioParam ports\n * if used with an AudioParam pass e.g. `synth.frequency` as newNode\n * @param {CABLES.Port} port - The port where the audio node needs to be replaced\n */\nWEBAUDIO.replaceNodeInPort = function (port, oldNode, newNode)\n{\n    const connectedNode = port.webAudio.previousAudioInNode;\n    // check if connected\n    if (connectedNode && connectedNode.disconnect)\n    {\n        try\n        {\n            connectedNode.disconnect(oldNode);\n        }\n        catch (e)\n        {\n            if (e.printStackTrace)\n            {\n                e.printStackTrace();\n            }\n            throw new Error(\"replaceNodeInPort: Could not disconnect old audio node. \" + e.name + \" \" + e.message);\n        }\n        port.webAudio.audioNode = newNode;\n        try\n        {\n            connectedNode.connect(newNode);\n        }\n        catch (e)\n        {\n            if (e.printStackTrace)\n            {\n                e.printStackTrace();\n            }\n            throw new Error(\"replaceNodeInPort: Could not connect to new node. \" + e.name + \" \" + e.message);\n        }\n    }\n};\n\n/**\n * Creates an audio out port which takes care of (dis-)connecting on it’s own\n * @param {CABLES.op} op - The op to create an audio out port for\n * @param {string} portName - The name of the port to be created\n * @param {AudioNode} audioNode - The audio node to link to the port\n * @returns {(CABLES.Port|undefined)} - The newly created audio out port or `undefined` if there was an error\n */\nWEBAUDIO.createAudioOutPort = function (op, portName, audioNode)\n{\n    if (!op || !portName || !audioNode)\n    {\n        const msg = \"ERROR: createAudioOutPort needs three parameters, op, portName and audioNode\";\n        op.log(msg);\n        throw new Error(msg);\n    }\n\n    const port = op.outObject(portName);\n    // TODO: Maybe add subtype to audio-node-object?\n    port.set(audioNode);\n    return port;\n};\n\n/**\n * Creates an audio param in port for the op with name portName.\n * The port accepts other audio nodes as signals as well as values (numbers)\n * When the port is disconnected it will disconnect the previous connected audio node\n * from the op's audio node and restore the number value set before.\n * @param {CABLES.Op} op - The operator to create an audio param input port for\n * @param {string} portName - The name of the port to create\n * @returns {(CABLES.Port|undefined)} - The newly created port, which takes care of (dis-)connecting on its own, or `undefined` if there was an error\n */\nWEBAUDIO.createAudioParamInPort = function (op, portName, audioNode, options, defaultValue)\n{\n    if (!op || !portName || !audioNode)\n    {\n        op.log(\"ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode\");\n        if (op && op.name) op.log(\"opname: \", op.name);\n        op.log(\"portName\", portName);\n        op.log(\"audioNode: \", audioNode);\n        return;\n    }\n    op.webAudio = op.webAudio || {};\n    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];\n    // var port = op.inObject(portName);\n    const port = op.inDynamic(\n        portName,\n        [_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, _constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT],\n        options,\n        defaultValue,\n    );\n    port.webAudio = {};\n    port.webAudio.previousAudioInNode = null;\n    port.webAudio.audioNode = audioNode;\n\n    op.webAudio.audioInPorts[portName] = port;\n\n    // port.onLinkChanged = function() {\n    //   op.log(\"onLinkChanged\");\n    //   if(port.isLinked()) {\n    //\n    //       if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_) { // value\n    //\n    //       } else if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) { // object\n    //\n    //       }\n    //   } else { // unlinked\n    //\n    //   }\n    // };\n\n    port.onChange = function ()\n    {\n        const audioInNode = port.get();\n        const node = port.webAudio.audioNode;\n        const audioCtx = WEBAUDIO.getAudioContext();\n\n        if (audioInNode != undefined)\n        {\n            if (typeof audioInNode === \"object\" && audioInNode.connect)\n            {\n                try\n                {\n                    audioInNode.connect(node);\n                }\n                catch (e)\n                {\n                    op.log(\"Could not connect audio node: \", e);\n                    if (e.printStackTrace)\n                    {\n                        e.printStackTrace();\n                    }\n                    throw e;\n                }\n                port.webAudio.previousAudioInNode = audioInNode;\n            }\n            else\n            {\n                // tone.js audio param\n                if (node._param && node._param.minValue && node._param.maxValue)\n                {\n                    if (audioInNode >= node._param.minValue && audioInNode <= node._param.maxValue)\n                    {\n                        try\n                        {\n                            if (node.setValueAtTime)\n                            {\n                                node.setValueAtTime(audioInNode, audioCtx.currentTime);\n                            }\n                            else\n                            {\n                                node.value = audioInNode;\n                            }\n                        }\n                        catch (e)\n                        {\n                            op.log(\"Possible AudioParam problem with tone.js op: \", e);\n                            if (e.printStackTrace)\n                            {\n                                e.printStackTrace();\n                            }\n                            throw e;\n                        }\n                    }\n                    else\n                    {\n                        op.log(\"Warning: The value for an audio parameter is out of range!\");\n                    }\n                } // native Web Audio param\n                else if (node.minValue && node.maxValue)\n                {\n                    if (audioInNode >= node.minValue && audioInNode <= node.maxValue)\n                    {\n                        try\n                        {\n                            if (node.setValueAtTime)\n                            {\n                                node.setValueAtTime(audioInNode, audioCtx.currentTime);\n                            }\n                            else\n                            {\n                                node.value = audioInNode;\n                            }\n                        }\n                        catch (e)\n                        {\n                            op.log(\n                                \"AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! \",\n                                e,\n                            );\n                            if (e.printStackTrace)\n                            {\n                                e.printStackTrace();\n                            }\n                            throw e;\n                        }\n                    }\n                    else\n                    {\n                        op.log(\"Warning: The value for an audio parameter is out of range!\");\n                    }\n                } // no min-max values, try anyway\n                else\n                {\n                    try\n                    {\n                        if (node.setValueAtTime)\n                        {\n                            node.setValueAtTime(audioInNode, audioCtx.currentTime);\n                        }\n                        else\n                        {\n                            node.value = audioInNode;\n                        }\n                    }\n                    catch (e)\n                    {\n                        op.log(\"Possible AudioParam problem (without minValue / maxValue): \", e);\n                        if (e.printStackTrace)\n                        {\n                            e.printStackTrace();\n                        }\n                        throw e;\n                    }\n                }\n\n                if (port.webAudio.previousAudioInNode && port.webAudio.previousAudioInNode.disconnect)\n                {\n                    try\n                    {\n                        port.webAudio.previousAudioInNode.disconnect(node);\n                    }\n                    catch (e)\n                    {\n                        op.log(\"Could not disconnect previous audio node: \", e);\n                        throw e;\n                    }\n                    port.webAudio.previousAudioInNode = undefined;\n                }\n            }\n        }\n        else\n        {\n            // disconnected\n            if (port.webAudio.previousAudioInNode)\n            {\n            }\n        }\n    };\n    return port;\n};\n\n\n/**\n * Loads an audio file and updates the loading indicators when cables is run in the editor.\n * @param {CABLES.Patch} patch - The cables patch, when called from inside an op this is `op.patch`\n * @param {string} url - The url of the audio file to load\n * @param {loadAudioFileFinishedCallback} onFinished - The callback to be called when the loading is finished, passes the AudioBuffer\n * @param {loadAudioFileErrorCallback} onError - The callback when there was an error loading the file, the rror message is passed\n * @see {@link https://developer.mozilla.org/de/docs/Web/API/AudioContext/decodeAudioData}\n */\nWEBAUDIO.loadAudioFile = function (patch, url, onFinished, onError, loadingTask)\n{\n    const audioContext = WEBAUDIO.createAudioContext();\n\n    let loadingId = null;\n    if (loadingTask || loadingTask === undefined)\n    {\n        loadingId = patch.loading.start(\"audio\", url);\n        if (patch.isEditorMode()) gui.jobs().start({ \"id\": \"loadaudio\" + loadingId, \"title\": \" loading audio (\" + url + \")\" });\n    }\n    const request = new XMLHttpRequest();\n    if (!url)\n    {\n        return;\n    }\n    request.open(\"GET\", url, true);\n    request.responseType = \"arraybuffer\";\n    // TODO: maybe crossorigin stuff needed?\n    // Decode asynchronously\n    request.onload = function ()\n    {\n        patch.loading.finished(loadingId);\n        if (patch.isEditorMode()) gui.jobs().finish(\"loadaudio\" + loadingId);\n        audioContext.decodeAudioData(request.response, onFinished, onError);\n    };\n    request.send();\n};\n\n/**\n * Checks if the passed time is a valid time to be used in any of the Tone.js ops.\n * @param {(string|number)} t - The time to check\n * @returns {boolean} - True if time is valid, false if not\n */\nWEBAUDIO.isValidToneTime = function (t)\n{\n    try\n    {\n        const time = new Tone.Time(t);\n    }\n    catch (e)\n    {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Checks if the passed note is a valid note to be used with Tone.js\n * @param {string} note - The note to be checked, e.g. `\"C4\"`\n * @returns {boolean} - True if the note is a valid note, false otherwise\n */\nWEBAUDIO.isValidToneNote = function (note)\n{\n    try\n    {\n        Tone.Frequency(note);\n    }\n    catch (e)\n    {\n        return false;\n    }\n    return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS93ZWJhdWRpby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL3dlYmF1ZGlvLmpzPzY3MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBuYW1lc3BhY2UgV0VCQVVESU8gKi9cblxuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IFdFQkFVRElPID0ge307XG5cbldFQkFVRElPLnRvbmVKc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qXG4gKiBFeHRlcm5hbCBKU0RvYyBkZWZpbml0aW9uc1xuICovXG5cbi8qKlxuICogUGFydCBvZiB0aGUgV2ViIEF1ZGlvIEFQSSwgdGhlIEF1ZGlvQnVmZmVyIGludGVyZmFjZSByZXByZXNlbnRzIGEgc2hvcnQgYXVkaW8gYXNzZXQgcmVzaWRpbmcgaW4gbWVtb3J5LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQnVmZmVyfVxuICovXG5cbi8qKlxuICogUGFydCBvZiB0aGUgV2ViIEF1ZGlvIEFQSSwgdGhlIEF1ZGlvTm9kZSBpbnRlcmZhY2UgaXMgYSBnZW5lcmljIGludGVyZmFjZSBmb3IgcmVwcmVzZW50aW5nIGFuIGF1ZGlvIHByb2Nlc3NpbmcgbW9kdWxlLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZX1cbiAqL1xuXG4vKipcbiAqIFRoZSBBdWRpb0NvbnRleHQgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gYXVkaW8tcHJvY2Vzc2luZyBncmFwaCBidWlsdCBmcm9tIGF1ZGlvIG1vZHVsZXMgbGlua2VkIHRvZ2V0aGVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0fVxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2xvYmFsIGF1ZGlvIGNvbnRleHQgaGFzIGJlZW4gY3JlYXRlZCBhbmQgY3JlYXRlc1xuICogaXQgaWYgbmVjZXNzYXJ5LiBUaGlzIGF1ZGlvIGNvbnRleHQgY2FuIGJlIHVzZWQgZm9yIG5hdGl2ZSBXZWIgQXVkaW8gYXMgd2VsbCBhcyBUb25lLmpzIG9wcy5cbiAqIEFzc29jaWF0ZXMgdGhlIGF1ZGlvIGNvbnRleHQgd2l0aCBUb25lLmpzIGlmIGl0IGlzIGJlaW5nIHVzZWRcbiAqIEBwYXJhbSB7Q0FCTEVTLk9wfSBvcCAtIFRoZSBvcGVyYXRvciB3aGljaCBuZWVkcyB0aGUgQXVkaW8gQ29udGV4dFxuICovXG5XRUJBVURJTy5jcmVhdGVBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiAob3ApXG57XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbiAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dClcbiAgICB7XG4gICAgICAgIGlmICghd2luZG93LmF1ZGlvQ29udGV4dClcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LmF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0b25lLmpzIGxpYiBpcyBiZWluZyB1c2VkXG4gICAgICAgIGlmICh3aW5kb3cuVG9uZSAmJiAhV0VCQVVESU8udG9uZUpzSW5pdGlhbGl6ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHNldCBjdXJyZW50IGF1ZGlvIGNvbnRleHQgaW4gdG9uZS5qc1xuICAgICAgICAgICAgVG9uZS5zZXRDb250ZXh0KHdpbmRvdy5hdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgV0VCQVVESU8udG9uZUpzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIG9wLnBhdGNoLmNvbmZpZy5vbkVycm9yKFwiTk9fV0VCQVVESU9cIiwgXCJXZWIgQXVkaW8gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYXVkaW9Db250ZXh0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhdWRpbyBjb250ZXh0LlxuICogQmVmb3JlIGBjcmVhdGVBdWRpb0NvbnRleHRgIG11c3QgaGF2ZSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlLlxuICogSXQgbW9zdCBjYXNlcyB5b3Ugc2hvdWxkIHVzZSBgY3JlYXRlQXVkaW9Db250ZXh0YCwgd2hpY2gganVzdCByZXR1cm5zIHRoZSBhdWRpbyBjb250ZXh0XG4gKiB3aGVuIGl0IGhhcyBiZWVuIGNyZWF0ZWQgYWxyZWFkeS5cbiAqL1xuV0VCQVVESU8uZ2V0QXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gd2luZG93LmF1ZGlvQ29udGV4dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWRpbyBpbiBwb3J0IGZvciB0aGUgb3Agd2l0aCBuYW1lIGBwb3J0TmFtZWBcbiAqIFdoZW4gZGlzY29ubmVjdGVkIGl0IHdpbGwgZGlzY29ubmVjdCB0aGUgcHJldmlvdXMgY29ubmVjdGVkIGF1ZGlvIG5vZGVcbiAqIGZyb20gdGhlIG9wJ3MgYXVkaW8gbm9kZS5cbiAqIEBwYXJhbSB7Q0FCTEVTLk9wfSBvcCAtIFRoZSBvcGVyYXRvciB0byBjcmVhdGUgdGhlIGF1ZGlvIHBvcnQgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwb3J0XG4gKiBAcGFyYW0ge0F1ZGlvTm9kZX0gYXVkaW9Ob2RlIC0gVGhlIGF1ZGlvbm9kZSBpbmNvbWluZyBjb25uZWN0aW9ucyBzaG91bGQgY29ubmVjdCB0b1xuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dENoYW5uZWxJbmRleD0wXSAtIElmIHRoZSBhdWRpbyBub2RlIGhhcyBtdWx0aXBsZSBpbnB1dHMsIHRoaXMgaXMgdGhlIGluZGV4IG9mIHRoZSBpbnB1dCBjaGFubmVsIHRvIGNvbm5lY3QgdG9cbiAqIEByZXR1cm5zIHtDQUJMRVMuUG9ydHx1bmRlZmluZWR9IC0gVGhlIG5ld2x5IGNyZWF0ZWQgYXVkaW8gaW4gcG9ydCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAqL1xuV0VCQVVESU8uY3JlYXRlQXVkaW9JblBvcnQgPSBmdW5jdGlvbiAob3AsIHBvcnROYW1lLCBhdWRpb05vZGUsIGlucHV0Q2hhbm5lbEluZGV4KVxue1xuICAgIGlmICghb3AgfHwgIXBvcnROYW1lIHx8ICFhdWRpb05vZGUpXG4gICAge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkVSUk9SOiBjcmVhdGVBdWRpb0luUG9ydCBuZWVkcyB0aHJlZSBwYXJhbWV0ZXJzLCBvcCwgcG9ydE5hbWUgYW5kIGF1ZGlvTm9kZVwiO1xuICAgICAgICBvcC5sb2cobXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIC8vIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpbnB1dENoYW5uZWxJbmRleClcbiAgICB7XG4gICAgICAgIGlucHV0Q2hhbm5lbEluZGV4ID0gMDtcbiAgICB9XG4gICAgb3Aud2ViQXVkaW8gPSBvcC53ZWJBdWRpbyB8fCB7fTtcbiAgICBvcC53ZWJBdWRpby5hdWRpb0luUG9ydHMgPSBvcC53ZWJBdWRpby5hdWRpb0luUG9ydHMgfHwgW107XG4gICAgY29uc3QgcG9ydCA9IG9wLmluT2JqZWN0KHBvcnROYW1lKTtcbiAgICBwb3J0LndlYkF1ZGlvID0ge307XG4gICAgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlID0gbnVsbDtcbiAgICBwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZSA9IGF1ZGlvTm9kZTtcblxuICAgIG9wLndlYkF1ZGlvLmF1ZGlvSW5Qb3J0c1twb3J0TmFtZV0gPSBwb3J0O1xuXG4gICAgcG9ydC5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjb25zdCBhdWRpb0luTm9kZSA9IHBvcnQuZ2V0KCk7XG4gICAgICAgIC8vIHdoZW4gcG9ydCBkaXNjb25uZWN0ZWQsIGRpc2Nvbm5lY3QgYXVkaW8gbm9kZXNcbiAgICAgICAgaWYgKCFhdWRpb0luTm9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUuZGlzY29ubmVjdCkgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlLmRpc2Nvbm5lY3QocG9ydC53ZWJBdWRpby5hdWRpb05vZGUsIDAsIGlucHV0Q2hhbm5lbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgb3Auc2V0VWlFcnJvcihcImF1ZGlvQ3R4XCIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUuZGlzY29ubmVjdChwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVyKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEaXNjb25uZWN0aW5nIGF1ZGlvIG5vZGUgd2l0aCBpbi9vdXQgcG9ydCBpbmRleCwgYXMgd2VsbCBhcyB3aXRob3V0IGluL291dC1wb3J0LWluZGV4IGRpZCBub3Qgd29yayBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb0luTm9kZS5jb25uZWN0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Jbk5vZGUuY29ubmVjdChwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZSwgMCwgaW5wdXRDaGFubmVsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBvcC5zZXRVaUVycm9yKFwiYXVkaW9DdHhcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Ugb3Auc2V0VWlFcnJvcihcImF1ZGlvQ3R4XCIsIFwiVGhlIHBhc3NlZCBpbnB1dCBpcyBub3QgYW4gYXVkaW8gY29udGV4dC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgY29ubmVjdCBhbiBhdWRpbyBjb250ZXh0IHRvIHRoZSBpbnB1dC5cIiwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcC5sb2coXCJFcnJvcjogRmFpbGVkIHRvIGNvbm5lY3Qgd2ViIGF1ZGlvIG5vZGUhXCIsIGUpO1xuICAgICAgICAgICAgICAgIG9wLmxvZyhcInBvcnQud2ViQXVkaW8uYXVkaW9Ob2RlXCIsIHBvcnQud2ViQXVkaW8uYXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICBvcC5sb2coXCJhdWRpb0luTm9kZTogXCIsIGF1ZGlvSW5Ob2RlKTtcbiAgICAgICAgICAgICAgICBvcC5sb2coXCJpbnB1dENoYW5uZWxJbmRleDpcIiwgaW5wdXRDaGFubmVsSW5kZXgpO1xuICAgICAgICAgICAgICAgIG9wLmxvZyhcImF1ZGlvSW5Ob2RlLmNvbm5lY3Q6IFwiLCBhdWRpb0luTm9kZS5jb25uZWN0KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZSA9IGF1ZGlvSW5Ob2RlO1xuICAgIH07XG4gICAgLy8gVE9ETzogTWF5YmUgYWRkIHN1YnR5cGUgdG8gYXVkaW8tbm9kZS1vYmplY3Q/XG4gICAgcmV0dXJuIHBvcnQ7XG59O1xuXG4vKipcbiAqIFNvbWV0aW1lcyBpdCBpcyBuZWNlc3NhcnkgdG8gcmVwbGFjZSBhIG5vZGUgb2YgYSBwb3J0LCBpZiBzbyBhbGxcbiAqIGNvbm5lY3Rpb25zIHRvIHRoaXMgbm9kZSBtdXN0IGJlIGRpc2Nvbm5lY3RlZCBhbmQgY29ubmVjdGlvbnMgdG8gdGhlIG5ld1xuICogbm9kZSBtdXN0IGJlIG1hZGUuXG4gKiBDYW4gYmUgdXNlZCBmb3IgYm90aCBBdWRpbyBwb3J0cyBhcyB3ZWxsIGFzIEF1ZGlvUGFyYW0gcG9ydHNcbiAqIGlmIHVzZWQgd2l0aCBhbiBBdWRpb1BhcmFtIHBhc3MgZS5nLiBgc3ludGguZnJlcXVlbmN5YCBhcyBuZXdOb2RlXG4gKiBAcGFyYW0ge0NBQkxFUy5Qb3J0fSBwb3J0IC0gVGhlIHBvcnQgd2hlcmUgdGhlIGF1ZGlvIG5vZGUgbmVlZHMgdG8gYmUgcmVwbGFjZWRcbiAqL1xuV0VCQVVESU8ucmVwbGFjZU5vZGVJblBvcnQgPSBmdW5jdGlvbiAocG9ydCwgb2xkTm9kZSwgbmV3Tm9kZSlcbntcbiAgICBjb25zdCBjb25uZWN0ZWROb2RlID0gcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlO1xuICAgIC8vIGNoZWNrIGlmIGNvbm5lY3RlZFxuICAgIGlmIChjb25uZWN0ZWROb2RlICYmIGNvbm5lY3RlZE5vZGUuZGlzY29ubmVjdClcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25uZWN0ZWROb2RlLmRpc2Nvbm5lY3Qob2xkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVwbGFjZU5vZGVJblBvcnQ6IENvdWxkIG5vdCBkaXNjb25uZWN0IG9sZCBhdWRpbyBub2RlLiBcIiArIGUubmFtZSArIFwiIFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZSA9IG5ld05vZGU7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25uZWN0ZWROb2RlLmNvbm5lY3QobmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVwbGFjZU5vZGVJblBvcnQ6IENvdWxkIG5vdCBjb25uZWN0IHRvIG5ldyBub2RlLiBcIiArIGUubmFtZSArIFwiIFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWRpbyBvdXQgcG9ydCB3aGljaCB0YWtlcyBjYXJlIG9mIChkaXMtKWNvbm5lY3Rpbmcgb24gaXTigJlzIG93blxuICogQHBhcmFtIHtDQUJMRVMub3B9IG9wIC0gVGhlIG9wIHRvIGNyZWF0ZSBhbiBhdWRpbyBvdXQgcG9ydCBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwb3J0IHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBhdWRpb05vZGUgLSBUaGUgYXVkaW8gbm9kZSB0byBsaW5rIHRvIHRoZSBwb3J0XG4gKiBAcmV0dXJucyB7KENBQkxFUy5Qb3J0fHVuZGVmaW5lZCl9IC0gVGhlIG5ld2x5IGNyZWF0ZWQgYXVkaW8gb3V0IHBvcnQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKi9cbldFQkFVRElPLmNyZWF0ZUF1ZGlvT3V0UG9ydCA9IGZ1bmN0aW9uIChvcCwgcG9ydE5hbWUsIGF1ZGlvTm9kZSlcbntcbiAgICBpZiAoIW9wIHx8ICFwb3J0TmFtZSB8fCAhYXVkaW9Ob2RlKVxuICAgIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJFUlJPUjogY3JlYXRlQXVkaW9PdXRQb3J0IG5lZWRzIHRocmVlIHBhcmFtZXRlcnMsIG9wLCBwb3J0TmFtZSBhbmQgYXVkaW9Ob2RlXCI7XG4gICAgICAgIG9wLmxvZyhtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gb3Aub3V0T2JqZWN0KHBvcnROYW1lKTtcbiAgICAvLyBUT0RPOiBNYXliZSBhZGQgc3VidHlwZSB0byBhdWRpby1ub2RlLW9iamVjdD9cbiAgICBwb3J0LnNldChhdWRpb05vZGUpO1xuICAgIHJldHVybiBwb3J0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF1ZGlvIHBhcmFtIGluIHBvcnQgZm9yIHRoZSBvcCB3aXRoIG5hbWUgcG9ydE5hbWUuXG4gKiBUaGUgcG9ydCBhY2NlcHRzIG90aGVyIGF1ZGlvIG5vZGVzIGFzIHNpZ25hbHMgYXMgd2VsbCBhcyB2YWx1ZXMgKG51bWJlcnMpXG4gKiBXaGVuIHRoZSBwb3J0IGlzIGRpc2Nvbm5lY3RlZCBpdCB3aWxsIGRpc2Nvbm5lY3QgdGhlIHByZXZpb3VzIGNvbm5lY3RlZCBhdWRpbyBub2RlXG4gKiBmcm9tIHRoZSBvcCdzIGF1ZGlvIG5vZGUgYW5kIHJlc3RvcmUgdGhlIG51bWJlciB2YWx1ZSBzZXQgYmVmb3JlLlxuICogQHBhcmFtIHtDQUJMRVMuT3B9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIGNyZWF0ZSBhbiBhdWRpbyBwYXJhbSBpbnB1dCBwb3J0IGZvclxuICogQHBhcmFtIHtzdHJpbmd9IHBvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBvcnQgdG8gY3JlYXRlXG4gKiBAcmV0dXJucyB7KENBQkxFUy5Qb3J0fHVuZGVmaW5lZCl9IC0gVGhlIG5ld2x5IGNyZWF0ZWQgcG9ydCwgd2hpY2ggdGFrZXMgY2FyZSBvZiAoZGlzLSljb25uZWN0aW5nIG9uIGl0cyBvd24sIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICovXG5XRUJBVURJTy5jcmVhdGVBdWRpb1BhcmFtSW5Qb3J0ID0gZnVuY3Rpb24gKG9wLCBwb3J0TmFtZSwgYXVkaW9Ob2RlLCBvcHRpb25zLCBkZWZhdWx0VmFsdWUpXG57XG4gICAgaWYgKCFvcCB8fCAhcG9ydE5hbWUgfHwgIWF1ZGlvTm9kZSlcbiAgICB7XG4gICAgICAgIG9wLmxvZyhcIkVSUk9SOiBjcmVhdGVBdWRpb1BhcmFtSW5Qb3J0IG5lZWRzIHRocmVlIHBhcmFtZXRlcnMsIG9wLCBwb3J0TmFtZSBhbmQgYXVkaW9Ob2RlXCIpO1xuICAgICAgICBpZiAob3AgJiYgb3AubmFtZSkgb3AubG9nKFwib3BuYW1lOiBcIiwgb3AubmFtZSk7XG4gICAgICAgIG9wLmxvZyhcInBvcnROYW1lXCIsIHBvcnROYW1lKTtcbiAgICAgICAgb3AubG9nKFwiYXVkaW9Ob2RlOiBcIiwgYXVkaW9Ob2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcC53ZWJBdWRpbyA9IG9wLndlYkF1ZGlvIHx8IHt9O1xuICAgIG9wLndlYkF1ZGlvLmF1ZGlvSW5Qb3J0cyA9IG9wLndlYkF1ZGlvLmF1ZGlvSW5Qb3J0cyB8fCBbXTtcbiAgICAvLyB2YXIgcG9ydCA9IG9wLmluT2JqZWN0KHBvcnROYW1lKTtcbiAgICBjb25zdCBwb3J0ID0gb3AuaW5EeW5hbWljKFxuICAgICAgICBwb3J0TmFtZSxcbiAgICAgICAgW0NPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUXSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICk7XG4gICAgcG9ydC53ZWJBdWRpbyA9IHt9O1xuICAgIHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZSA9IG51bGw7XG4gICAgcG9ydC53ZWJBdWRpby5hdWRpb05vZGUgPSBhdWRpb05vZGU7XG5cbiAgICBvcC53ZWJBdWRpby5hdWRpb0luUG9ydHNbcG9ydE5hbWVdID0gcG9ydDtcblxuICAgIC8vIHBvcnQub25MaW5rQ2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgb3AubG9nKFwib25MaW5rQ2hhbmdlZFwiKTtcbiAgICAvLyAgIGlmKHBvcnQuaXNMaW5rZWQoKSkge1xuICAgIC8vXG4gICAgLy8gICAgICAgaWYocG9ydC5saW5rc1swXS5wb3J0T3V0LnR5cGUgPT09IENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFXykgeyAvLyB2YWx1ZVxuICAgIC8vXG4gICAgLy8gICAgICAgfSBlbHNlIGlmKHBvcnQubGlua3NbMF0ucG9ydE91dC50eXBlID09PSBDQUJMRVMuQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QpIHsgLy8gb2JqZWN0XG4gICAgLy9cbiAgICAvLyAgICAgICB9XG4gICAgLy8gICB9IGVsc2UgeyAvLyB1bmxpbmtlZFxuICAgIC8vXG4gICAgLy8gICB9XG4gICAgLy8gfTtcblxuICAgIHBvcnQub25DaGFuZ2UgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc3QgYXVkaW9Jbk5vZGUgPSBwb3J0LmdldCgpO1xuICAgICAgICBjb25zdCBub2RlID0gcG9ydC53ZWJBdWRpby5hdWRpb05vZGU7XG4gICAgICAgIGNvbnN0IGF1ZGlvQ3R4ID0gV0VCQVVESU8uZ2V0QXVkaW9Db250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGF1ZGlvSW5Ob2RlICE9IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdWRpb0luTm9kZSA9PT0gXCJvYmplY3RcIiAmJiBhdWRpb0luTm9kZS5jb25uZWN0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Jbk5vZGUuY29ubmVjdChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcC5sb2coXCJDb3VsZCBub3QgY29ubmVjdCBhdWRpbyBub2RlOiBcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmludFN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUgPSBhdWRpb0luTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0b25lLmpzIGF1ZGlvIHBhcmFtXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX3BhcmFtICYmIG5vZGUuX3BhcmFtLm1pblZhbHVlICYmIG5vZGUuX3BhcmFtLm1heFZhbHVlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvSW5Ob2RlID49IG5vZGUuX3BhcmFtLm1pblZhbHVlICYmIGF1ZGlvSW5Ob2RlIDw9IG5vZGUuX3BhcmFtLm1heFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zZXRWYWx1ZUF0VGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0VmFsdWVBdFRpbWUoYXVkaW9Jbk5vZGUsIGF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IGF1ZGlvSW5Ob2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLmxvZyhcIlBvc3NpYmxlIEF1ZGlvUGFyYW0gcHJvYmxlbSB3aXRoIHRvbmUuanMgb3A6IFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmludFN0YWNrVHJhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AubG9nKFwiV2FybmluZzogVGhlIHZhbHVlIGZvciBhbiBhdWRpbyBwYXJhbWV0ZXIgaXMgb3V0IG9mIHJhbmdlIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gbmF0aXZlIFdlYiBBdWRpbyBwYXJhbVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubWluVmFsdWUgJiYgbm9kZS5tYXhWYWx1ZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0luTm9kZSA+PSBub2RlLm1pblZhbHVlICYmIGF1ZGlvSW5Ob2RlIDw9IG5vZGUubWF4VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNldFZhbHVlQXRUaW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRWYWx1ZUF0VGltZShhdWRpb0luTm9kZSwgYXVkaW9DdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gYXVkaW9Jbk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkF1ZGlvUGFyYW0gaGFzIG1pblZhbHVlIC8gbWF4VmFsdWUgZGVmaW5lZCwgYW5kIHZhbHVlIGlzIGluIHJhbmdlLCBidXQgc2V0dGluZyB0aGUgdmFsdWUgZmFpbGVkISBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5sb2coXCJXYXJuaW5nOiBUaGUgdmFsdWUgZm9yIGFuIGF1ZGlvIHBhcmFtZXRlciBpcyBvdXQgb2YgcmFuZ2UhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBubyBtaW4tbWF4IHZhbHVlcywgdHJ5IGFueXdheVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zZXRWYWx1ZUF0VGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFZhbHVlQXRUaW1lKGF1ZGlvSW5Ob2RlLCBhdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IGF1ZGlvSW5Ob2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5sb2coXCJQb3NzaWJsZSBBdWRpb1BhcmFtIHByb2JsZW0gKHdpdGhvdXQgbWluVmFsdWUgLyBtYXhWYWx1ZSk6IFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUgJiYgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlLmRpc2Nvbm5lY3QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlLmRpc2Nvbm5lY3Qobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLmxvZyhcIkNvdWxkIG5vdCBkaXNjb25uZWN0IHByZXZpb3VzIGF1ZGlvIG5vZGU6IFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHBvcnQ7XG59O1xuXG5cbi8qKlxuICogTG9hZHMgYW4gYXVkaW8gZmlsZSBhbmQgdXBkYXRlcyB0aGUgbG9hZGluZyBpbmRpY2F0b3JzIHdoZW4gY2FibGVzIGlzIHJ1biBpbiB0aGUgZWRpdG9yLlxuICogQHBhcmFtIHtDQUJMRVMuUGF0Y2h9IHBhdGNoIC0gVGhlIGNhYmxlcyBwYXRjaCwgd2hlbiBjYWxsZWQgZnJvbSBpbnNpZGUgYW4gb3AgdGhpcyBpcyBgb3AucGF0Y2hgXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHVybCBvZiB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gKiBAcGFyYW0ge2xvYWRBdWRpb0ZpbGVGaW5pc2hlZENhbGxiYWNrfSBvbkZpbmlzaGVkIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBsb2FkaW5nIGlzIGZpbmlzaGVkLCBwYXNzZXMgdGhlIEF1ZGlvQnVmZmVyXG4gKiBAcGFyYW0ge2xvYWRBdWRpb0ZpbGVFcnJvckNhbGxiYWNrfSBvbkVycm9yIC0gVGhlIGNhbGxiYWNrIHdoZW4gdGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhlIGZpbGUsIHRoZSBycm9yIG1lc3NhZ2UgaXMgcGFzc2VkXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0L2RlY29kZUF1ZGlvRGF0YX1cbiAqL1xuV0VCQVVESU8ubG9hZEF1ZGlvRmlsZSA9IGZ1bmN0aW9uIChwYXRjaCwgdXJsLCBvbkZpbmlzaGVkLCBvbkVycm9yLCBsb2FkaW5nVGFzaylcbntcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBXRUJBVURJTy5jcmVhdGVBdWRpb0NvbnRleHQoKTtcblxuICAgIGxldCBsb2FkaW5nSWQgPSBudWxsO1xuICAgIGlmIChsb2FkaW5nVGFzayB8fCBsb2FkaW5nVGFzayA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgbG9hZGluZ0lkID0gcGF0Y2gubG9hZGluZy5zdGFydChcImF1ZGlvXCIsIHVybCk7XG4gICAgICAgIGlmIChwYXRjaC5pc0VkaXRvck1vZGUoKSkgZ3VpLmpvYnMoKS5zdGFydCh7IFwiaWRcIjogXCJsb2FkYXVkaW9cIiArIGxvYWRpbmdJZCwgXCJ0aXRsZVwiOiBcIiBsb2FkaW5nIGF1ZGlvIChcIiArIHVybCArIFwiKVwiIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIC8vIFRPRE86IG1heWJlIGNyb3Nzb3JpZ2luIHN0dWZmIG5lZWRlZD9cbiAgICAvLyBEZWNvZGUgYXN5bmNocm9ub3VzbHlcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBwYXRjaC5sb2FkaW5nLmZpbmlzaGVkKGxvYWRpbmdJZCk7XG4gICAgICAgIGlmIChwYXRjaC5pc0VkaXRvck1vZGUoKSkgZ3VpLmpvYnMoKS5maW5pc2goXCJsb2FkYXVkaW9cIiArIGxvYWRpbmdJZCk7XG4gICAgICAgIGF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgb25GaW5pc2hlZCwgb25FcnJvcik7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQoKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgdGltZSBpcyBhIHZhbGlkIHRpbWUgdG8gYmUgdXNlZCBpbiBhbnkgb2YgdGhlIFRvbmUuanMgb3BzLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHQgLSBUaGUgdGltZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aW1lIGlzIHZhbGlkLCBmYWxzZSBpZiBub3RcbiAqL1xuV0VCQVVESU8uaXNWYWxpZFRvbmVUaW1lID0gZnVuY3Rpb24gKHQpXG57XG4gICAgdHJ5XG4gICAge1xuICAgICAgICBjb25zdCB0aW1lID0gbmV3IFRvbmUuVGltZSh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHBhc3NlZCBub3RlIGlzIGEgdmFsaWQgbm90ZSB0byBiZSB1c2VkIHdpdGggVG9uZS5qc1xuICogQHBhcmFtIHtzdHJpbmd9IG5vdGUgLSBUaGUgbm90ZSB0byBiZSBjaGVja2VkLCBlLmcuIGBcIkM0XCJgXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBub3RlIGlzIGEgdmFsaWQgbm90ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbldFQkFVRElPLmlzVmFsaWRUb25lTm90ZSA9IGZ1bmN0aW9uIChub3RlKVxue1xuICAgIHRyeVxuICAgIHtcbiAgICAgICAgVG9uZS5GcmVxdWVuY3kobm90ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCB7IFdFQkFVRElPIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/webaudio.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core/index.js");
/******/ 	CABLES = __webpack_exports__["default"];
/******/ 	
/******/ })()
;

var CABLES = CABLES || {}; CABLES.build = {"timestamp":1707302392182,"created":"2024-02-07T10:39:52.182Z","git":{"branch":"master","commit":"d110e346f781717b29314c9073ca439cd71dc843","date":"2024-02-07T10:39:23.000Z","message":"Merge branch 'master' of github.com:pandrr/cables"}};
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.1.0

Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t=t||self).glMatrix={})}(this,function(t){"use strict";var n=1e-6,a="undefined"!=typeof Float32Array?Float32Array:Array,r=Math.random;var u=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});var e=Object.freeze({EPSILON:n,get ARRAY_TYPE(){return a},RANDOM:r,setMatrixArrayType:function(t){a=t},toRadian:function(t){return t*u},equals:function(t,a){return Math.abs(t-a)<=n*Math.max(1,Math.abs(t),Math.abs(a))}});function o(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1],h=a[2],s=a[3];return t[0]=r*i+e*c,t[1]=u*i+o*c,t[2]=r*h+e*s,t[3]=u*h+o*s,t}function i(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t}var c=o,h=i,s=Object.freeze({create:function(){var t=new a(4);return a!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t},clone:function(t){var n=new a(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},fromValues:function(t,n,r,u){var e=new a(4);return e[0]=t,e[1]=n,e[2]=r,e[3]=u,e},set:function(t,n,a,r,u){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t},transpose:function(t,n){if(t===n){var a=n[1];t[1]=n[2],t[2]=a}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*e-u*r;return o?(o=1/o,t[0]=e*o,t[1]=-r*o,t[2]=-u*o,t[3]=a*o,t):null},adjoint:function(t,n){var a=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=a,t},determinant:function(t){return t[0]*t[3]-t[2]*t[1]},multiply:o,rotate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c+e*i,t[1]=u*c+o*i,t[2]=r*-i+e*c,t[3]=u*-i+o*c,t},scale:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1];return t[0]=r*i,t[1]=u*i,t[2]=e*c,t[3]=o*c,t},fromRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=-a,t[3]=r,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},str:function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[2],t[3])},LDU:function(t,n,a,r){return t[2]=r[2]/r[0],a[0]=r[0],a[1]=r[1],a[3]=r[3]-t[2]*a[1],[t,n,a]},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t},subtract:i,exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=a[0],c=a[1],h=a[2],s=a[3];return Math.abs(r-i)<=n*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(u-c)<=n*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(e-h)<=n*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(o-s)<=n*Math.max(1,Math.abs(o),Math.abs(s))},multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t},mul:c,sub:h});function M(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=a[0],s=a[1],M=a[2],f=a[3],l=a[4],v=a[5];return t[0]=r*h+e*s,t[1]=u*h+o*s,t[2]=r*M+e*f,t[3]=u*M+o*f,t[4]=r*l+e*v+i,t[5]=u*l+o*v+c,t}function f(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t}var l=M,v=f,b=Object.freeze({create:function(){var t=new a(6);return a!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t},clone:function(t){var n=new a(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},fromValues:function(t,n,r,u,e,o){var i=new a(6);return i[0]=t,i[1]=n,i[2]=r,i[3]=u,i[4]=e,i[5]=o,i},set:function(t,n,a,r,u,e,o){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=a*e-r*u;return c?(c=1/c,t[0]=e*c,t[1]=-r*c,t[2]=-u*c,t[3]=a*c,t[4]=(u*i-e*o)*c,t[5]=(r*o-a*i)*c,t):null},determinant:function(t){return t[0]*t[3]-t[1]*t[2]},multiply:M,rotate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=Math.sin(a),s=Math.cos(a);return t[0]=r*s+e*h,t[1]=u*s+o*h,t[2]=r*-h+e*s,t[3]=u*-h+o*s,t[4]=i,t[5]=c,t},scale:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=a[0],s=a[1];return t[0]=r*h,t[1]=u*h,t[2]=e*s,t[3]=o*s,t[4]=i,t[5]=c,t},translate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=a[0],s=a[1];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=r*h+e*s+i,t[5]=u*h+o*s+c,t},fromRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=-a,t[3]=r,t[4]=0,t[5]=0,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},fromTranslation:function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},str:function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],1)},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t},subtract:f,multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=a[0],s=a[1],M=a[2],f=a[3],l=a[4],v=a[5];return Math.abs(r-h)<=n*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(u-s)<=n*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(e-M)<=n*Math.max(1,Math.abs(e),Math.abs(M))&&Math.abs(o-f)<=n*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(i-l)<=n*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(c-v)<=n*Math.max(1,Math.abs(c),Math.abs(v))},mul:l,sub:v});function m(){var t=new a(9);return a!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function d(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=a[0],l=a[1],v=a[2],b=a[3],m=a[4],d=a[5],x=a[6],p=a[7],y=a[8];return t[0]=f*r+l*o+v*h,t[1]=f*u+l*i+v*s,t[2]=f*e+l*c+v*M,t[3]=b*r+m*o+d*h,t[4]=b*u+m*i+d*s,t[5]=b*e+m*c+d*M,t[6]=x*r+p*o+y*h,t[7]=x*u+p*i+y*s,t[8]=x*e+p*c+y*M,t}function x(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t[6]=n[6]-a[6],t[7]=n[7]-a[7],t[8]=n[8]-a[8],t}var p=d,y=x,q=Object.freeze({create:m,fromMat4:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},clone:function(t){var n=new a(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},fromValues:function(t,n,r,u,e,o,i,c,h){var s=new a(9);return s[0]=t,s[1]=n,s[2]=r,s[3]=u,s[4]=e,s[5]=o,s[6]=i,s[7]=c,s[8]=h,s},set:function(t,n,a,r,u,e,o,i,c,h){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=c,t[8]=h,t},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},transpose:function(t,n){if(t===n){var a=n[1],r=n[2],u=n[5];t[1]=n[3],t[2]=n[6],t[3]=a,t[5]=n[7],t[6]=r,t[7]=u}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=s*o-i*h,f=-s*e+i*c,l=h*e-o*c,v=a*M+r*f+u*l;return v?(v=1/v,t[0]=M*v,t[1]=(-s*r+u*h)*v,t[2]=(i*r-u*o)*v,t[3]=f*v,t[4]=(s*a-u*c)*v,t[5]=(-i*a+u*e)*v,t[6]=l*v,t[7]=(-h*a+r*c)*v,t[8]=(o*a-r*e)*v,t):null},adjoint:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8];return t[0]=o*s-i*h,t[1]=u*h-r*s,t[2]=r*i-u*o,t[3]=i*c-e*s,t[4]=a*s-u*c,t[5]=u*e-a*i,t[6]=e*h-o*c,t[7]=r*c-a*h,t[8]=a*o-r*e,t},determinant:function(t){var n=t[0],a=t[1],r=t[2],u=t[3],e=t[4],o=t[5],i=t[6],c=t[7],h=t[8];return n*(h*e-o*c)+a*(-h*u+o*i)+r*(c*u-e*i)},multiply:d,translate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=a[0],l=a[1];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=i,t[5]=c,t[6]=f*r+l*o+h,t[7]=f*u+l*i+s,t[8]=f*e+l*c+M,t},rotate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=Math.sin(a),l=Math.cos(a);return t[0]=l*r+f*o,t[1]=l*u+f*i,t[2]=l*e+f*c,t[3]=l*o-f*r,t[4]=l*i-f*u,t[5]=l*c-f*e,t[6]=h,t[7]=s,t[8]=M,t},scale:function(t,n,a){var r=a[0],u=a[1];return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=u*n[3],t[4]=u*n[4],t[5]=u*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},fromTranslation:function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},fromRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=0,t[3]=-a,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},fromMat2d:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},fromQuat:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a+a,i=r+r,c=u+u,h=a*o,s=r*o,M=r*i,f=u*o,l=u*i,v=u*c,b=e*o,m=e*i,d=e*c;return t[0]=1-M-v,t[3]=s-d,t[6]=f+m,t[1]=s+d,t[4]=1-h-v,t[7]=l-b,t[2]=f-m,t[5]=l+b,t[8]=1-h-M,t},normalFromMat4:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15],x=a*i-r*o,p=a*c-u*o,y=a*h-e*o,q=r*c-u*i,g=r*h-e*i,A=u*h-e*c,w=s*b-M*v,R=s*m-f*v,z=s*d-l*v,P=M*m-f*b,j=M*d-l*b,I=f*d-l*m,S=x*I-p*j+y*P+q*z-g*R+A*w;return S?(S=1/S,t[0]=(i*I-c*j+h*P)*S,t[1]=(c*z-o*I-h*R)*S,t[2]=(o*j-i*z+h*w)*S,t[3]=(u*j-r*I-e*P)*S,t[4]=(a*I-u*z+e*R)*S,t[5]=(r*z-a*j-e*w)*S,t[6]=(b*A-m*g+d*q)*S,t[7]=(m*y-v*A-d*p)*S,t[8]=(v*g-b*y+d*x)*S,t):null},projection:function(t,n,a){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/a,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t},str:function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t[8]=n[8]+a[8],t},subtract:x,multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t[8]=n[8]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t[6]=n[6]+a[6]*r,t[7]=n[7]+a[7]*r,t[8]=n[8]+a[8]*r,t},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=t[6],s=t[7],M=t[8],f=a[0],l=a[1],v=a[2],b=a[3],m=a[4],d=a[5],x=a[6],p=a[7],y=a[8];return Math.abs(r-f)<=n*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(u-l)<=n*Math.max(1,Math.abs(u),Math.abs(l))&&Math.abs(e-v)<=n*Math.max(1,Math.abs(e),Math.abs(v))&&Math.abs(o-b)<=n*Math.max(1,Math.abs(o),Math.abs(b))&&Math.abs(i-m)<=n*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(c-d)<=n*Math.max(1,Math.abs(c),Math.abs(d))&&Math.abs(h-x)<=n*Math.max(1,Math.abs(h),Math.abs(x))&&Math.abs(s-p)<=n*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(M-y)<=n*Math.max(1,Math.abs(M),Math.abs(y))},mul:p,sub:y});function g(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function A(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=n[9],l=n[10],v=n[11],b=n[12],m=n[13],d=n[14],x=n[15],p=a[0],y=a[1],q=a[2],g=a[3];return t[0]=p*r+y*i+q*M+g*b,t[1]=p*u+y*c+q*f+g*m,t[2]=p*e+y*h+q*l+g*d,t[3]=p*o+y*s+q*v+g*x,p=a[4],y=a[5],q=a[6],g=a[7],t[4]=p*r+y*i+q*M+g*b,t[5]=p*u+y*c+q*f+g*m,t[6]=p*e+y*h+q*l+g*d,t[7]=p*o+y*s+q*v+g*x,p=a[8],y=a[9],q=a[10],g=a[11],t[8]=p*r+y*i+q*M+g*b,t[9]=p*u+y*c+q*f+g*m,t[10]=p*e+y*h+q*l+g*d,t[11]=p*o+y*s+q*v+g*x,p=a[12],y=a[13],q=a[14],g=a[15],t[12]=p*r+y*i+q*M+g*b,t[13]=p*u+y*c+q*f+g*m,t[14]=p*e+y*h+q*l+g*d,t[15]=p*o+y*s+q*v+g*x,t}function w(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=r+r,c=u+u,h=e+e,s=r*i,M=r*c,f=r*h,l=u*c,v=u*h,b=e*h,m=o*i,d=o*c,x=o*h;return t[0]=1-(l+b),t[1]=M+x,t[2]=f-d,t[3]=0,t[4]=M-x,t[5]=1-(s+b),t[6]=v+m,t[7]=0,t[8]=f+d,t[9]=v-m,t[10]=1-(s+l),t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t}function R(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function z(t,n){var a=n[0],r=n[1],u=n[2],e=n[4],o=n[5],i=n[6],c=n[8],h=n[9],s=n[10];return t[0]=Math.hypot(a,r,u),t[1]=Math.hypot(e,o,i),t[2]=Math.hypot(c,h,s),t}function P(t,n){var r=new a(3);z(r,n);var u=1/r[0],e=1/r[1],o=1/r[2],i=n[0]*u,c=n[1]*e,h=n[2]*o,s=n[4]*u,M=n[5]*e,f=n[6]*o,l=n[8]*u,v=n[9]*e,b=n[10]*o,m=i+M+b,d=0;return m>0?(d=2*Math.sqrt(m+1),t[3]=.25*d,t[0]=(f-v)/d,t[1]=(l-h)/d,t[2]=(c-s)/d):i>M&&i>b?(d=2*Math.sqrt(1+i-M-b),t[3]=(f-v)/d,t[0]=.25*d,t[1]=(c+s)/d,t[2]=(l+h)/d):M>b?(d=2*Math.sqrt(1+M-i-b),t[3]=(l-h)/d,t[0]=(c+s)/d,t[1]=.25*d,t[2]=(f+v)/d):(d=2*Math.sqrt(1+b-i-M),t[3]=(c-s)/d,t[0]=(l+h)/d,t[1]=(f+v)/d,t[2]=.25*d),t}function j(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t[6]=n[6]-a[6],t[7]=n[7]-a[7],t[8]=n[8]-a[8],t[9]=n[9]-a[9],t[10]=n[10]-a[10],t[11]=n[11]-a[11],t[12]=n[12]-a[12],t[13]=n[13]-a[13],t[14]=n[14]-a[14],t[15]=n[15]-a[15],t}var I=A,S=j,E=Object.freeze({create:function(){var t=new a(16);return a!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},clone:function(t){var n=new a(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},fromValues:function(t,n,r,u,e,o,i,c,h,s,M,f,l,v,b,m){var d=new a(16);return d[0]=t,d[1]=n,d[2]=r,d[3]=u,d[4]=e,d[5]=o,d[6]=i,d[7]=c,d[8]=h,d[9]=s,d[10]=M,d[11]=f,d[12]=l,d[13]=v,d[14]=b,d[15]=m,d},set:function(t,n,a,r,u,e,o,i,c,h,s,M,f,l,v,b,m){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=c,t[8]=h,t[9]=s,t[10]=M,t[11]=f,t[12]=l,t[13]=v,t[14]=b,t[15]=m,t},identity:g,transpose:function(t,n){if(t===n){var a=n[1],r=n[2],u=n[3],e=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=a,t[6]=n[9],t[7]=n[13],t[8]=r,t[9]=e,t[11]=n[14],t[12]=u,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15],x=a*i-r*o,p=a*c-u*o,y=a*h-e*o,q=r*c-u*i,g=r*h-e*i,A=u*h-e*c,w=s*b-M*v,R=s*m-f*v,z=s*d-l*v,P=M*m-f*b,j=M*d-l*b,I=f*d-l*m,S=x*I-p*j+y*P+q*z-g*R+A*w;return S?(S=1/S,t[0]=(i*I-c*j+h*P)*S,t[1]=(u*j-r*I-e*P)*S,t[2]=(b*A-m*g+d*q)*S,t[3]=(f*g-M*A-l*q)*S,t[4]=(c*z-o*I-h*R)*S,t[5]=(a*I-u*z+e*R)*S,t[6]=(m*y-v*A-d*p)*S,t[7]=(s*A-f*y+l*p)*S,t[8]=(o*j-i*z+h*w)*S,t[9]=(r*z-a*j-e*w)*S,t[10]=(v*g-b*y+d*x)*S,t[11]=(M*y-s*g-l*x)*S,t[12]=(i*R-o*P-c*w)*S,t[13]=(a*P-r*R+u*w)*S,t[14]=(b*p-v*q-m*x)*S,t[15]=(s*q-M*p+f*x)*S,t):null},adjoint:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15];return t[0]=i*(f*d-l*m)-M*(c*d-h*m)+b*(c*l-h*f),t[1]=-(r*(f*d-l*m)-M*(u*d-e*m)+b*(u*l-e*f)),t[2]=r*(c*d-h*m)-i*(u*d-e*m)+b*(u*h-e*c),t[3]=-(r*(c*l-h*f)-i*(u*l-e*f)+M*(u*h-e*c)),t[4]=-(o*(f*d-l*m)-s*(c*d-h*m)+v*(c*l-h*f)),t[5]=a*(f*d-l*m)-s*(u*d-e*m)+v*(u*l-e*f),t[6]=-(a*(c*d-h*m)-o*(u*d-e*m)+v*(u*h-e*c)),t[7]=a*(c*l-h*f)-o*(u*l-e*f)+s*(u*h-e*c),t[8]=o*(M*d-l*b)-s*(i*d-h*b)+v*(i*l-h*M),t[9]=-(a*(M*d-l*b)-s*(r*d-e*b)+v*(r*l-e*M)),t[10]=a*(i*d-h*b)-o*(r*d-e*b)+v*(r*h-e*i),t[11]=-(a*(i*l-h*M)-o*(r*l-e*M)+s*(r*h-e*i)),t[12]=-(o*(M*m-f*b)-s*(i*m-c*b)+v*(i*f-c*M)),t[13]=a*(M*m-f*b)-s*(r*m-u*b)+v*(r*f-u*M),t[14]=-(a*(i*m-c*b)-o*(r*m-u*b)+v*(r*c-u*i)),t[15]=a*(i*f-c*M)-o*(r*f-u*M)+s*(r*c-u*i),t},determinant:function(t){var n=t[0],a=t[1],r=t[2],u=t[3],e=t[4],o=t[5],i=t[6],c=t[7],h=t[8],s=t[9],M=t[10],f=t[11],l=t[12],v=t[13],b=t[14],m=t[15];return(n*o-a*e)*(M*m-f*b)-(n*i-r*e)*(s*m-f*v)+(n*c-u*e)*(s*b-M*v)+(a*i-r*o)*(h*m-f*l)-(a*c-u*o)*(h*b-M*l)+(r*c-u*i)*(h*v-s*l)},multiply:A,translate:function(t,n,a){var r,u,e,o,i,c,h,s,M,f,l,v,b=a[0],m=a[1],d=a[2];return n===t?(t[12]=n[0]*b+n[4]*m+n[8]*d+n[12],t[13]=n[1]*b+n[5]*m+n[9]*d+n[13],t[14]=n[2]*b+n[6]*m+n[10]*d+n[14],t[15]=n[3]*b+n[7]*m+n[11]*d+n[15]):(r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=n[9],l=n[10],v=n[11],t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=i,t[5]=c,t[6]=h,t[7]=s,t[8]=M,t[9]=f,t[10]=l,t[11]=v,t[12]=r*b+i*m+M*d+n[12],t[13]=u*b+c*m+f*d+n[13],t[14]=e*b+h*m+l*d+n[14],t[15]=o*b+s*m+v*d+n[15]),t},scale:function(t,n,a){var r=a[0],u=a[1],e=a[2];return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*u,t[5]=n[5]*u,t[6]=n[6]*u,t[7]=n[7]*u,t[8]=n[8]*e,t[9]=n[9]*e,t[10]=n[10]*e,t[11]=n[11]*e,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},rotate:function(t,a,r,u){var e,o,i,c,h,s,M,f,l,v,b,m,d,x,p,y,q,g,A,w,R,z,P,j,I=u[0],S=u[1],E=u[2],O=Math.hypot(I,S,E);return O<n?null:(I*=O=1/O,S*=O,E*=O,e=Math.sin(r),i=1-(o=Math.cos(r)),c=a[0],h=a[1],s=a[2],M=a[3],f=a[4],l=a[5],v=a[6],b=a[7],m=a[8],d=a[9],x=a[10],p=a[11],y=I*I*i+o,q=S*I*i+E*e,g=E*I*i-S*e,A=I*S*i-E*e,w=S*S*i+o,R=E*S*i+I*e,z=I*E*i+S*e,P=S*E*i-I*e,j=E*E*i+o,t[0]=c*y+f*q+m*g,t[1]=h*y+l*q+d*g,t[2]=s*y+v*q+x*g,t[3]=M*y+b*q+p*g,t[4]=c*A+f*w+m*R,t[5]=h*A+l*w+d*R,t[6]=s*A+v*w+x*R,t[7]=M*A+b*w+p*R,t[8]=c*z+f*P+m*j,t[9]=h*z+l*P+d*j,t[10]=s*z+v*P+x*j,t[11]=M*z+b*P+p*j,a!==t&&(t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t)},rotateX:function(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[4],o=n[5],i=n[6],c=n[7],h=n[8],s=n[9],M=n[10],f=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=e*u+h*r,t[5]=o*u+s*r,t[6]=i*u+M*r,t[7]=c*u+f*r,t[8]=h*u-e*r,t[9]=s*u-o*r,t[10]=M*u-i*r,t[11]=f*u-c*r,t},rotateY:function(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[0],o=n[1],i=n[2],c=n[3],h=n[8],s=n[9],M=n[10],f=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=e*u-h*r,t[1]=o*u-s*r,t[2]=i*u-M*r,t[3]=c*u-f*r,t[8]=e*r+h*u,t[9]=o*r+s*u,t[10]=i*r+M*u,t[11]=c*r+f*u,t},rotateZ:function(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[0],o=n[1],i=n[2],c=n[3],h=n[4],s=n[5],M=n[6],f=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=e*u+h*r,t[1]=o*u+s*r,t[2]=i*u+M*r,t[3]=c*u+f*r,t[4]=h*u-e*r,t[5]=s*u-o*r,t[6]=M*u-i*r,t[7]=f*u-c*r,t},fromTranslation:function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromRotation:function(t,a,r){var u,e,o,i=r[0],c=r[1],h=r[2],s=Math.hypot(i,c,h);return s<n?null:(i*=s=1/s,c*=s,h*=s,u=Math.sin(a),o=1-(e=Math.cos(a)),t[0]=i*i*o+e,t[1]=c*i*o+h*u,t[2]=h*i*o-c*u,t[3]=0,t[4]=i*c*o-h*u,t[5]=c*c*o+e,t[6]=h*c*o+i*u,t[7]=0,t[8]=i*h*o+c*u,t[9]=c*h*o-i*u,t[10]=h*h*o+e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},fromXRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=a,t[7]=0,t[8]=0,t[9]=-a,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromYRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=0,t[2]=-a,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=a,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromZRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=0,t[3]=0,t[4]=-a,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromRotationTranslation:w,fromQuat2:function(t,n){var r=new a(3),u=-n[0],e=-n[1],o=-n[2],i=n[3],c=n[4],h=n[5],s=n[6],M=n[7],f=u*u+e*e+o*o+i*i;return f>0?(r[0]=2*(c*i+M*u+h*o-s*e)/f,r[1]=2*(h*i+M*e+s*u-c*o)/f,r[2]=2*(s*i+M*o+c*e-h*u)/f):(r[0]=2*(c*i+M*u+h*o-s*e),r[1]=2*(h*i+M*e+s*u-c*o),r[2]=2*(s*i+M*o+c*e-h*u)),w(t,n,r),t},getTranslation:R,getScaling:z,getRotation:P,fromRotationTranslationScale:function(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=n[3],c=u+u,h=e+e,s=o+o,M=u*c,f=u*h,l=u*s,v=e*h,b=e*s,m=o*s,d=i*c,x=i*h,p=i*s,y=r[0],q=r[1],g=r[2];return t[0]=(1-(v+m))*y,t[1]=(f+p)*y,t[2]=(l-x)*y,t[3]=0,t[4]=(f-p)*q,t[5]=(1-(M+m))*q,t[6]=(b+d)*q,t[7]=0,t[8]=(l+x)*g,t[9]=(b-d)*g,t[10]=(1-(M+v))*g,t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t},fromRotationTranslationScaleOrigin:function(t,n,a,r,u){var e=n[0],o=n[1],i=n[2],c=n[3],h=e+e,s=o+o,M=i+i,f=e*h,l=e*s,v=e*M,b=o*s,m=o*M,d=i*M,x=c*h,p=c*s,y=c*M,q=r[0],g=r[1],A=r[2],w=u[0],R=u[1],z=u[2],P=(1-(b+d))*q,j=(l+y)*q,I=(v-p)*q,S=(l-y)*g,E=(1-(f+d))*g,O=(m+x)*g,T=(v+p)*A,D=(m-x)*A,F=(1-(f+b))*A;return t[0]=P,t[1]=j,t[2]=I,t[3]=0,t[4]=S,t[5]=E,t[6]=O,t[7]=0,t[8]=T,t[9]=D,t[10]=F,t[11]=0,t[12]=a[0]+w-(P*w+S*R+T*z),t[13]=a[1]+R-(j*w+E*R+D*z),t[14]=a[2]+z-(I*w+O*R+F*z),t[15]=1,t},fromQuat:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a+a,i=r+r,c=u+u,h=a*o,s=r*o,M=r*i,f=u*o,l=u*i,v=u*c,b=e*o,m=e*i,d=e*c;return t[0]=1-M-v,t[1]=s+d,t[2]=f-m,t[3]=0,t[4]=s-d,t[5]=1-h-v,t[6]=l+b,t[7]=0,t[8]=f+m,t[9]=l-b,t[10]=1-h-M,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},frustum:function(t,n,a,r,u,e,o){var i=1/(a-n),c=1/(u-r),h=1/(e-o);return t[0]=2*e*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*e*c,t[6]=0,t[7]=0,t[8]=(a+n)*i,t[9]=(u+r)*c,t[10]=(o+e)*h,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*e*2*h,t[15]=0,t},perspective:function(t,n,a,r,u){var e,o=1/Math.tan(n/2);return t[0]=o/a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=u&&u!==1/0?(e=1/(r-u),t[10]=(u+r)*e,t[14]=2*u*r*e):(t[10]=-1,t[14]=-2*r),t},perspectiveFromFieldOfView:function(t,n,a,r){var u=Math.tan(n.upDegrees*Math.PI/180),e=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),c=2/(o+i),h=2/(u+e);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=h,t[6]=0,t[7]=0,t[8]=-(o-i)*c*.5,t[9]=(u-e)*h*.5,t[10]=r/(a-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*a/(a-r),t[15]=0,t},ortho:function(t,n,a,r,u,e,o){var i=1/(n-a),c=1/(r-u),h=1/(e-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(n+a)*i,t[13]=(u+r)*c,t[14]=(o+e)*h,t[15]=1,t},lookAt:function(t,a,r,u){var e,o,i,c,h,s,M,f,l,v,b=a[0],m=a[1],d=a[2],x=u[0],p=u[1],y=u[2],q=r[0],A=r[1],w=r[2];return Math.abs(b-q)<n&&Math.abs(m-A)<n&&Math.abs(d-w)<n?g(t):(M=b-q,f=m-A,l=d-w,e=p*(l*=v=1/Math.hypot(M,f,l))-y*(f*=v),o=y*(M*=v)-x*l,i=x*f-p*M,(v=Math.hypot(e,o,i))?(e*=v=1/v,o*=v,i*=v):(e=0,o=0,i=0),c=f*i-l*o,h=l*e-M*i,s=M*o-f*e,(v=Math.hypot(c,h,s))?(c*=v=1/v,h*=v,s*=v):(c=0,h=0,s=0),t[0]=e,t[1]=c,t[2]=M,t[3]=0,t[4]=o,t[5]=h,t[6]=f,t[7]=0,t[8]=i,t[9]=s,t[10]=l,t[11]=0,t[12]=-(e*b+o*m+i*d),t[13]=-(c*b+h*m+s*d),t[14]=-(M*b+f*m+l*d),t[15]=1,t)},targetTo:function(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=r[0],c=r[1],h=r[2],s=u-a[0],M=e-a[1],f=o-a[2],l=s*s+M*M+f*f;l>0&&(s*=l=1/Math.sqrt(l),M*=l,f*=l);var v=c*f-h*M,b=h*s-i*f,m=i*M-c*s;return(l=v*v+b*b+m*m)>0&&(v*=l=1/Math.sqrt(l),b*=l,m*=l),t[0]=v,t[1]=b,t[2]=m,t[3]=0,t[4]=M*m-f*b,t[5]=f*v-s*m,t[6]=s*b-M*v,t[7]=0,t[8]=s,t[9]=M,t[10]=f,t[11]=0,t[12]=u,t[13]=e,t[14]=o,t[15]=1,t},str:function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t[8]=n[8]+a[8],t[9]=n[9]+a[9],t[10]=n[10]+a[10],t[11]=n[11]+a[11],t[12]=n[12]+a[12],t[13]=n[13]+a[13],t[14]=n[14]+a[14],t[15]=n[15]+a[15],t},subtract:j,multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=n[11]*a,t[12]=n[12]*a,t[13]=n[13]*a,t[14]=n[14]*a,t[15]=n[15]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t[6]=n[6]+a[6]*r,t[7]=n[7]+a[7]*r,t[8]=n[8]+a[8]*r,t[9]=n[9]+a[9]*r,t[10]=n[10]+a[10]*r,t[11]=n[11]+a[11]*r,t[12]=n[12]+a[12]*r,t[13]=n[13]+a[13]*r,t[14]=n[14]+a[14]*r,t[15]=n[15]+a[15]*r,t},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=t[6],s=t[7],M=t[8],f=t[9],l=t[10],v=t[11],b=t[12],m=t[13],d=t[14],x=t[15],p=a[0],y=a[1],q=a[2],g=a[3],A=a[4],w=a[5],R=a[6],z=a[7],P=a[8],j=a[9],I=a[10],S=a[11],E=a[12],O=a[13],T=a[14],D=a[15];return Math.abs(r-p)<=n*Math.max(1,Math.abs(r),Math.abs(p))&&Math.abs(u-y)<=n*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(e-q)<=n*Math.max(1,Math.abs(e),Math.abs(q))&&Math.abs(o-g)<=n*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-A)<=n*Math.max(1,Math.abs(i),Math.abs(A))&&Math.abs(c-w)<=n*Math.max(1,Math.abs(c),Math.abs(w))&&Math.abs(h-R)<=n*Math.max(1,Math.abs(h),Math.abs(R))&&Math.abs(s-z)<=n*Math.max(1,Math.abs(s),Math.abs(z))&&Math.abs(M-P)<=n*Math.max(1,Math.abs(M),Math.abs(P))&&Math.abs(f-j)<=n*Math.max(1,Math.abs(f),Math.abs(j))&&Math.abs(l-I)<=n*Math.max(1,Math.abs(l),Math.abs(I))&&Math.abs(v-S)<=n*Math.max(1,Math.abs(v),Math.abs(S))&&Math.abs(b-E)<=n*Math.max(1,Math.abs(b),Math.abs(E))&&Math.abs(m-O)<=n*Math.max(1,Math.abs(m),Math.abs(O))&&Math.abs(d-T)<=n*Math.max(1,Math.abs(d),Math.abs(T))&&Math.abs(x-D)<=n*Math.max(1,Math.abs(x),Math.abs(D))},mul:I,sub:S});function O(){var t=new a(3);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function T(t){var n=t[0],a=t[1],r=t[2];return Math.hypot(n,a,r)}function D(t,n,r){var u=new a(3);return u[0]=t,u[1]=n,u[2]=r,u}function F(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t}function L(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t[2]=n[2]*a[2],t}function V(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t[2]=n[2]/a[2],t}function Q(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2];return Math.hypot(a,r,u)}function Y(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2];return a*a+r*r+u*u}function X(t){var n=t[0],a=t[1],r=t[2];return n*n+a*a+r*r}function Z(t,n){var a=n[0],r=n[1],u=n[2],e=a*a+r*r+u*u;return e>0&&(e=1/Math.sqrt(e)),t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}function _(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function B(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[0],i=a[1],c=a[2];return t[0]=u*c-e*i,t[1]=e*o-r*c,t[2]=r*i-u*o,t}var N,k=F,U=L,W=V,C=Q,G=Y,H=T,J=X,K=(N=O(),function(t,n,a,r,u,e){var o,i;for(n||(n=3),a||(a=0),i=r?Math.min(r*n+a,t.length):t.length,o=a;o<i;o+=n)N[0]=t[o],N[1]=t[o+1],N[2]=t[o+2],u(N,N,e),t[o]=N[0],t[o+1]=N[1],t[o+2]=N[2];return t}),$=Object.freeze({create:O,clone:function(t){var n=new a(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},length:T,fromValues:D,copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},set:function(t,n,a,r){return t[0]=n,t[1]=a,t[2]=r,t},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t},subtract:F,multiply:L,divide:V,ceil:function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t},floor:function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t},min:function(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t[2]=Math.min(n[2],a[2]),t},max:function(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t[2]=Math.max(n[2],a[2]),t},round:function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t},scale:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t},scaleAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t},distance:Q,squaredDistance:Y,squaredLength:X,negate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},inverse:function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},normalize:Z,dot:_,cross:B,lerp:function(t,n,a,r){var u=n[0],e=n[1],o=n[2];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t[2]=o+r*(a[2]-o),t},hermite:function(t,n,a,r,u,e){var o=e*e,i=o*(2*e-3)+1,c=o*(e-2)+e,h=o*(e-1),s=o*(3-2*e);return t[0]=n[0]*i+a[0]*c+r[0]*h+u[0]*s,t[1]=n[1]*i+a[1]*c+r[1]*h+u[1]*s,t[2]=n[2]*i+a[2]*c+r[2]*h+u[2]*s,t},bezier:function(t,n,a,r,u,e){var o=1-e,i=o*o,c=e*e,h=i*o,s=3*e*i,M=3*c*o,f=c*e;return t[0]=n[0]*h+a[0]*s+r[0]*M+u[0]*f,t[1]=n[1]*h+a[1]*s+r[1]*M+u[1]*f,t[2]=n[2]*h+a[2]*s+r[2]*M+u[2]*f,t},random:function(t,n){n=n||1;var a=2*r()*Math.PI,u=2*r()-1,e=Math.sqrt(1-u*u)*n;return t[0]=Math.cos(a)*e,t[1]=Math.sin(a)*e,t[2]=u*n,t},transformMat4:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[3]*r+a[7]*u+a[11]*e+a[15];return o=o||1,t[0]=(a[0]*r+a[4]*u+a[8]*e+a[12])/o,t[1]=(a[1]*r+a[5]*u+a[9]*e+a[13])/o,t[2]=(a[2]*r+a[6]*u+a[10]*e+a[14])/o,t},transformMat3:function(t,n,a){var r=n[0],u=n[1],e=n[2];return t[0]=r*a[0]+u*a[3]+e*a[6],t[1]=r*a[1]+u*a[4]+e*a[7],t[2]=r*a[2]+u*a[5]+e*a[8],t},transformQuat:function(t,n,a){var r=a[0],u=a[1],e=a[2],o=a[3],i=n[0],c=n[1],h=n[2],s=u*h-e*c,M=e*i-r*h,f=r*c-u*i,l=u*f-e*M,v=e*s-r*f,b=r*M-u*s,m=2*o;return s*=m,M*=m,f*=m,l*=2,v*=2,b*=2,t[0]=i+s+l,t[1]=c+M+v,t[2]=h+f+b,t},rotateX:function(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[0],e[1]=u[1]*Math.cos(r)-u[2]*Math.sin(r),e[2]=u[1]*Math.sin(r)+u[2]*Math.cos(r),t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t},rotateY:function(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[2]*Math.sin(r)+u[0]*Math.cos(r),e[1]=u[1],e[2]=u[2]*Math.cos(r)-u[0]*Math.sin(r),t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t},rotateZ:function(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[0]*Math.cos(r)-u[1]*Math.sin(r),e[1]=u[0]*Math.sin(r)+u[1]*Math.cos(r),e[2]=u[2],t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t},angle:function(t,n){var a=D(t[0],t[1],t[2]),r=D(n[0],n[1],n[2]);Z(a,a),Z(r,r);var u=_(a,r);return u>1?0:u<-1?Math.PI:Math.acos(u)},zero:function(t){return t[0]=0,t[1]=0,t[2]=0,t},str:function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=a[0],i=a[1],c=a[2];return Math.abs(r-o)<=n*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(u-i)<=n*Math.max(1,Math.abs(u),Math.abs(i))&&Math.abs(e-c)<=n*Math.max(1,Math.abs(e),Math.abs(c))},sub:k,mul:U,div:W,dist:C,sqrDist:G,len:H,sqrLen:J,forEach:K});function tt(){var t=new a(4);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function nt(t){var n=new a(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function at(t,n,r,u){var e=new a(4);return e[0]=t,e[1]=n,e[2]=r,e[3]=u,e}function rt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function ut(t,n,a,r,u){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t}function et(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t}function ot(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t}function it(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t[2]=n[2]*a[2],t[3]=n[3]*a[3],t}function ct(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t[2]=n[2]/a[2],t[3]=n[3]/a[3],t}function ht(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t}function st(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2],e=n[3]-t[3];return Math.hypot(a,r,u,e)}function Mt(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2],e=n[3]-t[3];return a*a+r*r+u*u+e*e}function ft(t){var n=t[0],a=t[1],r=t[2],u=t[3];return Math.hypot(n,a,r,u)}function lt(t){var n=t[0],a=t[1],r=t[2],u=t[3];return n*n+a*a+r*r+u*u}function vt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*a+r*r+u*u+e*e;return o>0&&(o=1/Math.sqrt(o)),t[0]=a*o,t[1]=r*o,t[2]=u*o,t[3]=e*o,t}function bt(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]}function mt(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=n[3];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t[2]=o+r*(a[2]-o),t[3]=i+r*(a[3]-i),t}function dt(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function xt(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=a[0],c=a[1],h=a[2],s=a[3];return Math.abs(r-i)<=n*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(u-c)<=n*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(e-h)<=n*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(o-s)<=n*Math.max(1,Math.abs(o),Math.abs(s))}var pt=ot,yt=it,qt=ct,gt=st,At=Mt,wt=ft,Rt=lt,zt=function(){var t=tt();return function(n,a,r,u,e,o){var i,c;for(a||(a=4),r||(r=0),c=u?Math.min(u*a+r,n.length):n.length,i=r;i<c;i+=a)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],e(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}(),Pt=Object.freeze({create:tt,clone:nt,fromValues:at,copy:rt,set:ut,add:et,subtract:ot,multiply:it,divide:ct,ceil:function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t},floor:function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t},min:function(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t[2]=Math.min(n[2],a[2]),t[3]=Math.min(n[3],a[3]),t},max:function(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t[2]=Math.max(n[2],a[2]),t[3]=Math.max(n[3],a[3]),t},round:function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t},scale:ht,scaleAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t},distance:st,squaredDistance:Mt,length:ft,squaredLength:lt,negate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},inverse:function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},normalize:vt,dot:bt,cross:function(t,n,a,r){var u=a[0]*r[1]-a[1]*r[0],e=a[0]*r[2]-a[2]*r[0],o=a[0]*r[3]-a[3]*r[0],i=a[1]*r[2]-a[2]*r[1],c=a[1]*r[3]-a[3]*r[1],h=a[2]*r[3]-a[3]*r[2],s=n[0],M=n[1],f=n[2],l=n[3];return t[0]=M*h-f*c+l*i,t[1]=-s*h+f*o-l*e,t[2]=s*c-M*o+l*u,t[3]=-s*i+M*e-f*u,t},lerp:mt,random:function(t,n){var a,u,e,o,i,c;n=n||1;do{i=(a=2*r()-1)*a+(u=2*r()-1)*u}while(i>=1);do{c=(e=2*r()-1)*e+(o=2*r()-1)*o}while(c>=1);var h=Math.sqrt((1-i)/c);return t[0]=n*a,t[1]=n*u,t[2]=n*e*h,t[3]=n*o*h,t},transformMat4:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3];return t[0]=a[0]*r+a[4]*u+a[8]*e+a[12]*o,t[1]=a[1]*r+a[5]*u+a[9]*e+a[13]*o,t[2]=a[2]*r+a[6]*u+a[10]*e+a[14]*o,t[3]=a[3]*r+a[7]*u+a[11]*e+a[15]*o,t},transformQuat:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[0],i=a[1],c=a[2],h=a[3],s=h*r+i*e-c*u,M=h*u+c*r-o*e,f=h*e+o*u-i*r,l=-o*r-i*u-c*e;return t[0]=s*h+l*-o+M*-c-f*-i,t[1]=M*h+l*-i+f*-o-s*-c,t[2]=f*h+l*-c+s*-i-M*-o,t[3]=n[3],t},zero:function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},str:function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},exactEquals:dt,equals:xt,sub:pt,mul:yt,div:qt,dist:gt,sqrDist:At,len:wt,sqrLen:Rt,forEach:zt});function jt(){var t=new a(4);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function It(t,n,a){a*=.5;var r=Math.sin(a);return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=Math.cos(a),t}function St(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1],h=a[2],s=a[3];return t[0]=r*s+o*i+u*h-e*c,t[1]=u*s+o*c+e*i-r*h,t[2]=e*s+o*h+r*c-u*i,t[3]=o*s-r*i-u*c-e*h,t}function Et(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c+o*i,t[1]=u*c+e*i,t[2]=e*c-u*i,t[3]=o*c-r*i,t}function Ot(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c-e*i,t[1]=u*c+o*i,t[2]=e*c+r*i,t[3]=o*c-u*i,t}function Tt(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c+u*i,t[1]=u*c-r*i,t[2]=e*c+o*i,t[3]=o*c-e*i,t}function Dt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=Math.sqrt(a*a+r*r+u*u),i=Math.exp(e),c=o>0?i*Math.sin(o)/o:0;return t[0]=a*c,t[1]=r*c,t[2]=u*c,t[3]=i*Math.cos(o),t}function Ft(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=Math.sqrt(a*a+r*r+u*u),i=o>0?Math.atan2(o,e)/o:0;return t[0]=a*i,t[1]=r*i,t[2]=u*i,t[3]=.5*Math.log(a*a+r*r+u*u+e*e),t}function Lt(t,a,r,u){var e,o,i,c,h,s=a[0],M=a[1],f=a[2],l=a[3],v=r[0],b=r[1],m=r[2],d=r[3];return(o=s*v+M*b+f*m+l*d)<0&&(o=-o,v=-v,b=-b,m=-m,d=-d),1-o>n?(e=Math.acos(o),i=Math.sin(e),c=Math.sin((1-u)*e)/i,h=Math.sin(u*e)/i):(c=1-u,h=u),t[0]=c*s+h*v,t[1]=c*M+h*b,t[2]=c*f+h*m,t[3]=c*l+h*d,t}function Vt(t,n){var a,r=n[0]+n[4]+n[8];if(r>0)a=Math.sqrt(r+1),t[3]=.5*a,a=.5/a,t[0]=(n[5]-n[7])*a,t[1]=(n[6]-n[2])*a,t[2]=(n[1]-n[3])*a;else{var u=0;n[4]>n[0]&&(u=1),n[8]>n[3*u+u]&&(u=2);var e=(u+1)%3,o=(u+2)%3;a=Math.sqrt(n[3*u+u]-n[3*e+e]-n[3*o+o]+1),t[u]=.5*a,a=.5/a,t[3]=(n[3*e+o]-n[3*o+e])*a,t[e]=(n[3*e+u]+n[3*u+e])*a,t[o]=(n[3*o+u]+n[3*u+o])*a}return t}var Qt,Yt,Xt,Zt,_t,Bt,Nt=nt,kt=at,Ut=rt,Wt=ut,Ct=et,Gt=St,Ht=ht,Jt=bt,Kt=mt,$t=ft,tn=$t,nn=lt,an=nn,rn=vt,un=dt,en=xt,on=(Qt=O(),Yt=D(1,0,0),Xt=D(0,1,0),function(t,n,a){var r=_(n,a);return r<-.999999?(B(Qt,Yt,n),H(Qt)<1e-6&&B(Qt,Xt,n),Z(Qt,Qt),It(t,Qt,Math.PI),t):r>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(B(Qt,n,a),t[0]=Qt[0],t[1]=Qt[1],t[2]=Qt[2],t[3]=1+r,rn(t,t))}),cn=(Zt=jt(),_t=jt(),function(t,n,a,r,u,e){return Lt(Zt,n,u,e),Lt(_t,a,r,e),Lt(t,Zt,_t,2*e*(1-e)),t}),hn=(Bt=m(),function(t,n,a,r){return Bt[0]=a[0],Bt[3]=a[1],Bt[6]=a[2],Bt[1]=r[0],Bt[4]=r[1],Bt[7]=r[2],Bt[2]=-n[0],Bt[5]=-n[1],Bt[8]=-n[2],rn(t,Vt(t,Bt))}),sn=Object.freeze({create:jt,identity:function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},setAxisAngle:It,getAxisAngle:function(t,a){var r=2*Math.acos(a[3]),u=Math.sin(r/2);return u>n?(t[0]=a[0]/u,t[1]=a[1]/u,t[2]=a[2]/u):(t[0]=1,t[1]=0,t[2]=0),r},getAngle:function(t,n){var a=Jt(t,n);return Math.acos(2*a*a-1)},multiply:St,rotateX:Et,rotateY:Ot,rotateZ:Tt,calculateW:function(t,n){var a=n[0],r=n[1],u=n[2];return t[0]=a,t[1]=r,t[2]=u,t[3]=Math.sqrt(Math.abs(1-a*a-r*r-u*u)),t},exp:Dt,ln:Ft,pow:function(t,n,a){return Ft(t,n),Ht(t,t,a),Dt(t,t),t},slerp:Lt,random:function(t){var n=r(),a=r(),u=r(),e=Math.sqrt(1-n),o=Math.sqrt(n);return t[0]=e*Math.sin(2*Math.PI*a),t[1]=e*Math.cos(2*Math.PI*a),t[2]=o*Math.sin(2*Math.PI*u),t[3]=o*Math.cos(2*Math.PI*u),t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*a+r*r+u*u+e*e,i=o?1/o:0;return t[0]=-a*i,t[1]=-r*i,t[2]=-u*i,t[3]=e*i,t},conjugate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},fromMat3:Vt,fromEuler:function(t,n,a,r){var u=.5*Math.PI/180;n*=u,a*=u,r*=u;var e=Math.sin(n),o=Math.cos(n),i=Math.sin(a),c=Math.cos(a),h=Math.sin(r),s=Math.cos(r);return t[0]=e*c*s-o*i*h,t[1]=o*i*s+e*c*h,t[2]=o*c*h-e*i*s,t[3]=o*c*s+e*i*h,t},str:function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},clone:Nt,fromValues:kt,copy:Ut,set:Wt,add:Ct,mul:Gt,scale:Ht,dot:Jt,lerp:Kt,length:$t,len:tn,squaredLength:nn,sqrLen:an,normalize:rn,exactEquals:un,equals:en,rotationTo:on,sqlerp:cn,setAxes:hn});function Mn(t,n,a){var r=.5*a[0],u=.5*a[1],e=.5*a[2],o=n[0],i=n[1],c=n[2],h=n[3];return t[0]=o,t[1]=i,t[2]=c,t[3]=h,t[4]=r*h+u*c-e*i,t[5]=u*h+e*o-r*c,t[6]=e*h+r*i-u*o,t[7]=-r*o-u*i-e*c,t}function fn(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t}var ln=Ut;var vn=Ut;function bn(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[4],c=a[5],h=a[6],s=a[7],M=n[4],f=n[5],l=n[6],v=n[7],b=a[0],m=a[1],d=a[2],x=a[3];return t[0]=r*x+o*b+u*d-e*m,t[1]=u*x+o*m+e*b-r*d,t[2]=e*x+o*d+r*m-u*b,t[3]=o*x-r*b-u*m-e*d,t[4]=r*s+o*i+u*h-e*c+M*x+v*b+f*d-l*m,t[5]=u*s+o*c+e*i-r*h+f*x+v*m+l*b-M*d,t[6]=e*s+o*h+r*c-u*i+l*x+v*d+M*m-f*b,t[7]=o*s-r*i-u*c-e*h+v*x-M*b-f*m-l*d,t}var mn=bn;var dn=Jt;var xn=$t,pn=xn,yn=nn,qn=yn;var gn=Object.freeze({create:function(){var t=new a(8);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0),t[3]=1,t},clone:function(t){var n=new a(8);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n},fromValues:function(t,n,r,u,e,o,i,c){var h=new a(8);return h[0]=t,h[1]=n,h[2]=r,h[3]=u,h[4]=e,h[5]=o,h[6]=i,h[7]=c,h},fromRotationTranslationValues:function(t,n,r,u,e,o,i){var c=new a(8);c[0]=t,c[1]=n,c[2]=r,c[3]=u;var h=.5*e,s=.5*o,M=.5*i;return c[4]=h*u+s*r-M*n,c[5]=s*u+M*t-h*r,c[6]=M*u+h*n-s*t,c[7]=-h*t-s*n-M*r,c},fromRotationTranslation:Mn,fromTranslation:function(t,n){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*n[0],t[5]=.5*n[1],t[6]=.5*n[2],t[7]=0,t},fromRotation:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},fromMat4:function(t,n){var r=jt();P(r,n);var u=new a(3);return R(u,n),Mn(t,r,u),t},copy:fn,identity:function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},set:function(t,n,a,r,u,e,o,i,c){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=c,t},getReal:ln,getDual:function(t,n){return t[0]=n[4],t[1]=n[5],t[2]=n[6],t[3]=n[7],t},setReal:vn,setDual:function(t,n){return t[4]=n[0],t[5]=n[1],t[6]=n[2],t[7]=n[3],t},getTranslation:function(t,n){var a=n[4],r=n[5],u=n[6],e=n[7],o=-n[0],i=-n[1],c=-n[2],h=n[3];return t[0]=2*(a*h+e*o+r*c-u*i),t[1]=2*(r*h+e*i+u*o-a*c),t[2]=2*(u*h+e*c+a*i-r*o),t},translate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=.5*a[0],c=.5*a[1],h=.5*a[2],s=n[4],M=n[5],f=n[6],l=n[7];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=o*i+u*h-e*c+s,t[5]=o*c+e*i-r*h+M,t[6]=o*h+r*c-u*i+f,t[7]=-r*i-u*c-e*h+l,t},rotateX:function(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=i*o+s*r+c*e-h*u,f=c*o+s*u+h*r-i*e,l=h*o+s*e+i*u-c*r,v=s*o-i*r-c*u-h*e;return Et(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t},rotateY:function(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=i*o+s*r+c*e-h*u,f=c*o+s*u+h*r-i*e,l=h*o+s*e+i*u-c*r,v=s*o-i*r-c*u-h*e;return Ot(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t},rotateZ:function(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=i*o+s*r+c*e-h*u,f=c*o+s*u+h*r-i*e,l=h*o+s*e+i*u-c*r,v=s*o-i*r-c*u-h*e;return Tt(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t},rotateByQuatAppend:function(t,n,a){var r=a[0],u=a[1],e=a[2],o=a[3],i=n[0],c=n[1],h=n[2],s=n[3];return t[0]=i*o+s*r+c*e-h*u,t[1]=c*o+s*u+h*r-i*e,t[2]=h*o+s*e+i*u-c*r,t[3]=s*o-i*r-c*u-h*e,i=n[4],c=n[5],h=n[6],s=n[7],t[4]=i*o+s*r+c*e-h*u,t[5]=c*o+s*u+h*r-i*e,t[6]=h*o+s*e+i*u-c*r,t[7]=s*o-i*r-c*u-h*e,t},rotateByQuatPrepend:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1],h=a[2],s=a[3];return t[0]=r*s+o*i+u*h-e*c,t[1]=u*s+o*c+e*i-r*h,t[2]=e*s+o*h+r*c-u*i,t[3]=o*s-r*i-u*c-e*h,i=a[4],c=a[5],h=a[6],s=a[7],t[4]=r*s+o*i+u*h-e*c,t[5]=u*s+o*c+e*i-r*h,t[6]=e*s+o*h+r*c-u*i,t[7]=o*s-r*i-u*c-e*h,t},rotateAroundAxis:function(t,a,r,u){if(Math.abs(u)<n)return fn(t,a);var e=Math.hypot(r[0],r[1],r[2]);u*=.5;var o=Math.sin(u),i=o*r[0]/e,c=o*r[1]/e,h=o*r[2]/e,s=Math.cos(u),M=a[0],f=a[1],l=a[2],v=a[3];t[0]=M*s+v*i+f*h-l*c,t[1]=f*s+v*c+l*i-M*h,t[2]=l*s+v*h+M*c-f*i,t[3]=v*s-M*i-f*c-l*h;var b=a[4],m=a[5],d=a[6],x=a[7];return t[4]=b*s+x*i+m*h-d*c,t[5]=m*s+x*c+d*i-b*h,t[6]=d*s+x*h+b*c-m*i,t[7]=x*s-b*i-m*c-d*h,t},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t},multiply:bn,mul:mn,scale:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t},dot:dn,lerp:function(t,n,a,r){var u=1-r;return dn(n,a)<0&&(r=-r),t[0]=n[0]*u+a[0]*r,t[1]=n[1]*u+a[1]*r,t[2]=n[2]*u+a[2]*r,t[3]=n[3]*u+a[3]*r,t[4]=n[4]*u+a[4]*r,t[5]=n[5]*u+a[5]*r,t[6]=n[6]*u+a[6]*r,t[7]=n[7]*u+a[7]*r,t},invert:function(t,n){var a=yn(n);return t[0]=-n[0]/a,t[1]=-n[1]/a,t[2]=-n[2]/a,t[3]=n[3]/a,t[4]=-n[4]/a,t[5]=-n[5]/a,t[6]=-n[6]/a,t[7]=n[7]/a,t},conjugate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=n[7],t},length:xn,len:pn,squaredLength:yn,sqrLen:qn,normalize:function(t,n){var a=yn(n);if(a>0){a=Math.sqrt(a);var r=n[0]/a,u=n[1]/a,e=n[2]/a,o=n[3]/a,i=n[4],c=n[5],h=n[6],s=n[7],M=r*i+u*c+e*h+o*s;t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=(i-r*M)/a,t[5]=(c-u*M)/a,t[6]=(h-e*M)/a,t[7]=(s-o*M)/a}return t},str:function(t){return"quat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+")"},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=t[6],s=t[7],M=a[0],f=a[1],l=a[2],v=a[3],b=a[4],m=a[5],d=a[6],x=a[7];return Math.abs(r-M)<=n*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(u-f)<=n*Math.max(1,Math.abs(u),Math.abs(f))&&Math.abs(e-l)<=n*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(o-v)<=n*Math.max(1,Math.abs(o),Math.abs(v))&&Math.abs(i-b)<=n*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(c-m)<=n*Math.max(1,Math.abs(c),Math.abs(m))&&Math.abs(h-d)<=n*Math.max(1,Math.abs(h),Math.abs(d))&&Math.abs(s-x)<=n*Math.max(1,Math.abs(s),Math.abs(x))}});function An(){var t=new a(2);return a!=Float32Array&&(t[0]=0,t[1]=0),t}function wn(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t}function Rn(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t}function zn(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t}function Pn(t,n){var a=n[0]-t[0],r=n[1]-t[1];return Math.hypot(a,r)}function jn(t,n){var a=n[0]-t[0],r=n[1]-t[1];return a*a+r*r}function In(t){var n=t[0],a=t[1];return Math.hypot(n,a)}function Sn(t){var n=t[0],a=t[1];return n*n+a*a}var En=In,On=wn,Tn=Rn,Dn=zn,Fn=Pn,Ln=jn,Vn=Sn,Qn=function(){var t=An();return function(n,a,r,u,e,o){var i,c;for(a||(a=2),r||(r=0),c=u?Math.min(u*a+r,n.length):n.length,i=r;i<c;i+=a)t[0]=n[i],t[1]=n[i+1],e(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}(),Yn=Object.freeze({create:An,clone:function(t){var n=new a(2);return n[0]=t[0],n[1]=t[1],n},fromValues:function(t,n){var r=new a(2);return r[0]=t,r[1]=n,r},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t},set:function(t,n,a){return t[0]=n,t[1]=a,t},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t},subtract:wn,multiply:Rn,divide:zn,ceil:function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t},floor:function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t},min:function(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t},max:function(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t},round:function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t},scale:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t},scaleAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t},distance:Pn,squaredDistance:jn,length:In,squaredLength:Sn,negate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t},inverse:function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},normalize:function(t,n){var a=n[0],r=n[1],u=a*a+r*r;return u>0&&(u=1/Math.sqrt(u)),t[0]=n[0]*u,t[1]=n[1]*u,t},dot:function(t,n){return t[0]*n[0]+t[1]*n[1]},cross:function(t,n,a){var r=n[0]*a[1]-n[1]*a[0];return t[0]=t[1]=0,t[2]=r,t},lerp:function(t,n,a,r){var u=n[0],e=n[1];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t},random:function(t,n){n=n||1;var a=2*r()*Math.PI;return t[0]=Math.cos(a)*n,t[1]=Math.sin(a)*n,t},transformMat2:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[2]*u,t[1]=a[1]*r+a[3]*u,t},transformMat2d:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[2]*u+a[4],t[1]=a[1]*r+a[3]*u+a[5],t},transformMat3:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[3]*u+a[6],t[1]=a[1]*r+a[4]*u+a[7],t},transformMat4:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[4]*u+a[12],t[1]=a[1]*r+a[5]*u+a[13],t},rotate:function(t,n,a,r){var u=n[0]-a[0],e=n[1]-a[1],o=Math.sin(r),i=Math.cos(r);return t[0]=u*i-e*o+a[0],t[1]=u*o+e*i+a[1],t},angle:function(t,n){var a=t[0],r=t[1],u=n[0],e=n[1],o=a*a+r*r;o>0&&(o=1/Math.sqrt(o));var i=u*u+e*e;i>0&&(i=1/Math.sqrt(i));var c=(a*u+r*e)*o*i;return c>1?0:c<-1?Math.PI:Math.acos(c)},zero:function(t){return t[0]=0,t[1]=0,t},str:function(t){return"vec2("+t[0]+", "+t[1]+")"},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]},equals:function(t,a){var r=t[0],u=t[1],e=a[0],o=a[1];return Math.abs(r-e)<=n*Math.max(1,Math.abs(r),Math.abs(e))&&Math.abs(u-o)<=n*Math.max(1,Math.abs(u),Math.abs(o))},len:En,sub:On,mul:Tn,div:Dn,dist:Fn,sqrDist:Ln,sqrLen:Vn,forEach:Qn});t.glMatrix=e,t.mat2=s,t.mat2d=b,t.mat3=q,t.mat4=E,t.quat=sn,t.quat2=gn,t.vec2=Yn,t.vec3=$,t.vec4=Pt,Object.defineProperty(t,"__esModule",{value:!0})});

// ["glMatrix", "mat2", "mat2d", "mat3", "mat4", "quat", "quat2", "vec2", "vec3", "vec4"]
window.glMatrix = glMatrix;
window.mat2 = glMatrix.mat2;
window.mat2d = glMatrix.mat2d;
window.mat3 = glMatrix.mat3;
window.mat4 = glMatrix.mat4;
window.quat = glMatrix.quat;
window.quat2 = glMatrix.quat2;
window.vec2 = glMatrix.vec2;
window.vec3 = glMatrix.vec3;
window.vec4 = glMatrix.vec4;



var CABLES = CABLES || {}; CABLES.build = {"timestamp":1707302392182,"created":"2024-02-07T10:39:52.182Z","git":{"branch":"master","commit":"d110e346f781717b29314c9073ca439cd71dc843","date":"2024-02-07T10:39:23.000Z","message":"Merge branch 'master' of github.com:pandrr/cables"}};

if(!CABLES.exportedPatches) CABLES.exportedPatches={};CABLES.exportedPatches['L3eri4']={"ops":[{"id":"smtodxhtv","uiAttribs":{},"portsIn":[{"name":"Area index","value":0},{"name":"Area","value":"Canvas"},{"name":"Active","value":true}],"portsOut":[{"name":"Click Left","links":[{"portIn":"Start","portOut":"Click Left","objIn":"sjcgdjdex","objOut":"smtodxhtv"}]},{"name":"Button pressed Left","links":[{"portIn":"Value In","portOut":"Button pressed Left","objIn":"49pg7wh42","objOut":"smtodxhtv"}]},{"name":"Button pressed Middle","value":0},{"name":"Button pressed Right","value":0},{"name":"Mouse Down Left","links":[{"portIn":"exe","portOut":"Mouse Down Left","objIn":"pmsecvr1z","objOut":"smtodxhtv"}]},{"name":"Mouse Down Right","links":[{"portIn":"Reset","portOut":"Mouse Down Right","objIn":"76ucdw0ke","objOut":"smtodxhtv"}]}],"objName":"Ops.Devices.Mouse.MouseButtons"},{"id":"gwkvu5snd","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"mainClock"}],"objName":"Ops.Trigger.TriggerSend"},{"id":"sjcgdjdex","uiAttribs":{},"portsIn":[{"name":"Duration Out","value":0.01},{"name":"Easing Out index","value":0},{"name":"Easing Out","value":"Cubic In"},{"name":"Value Out","value":0},{"name":"Hold duration","value":0.1},{"name":"Duration In","value":0.1},{"name":"Easing In index","value":0},{"name":"Easing In","value":"linear"},{"name":"Value In","value":0.8}],"portsOut":[{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"96x83vsk6","objOut":"sjcgdjdex"}]}],"objName":"Ops.Anim.InOutInAnim"},{"id":"a3n1oh5tw","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"leftButtonDown"}],"objName":"Ops.Trigger.TriggerSend"},{"id":"lboeuww7w","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_mod"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"gv5zyiqy7","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Visible","value":true},{"name":"Opacity","value":1},{"name":"Default Minimized","value":true},{"name":"Minimized Opacity","value":0.5},{"name":"Show undo button","value":false},{"name":"Show Minimize","value":true},{"name":"Title","value":"Parameters"},{"name":"Side","value":true},{"name":"Default CSS","value":true}],"portsOut":[{"name":"childs","title":"Children","links":[{"portIn":"link","portOut":"childs","objIn":"styx85rm7","objOut":"gv5zyiqy7"},{"portIn":"link","portOut":"childs","objIn":"6b0c7688-6521-4e6a-aef5-a5c23e057783","objOut":"gv5zyiqy7"}]},{"name":"Opfened","value":true,"title":"Opened"}],"objName":"Ops.Sidebar.Sidebar"},{"id":"3yjp0l99a","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_mix"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"styx85rm7","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Width","value":180},{"name":"Round Corners","value":12.5},{"name":"Special Color","value":"#a01074"}],"objName":"Ops.Sidebar.SideBarStyle"},{"id":"daq6ojhol","uiAttribs":{},"portsIn":[{"name":"Speed","value":3},{"name":"Play","value":true},{"name":"Sync to timeline","value":false}],"portsOut":[{"name":"Time","links":[{"portIn":"Value","portOut":"Time","objIn":"erjz7zx43","objOut":"daq6ojhol"}]}],"objName":"Ops.Anim.Timer_v2"},{"id":"xijlxsttk","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"Reset","portOut":"Next","objIn":"daq6ojhol","objOut":"xijlxsttk"},{"portIn":"Trigger","portOut":"Next","objIn":"h1cfb32rh","objOut":"xijlxsttk"}]},{"name":"Was Triggered","value":1}],"objName":"Ops.Trigger.TriggerOnce"},{"id":"erjz7zx43","uiAttribs":{},"portsIn":[{"name":"Min","value":0},{"name":"Max","value":4},{"name":"Easing index","value":0},{"name":"Easing","value":"Sin Out"}],"portsOut":[{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"05tl2aqf5","objOut":"erjz7zx43"}]}],"objName":"Ops.Math.Ease"},{"id":"05tl2aqf5","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_fadeUp"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"8nr86xjqq","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_decay"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"reovflbwn","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_size"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"m5a9my9f7","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsOut":[{"name":"create port","value":0}],"objName":"Ops.Ui.PatchInput"},{"id":"fhm4em29q","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"create port","value":0}],"objName":"Ops.Ui.PatchOutput"},{"id":"oeb6iwib9","uiAttribs":{},"storage":{"subPatchVer":1},"portsIn":[{"name":"create port","value":0},{"name":"dataStr","value":0},{"name":"patchId","value":"9d01962a-fa89-4cfb-b892-b87e7423e92f"}],"portsOut":[{"name":"create port out","value":0}],"objName":"Ops.Ui.SubPatch"},{"id":"zxiclv8ke","uiAttribs":{},"portsIn":[{"name":"Title","value":"Interactivity"}],"objName":"Ops.Ui.Area"},{"id":"kjz264ffc","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_buttonDown"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"qe1i0ww8p","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_storedPresets"}],"objName":"Ops.Vars.VarSetArray_v2"},{"id":"ejhvngei8","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_storedPresets"}],"portsOut":[{"name":"Value","links":[{"portIn":"Array of Arrays","portOut":"Value","objIn":"ng57avp3w","objOut":"ejhvngei8"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"ng57avp3w","uiAttribs":{},"portsOut":[{"name":"Result Array","links":[{"portIn":"Array","portOut":"Result Array","objIn":"5edgaaahs","objOut":"ng57avp3w"}]}],"objName":"Ops.Array.ArrayGetArray"},{"id":"uqskenl8e","uiAttribs":{},"portsIn":[{"name":"render","title":"Trigger"},{"name":"Render Mesh","value":true,"title":"Render"},{"name":"width","value":0.12360939431396786},{"name":"height","value":0.82},{"name":"pivot x index","value":1},{"name":"pivot x","value":"left"},{"name":"pivot y index","value":1},{"name":"pivot y","value":"top"},{"name":"axis index","value":0},{"name":"axis","value":"xy"},{"name":"Flip TexCoord X","value":false},{"name":"Flip TexCoord Y","value":true},{"name":"num columns","value":4},{"name":"num rows","value":4}],"objName":"Ops.Gl.Meshes.Rectangle_v4"},{"id":"10c39o948","uiAttribs":{},"portsOut":[{"name":"trigger 0","links":[{"portIn":"Exec","portOut":"trigger 0","objIn":"xijlxsttk","objOut":"10c39o948"}]},{"name":"trigger 1","links":[{"portIn":"Exec","portOut":"trigger 1","objIn":"76ucdw0ke","objOut":"10c39o948"}]},{"name":"trigger 2","links":[{"portIn":"Trigger","portOut":"trigger 2","objIn":"gwkvu5snd","objOut":"10c39o948"}]},{"name":"trigger 3","links":[{"portIn":"Update","portOut":"trigger 3","objIn":"sjcgdjdex","objOut":"10c39o948"}]}],"objName":"Ops.Trigger.Sequence"},{"id":"ty56jkpgs","uiAttribs":{},"portsIn":[{"name":"Title","value":"Big Bar Chart"}],"objName":"Ops.Ui.Area"},{"id":"5edgaaahs","uiAttribs":{},"portsIn":[{"name":"Invalid when length is 0","value":true}],"portsOut":[{"name":"Last Valid Array","links":[{"portIn":"Array In","portOut":"Last Valid Array","objIn":"6hw1co6fv","objOut":"5edgaaahs"},{"portIn":"Value","portOut":"Last Valid Array","objIn":"zwh4x9wmb","objOut":"5edgaaahs"}]},{"name":"Is Valid","value":1}],"objName":"Ops.Array.FilterValidArray"},{"id":"tx8qgs3p8","uiAttribs":{},"portsIn":[{"name":"Repeats","value":4},{"name":"Direction index","value":0},{"name":"Direction","value":"Forward"}],"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"10jtj4lmb","objOut":"tx8qgs3p8"}]},{"name":"index","links":[{"portIn":"number1","portOut":"index","objIn":"2r4xbrsor","objOut":"tx8qgs3p8"},{"portIn":"index","portOut":"index","objIn":"m8w704bh0","objOut":"tx8qgs3p8"}]}],"objName":"Ops.Trigger.Repeat_v2"},{"id":"toe74msya","uiAttribs":{},"portsIn":[{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"uqskenl8e","objOut":"toe74msya"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"2r4xbrsor","uiAttribs":{},"portsIn":[{"name":"number2","value":0.17}],"portsOut":[{"name":"result","links":[{"portIn":"posX","portOut":"result","objIn":"toe74msya","objOut":"2r4xbrsor"}]}],"objName":"Ops.Math.Multiply"},{"id":"40b2b5w38","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"mainClock"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"render","portOut":"Triggered","objIn":"443pzneij","objOut":"40b2b5w38"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"m8w704bh0","uiAttribs":{},"portsOut":[{"name":"value","links":[{"portIn":"y","portOut":"value","objIn":"10jtj4lmb","objOut":"m8w704bh0"}]}],"objName":"Ops.Array.ArrayGetNumber"},{"id":"10jtj4lmb","uiAttribs":{},"portsIn":[{"name":"x","value":1},{"name":"z","value":1}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"3ni8cqwqb","objOut":"10jtj4lmb"}]}],"objName":"Ops.Gl.Matrix.ScaleXYZ"},{"id":"443pzneij","uiAttribs":{},"portsIn":[{"name":"posX","value":-1.69},{"name":"posY","value":0.91},{"name":"posZ","value":0},{"name":"scale","value":0.7},{"name":"rotX","value":-180},{"name":"rotY","value":0},{"name":"rotZ","value":90}],"portsOut":[{"name":"trigger","links":[{"portIn":"Execute","portOut":"trigger","objIn":"tx8qgs3p8","objOut":"443pzneij"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"3ni8cqwqb","uiAttribs":{},"portsIn":[{"name":"r","value":0.6278540266808976},{"name":"g","value":0.06753441475089472},{"name":"b","value":0.457},{"name":"a","value":1},{"name":"colorizeTexture","value":false},{"name":"Vertex Colors","value":false},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":false},{"name":"Discard Transparent Pixels","value":false},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":false},{"name":"billboard","value":false}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"toe74msya","objOut":"3ni8cqwqb"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"6hw1co6fv","uiAttribs":{},"portsIn":[{"name":"Separate inc/dec","value":false},{"name":"Inc factor","title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"Execute","portOut":"Next","objIn":"s313lwyua","objOut":"6hw1co6fv"}]},{"name":"Array Out","links":[{"portIn":"Array In","portOut":"Array Out","objIn":"s313lwyua","objOut":"6hw1co6fv"}]}],"objName":"Ops.Array.SmoothArray"},{"id":"96x83vsk6","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_ioAnim"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"5cat7nzn1","uiAttribs":{},"portsIn":[{"name":"Title","value":"View and Store"}],"objName":"Ops.Ui.Area"},{"id":"qhnsl12n2","uiAttribs":{},"portsIn":[{"name":"Num Values","value":36},{"name":"Mode index","value":0},{"name":"Mode","value":"ABCD"},{"name":"Integer","value":false},{"name":"Last == First","value":false},{"name":"Min A","value":0.1},{"name":"Max A","value":1},{"name":"Min B","value":0.1},{"name":"Max B","value":1},{"name":"Min C","value":0},{"name":"Max C","value":1},{"name":"Min D","value":-1},{"name":"Max D","value":1}],"portsOut":[{"name":"Array Out","links":[{"portIn":"In","portOut":"Array Out","objIn":"sha8gt6hs","objOut":"qhnsl12n2"}]},{"name":"Chunks Amount","value":36},{"name":"Array length","value":144}],"objName":"Ops.Array.RandomNumbersArray_v4"},{"id":"urjpsbb6m","uiAttribs":{},"portsIn":[{"name":"Stride","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"Array","portOut":"Result","objIn":"rak54dp2y","objOut":"urjpsbb6m"}]}],"objName":"Ops.Array.ArrayToArrays"},{"id":"hqnw66y5l","uiAttribs":{},"portsIn":[{"name":"Title","value":"Random Fill"}],"objName":"Ops.Ui.Area"},{"id":"pbm6cjbx3","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"Filter Prefix","value":"param_"}],"portsOut":[{"name":"Result","links":[{"portIn":"Object","portOut":"Result","objIn":"ivrl1vtce","objOut":"pbm6cjbx3"}]}],"objName":"Ops.Vars.VariablesAsObject"},{"id":"xp2objvcp","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"Title","value":"store"}],"objName":"Ops.Ui.Area"},{"id":"9c8ar4gru","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsOut":[{"name":"Values","links":[{"portIn":"new Array","portOut":"Values","objIn":"0redgkxbp","objOut":"9c8ar4gru"},{"portIn":"Array","portOut":"Values","objIn":"tobbb4gxk","objOut":"9c8ar4gru"}]},{"name":"Num values","value":4}],"objName":"Ops.Json.ObjectValuesAsArray"},{"id":"0redgkxbp","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsOut":[{"name":"values","links":[{"portIn":"Array","portOut":"values","objIn":"h19m2lqmw","objOut":"0redgkxbp"},{"portIn":"out0 ArraySetArray values","portOut":"values","objIn":"e3qg6hf06","objOut":"0redgkxbp"}]}],"objName":"Ops.Array.ArraySetArray"},{"id":"h19m2lqmw","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"h0ocrqz8z","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsOut":[{"name":"create port","value":0},{"name":"in0 VariablesAsObject Execute","title":"Execute","links":[{"portIn":"Execute","portOut":"in0 VariablesAsObject Execute","objIn":"pbm6cjbx3","objOut":"h0ocrqz8z"},{"portIn":"exe","portOut":"in0 VariablesAsObject Execute","objIn":"0redgkxbp","objOut":"h0ocrqz8z"}]},{"name":"in1 ArraySetArray array","title":"InitialArray","links":[{"portIn":"array","portOut":"in1 ArraySetArray array","objIn":"0redgkxbp","objOut":"h0ocrqz8z"}]}],"objName":"Ops.Ui.PatchInput"},{"id":"e3qg6hf06","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"create port","value":0}],"objName":"Ops.Ui.PatchOutput"},{"id":"t1agaa7cp","uiAttribs":{},"storage":{"subPatchVer":1},"portsIn":[{"name":"create port","value":0},{"name":"dataStr","value":"{\"ports\":[{\"name\":\"in0 VariablesAsObject Execute\",\"type\":1,\"title\":\"Execute\"},{\"name\":\"in1 ArraySetArray array\",\"type\":3,\"title\":\"InitialArray\",\"value\":null}],\"portsOut\":[{\"name\":\"out0 ArraySetArray values\",\"type\":3}]}"},{"name":"patchId","value":"c00e1133-7569-4211-a92f-5467fd37c7f8"},{"name":"in0 VariablesAsObject Execute","title":"Execute"},{"name":"in1 ArraySetArray array","title":"InitialArray"}],"portsOut":[{"name":"create port out","value":0},{"name":"out0 ArraySetArray values","links":[{"portIn":"Value","portOut":"out0 ArraySetArray values","objIn":"qe1i0ww8p","objOut":"t1agaa7cp"},{"portIn":"Array","portOut":"out0 ArraySetArray values","objIn":"duztwx0hg","objOut":"t1agaa7cp"}]}],"objName":"Ops.Ui.SubPatch"},{"id":"76ucdw0ke","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"in0 VariablesAsObject Execute","portOut":"Next","objIn":"t1agaa7cp","objOut":"76ucdw0ke"}]},{"name":"Was Triggered","value":1}],"objName":"Ops.Trigger.TriggerOnce"},{"id":"2oe2m9k57","uiAttribs":{},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"ea03f35d-e2b1-49fa-a4fc-0913ccbc5a12","uiAttribs":{},"portsOut":[{"name":"Min","value":0},{"name":"Max","value":0},{"name":"Average","links":[{"portIn":"number1","portOut":"Average","objIn":"af071ca3-b1e8-4613-a80b-e6b1b5029ccf","objOut":"ea03f35d-e2b1-49fa-a4fc-0913ccbc5a12"}]}],"objName":"Ops.Array.InfoArray"},{"id":"40c9a407-e62a-4aa1-ab30-9e9279cbac7b","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_paramsAverage"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"bf47e1f7-e957-4554-99ce-00b4c28a240e","uiAttribs":{},"portsIn":[{"name":"Decimal Places","value":4}],"portsOut":[{"name":"result","links":[{"portIn":"Value In","portOut":"result","objIn":"wymm2i7x6","objOut":"bf47e1f7-e957-4554-99ce-00b4c28a240e"}]}],"objName":"Ops.Math.Round"},{"id":"af071ca3-b1e8-4613-a80b-e6b1b5029ccf","uiAttribs":{},"portsIn":[{"name":"number2","value":1000}],"portsOut":[{"name":"result","links":[{"portIn":"number","portOut":"result","objIn":"bf47e1f7-e957-4554-99ce-00b4c28a240e","objOut":"af071ca3-b1e8-4613-a80b-e6b1b5029ccf"}]}],"objName":"Ops.Math.Multiply"},{"id":"ufm4tsmll","uiAttribs":{},"portsIn":[{"name":"css code","value":".cablesEle {\n--sidebar-slider-input-height: 12px;\n--nel-parambars: #a01074;\n--nel-darkbg: darkslategrey;\n--nel-transparent: #00000040;\n}\n\n.sidebar__slider-input-wrapper {\n    margin: 1px;\n}\n.sidebar__item-label {\n    margin-top: 0px;\n    font-size: smaller;\n}\n\n.sidebar__text .sidebar__item-label {\nfont-size: x-small;\ncolor: antiquewhite !important;\n}\n\n.sidebar-cables {\n    margin-top: 1em;\n    margin-left: -1em;\n    transform: scale(1);\n}\n\n.sidebar__slider-input {\n    background: var(--nel-transparent);\n}\n\n.sidebar--closed .sidebar__close-button {\n\n   background-color: darkgray;\n}\n\n.sidebar-cables .sidebar__close-button:hover {\n    background-color: var(--nel-parambars);\n    transition: background-color 0.5s ease-in-out;\n}\n\n/*.sidebar__items {*/\n    /* max-height: 1000px; */\n/*    background-color: #5555556b;*/\n/*    margin: auto;*/\n/*    padding-bottom: 10px;*/\n/*    font-size: x-small;*/\n/*}*/\n\n.sidebar__slider input[type=text] {\n    \n    font-size: x-small;\n\n}\n\n/*.sidebar__group-items {*/\n    \n/*    padding-top: 1px;*/\n/*    padding-bottom: 0px;*/\n/*}*/\n"}],"objName":"Ops.Html.CSS_v2"},{"id":"40f947a8-3a53-45b5-9038-dd7834bed318","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"ZoomText","value":false},{"name":"Line Numbers","value":true},{"name":"Font Size","value":10},{"name":"Scroll","value":0}],"objName":"Ops.Ui.VizObject"},{"id":"9f68771e-122c-4634-bae4-8357eeed9412","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Title","value":"Programmer"}],"objName":"Ops.Ui.Area"},{"id":"6b0c7688-6521-4e6a-aef5-a5c23e057783","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Set"},{"name":"Show Title","value":true},{"name":"Default Minimized","value":false},{"name":"Visible","value":true}],"portsOut":[{"name":"next","links":[{"portIn":"link","portOut":"next","objIn":"5d7a506f-b191-404e-8e79-1d4a5384abab","objOut":"6b0c7688-6521-4e6a-aef5-a5c23e057783"}]},{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"6l4no15e9","objOut":"6b0c7688-6521-4e6a-aef5-a5c23e057783"}]}],"objName":"Ops.Sidebar.Group"},{"id":"5d7a506f-b191-404e-8e79-1d4a5384abab","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Option "},{"name":"Show Title","value":true},{"name":"Default Minimized","value":false},{"name":"Visible","value":true}],"portsOut":[{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"myexmbg9t","objOut":"5d7a506f-b191-404e-8e79-1d4a5384abab"}]}],"objName":"Ops.Sidebar.Group"},{"id":"3bbcf635-a488-45fe-b341-d943d55f94cb","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"ui_smoothingTime"}],"objName":"Ops.Vars.VarSetString_v2"},{"id":"bhld45jgz","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_smoothingTime"}],"portsOut":[{"name":"Value","links":[{"portIn":"String","portOut":"Value","objIn":"d6b77124-d2c4-401c-a99b-8a41e74adc00","objOut":"bhld45jgz"}]}],"objName":"Ops.Vars.VarGetString"},{"id":"d6b77124-d2c4-401c-a99b-8a41e74adc00","uiAttribs":{},"portsOut":[{"name":"Number","links":[{"portIn":"Inc factor","portOut":"Number","objIn":"6hw1co6fv","objOut":"d6b77124-d2c4-401c-a99b-8a41e74adc00"}]}],"objName":"Ops.String.ParseFloat"},{"id":"bf8903b8-9745-4c15-b52f-af91c8ac4c09","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"key code","value":13},{"name":"canvas only","value":true},{"name":"Mod Key index","value":0},{"name":"Mod Key","value":"none"},{"name":"Enabled","value":true},{"name":"Prevent Default","value":false}],"portsOut":[{"name":"Pressed","value":0},{"name":"Key","value":"Enter"}],"objName":"Ops.Devices.Keyboard.KeyPressLearn"},{"id":"z27ki35ux","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsOut":[{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"3bbcf635-a488-45fe-b341-d943d55f94cb","objOut":"z27ki35ux"}]}],"objName":"Ops.String.NumberToString_v2"},{"id":"6l4no15e9","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Hover over a node and press the right mouse button to store."},{"name":"Id","value":"text-info"}],"portsOut":[{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"u3omcpuwe","objOut":"6l4no15e9"}]}],"objName":"Ops.Sidebar.SidebarText_v2"},{"id":"wymm2i7x6","uiAttribs":{},"portsOut":[{"name":"Value Out","links":[{"portIn":"Value","portOut":"Value Out","objIn":"40c9a407-e62a-4aa1-ab30-9e9279cbac7b","objOut":"wymm2i7x6"}]}],"objName":"Ops.Number.GateNumber"},{"id":"8vd8sx5no","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_buttonDown"}],"portsOut":[{"name":"Value","links":[{"portIn":"Pass Through","portOut":"Value","objIn":"wymm2i7x6","objOut":"8vd8sx5no"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"dh195jo6n","uiAttribs":{"subPatch":"fufcnab2y"},"portsOut":[{"name":"create port","value":0}],"objName":"Ops.Ui.PatchInput"},{"id":"ufmlvte12","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"create port","value":0}],"objName":"Ops.Ui.PatchOutput"},{"id":"5a439lwkq","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"Id","value":"nel-logo"},{"name":"Class","value":""},{"name":"Style","value":"position:fixed;\nz-index:0;\nmargin: 0;\npadding: 0;\n\n"},{"name":"Interactive","value":false},{"name":"Visible","value":true},{"name":"Convert Line Breaks","value":false},{"name":"Propagate Click-Events","value":false}],"portsOut":[{"name":"DOM Element","links":[{"portIn":"HTML Element","portOut":"DOM Element","objIn":"kpbh94lru","objOut":"5a439lwkq"},{"portIn":"DOMElement","portOut":"DOM Element","objIn":"myhmlcg27","objOut":"5a439lwkq"}]},{"name":"Hover","value":0}],"objName":"Ops.Html.DivElement_v3"},{"id":"a9s2ktkpe","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"value","value":"<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n  width=\"402px\" height=\"110px\" viewBox=\"20 45 400 0.1\">\n  <style type=\"text/css\">\n    .st0 {\n      fill: #F79355;\n    }\n\n    .st1 {\n      fill: #33C21C;\n    }\n\n    .st2 {\n      fill: #00000000\n    }\n  </style>\n  <symbol id=\"a59f87b6-0439-40fb-bcac-5aff05fde512\" viewBox=\"-76.33 -6.58 152.66 13.16\">\n    <g>\n      <g>\n        <rect x=\"-76.32\" y=\"-6.58\" class=\"st0\" width=\"6.53\" height=\"1.89\" />\n        <rect x=\"-76.33\" y=\"-2.8\" class=\"st0\" width=\"2.95\" height=\"1.85\" />\n        <rect x=\"-70.44\" y=\"-2.8\" class=\"st0\" width=\"2.92\" height=\"1.85\" />\n        <rect x=\"-68.18\" y=\"-6.58\" class=\"st0\" width=\"6.53\" height=\"1.89\" />\n        <rect x=\"-76.32\" y=\"4.69\" class=\"st0\" width=\"6.53\" height=\"1.89\" />\n        <rect x=\"-68.18\" y=\"4.69\" class=\"st0\" width=\"6.53\" height=\"1.89\" />\n        <rect x=\"-64.6\" y=\"-2.8\" class=\"st0\" width=\"2.95\" height=\"1.85\" />\n        <rect x=\"-76.33\" y=\"0.95\" class=\"st0\" width=\"2.95\" height=\"1.85\" />\n        <rect x=\"-70.44\" y=\"0.95\" class=\"st0\" width=\"2.92\" height=\"1.85\" />\n        <rect x=\"-64.6\" y=\"0.95\" class=\"st0\" width=\"2.95\" height=\"1.85\" />\n      </g>\n      <path class=\"st1\" d=\"M-54.33-3.09l1.16,3v-3h1.18V3h-1.15l-1.19-3.05V3h-1.16v-6.09H-54.33z\" />\n      <path class=\"st1\" d=\"M-42.82-3.09v1.22h-2.35v1.23h2.35v1.19h-2.35v1.23h2.35V3h-3.51v-6.09H-42.82z\" />\n      <path class=\"st1\" d=\"M-36.04-3.09l0.58,3l0.58-3h1.19L-34.88,3h-1.16l-1.19-6.09H-36.04z\" />\n      <path class=\"st1\" d=\"M-24.56-3.09v1.22h-2.35v1.23h2.35v1.19h-2.35v1.23h2.35V3h-3.53v-6.09H-24.56z\" />\n      <path class=\"st1\"\n        d=\"M-16.62-3.09c0.32,0.01,0.62,0.14,0.84,0.37c0.23,0.22,0.36,0.53,0.35,0.85v1.23c0,0.24-0.07,0.47-0.19,0.67&#xA;&#x9;&#x9;&#x9;c-0.13,0.2-0.31,0.35-0.53,0.44L-15.43,3h-1.19l-0.71-2.45h-0.47V3h-1.16v-6.09H-16.62z M-17.78-0.64h1.16v-1.23h-1.16V-0.64z\" />\n      <path class=\"st1\" d=\"M-6.33-3.09v1.22h-2.32v1.23h2.32v1.19h-2.32v1.23h2.32V3h-3.5v-6.09H-6.33z\" />\n      <path class=\"st1\" d=\"M0.49-3.09l1.15,3v-3h1.19V3H1.67L0.52,0v3H-0.7v-6.09H0.49z\" />\n      <path class=\"st1\"\n        d=\"M11.96-3.09v1.22H9.67v3.65h1.16v-2.42h1.18v2.42c0.01,0.32-0.11,0.63-0.34,0.85&#xA;&#x9;&#x9;&#x9;C11.45,2.86,11.15,2.99,10.83,3H9.67C9.35,2.99,9.05,2.85,8.82,2.63C8.59,2.41,8.47,2.1,8.48,1.78v-3.65&#xA;&#x9;&#x9;&#x9;C8.47-2.19,8.59-2.5,8.82-2.72c0.23-0.22,0.53-0.36,0.85-0.37H11.96z\" />\n      <path class=\"st1\" d=\"M20.51-3.09v1.22h-0.6v3.65h0.6V3h-2.37V1.78h0.61v-3.65h-0.61v-1.22H20.51z\" />\n      <path class=\"st1\" d=\"M28.33-3.09l1.15,3v-3h1.19V3h-1.19l-1.15-3v3h-1.19v-6.09H28.33z\" />\n      <path class=\"st1\" d=\"M39.8-3.09v1.22h-2.34v1.23h2.34v1.19h-2.34v1.23h2.34V3h-3.53v-6.09H39.8z\" />\n      <path class=\"st1\" d=\"M46.59-3.09v4.87h2.34V3H45.4v-6.09H46.59z\" />\n      <path class=\"st1\"\n        d=\"M56.88-3.09c0.32,0.01,0.62,0.14,0.84,0.37c0.23,0.22,0.36,0.53,0.35,0.85V3h-1.19V0.55h-1.16V3h-1.19v-4.87&#xA;&#x9;&#x9;&#x9;c-0.01-0.32,0.12-0.63,0.35-0.85c0.22-0.23,0.52-0.36,0.84-0.37L56.88-3.09z M55.72-0.64h1.16v-1.23h-1.16V-0.64z\" />\n      <path class=\"st1\"\n        d=\"M66.93-0.32c-0.16,0.17-0.38,0.27-0.62,0.27c0.24,0,0.46,0.1,0.62,0.28c0.17,0.17,0.27,0.4,0.27,0.64v0.91&#xA;&#x9;&#x9;&#x9;c0.01,0.32-0.12,0.63-0.35,0.85C66.63,2.86,66.33,2.99,66.01,3h-2.34v-6.09h2.35c0.32,0.01,0.62,0.14,0.84,0.37&#xA;&#x9;&#x9;&#x9;c0.23,0.22,0.36,0.53,0.35,0.85v0.91C67.21-0.72,67.11-0.48,66.93-0.32z M66.01-1.87h-1.16v1.23h1.16V-1.87z M66.01,0.55h-1.16&#xA;&#x9;&#x9;&#x9;v1.23h1.16V0.55z\" />\n      <path class=\"st1\"\n        d=\"M76.33-3.09v1.22h-2.35v1.23h1.16c0.31-0.01,0.62,0.12,0.84,0.34c0.23,0.22,0.36,0.53,0.35,0.85v1.23&#xA;&#x9;&#x9;&#x9;c0.01,0.32-0.12,0.63-0.35,0.85C75.76,2.86,75.46,2.99,75.14,3H72.8V1.78h2.34V0.55h-1.16c-0.64,0.01-1.17-0.5-1.18-1.14&#xA;&#x9;&#x9;&#x9;c0-0.02,0-0.03,0-0.05v-1.23c-0.01-0.32,0.11-0.63,0.34-0.85c0.22-0.23,0.52-0.36,0.84-0.37L76.33-3.09z\" />\n    </g>\n  </symbol>\n\n  <g id=\"ab50a4d6-51e3-4638-b29d-7ff1e5b6a9df\">\n    <g>\n      <defs>\n        <rect id=\"SVGID_1_\" x=\"21.91\" y=\"46.04\" width=\"367.73\" height=\"31.38\" />\n      </defs>\n      <clipPath id=\"SVGID_2_\">\n        <use xlink:href=\"#SVGID_1_\" style=\"overflow:hidden;\" />\n      </clipPath>\n      <g style=\"clip-path:url(#SVGID_2_);\">\n        <use xlink:href=\"#a59f87b6-0439-40fb-bcac-5aff05fde512\" width=\"152.66\" height=\"13.16\" x=\"-76.33\" y=\"-6.58\"\n          transform=\"matrix(2.4088 0 0 2.3848 205.7744 61.728)\" style=\"overflow:hidden;\" />\n      </g>\n    </g>\n  </g>\n</svg>"},{"name":"Syntax index","value":0},{"name":"Syntax","value":"html"}],"portsOut":[{"name":"Result","links":[{"portIn":"Text","portOut":"Result","objIn":"5a439lwkq","objOut":"a9s2ktkpe"}]}],"objName":"Ops.String.StringEditor"},{"id":"kpbh94lru","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"Duration","value":0.9},{"name":"Opacity","value":1}],"portsOut":[{"name":"Is Showing","value":1}],"objName":"Ops.Html.ElementFadeInOut"},{"id":"myhmlcg27","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"origin index","value":4},{"name":"origin","value":"center-left"}],"objName":"Ops.Html.TransformCSS3DElement"},{"id":"vmdzr3zqk","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"posX","value":-0.67},{"name":"posY","value":0.41},{"name":"posZ","value":1.21},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"trigger","portOut":"trigger","objIn":"myhmlcg27","objOut":"vmdzr3zqk"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"uxswg9f8h","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"Named Trigger","value":"mainClock"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"render","portOut":"Triggered","objIn":"vmdzr3zqk","objOut":"uxswg9f8h"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"4oi51cdds","uiAttribs":{},"storage":{"subPatchVer":1},"portsIn":[{"name":"create port","value":0},{"name":"dataStr","value":"{\"ports\":[{\"name\":\"in0 Ops.Trigger.Sequence trigger 3\",\"type\":1}],\"portsOut\":[{\"name\":\"out0 Ops.Html.TransformCSS3DElement next\",\"type\":1},{\"name\":\"out1 Ops.Html.TransformCSS3DElement next\",\"type\":1}]}"},{"name":"patchId","value":"fufcnab2y"}],"portsOut":[{"name":"create port out","value":0}],"objName":"Ops.Ui.SubPatch"},{"id":"h1cfb32rh","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"startTrigger"}],"objName":"Ops.Trigger.TriggerSend"},{"id":"0nwn5yw66","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"Named Trigger","value":"startTrigger"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"trigger","portOut":"Triggered","objIn":"58ysfl9dw","objOut":"0nwn5yw66"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"58ysfl9dw","uiAttribs":{"subPatch":"fufcnab2y"},"portsIn":[{"name":"Default","value":false}],"portsOut":[{"name":"result","links":[{"portIn":"Visible","portOut":"result","objIn":"kpbh94lru","objOut":"58ysfl9dw"}]}],"objName":"Ops.Boolean.ToggleBool_v2"},{"id":"fyaa9dnkh","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_decay"}],"portsOut":[{"name":"Value","links":[{"portIn":"Input","portOut":"Value","objIn":"u3omcpuwe","objOut":"fyaa9dnkh"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"07mo0ywnx","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_mix"}],"portsOut":[{"name":"Value","links":[{"portIn":"Input","portOut":"Value","objIn":"wwpx8aqmi","objOut":"07mo0ywnx"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"fgtttw0ip","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_mod"}],"portsOut":[{"name":"Value","links":[{"portIn":"Input","portOut":"Value","objIn":"aonhpx6m7","objOut":"fgtttw0ip"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"1moo1v08a","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Variable","value":"param_size"}],"portsOut":[{"name":"Value","links":[{"portIn":"Input","portOut":"Value","objIn":"1enzkm1k2","objOut":"1moo1v08a"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"sha8gt6hs","uiAttribs":{},"portsOut":[{"name":"Result","links":[{"portIn":"Array","portOut":"Result","objIn":"urjpsbb6m","objOut":"sha8gt6hs"}]}],"objName":"Ops.Array.ArrayAbs"},{"id":"65zy74xvv","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_randomisePresets"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"zzlxvxf21","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_randomisePresets"}],"portsOut":[{"name":"Value","links":[{"portIn":"Value","portOut":"Value","objIn":"bmjt13f5m","objOut":"zzlxvxf21"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"bmjt13f5m","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"Reset","portOut":"Next","objIn":"76ucdw0ke","objOut":"bmjt13f5m"}]},{"name":"Number","value":0}],"objName":"Ops.Number.TriggerOnChangeNumber"},{"id":"ov0sr1ubj","uiAttribs":{},"portsIn":[{"name":"FPS Limit","value":60},{"name":"Reduce FPS not focussed","value":true},{"name":"Reduce FPS loading","value":false},{"name":"Clear","value":true},{"name":"ClearAlpha","value":true},{"name":"Fullscreen Button","value":false},{"name":"Active","value":true},{"name":"Hires Displays","value":true},{"name":"Pixel Unit index","value":0},{"name":"Pixel Unit","value":"Display"}],"portsOut":[{"name":"trigger","links":[{"portIn":"Trigger","portOut":"trigger","objIn":"ez75pjoud","objOut":"ov0sr1ubj"},{"portIn":"rgd42fpcf","portOut":"trigger","objIn":"ezywphh08","objOut":"ov0sr1ubj"}]},{"name":"width","value":1342},{"name":"height","value":594}],"objName":"Ops.Gl.MainLoop"},{"id":"to2191b15","uiAttribs":{},"portsIn":[{"name":"Scale","value":1},{"name":"Limit Instances","value":true},{"name":"Limit","value":36},{"name":"Rotations","value":0},{"name":"Rotation Type index","value":0},{"name":"Rotation Type","value":"Euler"},{"name":"Material blend mode index","value":0},{"name":"Material blend mode","value":"Multiply"},{"name":"TexCoords","value":0}],"portsOut":[{"name":"Num","value":36}],"objName":"Ops.Gl.MeshInstancer_v4"},{"id":"tbpgaoc9h","uiAttribs":{},"portsIn":[{"name":"radius","value":0.45},{"name":"innerRadius","value":0},{"name":"segments","value":30},{"name":"percent","value":1},{"name":"steps","value":0},{"name":"invertSteps","value":false},{"name":"mapping index","value":0},{"name":"mapping","value":"flat"},{"name":"Spline","value":false},{"name":"Draw","value":false,"title":"Render mesh"}],"portsOut":[{"name":"geometry","links":[{"portIn":"Geometry","portOut":"geometry","objIn":"7eq4lyw76","objOut":"tbpgaoc9h"}]}],"objName":"Ops.Gl.Meshes.Circle_v3"},{"id":"1h921o27m","uiAttribs":{},"portsIn":[{"name":"Rows","value":6},{"name":"Columns","value":6},{"name":"Width","value":6.25},{"name":"Height","value":5.86},{"name":"Row Offset","value":-1.25},{"name":"Center","value":true}],"portsOut":[{"name":"Result","links":[{"portIn":"Positions","portOut":"Result","objIn":"3kb79upnd","objOut":"1h921o27m"},{"portIn":"positions","portOut":"Result","objIn":"to2191b15","objOut":"1h921o27m"}]},{"name":"Total points","value":36},{"name":"Array length","value":108}],"objName":"Ops.Array.PointArray.PointsPlane_v2"},{"id":"ipm6puwpj","uiAttribs":{},"portsIn":[{"name":"Format index","value":0},{"name":"Format","value":"RGBA"}],"portsOut":[{"name":"Colors","links":[{"portIn":"Value","portOut":"Colors","objIn":"wi0k8dnhc","objOut":"ipm6puwpj"}]},{"name":"Floating Point","value":0}],"objName":"Ops.Gl.Texture2ColorArray_v2"},{"id":"wbnltxv6i","uiAttribs":{},"portsOut":[{"name":"trigger 0","links":[{"portIn":"Execute","portOut":"trigger 0","objIn":"uxi808ntq","objOut":"wbnltxv6i"}]},{"name":"trigger 3","links":[{"portIn":"Trigger","portOut":"trigger 3","objIn":"3kb79upnd","objOut":"wbnltxv6i"}]},{"name":"trigger 13","links":[{"portIn":"Trigger","portOut":"trigger 13","objIn":"v63aek9xf","objOut":"wbnltxv6i"}]},{"name":"trigger 15","links":[{"portIn":"Execute","portOut":"trigger 15","objIn":"po83fg9uc","objOut":"wbnltxv6i"}]}],"objName":"Ops.Trigger.Sequence"},{"id":"ospnndt4z","uiAttribs":{},"portsIn":[{"name":"Render","value":false},{"name":"Check Body Collisions","value":false}],"portsOut":[{"name":"Next","links":[{"portIn":"Trigger","portOut":"Next","objIn":"8xjd2r7ki","objOut":"ospnndt4z"}]},{"name":"Total Bodies","value":36}],"objName":"Ops.Graphics.Intersection.IntersectWorld"},{"id":"8xjd2r7ki","uiAttribs":{},"portsIn":[{"name":"Coordinate Format index","value":0},{"name":"Coordinate Format","value":"-1 to 1"},{"name":"Z","value":0},{"name":"To X","value":0},{"name":"To Y","value":0},{"name":"To Z","value":0},{"name":"Active","value":true},{"name":"Change Cursor","value":false}],"portsOut":[{"name":"Next","links":[{"portIn":"exe","portOut":"Next","objIn":"wbnltxv6i","objOut":"8xjd2r7ki"}]},{"name":"Has Hit","links":[{"portIn":"Value","portOut":"Has Hit","objIn":"tnc1kjtw7","objOut":"8xjd2r7ki"}]},{"name":"Hit Body Name","links":[{"portIn":"Value","portOut":"Hit Body Name","objIn":"g6mdwgw2f","objOut":"8xjd2r7ki"},{"portIn":"String","portOut":"Hit Body Name","objIn":"ns1vo9nla","objOut":"8xjd2r7ki"}]},{"name":"Hit X","links":[{"portIn":"Value","portOut":"Hit X","objIn":"3sjr0zshe","objOut":"8xjd2r7ki"}]},{"name":"Hit Y","links":[{"portIn":"Value","portOut":"Hit Y","objIn":"763blqpak","objOut":"8xjd2r7ki"}]},{"name":"Hit Z","links":[{"portIn":"Value","portOut":"Hit Z","objIn":"zqjxquk24","objOut":"8xjd2r7ki"}]}],"objName":"Ops.Graphics.Intersection.IntersectRaycast"},{"id":"3kb79upnd","uiAttribs":{},"portsIn":[{"name":"Shape index","value":0},{"name":"Shape","value":"Sphere"},{"name":"Name","value":"node"},{"name":"Radius","value":0.5},{"name":"Size X","value":1},{"name":"Size Y","value":1},{"name":"Size Z","value":1},{"name":"Append Index to name","value":true}],"portsOut":[{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"gtplwvx3v","objOut":"3kb79upnd"}]}],"objName":"Ops.Graphics.Intersection.IntersectBody"},{"id":"g6mdwgw2f","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hitBodyName"}],"objName":"Ops.Vars.VarSetString_v2"},{"id":"e4p46sva0","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hitBodyName"}],"portsOut":[{"name":"Value","links":[{"portIn":"String","portOut":"Value","objIn":"5ytdfngfb","objOut":"e4p46sva0"}]}],"objName":"Ops.Vars.VarGetString"},{"id":"ic6fpv7ll","uiAttribs":{},"portsIn":[{"name":"Font File","value":"assets/65c7d7e973797610ac15a127_ChivoMono-Medium.ttf","display":"file"}],"portsOut":[{"name":"Opentype Font","links":[{"portIn":"Opentype Font","portOut":"Opentype Font","objIn":"1lo7344o9","objOut":"ic6fpv7ll"}]}],"objName":"Ops.Extension.OpenType.OpentypeFont"},{"id":"1lo7344o9","uiAttribs":{},"portsIn":[{"name":"Letter Spacing","value":0}],"portsOut":[{"name":"Path String","links":[{"portIn":"SVG Path","portOut":"Path String","objIn":"k2ctala9q","objOut":"1lo7344o9"}]}],"objName":"Ops.Extension.OpenType.OpentypeToSvgPath"},{"id":"k2ctala9q","uiAttribs":{},"portsIn":[{"name":"Bezier Stepsize","value":3},{"name":"Rescale","value":0.47}],"portsOut":[{"name":"Geometry","links":[{"portIn":"Value","portOut":"Geometry","objIn":"ot0cslmz8","objOut":"k2ctala9q"}]}],"objName":"Ops.Graphics.Geometry.SvgPathToGeometry_v2"},{"id":"763blqpak","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hitY"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"3sjr0zshe","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hitX"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"gb2u3fqan","uiAttribs":{},"portsIn":[{"name":"Visible","value":false},{"name":"Measure GPU","value":true},{"name":"Position index","value":0},{"name":"Position","value":"top"},{"name":"Open","value":false},{"name":"Smooth Graph","value":true},{"name":"Scale","value":3},{"name":"Size","value":128}],"portsOut":[{"name":"childs","links":[{"portIn":"render","portOut":"childs","objIn":"3nwnpa7a8","objOut":"gb2u3fqan"}]},{"name":"FPS","value":53}],"objName":"Ops.Gl.Performance"},{"id":"3nwnpa7a8","uiAttribs":{},"portsIn":[{"name":"projection mode index","value":0},{"name":"projection mode","value":"prespective"},{"name":"frustum near","value":0.01},{"name":"frustum far","value":50},{"name":"fov","value":45},{"name":"Auto Aspect Ratio","value":true},{"name":"Aspect Ratio","value":1},{"name":"eye X","value":-0.76},{"name":"eye Z","value":8},{"name":"center X","value":0},{"name":"center Y","value":0},{"name":"center Z","value":0},{"name":"truck","value":0},{"name":"boom","value":-0.28},{"name":"dolly","value":-1.68},{"name":"tilt","value":-0.678},{"name":"pan","value":0},{"name":"roll","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"gv1z4ggjq","objOut":"3nwnpa7a8"}]},{"name":"Aspect","value":2.259259259259259}],"objName":"Ops.Gl.Matrix.Camera"},{"id":"v9fv15i1l","uiAttribs":{},"portsIn":[{"name":"Add Vertex Numbers","value":false}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"lccncsujd","objOut":"v9fv15i1l"}]}],"objName":"Ops.Gl.RenderGeometry_v2"},{"id":"tnc1kjtw7","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hasHit"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"s5bcjmqmb","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hasHit"}],"portsOut":[{"name":"Value","links":[{"portIn":"Value","portOut":"Value","objIn":"sr66hz9dk","objOut":"s5bcjmqmb"},{"portIn":"Use Value 1","portOut":"Value","objIn":"nmhux1ipx","objOut":"s5bcjmqmb"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"dkt1ljjre","uiAttribs":{},"portsIn":[{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":-45}],"portsOut":[{"name":"trigger","links":[{"portIn":"Update","portOut":"trigger","objIn":"yj714f2qn","objOut":"dkt1ljjre"},{"portIn":"Exec","portOut":"trigger","objIn":"jn7fiog3y","objOut":"dkt1ljjre"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"gv1z4ggjq","uiAttribs":{},"portsIn":[{"name":"posX","value":0.25},{"name":"posY","value":1.78},{"name":"posZ","value":0},{"name":"scale","value":1},{"name":"rotX","value":-30},{"name":"rotY","value":0},{"name":"rotZ","value":45}],"portsOut":[{"name":"trigger","links":[{"portIn":"Trigger","portOut":"trigger","objIn":"ospnndt4z","objOut":"gv1z4ggjq"}]}],"objName":"Ops.Gl.Matrix.TransformView"},{"id":"av78asjsh","uiAttribs":{},"portsIn":[{"name":"Coordinates index","value":2},{"name":"Coordinates","value":"-1 to 1"},{"name":"Area index","value":0},{"name":"Area","value":"Canvas"},{"name":"flip y","value":true},{"name":"right click prevent default","value":true},{"name":"Touch support","value":true},{"name":"Active","value":true}],"portsOut":[{"name":"x","links":[{"portIn":"X","portOut":"x","objIn":"8xjd2r7ki","objOut":"av78asjsh"}]},{"name":"y","links":[{"portIn":"Y","portOut":"y","objIn":"8xjd2r7ki","objOut":"av78asjsh"}]},{"name":"Button is down","value":0},{"name":"Mouse is hovering","value":0},{"name":"Movement X","value":-15},{"name":"Movement Y","value":-8.5}],"objName":"Ops.Devices.Mouse.Mouse_v3"},{"id":"zqjxquk24","uiAttribs":{},"portsIn":[{"name":"Variable","value":"#ui_hitZ"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"hvjtea3m3","uiAttribs":{},"portsIn":[{"name":"r","value":0.20000000000000007},{"name":"g","value":0.7647058823529411},{"name":"b","value":0.10980392156862748},{"name":"colorizeTexture","value":false},{"name":"Vertex Colors","value":false},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":false},{"name":"Discard Transparent Pixels","value":false},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":false},{"name":"billboard","value":true}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"v9fv15i1l","objOut":"hvjtea3m3"},{"portIn":"render","portOut":"trigger","objIn":"zqpk61u8a","objOut":"hvjtea3m3"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"yj714f2qn","uiAttribs":{},"portsIn":[{"name":"Separate inc/dec","value":false},{"name":"Inc factor","value":4,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"number1","portOut":"Result","objIn":"r2vst8y2z","objOut":"yj714f2qn"},{"portIn":"a","portOut":"Result","objIn":"hvjtea3m3","objOut":"yj714f2qn"}]}],"objName":"Ops.Anim.Smooth"},{"id":"yjrbxqyut","uiAttribs":{},"portsIn":[{"name":"CSS Cursors","value":"none"}],"objName":"Ops.Html.Cursor_v2"},{"id":"sr66hz9dk","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"Update","portOut":"Next","objIn":"yjrbxqyut","objOut":"sr66hz9dk"}]},{"name":"Number","value":0}],"objName":"Ops.Number.TriggerOnChangeNumber"},{"id":"nmhux1ipx","uiAttribs":{},"portsIn":[{"name":"Value 0","value":17},{"name":"Value 1","value":6}],"portsOut":[{"name":"Out Value","links":[{"portIn":"CSS Cursors index","portOut":"Out Value","objIn":"yjrbxqyut","objOut":"nmhux1ipx"}]}],"objName":"Ops.Number.ToggleNumber"},{"id":"se91ah4qw","uiAttribs":{},"portsIn":[{"name":"number2","value":0.1}],"portsOut":[{"name":"result","links":[{"portIn":"height","portOut":"result","objIn":"p8e8ow6ya","objOut":"se91ah4qw"}]}],"objName":"Ops.Math.Multiply"},{"id":"lccncsujd","uiAttribs":{},"portsIn":[{"name":"x","value":-0.15},{"name":"y","value":0},{"name":"z","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"vp4c44pq1","objOut":"lccncsujd"}]}],"objName":"Ops.Gl.Matrix.Translate"},{"id":"43v7zsj10","uiAttribs":{},"portsIn":[{"name":"number2","value":0.2}],"portsOut":[{"name":"result","links":[{"portIn":"posX","portOut":"result","objIn":"dkt1ljjre","objOut":"43v7zsj10"}]}],"objName":"Ops.Math.Sum"},{"id":"hti8wdxvp","uiAttribs":{},"portsOut":[{"name":"Number","links":[{"portIn":"Value","portOut":"Number","objIn":"lb2qb1gr3","objOut":"hti8wdxvp"}]}],"objName":"Ops.String.ParseInt_v2"},{"id":"ns1vo9nla","uiAttribs":{},"portsIn":[{"name":"Search For","value":"node."},{"name":"Replace","value":""},{"name":"Replace What index","value":0},{"name":"Replace What","value":"All"}],"portsOut":[{"name":"Result","links":[{"portIn":"String","portOut":"Result","objIn":"hti8wdxvp","objOut":"ns1vo9nla"}]}],"objName":"Ops.String.StringReplace"},{"id":"lb2qb1gr3","uiAttribs":{},"portsIn":[{"name":"Variable","value":"param_pickedID"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"fslxtb2u5","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hasHit"}],"portsOut":[{"name":"Value","links":[{"portIn":"number1","portOut":"Value","objIn":"se91ah4qw","objOut":"fslxtb2u5"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"po83fg9uc","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"5l0ul3gca","portOut":"Next","objIn":"mb8o3fesj","objOut":"po83fg9uc"},{"portIn":"render","portOut":"Next","objIn":"amq5nwrl7","objOut":"po83fg9uc"}]}],"objName":"Ops.Trigger.TriggerExtender"},{"id":"5lq71oskc","uiAttribs":{},"portsIn":[{"name":"Title","value":"intersecting"}],"objName":"Ops.Ui.Area"},{"id":"7eq4lyw76","uiAttribs":{},"portsIn":[{"name":"Height","value":0.08},{"name":"Smooth","value":true},{"name":"Walls","value":true},{"name":"Top","value":true},{"name":"Bottom","value":true}],"portsOut":[{"name":"Result Geometry","links":[{"portIn":"geom","portOut":"Result Geometry","objIn":"to2191b15","objOut":"7eq4lyw76"}]}],"objName":"Ops.Graphics.Geometry.GeometryExtrude"},{"id":"mb8o3fesj","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"5l0ul3gca","title":"exec"},{"name":"5jmbfmc3k","value":0,"title":"num"},{"name":"patchId","value":"bp2sub_mb8o3fesj"}],"portsOut":[{"name":"9yuykm3cr","title":"texture","links":[{"portIn":"texture","portOut":"9yuykm3cr","objIn":"ipm6puwpj","objOut":"mb8o3fesj"}]}],"objName":"Ops.Patch.PL3eri4.GradientSwitching_WfT5140"},{"id":"rmpwf7w0n","uiAttribs":{},"portsIn":[{"name":"Title","value":"Paint Matrix"}],"objName":"Ops.Ui.Area"},{"id":"iqrwqwecl","uiAttribs":{},"portsIn":[{"name":"Title","value":"Home of the hits"}],"objName":"Ops.Ui.Area"},{"id":"lujkpi9yq","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_NodeStateArray"}],"portsOut":[{"name":"Value","links":[{"portIn":"array","portOut":"Value","objIn":"u90vkvew6","objOut":"lujkpi9yq"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"u90vkvew6","uiAttribs":{},"portsOut":[{"name":"value","links":[{"portIn":"number1","portOut":"value","objIn":"cqc26g4fu","objOut":"u90vkvew6"}]}],"objName":"Ops.Array.ArrayGetNumber"},{"id":"cqc26g4fu","uiAttribs":{},"portsIn":[{"name":"number2","value":0}],"portsOut":[{"name":"result","links":[{"portIn":"Render Mesh","portOut":"result","objIn":"v9fv15i1l","objOut":"cqc26g4fu"}]}],"objName":"Ops.Math.Compare.GreaterThan"},{"id":"wi0k8dnhc","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_colorArray"}],"objName":"Ops.Vars.VarSetArray_v2"},{"id":"lkfvsb7e0","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_colorArray"}],"portsOut":[{"name":"Value","links":[{"portIn":"Array","portOut":"Value","objIn":"9nq3k2kg2","objOut":"lkfvsb7e0"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"g3e24cyc1","uiAttribs":{},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"bz7y2qjgl","uiAttribs":{},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"9nq3k2kg2","uiAttribs":{},"portsIn":[{"name":"Array Stride index","value":2},{"name":"Array Stride","value":"4"},{"name":"Result Stride index","value":1},{"name":"Result Stride","value":"4"},{"name":"X index","value":0},{"name":"X","value":"X"},{"name":"Y index","value":1},{"name":"Y","value":"Y"},{"name":"Z index","value":2},{"name":"Z","value":"Z"},{"name":"W index","value":5},{"name":"W","value":"lookup"}],"portsOut":[{"name":"Result","links":[{"portIn":"Colors","portOut":"Result","objIn":"to2191b15","objOut":"9nq3k2kg2"},{"portIn":"Array","portOut":"Result","objIn":"bz7y2qjgl","objOut":"9nq3k2kg2"},{"portIn":"Value","portOut":"Result","objIn":"dae6bpcmb","objOut":"9nq3k2kg2"}]}],"objName":"Ops.User.cristianvogel.ArraySwizzleWithInput"},{"id":"41gfmm6sb","uiAttribs":{},"portsIn":[{"name":"Array Stride index","value":2},{"name":"Array Stride","value":"3"},{"name":"Result Stride index","value":1},{"name":"Result Stride","value":"3"},{"name":"X index","value":0},{"name":"X","value":"1"},{"name":"Y index","value":1},{"name":"Y","value":"1"},{"name":"Z index","value":2},{"name":"Z","value":"lookup"},{"name":"W index","value":5},{"name":"W","value":"lookup"}],"portsOut":[{"name":"Result","links":[{"portIn":"Array","portOut":"Result","objIn":"g3e24cyc1","objOut":"41gfmm6sb"},{"portIn":"Source Array","portOut":"Result","objIn":"nylgabmj2","objOut":"41gfmm6sb"}]}],"objName":"Ops.User.cristianvogel.ArraySwizzleWithInput"},{"id":"ho644xlak","uiAttribs":{},"portsIn":[{"name":"Stretch Factor","value":4}],"portsOut":[{"name":"Length","value":144},{"name":"Result","links":[{"portIn":"LookUpArray","portOut":"Result","objIn":"9nq3k2kg2","objOut":"ho644xlak"},{"portIn":"Array","portOut":"Result","objIn":"41gfmm6sb","objOut":"ho644xlak"}]}],"objName":"Ops.User.cristianvogel.StretchArray"},{"id":"gpx59haiy","uiAttribs":{},"portsIn":[{"name":"Stretch Factor","value":3}],"portsOut":[{"name":"Length","value":108},{"name":"Result","links":[{"portIn":"LookUpArray","portOut":"Result","objIn":"41gfmm6sb","objOut":"gpx59haiy"}]}],"objName":"Ops.User.cristianvogel.StretchArray"},{"id":"uxi808ntq","uiAttribs":{},"portsIn":[{"name":"Nth","value":3}],"portsOut":[{"name":"Next","links":[{"portIn":"update","portOut":"Next","objIn":"ipm6puwpj","objOut":"uxi808ntq"},{"portIn":"render","portOut":"Next","objIn":"tbpgaoc9h","objOut":"uxi808ntq"}]}],"objName":"Ops.Trigger.NthTrigger_v2"},{"id":"nylgabmj2","uiAttribs":{},"portsIn":[{"name":"Start Index","value":0},{"name":"New Length","value":108}],"portsOut":[{"name":"Cropped Array","links":[{"portIn":"Scale Array","portOut":"Cropped Array","objIn":"to2191b15","objOut":"nylgabmj2"}]},{"name":"Array length","value":108}],"objName":"Ops.Array.CropArray"},{"id":"gbo1exsgj","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_NodeStateArray"}],"portsOut":[{"name":"Value","links":[{"portIn":"Array","portOut":"Value","objIn":"00eudjvka","objOut":"gbo1exsgj"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"00eudjvka","uiAttribs":{},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"r2vst8y2z","uiAttribs":{},"portsIn":[{"name":"number2","value":0.1}],"portsOut":[{"name":"result","links":[{"portIn":"width","portOut":"result","objIn":"p8e8ow6ya","objOut":"r2vst8y2z"}]}],"objName":"Ops.Math.Sum"},{"id":"wcg39k25h","uiAttribs":{},"portsIn":[{"name":"File","value":"assets/lib_matcaps_whitefluff.png","display":"file"},{"name":"Filter index","value":0},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"repeat"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":"0"},{"name":"Data Format index","value":3},{"name":"Data Format","value":"RGBA"},{"name":"Flip","value":false},{"name":"Pre Multiplied Alpha","value":false},{"name":"Active","value":true},{"name":"Save Memory","value":true},{"name":"Add Cachebuster","value":true}],"portsOut":[{"name":"Texture","links":[{"portIn":"MatCap","portOut":"Texture","objIn":"gtplwvx3v","objOut":"wcg39k25h"}]},{"name":"Width","value":256},{"name":"Height","value":256},{"name":"Aspect Ratio","value":1},{"name":"Loaded","value":true},{"name":"Loading","value":false}],"objName":"Ops.Gl.Texture_v2"},{"id":"gx16l5d7d","uiAttribs":{},"portsIn":[{"name":"Title","value":"viz"}],"objName":"Ops.Ui.Area"},{"id":"gtplwvx3v","uiAttribs":{},"portsIn":[{"name":"r","value":0.993},{"name":"g","value":0.933},{"name":"b","value":0.882},{"name":"Opacity","value":1},{"name":"AO Intensity","value":0.982},{"name":"Normal Map Intensity","value":0.222},{"name":"Repeat X","value":1},{"name":"Repeat Y","value":1},{"name":"Offset X","value":-0.38},{"name":"Offset Y","value":-1},{"name":"Screen Space Normals","value":true},{"name":"Calc normal tangents","value":false},{"name":"Opacity TexCoords Transform","value":false},{"name":"Discard Transparent Pixels","value":false},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"}],"portsOut":[{"name":"Next","links":[{"portIn":"exe","portOut":"Next","objIn":"to2191b15","objOut":"gtplwvx3v"}]}],"objName":"Ops.Gl.Shader.MatCapMaterialNew_v3"},{"id":"yg0q1ohdw","uiAttribs":{},"portsIn":[{"name":"Title","value":"Main Paint"}],"objName":"Ops.Ui.Area"},{"id":"ez75pjoud","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"newMain"}],"objName":"Ops.Trigger.TriggerSend"},{"id":"nzduebyab","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"newMain"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"exe","portOut":"Triggered","objIn":"10c39o948","objOut":"nzduebyab"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"ivrl1vtce","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"Key","value":"pickedID"}],"portsOut":[{"name":"Object Result","links":[{"portIn":"Object","portOut":"Object Result","objIn":"40f947a8-3a53-45b5-9038-dd7834bed318","objOut":"ivrl1vtce"},{"portIn":"Object","portOut":"Object Result","objIn":"9c8ar4gru","objOut":"ivrl1vtce"}]}],"objName":"Ops.Json.ObjectDeleteKey"},{"id":"csf00i719","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"patchId","value":"bp2sub_csf00i719"}],"portsOut":[{"name":"yimtxlm5q","title":"LastValue","links":[{"portIn":"Value In","portOut":"yimtxlm5q","objIn":"vatmrxnio","objOut":"csf00i719"}]}],"objName":"Ops.Patch.PL3eri4.TrackAndHoldPickedID"},{"id":"n9w0ly1qc","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"patchId","value":"bp2sub_n9w0ly1qc"}],"portsOut":[{"name":"yimtxlm5q","title":"LastValue","links":[{"portIn":"index","portOut":"yimtxlm5q","objIn":"0redgkxbp","objOut":"n9w0ly1qc"}]}],"objName":"Ops.Patch.PL3eri4.TrackAndHoldPickedID"},{"id":"lhz7t8idv","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_paramsVizNoSmooth"}],"portsOut":[{"name":"Value","links":[{"portIn":"Texture In","portOut":"Value","objIn":"ofnexf559","objOut":"lhz7t8idv"}]}],"objName":"Ops.Vars.VarGetTexture_v2"},{"id":"ofnexf559","uiAttribs":{},"portsIn":[{"name":"Show Info","value":false},{"name":"Visualize outside 0-1 index","value":1},{"name":"Visualize outside 0-1","value":"Anim"},{"name":"Show Color","value":false},{"name":"X","value":0.5},{"name":"Y","value":0.5}],"portsOut":[{"name":"Texture Out","links":[{"portIn":"Texture","portOut":"Texture Out","objIn":"h1pxd8o1x","objOut":"ofnexf559"}]},{"name":"Info","value":""}],"objName":"Ops.Ui.VizTexture"},{"id":"pcjznzvyh","uiAttribs":{},"portsIn":[{"name":"render","title":"Trigger"},{"name":"Render Mesh","title":"Render"},{"name":"width","value":1},{"name":"height","value":0.6},{"name":"pivot x index","value":1},{"name":"pivot x","value":"center"},{"name":"pivot y index","value":1},{"name":"pivot y","value":"center"},{"name":"axis index","value":0},{"name":"axis","value":"xy"},{"name":"Flip TexCoord X","value":false},{"name":"Flip TexCoord Y","value":true},{"name":"num columns","value":1},{"name":"num rows","value":1}],"objName":"Ops.Gl.Meshes.Rectangle_v4"},{"id":"h1pxd8o1x","uiAttribs":{},"portsIn":[{"name":"blendMode index","value":0},{"name":"blendMode","value":"normal"},{"name":"Amount","value":1},{"name":"Target index","value":0},{"name":"Target","value":"Color"},{"name":"Scale","value":0.75},{"name":"Use Texture Alpha","value":true},{"name":"Pos X","value":0},{"name":"Pos Y","value":0},{"name":"Rot X","value":0},{"name":"Rot Y","value":0},{"name":"Rot Z","value":0},{"name":"Mapping index","value":1},{"name":"Mapping","value":"XY"},{"name":"Discard","value":false},{"name":"WorldSpace","value":false}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"pcjznzvyh","objOut":"h1pxd8o1x"}]}],"objName":"Ops.Gl.ShaderEffects.TextureProjection_v2"},{"id":"0fqo2b3o9","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hasHit"}],"portsOut":[{"name":"Value","links":[{"portIn":"Render Mesh","portOut":"Value","objIn":"pcjznzvyh","objOut":"0fqo2b3o9"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"p8e8ow6ya","uiAttribs":{},"portsIn":[{"name":"render","title":"Trigger"},{"name":"Render Mesh","value":false,"title":"Render"},{"name":"pivot x index","value":1},{"name":"pivot x","value":"center"},{"name":"pivot y index","value":1},{"name":"pivot y","value":"center"},{"name":"axis index","value":0},{"name":"axis","value":"xy"},{"name":"Flip TexCoord X","value":false},{"name":"Flip TexCoord Y","value":true},{"name":"num columns","value":1},{"name":"num rows","value":1}],"portsOut":[{"name":"trigger","title":"Next","links":[{"portIn":"render","portOut":"trigger","objIn":"h1pxd8o1x","objOut":"p8e8ow6ya"}]}],"objName":"Ops.Gl.Meshes.Rectangle_v4"},{"id":"88uk5i00g","uiAttribs":{},"portsIn":[{"name":"Title","value":"Pointer"}],"objName":"Ops.Ui.Area"},{"id":"ocfmffrt7","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hasHit"}],"portsOut":[{"name":"Value","links":[{"portIn":"Value","portOut":"Value","objIn":"yj714f2qn","objOut":"ocfmffrt7"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"vp4c44pq1","uiAttribs":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1},{"name":"rotX","value":45},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"p8e8ow6ya","objOut":"vp4c44pq1"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"jn7fiog3y","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"hvjtea3m3","objOut":"jn7fiog3y"}]}],"objName":"Ops.Gl.Matrix.Billboard"},{"id":"lli0sq4ec","uiAttribs":{},"portsIn":[{"name":"Coordinates index","value":0},{"name":"Coordinates","value":"-1 to 1"},{"name":"Area index","value":0},{"name":"Area","value":"Canvas"},{"name":"flip y","value":true},{"name":"right click prevent default","value":true},{"name":"Touch support","value":false},{"name":"Active","value":true}],"portsOut":[{"name":"x","links":[{"portIn":"56c02rlis","portOut":"x","objIn":"ezywphh08","objOut":"lli0sq4ec"}]},{"name":"y","links":[{"portIn":"i89yopnbc","portOut":"y","objIn":"ezywphh08","objOut":"lli0sq4ec"}]},{"name":"Button is down","value":0},{"name":"Mouse is hovering","value":0},{"name":"Movement X","value":-15},{"name":"Movement Y","value":-8.5}],"objName":"Ops.Devices.Mouse.Mouse_v3"},{"id":"ezywphh08","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"rgd42fpcf","title":"Update"},{"name":"56c02rlis","title":"Value1"},{"name":"i89yopnbc","title":"Value2"},{"name":"mla1yespc","value":10,"title":"Inc/Dec factor"},{"name":"patchId","value":"bp2sub_ezywphh08"}],"portsOut":[{"name":"u44puxd40","title":"Next","links":[{"portIn":"exe","portOut":"u44puxd40","objIn":"gb2u3fqan","objOut":"ezywphh08"}]},{"name":"i56nc891p","value":-0.9910581222056631,"title":"Result1"},{"name":"w6t2jhm75","title":"Result2","links":[{"portIn":"eye Y","portOut":"w6t2jhm75","objIn":"3nwnpa7a8","objOut":"ezywphh08"}]}],"objName":"Ops.User.cristianvogel.SmoothPair"},{"id":"aonhpx6m7","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Depth"},{"name":"Min","value":0},{"name":"Max","value":1},{"name":"Step","value":0.0001},{"name":"Suffix","value":""},{"name":"Grey Out","value":false},{"name":"Visible","value":true},{"name":"Default","value":0.5}],"portsOut":[{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"1enzkm1k2","objOut":"aonhpx6m7"}]},{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"lboeuww7w","objOut":"aonhpx6m7"}]}],"objName":"Ops.Patch.PL3eri4.Slider_hideNumber_v1"},{"id":"wwpx8aqmi","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Mix"},{"name":"Min","value":0},{"name":"Max","value":1},{"name":"Step","value":0.0001},{"name":"Suffix","value":""},{"name":"Grey Out","value":false},{"name":"Visible","value":true},{"name":"Default","value":0.5}],"portsOut":[{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"aonhpx6m7","objOut":"wwpx8aqmi"}]},{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"3yjp0l99a","objOut":"wwpx8aqmi"}]}],"objName":"Ops.Patch.PL3eri4.Slider_hideNumber_v1"},{"id":"u3omcpuwe","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Decay"},{"name":"Min","value":0},{"name":"Max","value":1},{"name":"Step","value":0.0001},{"name":"Suffix","value":""},{"name":"Grey Out","value":false},{"name":"Visible","value":true},{"name":"Default","value":0.5}],"portsOut":[{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"wwpx8aqmi","objOut":"u3omcpuwe"}]},{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"8nr86xjqq","objOut":"u3omcpuwe"}]}],"objName":"Ops.Patch.PL3eri4.Slider_hideNumber_v1"},{"id":"1enzkm1k2","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Size"},{"name":"Min","value":0},{"name":"Max","value":1},{"name":"Step","value":0.0001},{"name":"Suffix","value":""},{"name":"Grey Out","value":false},{"name":"Visible","value":true},{"name":"Default","value":0.25}],"portsOut":[{"name":"Result","links":[{"portIn":"Value","portOut":"Result","objIn":"reovflbwn","objOut":"1enzkm1k2"}]}],"objName":"Ops.Patch.PL3eri4.Slider_hideNumber_v1"},{"id":"myexmbg9t","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Smoothing"},{"name":"Min","value":0},{"name":"Max","value":60},{"name":"Step","value":0.01},{"name":"Suffix","value":""},{"name":"Grey Out","value":false},{"name":"Visible","value":true},{"name":"Input","value":20},{"name":"Default","value":20}],"portsOut":[{"name":"childs","links":[{"portIn":"link","portOut":"childs","objIn":"th9kvcfp7","objOut":"myexmbg9t"}]},{"name":"Result","links":[{"portIn":"Number","portOut":"Result","objIn":"z27ki35ux","objOut":"myexmbg9t"}]}],"objName":"Ops.Patch.PL3eri4.Slider_hideNumber_v1"},{"id":"6zas09ljy","uiAttribs":{},"portsIn":[{"name":"Title","value":"overlay"}],"objName":"Ops.Ui.Area"},{"id":"2bipalf46","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"mainClock"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"Execute","portOut":"Triggered","objIn":"6hw1co6fv","objOut":"2bipalf46"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"zwh4x9wmb","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_storedParamsAtPickedID"}],"objName":"Ops.Vars.VarSetArray_v2"},{"id":"pbl7s7d9m","uiAttribs":{},"portsIn":[{"name":"Title","value":"svg type"}],"objName":"Ops.Ui.Area"},{"id":"5ytdfngfb","uiAttribs":{},"portsIn":[{"name":"Search For","value":"node"},{"name":"Replace","value":"preset"},{"name":"Replace What index","value":0},{"name":"Replace What","value":"All"}],"portsOut":[{"name":"Result","links":[{"portIn":"Text","portOut":"Result","objIn":"1lo7344o9","objOut":"5ytdfngfb"}]}],"objName":"Ops.String.StringReplace"},{"id":"ot0cslmz8","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_overlayText"}],"objName":"Ops.Vars.VarSetObject_v2"},{"id":"w0zdllw6l","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_overlayText"}],"portsOut":[{"name":"Value","links":[{"portIn":"Geometry","portOut":"Value","objIn":"v9fv15i1l","objOut":"w0zdllw6l"}]}],"objName":"Ops.Vars.VarGetObject_v2"},{"id":"7a3v163st","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"patchId","value":"bp2sub_7a3v163st"}],"portsOut":[{"name":"7xj1h37jx","title":"ArrayOut","links":[{"portIn":"Array","portOut":"7xj1h37jx","objIn":"gpx59haiy","objOut":"7a3v163st"},{"portIn":"Array","portOut":"7xj1h37jx","objIn":"ho644xlak","objOut":"7a3v163st"}]}],"objName":"Ops.Patch.PL3eri4.SubPatch0"},{"id":"oovc0xib4","uiAttribs":{},"portsIn":[{"name":"Callback Name","value":"interactionFromUI"},{"name":"Parameter 1","value":"","useVariable":"ui_hitBodyName"},{"name":"Parameter 2","value":""},{"name":"Parameter 3","value":""}],"objName":"Ops.Cables.CallBack_v2"},{"id":"2e72agt39","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_buttonDown"}],"portsOut":[{"name":"Value","links":[{"portIn":"Pass Through","portOut":"Value","objIn":"vatmrxnio","objOut":"2e72agt39"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"vatmrxnio","uiAttribs":{},"portsOut":[{"name":"Value Out","links":[{"portIn":"Index","portOut":"Value Out","objIn":"ng57avp3w","objOut":"vatmrxnio"}]}],"objName":"Ops.Number.GateNumber"},{"id":"bi8mzcxgn","uiAttribs":{},"portsIn":[{"name":"Coordinates index","value":0},{"name":"Coordinates","value":"-1 to 1"},{"name":"Area index","value":0},{"name":"Area","value":"Canvas"},{"name":"flip y","value":true},{"name":"right click prevent default","value":true},{"name":"Touch support","value":true},{"name":"Active","value":true}],"portsOut":[{"name":"x","value":-0.9910581222056631},{"name":"y","value":0.6026936026936027},{"name":"click right","links":[{"portIn":"exe","portOut":"click right","objIn":"oovc0xib4","objOut":"bi8mzcxgn"}]},{"name":"Button is down","value":0},{"name":"Mouse is hovering","value":0},{"name":"Movement X","value":-15},{"name":"Movement Y","value":-8.5}],"objName":"Ops.Devices.Mouse.Mouse_v3"},{"id":"v63aek9xf","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"mainSeq"}],"objName":"Ops.Trigger.TriggerSend"},{"id":"eq2rtg5bw","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_storedPresets"}],"portsOut":[{"name":"Value","links":[{"portIn":"Array of Arrays","portOut":"Value","objIn":"0qnwelx21","objOut":"eq2rtg5bw"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"0qnwelx21","uiAttribs":{},"portsOut":[{"name":"Result Array","links":[{"portIn":"Array","portOut":"Result Array","objIn":"a9nn9h186","objOut":"0qnwelx21"}]}],"objName":"Ops.Array.ArrayGetArray"},{"id":"ukqpyxydh","uiAttribs":{},"portsIn":[{"name":"Title","value":"Mini Bar Chart"}],"objName":"Ops.Ui.Area"},{"id":"a9nn9h186","uiAttribs":{},"portsIn":[{"name":"Invalid when length is 0","value":true}],"portsOut":[{"name":"Last Valid Array","links":[{"portIn":"array","portOut":"Last Valid Array","objIn":"y5v2jfww4","objOut":"a9nn9h186"}]},{"name":"Is Valid","value":1}],"objName":"Ops.Array.FilterValidArray"},{"id":"z5fwtc89j","uiAttribs":{},"portsIn":[{"name":"Repeats","value":4},{"name":"Direction index","value":0},{"name":"Direction","value":"Forward"}],"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"u85n3y7ln","objOut":"z5fwtc89j"}]},{"name":"index","links":[{"portIn":"number1","portOut":"index","objIn":"d54orl7d8","objOut":"z5fwtc89j"},{"portIn":"index","portOut":"index","objIn":"y5v2jfww4","objOut":"z5fwtc89j"}]}],"objName":"Ops.Trigger.Repeat_v2"},{"id":"94vibaodf","uiAttribs":{},"portsIn":[{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"nyv92gtx3","objOut":"94vibaodf"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"d54orl7d8","uiAttribs":{},"portsIn":[{"name":"number2","value":0.17}],"portsOut":[{"name":"result","links":[{"portIn":"posX","portOut":"result","objIn":"94vibaodf","objOut":"d54orl7d8"}]}],"objName":"Ops.Math.Multiply"},{"id":"y5v2jfww4","uiAttribs":{},"portsOut":[{"name":"value","links":[{"portIn":"y","portOut":"value","objIn":"u85n3y7ln","objOut":"y5v2jfww4"}]}],"objName":"Ops.Array.ArrayGetNumber"},{"id":"u85n3y7ln","uiAttribs":{},"portsIn":[{"name":"x","value":1},{"name":"z","value":1}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"r9gc34gop","objOut":"u85n3y7ln"}]}],"objName":"Ops.Gl.Matrix.ScaleXYZ"},{"id":"r9gc34gop","uiAttribs":{},"portsIn":[{"name":"a","value":1},{"name":"colorizeTexture","value":false},{"name":"Vertex Colors","value":false},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":false},{"name":"Discard Transparent Pixels","value":false},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":false},{"name":"billboard","value":false}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"94vibaodf","objOut":"r9gc34gop"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"qk0t5nh3q","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"patchId","value":"bp2sub_qk0t5nh3q"}],"portsOut":[{"name":"yimtxlm5q","title":"LastValue","links":[{"portIn":"Index","portOut":"yimtxlm5q","objIn":"0qnwelx21","objOut":"qk0t5nh3q"},{"portIn":"index","portOut":"yimtxlm5q","objIn":"2xc49i79z","objOut":"qk0t5nh3q"},{"portIn":"Value","portOut":"yimtxlm5q","objIn":"0xscqywfc","objOut":"qk0t5nh3q"}]}],"objName":"Ops.Patch.PL3eri4.TrackAndHoldPickedID"},{"id":"bjxjjnkly","uiAttribs":{},"portsIn":[{"name":"Size index","value":0},{"name":"Size","value":"Manual"},{"name":"texture width","value":256},{"name":"texture height","value":256},{"name":"Auto Aspect","value":false},{"name":"filter index","value":1},{"name":"filter","value":"nearest"},{"name":"Wrap index","value":1},{"name":"Wrap","value":"Clamp"},{"name":"MSAA index","value":0},{"name":"MSAA","value":"none"},{"name":"Pixel Format index","value":4},{"name":"Pixel Format","value":"RGBA 8bit ubyte"},{"name":"Depth","value":false},{"name":"Clear","value":true}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"c482t8koh","objOut":"bjxjjnkly"}]},{"name":"texture","links":[{"portIn":"Texture In","portOut":"texture","objIn":"v9n0f06vd","objOut":"bjxjjnkly"}]}],"objName":"Ops.Gl.RenderToTexture_v3"},{"id":"v9n0f06vd","uiAttribs":{},"portsIn":[{"name":"Show Info","value":false},{"name":"Visualize outside 0-1 index","value":1},{"name":"Visualize outside 0-1","value":"Anim"},{"name":"Show Color","value":false},{"name":"X","value":0.5},{"name":"Y","value":0.5}],"portsOut":[{"name":"Texture Out","links":[{"portIn":"Value","portOut":"Texture Out","objIn":"markfynes","objOut":"v9n0f06vd"}]},{"name":"Info","value":""}],"objName":"Ops.Ui.VizTexture"},{"id":"c482t8koh","uiAttribs":{},"portsIn":[{"name":"x","value":4},{"name":"y","value":4},{"name":"z","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Execute","portOut":"trigger","objIn":"z5fwtc89j","objOut":"c482t8koh"}]}],"objName":"Ops.Gl.Matrix.ScaleXYZ"},{"id":"markfynes","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_paramsVizNoSmooth"}],"objName":"Ops.Vars.VarSetTexture_v2"},{"id":"99elfe9zs","uiAttribs":{},"portsIn":[{"name":"posX","value":-1.69},{"name":"posY","value":0.91},{"name":"posZ","value":0},{"name":"scale","value":0.7},{"name":"rotX","value":-180},{"name":"rotY","value":0},{"name":"rotZ","value":90}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bjxjjnkly","objOut":"99elfe9zs"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"nyv92gtx3","uiAttribs":{},"portsIn":[{"name":"render","title":"Trigger"},{"name":"Render Mesh","title":"Render"},{"name":"width","value":0.12360939431396786},{"name":"height","value":0.82},{"name":"pivot x index","value":1},{"name":"pivot x","value":"left"},{"name":"pivot y index","value":1},{"name":"pivot y","value":"top"},{"name":"axis index","value":0},{"name":"axis","value":"xy"},{"name":"Flip TexCoord X","value":false},{"name":"Flip TexCoord Y","value":true},{"name":"num columns","value":4},{"name":"num rows","value":4}],"objName":"Ops.Gl.Meshes.Rectangle_v4"},{"id":"rskl981cx","uiAttribs":{},"portsIn":[{"name":"radius","value":0.1},{"name":"innerRadius","value":0.758},{"name":"segments","value":16},{"name":"percent","value":1},{"name":"steps","value":0},{"name":"invertSteps","value":false},{"name":"mapping index","value":0},{"name":"mapping","value":"flat"},{"name":"Spline","value":false},{"name":"Draw","title":"Render mesh"}],"objName":"Ops.Gl.Meshes.Circle_v3"},{"id":"zqpk61u8a","uiAttribs":{},"portsIn":[{"name":"posX","value":-0.6},{"name":"posY","value":0.03},{"name":"posZ","value":0.25},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"rskl981cx","objOut":"zqpk61u8a"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"amq5nwrl7","uiAttribs":{},"portsIn":[{"name":"x","value":0.25},{"name":"y","value":-0.5},{"name":"z","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"dkt1ljjre","objOut":"amq5nwrl7"}]}],"objName":"Ops.Gl.Matrix.Translate"},{"id":"7z5k4ev9u","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"patchId","value":"bp2sub_7z5k4ev9u"}],"portsOut":[{"name":"6ove2a7zx","title":"X","links":[{"portIn":"number1","portOut":"6ove2a7zx","objIn":"43v7zsj10","objOut":"7z5k4ev9u"}]},{"name":"zs6h90vhr","title":"Y","links":[{"portIn":"posY","portOut":"zs6h90vhr","objIn":"dkt1ljjre","objOut":"7z5k4ev9u"}]},{"name":"icxd5s8my","title":"Z","links":[{"portIn":"posZ","portOut":"icxd5s8my","objIn":"dkt1ljjre","objOut":"7z5k4ev9u"}]}],"objName":"Ops.Patch.PL3eri4.SubPatch2"},{"id":"dae6bpcmb","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_pickedRGBA"}],"objName":"Ops.Vars.VarSetArray_v2"},{"id":"kwisnp1st","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_pickedRGBA"}],"portsOut":[{"name":"Value","links":[{"portIn":"Array","portOut":"Value","objIn":"2xc49i79z","objOut":"kwisnp1st"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"2xc49i79z","uiAttribs":{},"portsOut":[{"name":"Value 1","links":[{"portIn":"bv3dr3wey","portOut":"Value 1","objIn":"2z9y3j96e","objOut":"2xc49i79z"}]},{"name":"Value 2","links":[{"portIn":"5w3hfcu2f","portOut":"Value 2","objIn":"2z9y3j96e","objOut":"2xc49i79z"}]},{"name":"Value 3","links":[{"portIn":"ytx8sx5p6","portOut":"Value 3","objIn":"2z9y3j96e","objOut":"2xc49i79z"}]},{"name":"Value 4","value":0.2}],"objName":"Ops.User.cristianvogel.IteratorArray4"},{"id":"0xscqywfc","uiAttribs":{},"portsOut":[{"name":"Next","links":[{"portIn":"Execute","portOut":"Next","objIn":"2xc49i79z","objOut":"0xscqywfc"}]},{"name":"Number","value":4}],"objName":"Ops.Number.TriggerOnChangeNumber"},{"id":"i7iw3exzb","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"patchId","value":"bp2sub_i7iw3exzb"}],"portsOut":[{"name":"yimtxlm5q","title":"LastValue","links":[{"portIn":"index","portOut":"yimtxlm5q","objIn":"u90vkvew6","objOut":"i7iw3exzb"}]}],"objName":"Ops.Patch.PL3eri4.TrackAndHoldPickedID"},{"id":"id9g0p7ii","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_hasHit"}],"portsOut":[{"name":"Value","links":[{"portIn":"Draw","portOut":"Value","objIn":"rskl981cx","objOut":"id9g0p7ii"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"2z9y3j96e","uiAttribs":{},"storage":{"blueprintVer":2,"subPatchVer":2},"portsIn":[{"name":"bv3dr3wey","title":"R"},{"name":"5w3hfcu2f","title":"G"},{"name":"ytx8sx5p6","title":"B"},{"name":"iihqp1pix","value":0.1,"title":"adjust hue +"},{"name":"kp4wy4e6s","value":1.5,"title":"adjust sat *"},{"name":"yp58oixtq","value":1.5,"title":"adjust bright *"},{"name":"patchId","value":"bp2sub_2z9y3j96e"}],"portsOut":[{"name":"m3nphmb8k","title":"R","links":[{"portIn":"r","portOut":"m3nphmb8k","objIn":"r9gc34gop","objOut":"2z9y3j96e"}]},{"name":"cg08y1buw","title":"G","links":[{"portIn":"g","portOut":"cg08y1buw","objIn":"r9gc34gop","objOut":"2z9y3j96e"}]},{"name":"pmtcdzefz","title":"B","links":[{"portIn":"b","portOut":"pmtcdzefz","objIn":"r9gc34gop","objOut":"2z9y3j96e"}]}],"objName":"Ops.User.cristianvogel.RGBHSBAdjust"},{"id":"duztwx0hg","uiAttribs":{},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"tobbb4gxk","uiAttribs":{"subPatch":"c00e1133-7569-4211-a92f-5467fd37c7f8"},"portsIn":[{"name":"Start Row","value":0}],"objName":"Ops.Ui.VizArrayTable"},{"id":"th9kvcfp7","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Text","value":"Random Fill"},{"name":"Grey Out","value":false},{"name":"Visible","value":true}],"portsOut":[{"name":"Pressed Trigger","links":[{"portIn":"Trigger","portOut":"Pressed Trigger","objIn":"u8m2hzm11","objOut":"th9kvcfp7"}]}],"objName":"Ops.Sidebar.Button_v2"},{"id":"u8m2hzm11","uiAttribs":{"subPatch":"9d01962a-fa89-4cfb-b892-b87e7423e92f"},"portsIn":[{"name":"Named Trigger","value":"TriggerRandomFill"}],"objName":"Ops.Trigger.TriggerSend"},{"id":"e4g3u5azp","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"TriggerRandomFill"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"trigger","portOut":"Triggered","objIn":"a4pv5qyfg","objOut":"e4g3u5azp"},{"portIn":"exe","portOut":"Triggered","objIn":"6fvfsmrnz","objOut":"e4g3u5azp"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"a4pv5qyfg","uiAttribs":{},"portsIn":[{"name":"Default","value":false}],"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"65zy74xvv","objOut":"a4pv5qyfg"}]}],"objName":"Ops.Boolean.ToggleBool_v2"},{"id":"6fvfsmrnz","uiAttribs":{},"portsOut":[{"name":"timesTriggered","links":[{"portIn":"number1","portOut":"timesTriggered","objIn":"koq9bozeh","objOut":"6fvfsmrnz"}]}],"objName":"Ops.Trigger.TriggerCounter"},{"id":"koq9bozeh","uiAttribs":{},"portsIn":[{"name":"number2","value":0.00001}],"portsOut":[{"name":"result","links":[{"portIn":"Random Seed ","portOut":"result","objIn":"qhnsl12n2","objOut":"koq9bozeh"}]}],"objName":"Ops.Math.Multiply"},{"id":"jzhsnchh9","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"mainClock"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"render","portOut":"Triggered","objIn":"99elfe9zs","objOut":"jzhsnchh9"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"wpsop3snv","uiAttribs":{},"portsIn":[{"name":"Parent Array length","value":36,"useVariable":"NUMBER_NODES"},{"name":"Array Element length","value":4,"useVariable":"NUMBER_PARAMS"},{"name":"Mode select index","value":0},{"name":"Mode select","value":"Number"},{"name":"Default Value","value":0.5},{"name":"Reverse","value":false}],"portsOut":[{"name":"Array","links":[{"portIn":"Array 0","portOut":"Array","objIn":"p46c9agrp","objOut":"wpsop3snv"}]},{"name":"Array length out","value":36}],"objName":"Ops.User.cristianvogel.NewArrayOfArrays"},{"id":"nmjwgnoh5","uiAttribs":{},"portsIn":[{"name":"Value","value":36},{"name":"Variable","value":"NUMBER_NODES"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"k1zu4dhd0","uiAttribs":{},"portsIn":[{"name":"Value","value":4},{"name":"Variable","value":"NUMBER_PARAMS"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"p46c9agrp","uiAttribs":{},"portsIn":[{"name":"Array 2","value":0},{"name":"Array 3","value":0},{"name":"Array 4","value":0},{"name":"Array 5","value":0},{"name":"Array 6","value":0},{"name":"Array 7","value":0},{"name":"Array 8","value":0},{"name":"Array 9","value":0}],"portsOut":[{"name":"Result","links":[{"portIn":"in1 ArraySetArray array","portOut":"Result","objIn":"t1agaa7cp","objOut":"p46c9agrp"}]}],"objName":"Ops.Array.SwitchArray"},{"id":"8aabq01ps","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"startTrigger"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"Execute","portOut":"Triggered","objIn":"wpsop3snv","objOut":"8aabq01ps"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"rak54dp2y","uiAttribs":{},"portsOut":[{"name":"Changed Trigger","links":[{"portIn":"Set","portOut":"Changed Trigger","objIn":"0n988xv11","objOut":"rak54dp2y"}]},{"name":"New Array","links":[{"portIn":"Array 1","portOut":"New Array","objIn":"p46c9agrp","objOut":"rak54dp2y"}]}],"objName":"Ops.Array.ArrayChangedTrigger"},{"id":"0n988xv11","uiAttribs":{},"portsIn":[{"name":"Number","value":1}],"portsOut":[{"name":"Out Value","links":[{"portIn":"Index","portOut":"Out Value","objIn":"p46c9agrp","objOut":"0n988xv11"}]}],"objName":"Ops.Trigger.TriggerNumber"},{"id":"qhzb4cvpo","uiAttribs":{},"portsIn":[{"name":"Named Trigger","value":"TriggerRandomFill"}],"portsOut":[{"name":"Triggered","links":[{"portIn":"exe","portOut":"Triggered","objIn":"t1zieq77q","objOut":"qhzb4cvpo"}]}],"objName":"Ops.Trigger.TriggerReceive"},{"id":"t1zieq77q","uiAttribs":{},"portsIn":[{"name":"Callback Name","value":"randomiseAllNodes"},{"name":"Parameter 1","value":""},{"name":"Parameter 2","value":""},{"name":"Parameter 3","value":""}],"objName":"Ops.Cables.CallBack_v2"},{"id":"jpq7j909o","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_NodeStateArray"}],"portsOut":[{"name":"Value","links":[{"portIn":"array","portOut":"Value","objIn":"rq08t8vpx","objOut":"jpq7j909o"}]}],"objName":"Ops.Vars.VarGetArray_v2"},{"id":"rq08t8vpx","uiAttribs":{},"portsOut":[{"name":"value","links":[{"portIn":"number1","portOut":"value","objIn":"j2yvlanq7","objOut":"rq08t8vpx"}]}],"objName":"Ops.Array.ArrayGetNumber"},{"id":"j2yvlanq7","uiAttribs":{},"portsIn":[{"name":"number2","value":0}],"portsOut":[{"name":"result","links":[{"portIn":"Render Mesh","portOut":"result","objIn":"nyv92gtx3","objOut":"j2yvlanq7"},{"portIn":"Value","portOut":"result","objIn":"qpr5d71gz","objOut":"j2yvlanq7"}]}],"objName":"Ops.Math.Compare.GreaterThan"},{"id":"yrpjdyiov","uiAttribs":{},"portsIn":[{"name":"Variable","value":"param_pickedID"}],"portsOut":[{"name":"Value","links":[{"portIn":"index","portOut":"Value","objIn":"rq08t8vpx","objOut":"yrpjdyiov"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"pmsecvr1z","uiAttribs":{},"portsOut":[{"name":"then","links":[{"portIn":"Trigger","portOut":"then","objIn":"a3n1oh5tw","objOut":"pmsecvr1z"}]}],"objName":"Ops.Boolean.IfTrueThen_v2"},{"id":"qpr5d71gz","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_nodeFilled"}],"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"3sydhdlg3","uiAttribs":{},"portsIn":[{"name":"Variable","value":"patch_nodeFilled"}],"portsOut":[{"name":"Value","links":[{"portIn":"boolean","portOut":"Value","objIn":"pmsecvr1z","objOut":"3sydhdlg3"},{"portIn":"Pass Through","portOut":"Value","objIn":"49pg7wh42","objOut":"3sydhdlg3"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"49pg7wh42","uiAttribs":{},"portsOut":[{"name":"Value Out","links":[{"portIn":"Value","portOut":"Value Out","objIn":"kjz264ffc","objOut":"49pg7wh42"}]}],"objName":"Ops.Number.GateNumber"},{"id":"dblpwvidz","uiAttribs":{},"portsIn":[{"name":"Decimal points","value":6}],"portsOut":[{"name":"Object","links":[{"portIn":"Object","portOut":"Object","objIn":"jiprkzxsk","objOut":"dblpwvidz"},{"portIn":"Value","portOut":"Object","objIn":"1crcd52b2","objOut":"dblpwvidz"}]}],"objName":"Ops.User.cristianvogel.ConvertArrayToObject"},{"id":"jiprkzxsk","uiAttribs":{},"portsIn":[{"name":"ZoomText","value":false},{"name":"Line Numbers","value":true},{"name":"Font Size","value":10},{"name":"Scroll","value":0}],"objName":"Ops.Ui.VizObject"},{"id":"1crcd52b2","uiAttribs":{},"portsIn":[{"name":"Variable","value":"ui_interpolatingPresetObject"}],"objName":"Ops.Vars.VarSetObject_v2"},{"id":"s313lwyua","uiAttribs":{},"portsIn":[{"name":"Separate inc/dec","value":false},{"name":"Inc factor","value":4,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"execute","portOut":"Next","objIn":"dblpwvidz","objOut":"s313lwyua"}]},{"name":"Array Out","links":[{"portIn":"array","portOut":"Array Out","objIn":"m8w704bh0","objOut":"s313lwyua"},{"portIn":"Array","portOut":"Array Out","objIn":"2oe2m9k57","objOut":"s313lwyua"},{"portIn":"Array","portOut":"Array Out","objIn":"ea03f35d-e2b1-49fa-a4fc-0913ccbc5a12","objOut":"s313lwyua"},{"portIn":"Array","portOut":"Array Out","objIn":"dblpwvidz","objOut":"s313lwyua"}]}],"objName":"Ops.User.cristianvogel.LofiSmoothArray"}],"_id":"65cd287d802a2d10c0143ed1","export":{"time":"2024-02-15 19:00:48","service":"github","exportNumber":16}};
if(!CABLES.exportedPatch){CABLES.exportedPatch=CABLES.exportedPatches['L3eri4']}
"use strict";

var CABLES=CABLES||{};
CABLES.OPS=CABLES.OPS||{};

var Ops=Ops || {};
Ops.Gl=Ops.Gl || {};
Ops.Ui=Ops.Ui || {};
Ops.Anim=Ops.Anim || {};
Ops.Html=Ops.Html || {};
Ops.Json=Ops.Json || {};
Ops.Math=Ops.Math || {};
Ops.User=Ops.User || {};
Ops.Vars=Ops.Vars || {};
Ops.Array=Ops.Array || {};
Ops.Color=Ops.Color || {};
Ops.Patch=Ops.Patch || {};
Ops.Cables=Ops.Cables || {};
Ops.Number=Ops.Number || {};
Ops.String=Ops.String || {};
Ops.Boolean=Ops.Boolean || {};
Ops.Devices=Ops.Devices || {};
Ops.Sidebar=Ops.Sidebar || {};
Ops.Trigger=Ops.Trigger || {};
Ops.Graphics=Ops.Graphics || {};
Ops.Extension=Ops.Extension || {};
Ops.Gl.Matrix=Ops.Gl.Matrix || {};
Ops.Gl.Meshes=Ops.Gl.Meshes || {};
Ops.Gl.Shader=Ops.Gl.Shader || {};
Ops.Math.Compare=Ops.Math.Compare || {};
Ops.Devices.Mouse=Ops.Devices.Mouse || {};
Ops.Patch.PL3eri4=Ops.Patch.PL3eri4 || {};
Ops.Array.PointArray=Ops.Array.PointArray || {};
Ops.Devices.Keyboard=Ops.Devices.Keyboard || {};
Ops.Gl.ShaderEffects=Ops.Gl.ShaderEffects || {};
Ops.Graphics.Geometry=Ops.Graphics.Geometry || {};
Ops.Extension.OpenType=Ops.Extension.OpenType || {};
Ops.User.cristianvogel=Ops.User.cristianvogel || {};
Ops.Graphics.Intersection=Ops.Graphics.Intersection || {};



// **************************************************************
// 
// Ops.Patch.PL3eri4.GradientSwitching_WfT5140
// 
// **************************************************************

Ops.Patch.PL3eri4.GradientSwitching_WfT5140 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_5l0ul3gca=op.inTrigger(\"5l0ul3gca\");\nport_5l0ul3gca.setUiAttribs({title:\"exec\",});\n\nconst port_5jmbfmc3k=op.inFloat(\"5jmbfmc3k\",0);\nport_5jmbfmc3k.setUiAttribs({title:\"num\",});\n\nconst port_9yuykm3cr=op.outObject(\"9yuykm3cr\");\nport_9yuykm3cr.setUiAttribs({title:\"texture\",});\n\nconst port_qnty937qo=op.outTrigger(\"qnty937qo\");\nport_qnty937qo.setUiAttribs({title:\"Next\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_5l0ul3gca = addedOps[i].outTrigger(\"innerOut_5l0ul3gca\");\ninnerOut_5l0ul3gca.setUiAttribs({title:\"exec\"});\nport_5l0ul3gca.onTriggered = () => { innerOut_5l0ul3gca.trigger(); };\n\nconst innerOut_5jmbfmc3k = addedOps[i].outNumber(\"innerOut_5jmbfmc3k\");\ninnerOut_5jmbfmc3k.set(port_5jmbfmc3k.get() );\ninnerOut_5jmbfmc3k.setUiAttribs({title:\"num\"});\nport_5jmbfmc3k.on(\"change\", (a,v) => { innerOut_5jmbfmc3k.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_9yuykm3cr = addedOps[i].inObject(\"innerIn_9yuykm3cr\");\ninnerIn_9yuykm3cr.setUiAttribs({title:\"texture\"});\ninnerIn_9yuykm3cr.on(\"change\", (a,v) => { port_9yuykm3cr.setRef(a); });\n\nconst innerIn_qnty937qo = addedOps[i].inTrigger(\"innerIn_qnty937qo\");\ninnerIn_qnty937qo.setUiAttribs({title:\"Next\"});\ninnerIn_qnty937qo.onTriggered = () => { port_qnty937qo.trigger(); };\n\n}\n}\n};\n","ports_json":"{\n    \"ports\": [\n        {\n            \"id\": \"5l0ul3gca\",\n            \"title\": \"exec\",\n            \"dir\": 0,\n            \"type\": 1,\n            \"order\": 0\n        },\n        {\n            \"id\": \"5jmbfmc3k\",\n            \"title\": \"num\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1\n        },\n        {\n            \"id\": \"9yuykm3cr\",\n            \"title\": \"texture\",\n            \"dir\": 1,\n            \"type\": 2,\n            \"order\": 1002\n        },\n        {\n            \"id\": \"qnty937qo\",\n            \"title\": \"Next\",\n            \"dir\": 1,\n            \"type\": 1,\n            \"order\": 1003\n        }\n    ]\n}","subpatch_json":"{\n  \"ops\": [\n    {\n      \"opId\": \"01380a50-2dbb-4465-ae80-86349b0b717a\",\n      \"id\": \"v97irkvbv\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 360,\n          \"y\": 500\n        },\n        \"comment\": \"randomisable?\",\n        \"subPatch\": \"9gje7g4cl\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Gradient\",\n          \"value\": \"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.56,\\\"r\\\":0.6202546039116739,\\\"g\\\":0.43674269667803833,\\\"b\\\":0.7361425522048106},{\\\"pos\\\":0.0068359375,\\\"posy\\\":0.56,\\\"r\\\":0.9577300728127345,\\\"g\\\":0.21030872898874065,\\\"b\\\":0.1009306726881607},{\\\"pos\\\":0.142578125,\\\"posy\\\":0.54,\\\"r\\\":0.7186517249679445,\\\"g\\\":0.9792616761399917,\\\"b\\\":0.669536578556196},{\\\"pos\\\":0.326171875,\\\"posy\\\":0.54,\\\"r\\\":0.0014889620795699443,\\\"g\\\":0.8833982092930659,\\\"b\\\":0.6804539321269494},{\\\"pos\\\":0.5,\\\"posy\\\":0.55,\\\"r\\\":0.4585010080848828,\\\"g\\\":0.42914256013736596,\\\"b\\\":0.27926497150110574},{\\\"pos\\\":0.701171875,\\\"posy\\\":0.56,\\\"r\\\":0.44130508338442187,\\\"g\\\":0.4848655814504017,\\\"b\\\":0.9645128223113604},{\\\"pos\\\":0.87109375,\\\"posy\\\":0.54,\\\"r\\\":0.41869841604419356,\\\"g\\\":0.22582753190730998,\\\"b\\\":0.45329012298861726},{\\\"pos\\\":1,\\\"posy\\\":0.54,\\\"r\\\":0.7567862926400641,\\\"g\\\":0.9851330861121792,\\\"b\\\":0.7676297393889975}]}\"\n        },\n        {\n          \"name\": \"Direction index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"Direction\",\n          \"value\": \"Y\"\n        },\n        {\n          \"name\": \"Smoothstep\",\n          \"value\": true\n        },\n        {\n          \"name\": \"Step\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Flip\",\n          \"value\": true\n        },\n        {\n          \"name\": \"sRGB\",\n          \"value\": true\n        },\n        {\n          \"name\": \"Oklab\",\n          \"value\": true\n        },\n        {\n          \"name\": \"Size\",\n          \"value\": 55\n        },\n        {\n          \"name\": \"filter index\",\n          \"value\": 1\n        },\n        {\n          \"name\": \"filter\",\n          \"value\": \"nearest\"\n        },\n        {\n          \"name\": \"wrap index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"wrap\",\n          \"value\": \"clamp to edge\"\n        },\n        {\n          \"name\": \"Gradient Array\",\n          \"value\": 0\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Texture\",\n          \"links\": [\n            {\n              \"portIn\": \"texture1\",\n              \"portOut\": \"Texture\",\n              \"objIn\": \"1zulf8gsn\",\n              \"objOut\": \"v97irkvbv\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"01380a50-2dbb-4465-ae80-86349b0b717a\",\n      \"id\": \"2he777t07\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 348,\n          \"y\": 460\n        },\n        \"comment\": \"default\",\n        \"subPatch\": \"9gje7g4cl\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Gradient\",\n          \"value\": \"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.7058823529411765,\\\"g\\\":0.9803921568627451,\\\"b\\\":0.8992616421568627},{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.7058823529411765,\\\"g\\\":0.9803921568627451,\\\"b\\\":0.8992616421568627},{\\\"pos\\\":0.115234375,\\\"posy\\\":0.67,\\\"r\\\":0.3919989156161212,\\\"g\\\":0.641487856356844,\\\"b\\\":0.3805734669142953},{\\\"pos\\\":0.296875,\\\"posy\\\":0.53,\\\"r\\\":0.43662109375,\\\"g\\\":0.4125919842804697,\\\"b\\\":0.3588798572309315},{\\\"pos\\\":0.578125,\\\"posy\\\":0.55,\\\"r\\\":0.8459891899628731,\\\"g\\\":0.12788963047700275,\\\"b\\\":0.4545573650143784},{\\\"pos\\\":0.787109375,\\\"posy\\\":0.36,\\\"r\\\":0.1052409011310762,\\\"g\\\":0.04238010364869038,\\\"b\\\":0.8444303013473085},{\\\"pos\\\":0.921875,\\\"posy\\\":0.47,\\\"r\\\":0.22502963872671233,\\\"g\\\":0.39659752336065046,\\\"b\\\":0.5451124718250866},{\\\"pos\\\":1,\\\"posy\\\":0.47,\\\"r\\\":0.22502963872671233,\\\"g\\\":0.39659752336065046,\\\"b\\\":0.5451124718250866}]}\"\n        },\n        {\n          \"name\": \"Direction index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"Direction\",\n          \"value\": \"Y\"\n        },\n        {\n          \"name\": \"Smoothstep\",\n          \"value\": true\n        },\n        {\n          \"name\": \"Step\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Flip\",\n          \"value\": true\n        },\n        {\n          \"name\": \"sRGB\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Oklab\",\n          \"value\": true\n        },\n        {\n          \"name\": \"Size\",\n          \"value\": 55\n        },\n        {\n          \"name\": \"filter index\",\n          \"value\": 1\n        },\n        {\n          \"name\": \"filter\",\n          \"value\": \"mipmap\"\n        },\n        {\n          \"name\": \"wrap index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"wrap\",\n          \"value\": \"clamp to edge\"\n        },\n        {\n          \"name\": \"Gradient Array\",\n          \"value\": 0\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Texture\",\n          \"links\": [\n            {\n              \"portIn\": \"texture0\",\n              \"portOut\": \"Texture\",\n              \"objIn\": \"1zulf8gsn\",\n              \"objOut\": \"2he777t07\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"e63cbdbe-0c03-4d3d-be9d-fafa8324ac53\",\n      \"id\": \"1zulf8gsn\",\n      \"uiAttribs\": {\n        \"title\": \"SwitchTextures\",\n        \"subPatch\": \"9gje7g4cl\",\n        \"translate\": {\n          \"x\": 312,\n          \"y\": 620\n        },\n        \"tempSubOldOpId\": \"h70gxq1pz\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Default Texture Transparent\",\n          \"value\": false\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"texture\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_9yuykm3cr\",\n              \"portOut\": \"texture\",\n              \"objIn\": \"h01k0w5m5\",\n              \"objOut\": \"1zulf8gsn\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"01380a50-2dbb-4465-ae80-86349b0b717a\",\n      \"id\": \"x6p9i0qo1\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 372,\n          \"y\": 540\n        },\n        \"comment\": \"randomisable?\",\n        \"subPatch\": \"9gje7g4cl\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Gradient\",\n          \"value\": \"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.4856957443999317,\\\"g\\\":0.4538464326727669,\\\"b\\\":0.4552224264202285},{\\\"pos\\\":0.05859375,\\\"posy\\\":0.5,\\\"r\\\":0.8452882584005907,\\\"g\\\":0.09763642590290811,\\\"b\\\":0.5571639902051404},{\\\"pos\\\":0.5,\\\"posy\\\":0.55,\\\"r\\\":0.12866672439299665,\\\"g\\\":0.8528177086265332,\\\"b\\\":0.1786908912997467},{\\\"pos\\\":0.8671875,\\\"posy\\\":0.58,\\\"r\\\":0.5364516371490868,\\\"g\\\":0.43154785529613493,\\\"b\\\":0.9122462340847404},{\\\"pos\\\":1,\\\"posy\\\":0.58,\\\"r\\\":0.26241943466581397,\\\"g\\\":0.21752841632900233,\\\"b\\\":0.8972728928521139}]}\"\n        },\n        {\n          \"name\": \"Direction index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"Direction\",\n          \"value\": \"X\"\n        },\n        {\n          \"name\": \"Smoothstep\",\n          \"value\": true\n        },\n        {\n          \"name\": \"Step\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Flip\",\n          \"value\": true\n        },\n        {\n          \"name\": \"sRGB\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Oklab\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Size\",\n          \"value\": 40\n        },\n        {\n          \"name\": \"filter index\",\n          \"value\": 1\n        },\n        {\n          \"name\": \"filter\",\n          \"value\": \"nearest\"\n        },\n        {\n          \"name\": \"wrap index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"wrap\",\n          \"value\": \"clamp to edge\"\n        },\n        {\n          \"name\": \"Gradient Array\",\n          \"value\": 0\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Texture\",\n          \"links\": [\n            {\n              \"portIn\": \"texture2\",\n              \"portOut\": \"Texture\",\n              \"objIn\": \"1zulf8gsn\",\n              \"objOut\": \"x6p9i0qo1\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"c4e4e933-136e-479e-8de8-0b35b75d9217\",\n      \"id\": \"9satyuqpg\",\n      \"uiAttribs\": {\n        \"subPatch\": \"9gje7g4cl\",\n        \"translate\": {\n          \"x\": 312,\n          \"y\": 380\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"innerOut_5l0ul3gca\",\n          \"title\": \"exec\",\n          \"links\": [\n            {\n              \"portIn\": \"exec\",\n              \"portOut\": \"innerOut_5l0ul3gca\",\n              \"objIn\": \"1zulf8gsn\",\n              \"objOut\": \"9satyuqpg\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_5jmbfmc3k\",\n          \"title\": \"num\",\n          \"links\": [\n            {\n              \"portIn\": \"num\",\n              \"portOut\": \"innerOut_5jmbfmc3k\",\n              \"objIn\": \"1zulf8gsn\",\n              \"objOut\": \"9satyuqpg\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"02d45073-7936-4830-81ad-59a162febf1f\",\n      \"id\": \"h01k0w5m5\",\n      \"uiAttribs\": {\n        \"subPatch\": \"9gje7g4cl\",\n        \"translate\": {\n          \"x\": 312,\n          \"y\": 700\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"innerIn_9yuykm3cr\",\n          \"title\": \"texture\"\n        }\n      ]\n    }\n  ]\n}",};
const port_5l0ul3gca=op.inTrigger("5l0ul3gca");
port_5l0ul3gca.setUiAttribs({title:"exec",});

const port_5jmbfmc3k=op.inFloat("5jmbfmc3k",0);
port_5jmbfmc3k.setUiAttribs({title:"num",});

const port_9yuykm3cr=op.outObject("9yuykm3cr");
port_9yuykm3cr.setUiAttribs({title:"texture",});

const port_qnty937qo=op.outTrigger("qnty937qo");
port_qnty937qo.setUiAttribs({title:"Next",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_5l0ul3gca = addedOps[i].outTrigger("innerOut_5l0ul3gca");
innerOut_5l0ul3gca.setUiAttribs({title:"exec"});
port_5l0ul3gca.onTriggered = () => { innerOut_5l0ul3gca.trigger(); };

const innerOut_5jmbfmc3k = addedOps[i].outNumber("innerOut_5jmbfmc3k");
innerOut_5jmbfmc3k.set(port_5jmbfmc3k.get() );
innerOut_5jmbfmc3k.setUiAttribs({title:"num"});
port_5jmbfmc3k.on("change", (a,v) => { innerOut_5jmbfmc3k.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_9yuykm3cr = addedOps[i].inObject("innerIn_9yuykm3cr");
innerIn_9yuykm3cr.setUiAttribs({title:"texture"});
innerIn_9yuykm3cr.on("change", (a,v) => { port_9yuykm3cr.setRef(a); });

const innerIn_qnty937qo = addedOps[i].inTrigger("innerIn_qnty937qo");
innerIn_qnty937qo.setUiAttribs({title:"Next"});
innerIn_qnty937qo.onTriggered = () => { port_qnty937qo.trigger(); };

}
}
};
const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
    if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
    op.patch.emitEvent("subpatchExpose", patchId);
    op.setStorage({ "blueprintVer": 2 });
    op.patch.emitEvent("subpatchExpose", patchId);
}


};

Ops.Patch.PL3eri4.GradientSwitching_WfT5140.prototype = new CABLES.Op();
CABLES.OPS["eeb15e15-d199-4825-a0db-a474b6f050c8"]={f:Ops.Patch.PL3eri4.GradientSwitching_WfT5140,objName:"Ops.Patch.PL3eri4.GradientSwitching_WfT5140"};




// **************************************************************
// 
// Ops.Patch.PL3eri4.TrackAndHoldPickedID
// 
// **************************************************************

Ops.Patch.PL3eri4.TrackAndHoldPickedID = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_yimtxlm5q=op.outNumber(\"yimtxlm5q\");\nport_yimtxlm5q.setUiAttribs({title:\"LastValue\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_yimtxlm5q = addedOps[i].inFloat(\"innerIn_yimtxlm5q\");\ninnerIn_yimtxlm5q.setUiAttribs({title:\"LastValue\"});\ninnerIn_yimtxlm5q.on(\"change\", (a,v) => { port_yimtxlm5q.set(a); });\n\n}\n}\n};\n","ports_json":"{\n    \"ports\": [\n        {\n            \"id\": \"yimtxlm5q\",\n            \"title\": \"LastValue\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1000\n        }\n    ]\n}","subpatch_json":"{\n  \"ops\": [\n    {\n      \"opId\": \"421f5b52-c0fa-47c4-8b7a-012b9e1c864a\",\n      \"id\": \"vn6dt0xtq\",\n      \"uiAttribs\": {\n        \"title\": \"var get\",\n        \"translate\": {\n          \"x\": 612,\n          \"y\": 1340\n        },\n        \"subPatch\": \"tks2l2w7a\",\n        \"extendTitle\": \"#param_pickedID\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Variable\",\n          \"value\": \"param_pickedID\"\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Value\",\n          \"links\": [\n            {\n              \"portIn\": \"Value\",\n              \"portOut\": \"Value\",\n              \"objIn\": \"5pm2qn9qv\",\n              \"objOut\": \"vn6dt0xtq\"\n            },\n            {\n              \"portIn\": \"number1\",\n              \"portOut\": \"Value\",\n              \"objIn\": \"zqlujir98\",\n              \"objOut\": \"vn6dt0xtq\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"dd4ac797-c309-42d1-b3c0-b62564bc6885\",\n      \"id\": \"5pm2qn9qv\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 612,\n          \"y\": 1440\n        },\n        \"extendTitlePort\": \"LastValue\",\n        \"subPatch\": \"tks2l2w7a\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"LastValue\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_yimtxlm5q\",\n              \"portOut\": \"LastValue\",\n              \"objIn\": \"h5ngs616d\",\n              \"objOut\": \"5pm2qn9qv\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"04fd113f-ade1-43fb-99fa-f8825f8814c0\",\n      \"id\": \"zqlujir98\",\n      \"uiAttribs\": {\n        \"title\": \"<\",\n        \"translate\": {\n          \"x\": 660,\n          \"y\": 1380\n        },\n        \"subPatch\": \"tks2l2w7a\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"number2\",\n          \"value\": 1\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"result\",\n          \"links\": [\n            {\n              \"portIn\": \"Track\",\n              \"portOut\": \"result\",\n              \"objIn\": \"5pm2qn9qv\",\n              \"objOut\": \"zqlujir98\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"c4e4e933-136e-479e-8de8-0b35b75d9217\",\n      \"id\": \"1knv1ldad\",\n      \"uiAttribs\": {\n        \"subPatch\": \"tks2l2w7a\",\n        \"translate\": {\n          \"x\": 612,\n          \"y\": 1260\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {}\n    },\n    {\n      \"opId\": \"02d45073-7936-4830-81ad-59a162febf1f\",\n      \"id\": \"h5ngs616d\",\n      \"uiAttribs\": {\n        \"subPatch\": \"tks2l2w7a\",\n        \"translate\": {\n          \"x\": 612,\n          \"y\": 1520\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"innerIn_yimtxlm5q\",\n          \"title\": \"LastValue\"\n        }\n      ]\n    }\n  ]\n}",};
const port_yimtxlm5q=op.outNumber("yimtxlm5q");
port_yimtxlm5q.setUiAttribs({title:"LastValue",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
    }
if(addedOps[i].innerOutput)
{
const innerIn_yimtxlm5q = addedOps[i].inFloat("innerIn_yimtxlm5q");
innerIn_yimtxlm5q.setUiAttribs({title:"LastValue"});
innerIn_yimtxlm5q.on("change", (a,v) => { port_yimtxlm5q.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
    if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
    op.patch.emitEvent("subpatchExpose", patchId);
    op.setStorage({ "blueprintVer": 2 });
    op.patch.emitEvent("subpatchExpose", patchId);
}


};

Ops.Patch.PL3eri4.TrackAndHoldPickedID.prototype = new CABLES.Op();
CABLES.OPS["a3fb0d17-cb20-4e29-b7c0-b6cf4e0a71c2"]={f:Ops.Patch.PL3eri4.TrackAndHoldPickedID,objName:"Ops.Patch.PL3eri4.TrackAndHoldPickedID"};




// **************************************************************
// 
// Ops.User.cristianvogel.SmoothPair
// 
// **************************************************************

Ops.User.cristianvogel.SmoothPair = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_rgd42fpcf=op.inTrigger(\"rgd42fpcf\");\nport_rgd42fpcf.setUiAttribs({title:\"Update\",});\n\nconst port_56c02rlis=op.inFloat(\"56c02rlis\",0);\nport_56c02rlis.setUiAttribs({title:\"Value1\",});\n\nconst port_i89yopnbc=op.inFloat(\"i89yopnbc\",0);\nport_i89yopnbc.setUiAttribs({title:\"Value2\",});\n\nconst port_mla1yespc=op.inFloat(\"mla1yespc\",10);\nport_mla1yespc.setUiAttribs({title:\"Inc/Dec factor\",});\n\nconst port_u44puxd40=op.outTrigger(\"u44puxd40\");\nport_u44puxd40.setUiAttribs({title:\"Next\",});\n\nconst port_i56nc891p=op.outNumber(\"i56nc891p\");\nport_i56nc891p.setUiAttribs({title:\"Result1\",});\n\nconst port_w6t2jhm75=op.outNumber(\"w6t2jhm75\");\nport_w6t2jhm75.setUiAttribs({title:\"Result2\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_rgd42fpcf = addedOps[i].outTrigger(\"innerOut_rgd42fpcf\");\ninnerOut_rgd42fpcf.setUiAttribs({title:\"Update\"});\nport_rgd42fpcf.onTriggered = () => { innerOut_rgd42fpcf.trigger(); };\n\nconst innerOut_56c02rlis = addedOps[i].outNumber(\"innerOut_56c02rlis\");\ninnerOut_56c02rlis.set(port_56c02rlis.get() );\ninnerOut_56c02rlis.setUiAttribs({title:\"Value1\"});\nport_56c02rlis.on(\"change\", (a,v) => { innerOut_56c02rlis.set(a); });\n\nconst innerOut_i89yopnbc = addedOps[i].outNumber(\"innerOut_i89yopnbc\");\ninnerOut_i89yopnbc.set(port_i89yopnbc.get() );\ninnerOut_i89yopnbc.setUiAttribs({title:\"Value2\"});\nport_i89yopnbc.on(\"change\", (a,v) => { innerOut_i89yopnbc.set(a); });\n\nconst innerOut_mla1yespc = addedOps[i].outNumber(\"innerOut_mla1yespc\");\ninnerOut_mla1yespc.set(port_mla1yespc.get() );\ninnerOut_mla1yespc.setUiAttribs({title:\"Inc/Dec factor\"});\nport_mla1yespc.on(\"change\", (a,v) => { innerOut_mla1yespc.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_u44puxd40 = addedOps[i].inTrigger(\"innerIn_u44puxd40\");\ninnerIn_u44puxd40.setUiAttribs({title:\"Next\"});\ninnerIn_u44puxd40.onTriggered = () => { port_u44puxd40.trigger(); };\n\nconst innerIn_i56nc891p = addedOps[i].inFloat(\"innerIn_i56nc891p\");\ninnerIn_i56nc891p.setUiAttribs({title:\"Result1\"});\ninnerIn_i56nc891p.on(\"change\", (a,v) => { port_i56nc891p.set(a); });\n\nconst innerIn_w6t2jhm75 = addedOps[i].inFloat(\"innerIn_w6t2jhm75\");\ninnerIn_w6t2jhm75.setUiAttribs({title:\"Result2\"});\ninnerIn_w6t2jhm75.on(\"change\", (a,v) => { port_w6t2jhm75.set(a); });\n\n}\n}\n};\n","ports_json":"{\n    \"ports\": [\n        {\n            \"id\": \"rgd42fpcf\",\n            \"title\": \"Update\",\n            \"dir\": 0,\n            \"type\": 1,\n            \"order\": 0\n        },\n        {\n            \"id\": \"56c02rlis\",\n            \"title\": \"Value1\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1\n        },\n        {\n            \"id\": \"i89yopnbc\",\n            \"title\": \"Value2\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 2\n        },\n        {\n            \"id\": \"mla1yespc\",\n            \"title\": \"Inc/Dec factor\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 10,\n            \"order\": 3\n        },\n        {\n            \"id\": \"u44puxd40\",\n            \"title\": \"Next\",\n            \"dir\": 1,\n            \"type\": 1,\n            \"order\": 1004\n        },\n        {\n            \"id\": \"i56nc891p\",\n            \"title\": \"Result1\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1005\n        },\n        {\n            \"id\": \"w6t2jhm75\",\n            \"title\": \"Result2\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1006\n        }\n    ]\n}","subpatch_json":"{\n  \"ops\": [\n    {\n      \"opId\": \"5677b5b5-753a-4fbf-9e91-64c81ec68a2f\",\n      \"id\": \"dl3d9k1w3\",\n      \"uiAttribs\": {\n        \"subPatch\": \"vxa1c7coa\",\n        \"translate\": {\n          \"x\": 3336,\n          \"y\": -40\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Separate inc/dec\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Inc factor\",\n          \"title\": \"Inc/Dec factor\"\n        },\n        {\n          \"name\": \"Dec factor\",\n          \"value\": 4\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Result\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_i56nc891p\",\n              \"portOut\": \"Result\",\n              \"objIn\": \"4xeabjfla\",\n              \"objOut\": \"dl3d9k1w3\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"5677b5b5-753a-4fbf-9e91-64c81ec68a2f\",\n      \"id\": \"05t9tlqcu\",\n      \"uiAttribs\": {\n        \"subPatch\": \"vxa1c7coa\",\n        \"translate\": {\n          \"x\": 3432,\n          \"y\": -40\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Separate inc/dec\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Inc factor\",\n          \"title\": \"Inc/Dec factor\"\n        },\n        {\n          \"name\": \"Dec factor\",\n          \"value\": 4\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Result\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_w6t2jhm75\",\n              \"portOut\": \"Result\",\n              \"objIn\": \"4xeabjfla\",\n              \"objOut\": \"05t9tlqcu\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"c4e4e933-136e-479e-8de8-0b35b75d9217\",\n      \"id\": \"tc18ggard\",\n      \"uiAttribs\": {\n        \"subPatch\": \"vxa1c7coa\",\n        \"translate\": {\n          \"x\": 3336,\n          \"y\": -120\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"innerOut_rgd42fpcf\",\n          \"title\": \"Update\",\n          \"links\": [\n            {\n              \"portIn\": \"Update\",\n              \"portOut\": \"innerOut_rgd42fpcf\",\n              \"objIn\": \"05t9tlqcu\",\n              \"objOut\": \"tc18ggard\"\n            },\n            {\n              \"portIn\": \"Update\",\n              \"portOut\": \"innerOut_rgd42fpcf\",\n              \"objIn\": \"dl3d9k1w3\",\n              \"objOut\": \"tc18ggard\"\n            },\n            {\n              \"portIn\": \"innerIn_u44puxd40\",\n              \"portOut\": \"innerOut_rgd42fpcf\",\n              \"objIn\": \"4xeabjfla\",\n              \"objOut\": \"tc18ggard\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_56c02rlis\",\n          \"title\": \"Value1\",\n          \"links\": [\n            {\n              \"portIn\": \"Value\",\n              \"portOut\": \"innerOut_56c02rlis\",\n              \"objIn\": \"dl3d9k1w3\",\n              \"objOut\": \"tc18ggard\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_i89yopnbc\",\n          \"title\": \"Value2\",\n          \"links\": [\n            {\n              \"portIn\": \"Value\",\n              \"portOut\": \"innerOut_i89yopnbc\",\n              \"objIn\": \"05t9tlqcu\",\n              \"objOut\": \"tc18ggard\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_mla1yespc\",\n          \"title\": \"Inc/Dec factor\",\n          \"links\": [\n            {\n              \"portIn\": \"Inc factor\",\n              \"portOut\": \"innerOut_mla1yespc\",\n              \"objIn\": \"05t9tlqcu\",\n              \"objOut\": \"tc18ggard\"\n            },\n            {\n              \"portIn\": \"Inc factor\",\n              \"portOut\": \"innerOut_mla1yespc\",\n              \"objIn\": \"dl3d9k1w3\",\n              \"objOut\": \"tc18ggard\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"02d45073-7936-4830-81ad-59a162febf1f\",\n      \"id\": \"4xeabjfla\",\n      \"uiAttribs\": {\n        \"subPatch\": \"vxa1c7coa\",\n        \"translate\": {\n          \"x\": 3336,\n          \"y\": 40\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"innerIn_u44puxd40\",\n          \"title\": \"Next\"\n        },\n        {\n          \"name\": \"innerIn_i56nc891p\",\n          \"title\": \"Result1\"\n        },\n        {\n          \"name\": \"innerIn_w6t2jhm75\",\n          \"title\": \"Result2\"\n        }\n      ]\n    }\n  ]\n}",};
const port_rgd42fpcf=op.inTrigger("rgd42fpcf");
port_rgd42fpcf.setUiAttribs({title:"Update",});

const port_56c02rlis=op.inFloat("56c02rlis",0);
port_56c02rlis.setUiAttribs({title:"Value1",});

const port_i89yopnbc=op.inFloat("i89yopnbc",0);
port_i89yopnbc.setUiAttribs({title:"Value2",});

const port_mla1yespc=op.inFloat("mla1yespc",10);
port_mla1yespc.setUiAttribs({title:"Inc/Dec factor",});

const port_u44puxd40=op.outTrigger("u44puxd40");
port_u44puxd40.setUiAttribs({title:"Next",});

const port_i56nc891p=op.outNumber("i56nc891p");
port_i56nc891p.setUiAttribs({title:"Result1",});

const port_w6t2jhm75=op.outNumber("w6t2jhm75");
port_w6t2jhm75.setUiAttribs({title:"Result2",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_rgd42fpcf = addedOps[i].outTrigger("innerOut_rgd42fpcf");
innerOut_rgd42fpcf.setUiAttribs({title:"Update"});
port_rgd42fpcf.onTriggered = () => { innerOut_rgd42fpcf.trigger(); };

const innerOut_56c02rlis = addedOps[i].outNumber("innerOut_56c02rlis");
innerOut_56c02rlis.set(port_56c02rlis.get() );
innerOut_56c02rlis.setUiAttribs({title:"Value1"});
port_56c02rlis.on("change", (a,v) => { innerOut_56c02rlis.set(a); });

const innerOut_i89yopnbc = addedOps[i].outNumber("innerOut_i89yopnbc");
innerOut_i89yopnbc.set(port_i89yopnbc.get() );
innerOut_i89yopnbc.setUiAttribs({title:"Value2"});
port_i89yopnbc.on("change", (a,v) => { innerOut_i89yopnbc.set(a); });

const innerOut_mla1yespc = addedOps[i].outNumber("innerOut_mla1yespc");
innerOut_mla1yespc.set(port_mla1yespc.get() );
innerOut_mla1yespc.setUiAttribs({title:"Inc/Dec factor"});
port_mla1yespc.on("change", (a,v) => { innerOut_mla1yespc.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_u44puxd40 = addedOps[i].inTrigger("innerIn_u44puxd40");
innerIn_u44puxd40.setUiAttribs({title:"Next"});
innerIn_u44puxd40.onTriggered = () => { port_u44puxd40.trigger(); };

const innerIn_i56nc891p = addedOps[i].inFloat("innerIn_i56nc891p");
innerIn_i56nc891p.setUiAttribs({title:"Result1"});
innerIn_i56nc891p.on("change", (a,v) => { port_i56nc891p.set(a); });

const innerIn_w6t2jhm75 = addedOps[i].inFloat("innerIn_w6t2jhm75");
innerIn_w6t2jhm75.setUiAttribs({title:"Result2"});
innerIn_w6t2jhm75.on("change", (a,v) => { port_w6t2jhm75.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
    if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
    op.patch.emitEvent("subpatchExpose", patchId);
    op.setStorage({ "blueprintVer": 2 });
    op.patch.emitEvent("subpatchExpose", patchId);
}


};

Ops.User.cristianvogel.SmoothPair.prototype = new CABLES.Op();
CABLES.OPS["69c42e4c-ba3e-4b81-a9a3-28dcf0b04e1f"]={f:Ops.User.cristianvogel.SmoothPair,objName:"Ops.User.cristianvogel.SmoothPair"};




// **************************************************************
// 
// Ops.Patch.PL3eri4.SubPatch0
// 
// **************************************************************

Ops.Patch.PL3eri4.SubPatch0 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_7xj1h37jx=op.outArray(\"7xj1h37jx\");\nport_7xj1h37jx.setUiAttribs({title:\"ArrayOut\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_7xj1h37jx = addedOps[i].inArray(\"innerIn_7xj1h37jx\");\ninnerIn_7xj1h37jx.setUiAttribs({title:\"ArrayOut\"});\ninnerIn_7xj1h37jx.on(\"change\", (a,v) => { port_7xj1h37jx.setRef(a); });\n\n}\n}\n};\n","ports_json":"{\"ports\":[{\"id\":\"7xj1h37jx\",\"title\":\"ArrayOut\",\"dir\":1,\"type\":3}]}","subpatch_json":"{\n  \"ops\": [\n    {\n      \"opId\": \"1a8c3535-6fce-4cba-8601-ddb7a5dd7656\",\n      \"id\": \"c96i9dg2a\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 3024,\n          \"y\": 920\n        },\n        \"comment\": \"..or test data\",\n        \"subPatch\": \"r1z9d8dk0\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null,\n        \"bookmarked\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Num\",\n          \"value\": 36\n        },\n        {\n          \"name\": \"Deviation\",\n          \"value\": 2.3\n        },\n        {\n          \"name\": \"Random Seed\",\n          \"value\": 1.48\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Array\",\n          \"links\": [\n            {\n              \"portIn\": \"Value\",\n              \"portOut\": \"Array\",\n              \"objIn\": \"4an6eh8uc\",\n              \"objOut\": \"c96i9dg2a\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"38f79614-b0de-4960-8da5-2827e7f43415\",\n      \"id\": \"wwvvg7a47\",\n      \"uiAttribs\": {\n        \"hasArea\": true,\n        \"comment_title\": \"state\",\n        \"translate\": {\n          \"x\": 3024,\n          \"y\": 840\n        },\n        \"area\": {\n          \"w\": 588,\n          \"h\": 500,\n          \"id\": \"aia6khfm3\"\n        },\n        \"color\": \"#F0D165\",\n        \"comment\": null,\n        \"bookmarked\": true,\n        \"subPatch\": \"r1z9d8dk0\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Title\",\n          \"value\": \"state\"\n        }\n      ]\n    },\n    {\n      \"opId\": \"e435d07b-8545-4469-befb-868510adcb76\",\n      \"id\": \"wkfmguqs8\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 3072,\n          \"y\": 1120\n        },\n        \"comment\": \"needs an offset of 1\\nfor this to work!\",\n        \"subPatch\": \"r1z9d8dk0\",\n        \"tempSubOldOpId\": null,\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Rotate amount\",\n          \"value\": 1\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"ArrayOut\",\n          \"links\": [\n            {\n              \"portIn\": \"Array In\",\n              \"portOut\": \"ArrayOut\",\n              \"objIn\": \"mge9n04m2\",\n              \"objOut\": \"wkfmguqs8\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"afa79294-aa9c-43bc-a49a-cade000a1de5\",\n      \"id\": \"mcg3t98h2\",\n      \"uiAttribs\": {\n        \"title\": \"var get\",\n        \"translate\": {\n          \"x\": 3180,\n          \"y\": 880\n        },\n        \"comment\": \"get from Svelte\\nstore\",\n        \"subPatch\": \"r1z9d8dk0\",\n        \"extendTitle\": \"#patch_NodeStateArray\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Variable\",\n          \"value\": \"patch_NodeStateArray\"\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Value\",\n          \"links\": [\n            {\n              \"portIn\": \"Array\",\n              \"portOut\": \"Value\",\n              \"objIn\": \"jdm56thiv\",\n              \"objOut\": \"mcg3t98h2\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"8088290f-45d4-4312-b4ca-184d34ca4667\",\n      \"id\": \"4an6eh8uc\",\n      \"uiAttribs\": {\n        \"title\": \"var set\",\n        \"translate\": {\n          \"x\": 3024,\n          \"y\": 980\n        },\n        \"subPatch\": \"r1z9d8dk0\",\n        \"extendTitle\": \"#patch_NodeStateArray\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Variable\",\n          \"value\": \"patch_NodeStateArray\"\n        }\n      ]\n    },\n    {\n      \"opId\": \"502083f2-8ade-4cb5-b1c5-e5b60eb3255f\",\n      \"id\": \"75xvr2gkt\",\n      \"uiAttribs\": {\n        \"extendTitle\": \">\",\n        \"translate\": {\n          \"x\": 3144,\n          \"y\": 1080\n        },\n        \"comment\": \"test data\",\n        \"subPatch\": \"r1z9d8dk0\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Comparison mode index\",\n          \"value\": 0\n        },\n        {\n          \"name\": \"Comparison mode\",\n          \"value\": \">\"\n        },\n        {\n          \"name\": \"Number for comparison\",\n          \"value\": 0.5\n        },\n        {\n          \"name\": \"value if true\",\n          \"value\": 4\n        },\n        {\n          \"name\": \"value if false\",\n          \"value\": 0.2\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Array result\",\n          \"links\": [\n            {\n              \"portIn\": \"Array in\",\n              \"portOut\": \"Array result\",\n              \"objIn\": \"wkfmguqs8\",\n              \"objOut\": \"75xvr2gkt\"\n            }\n          ]\n        },\n        {\n          \"name\": \"Array length\",\n          \"value\": 36\n        }\n      ]\n    },\n    {\n      \"opId\": \"e28a489c-46b6-4279-928c-6b0cbaaaae2a\",\n      \"id\": \"2wsskcnc3\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 3312,\n          \"y\": 1020\n        },\n        \"subPatch\": \"r1z9d8dk0\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"Array Out\",\n          \"links\": [\n            {\n              \"portIn\": \"array 0\",\n              \"portOut\": \"Array Out\",\n              \"objIn\": \"75xvr2gkt\",\n              \"objOut\": \"2wsskcnc3\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"bb55860d-a186-4e39-9542-8d21185e7e12\",\n      \"id\": \"jdm56thiv\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 3420,\n          \"y\": 920\n        },\n        \"subPatch\": \"r1z9d8dk0\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"Changed Trigger\",\n          \"links\": [\n            {\n              \"portIn\": \"Set\",\n              \"portOut\": \"Changed Trigger\",\n              \"objIn\": \"f9oaeegri\",\n              \"objOut\": \"jdm56thiv\"\n            }\n          ]\n        },\n        {\n          \"name\": \"New Array\",\n          \"links\": [\n            {\n              \"portIn\": \"Array in\",\n              \"portOut\": \"New Array\",\n              \"objIn\": \"2wsskcnc3\",\n              \"objOut\": \"jdm56thiv\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"9989b1c0-1073-4d5f-bfa0-36dd98b66e27\",\n      \"id\": \"f9oaeegri\",\n      \"uiAttribs\": {\n        \"translate\": {\n          \"x\": 3420,\n          \"y\": 980\n        },\n        \"subPatch\": \"r1z9d8dk0\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Number\",\n          \"value\": 1\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Out Value\",\n          \"links\": [\n            {\n              \"portIn\": \"Pass Through\",\n              \"portOut\": \"Out Value\",\n              \"objIn\": \"2wsskcnc3\",\n              \"objOut\": \"f9oaeegri\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"c4e4e933-136e-479e-8de8-0b35b75d9217\",\n      \"id\": \"cowyd3efx\",\n      \"uiAttribs\": {\n        \"subPatch\": \"r1z9d8dk0\",\n        \"translate\": {\n          \"x\": 3024,\n          \"y\": 800\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {}\n    },\n    {\n      \"opId\": \"02d45073-7936-4830-81ad-59a162febf1f\",\n      \"id\": \"sub4lu2xs\",\n      \"uiAttribs\": {\n        \"subPatch\": \"r1z9d8dk0\",\n        \"translate\": {\n          \"x\": 3024,\n          \"y\": 1300\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"innerIn_7xj1h37jx\",\n          \"title\": \"ArrayOut\"\n        }\n      ]\n    },\n    {\n      \"opId\": \"8fd2ed9b-02e5-4349-b7bc-6665ca240ffa\",\n      \"id\": \"mge9n04m2\",\n      \"uiAttribs\": {\n        \"subPatch\": \"r1z9d8dk0\",\n        \"translate\": {\n          \"x\": 3072,\n          \"y\": 1220\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Separate inc/dec\",\n          \"value\": false\n        },\n        {\n          \"name\": \"Inc factor\",\n          \"value\": 4,\n          \"title\": \"Inc/Dec factor\"\n        },\n        {\n          \"name\": \"Dec factor\",\n          \"value\": 4\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Array Out\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_7xj1h37jx\",\n              \"portOut\": \"Array Out\",\n              \"objIn\": \"sub4lu2xs\",\n              \"objOut\": \"mge9n04m2\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"0816c999-f2db-466b-9777-2814573574c5\",\n      \"id\": \"gohr7zi9o\",\n      \"uiAttribs\": {\n        \"title\": \">newMain\",\n        \"subPatch\": \"r1z9d8dk0\",\n        \"translate\": {\n          \"x\": 3024,\n          \"y\": 1040\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Named Trigger\",\n          \"value\": \"newMain\"\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Triggered\",\n          \"links\": [\n            {\n              \"portIn\": \"Execute\",\n              \"portOut\": \"Triggered\",\n              \"objIn\": \"mge9n04m2\",\n              \"objOut\": \"gohr7zi9o\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}",};
const port_7xj1h37jx=op.outArray("7xj1h37jx");
port_7xj1h37jx.setUiAttribs({title:"ArrayOut",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
    }
if(addedOps[i].innerOutput)
{
const innerIn_7xj1h37jx = addedOps[i].inArray("innerIn_7xj1h37jx");
innerIn_7xj1h37jx.setUiAttribs({title:"ArrayOut"});
innerIn_7xj1h37jx.on("change", (a,v) => { port_7xj1h37jx.setRef(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
    if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
    op.patch.emitEvent("subpatchExpose", patchId);
    op.setStorage({ "blueprintVer": 2 });
    op.patch.emitEvent("subpatchExpose", patchId);
}


};

Ops.Patch.PL3eri4.SubPatch0.prototype = new CABLES.Op();
CABLES.OPS["881aa868-164e-420b-8837-d526aad0e679"]={f:Ops.Patch.PL3eri4.SubPatch0,objName:"Ops.Patch.PL3eri4.SubPatch0"};




// **************************************************************
// 
// Ops.Patch.PL3eri4.SubPatch2
// 
// **************************************************************

Ops.Patch.PL3eri4.SubPatch2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_6ove2a7zx=op.outNumber(\"6ove2a7zx\");\nport_6ove2a7zx.setUiAttribs({title:\"X\",});\n\nconst port_zs6h90vhr=op.outNumber(\"zs6h90vhr\");\nport_zs6h90vhr.setUiAttribs({title:\"Y\",});\n\nconst port_icxd5s8my=op.outNumber(\"icxd5s8my\");\nport_icxd5s8my.setUiAttribs({title:\"Z\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_6ove2a7zx = addedOps[i].inFloat(\"innerIn_6ove2a7zx\");\ninnerIn_6ove2a7zx.setUiAttribs({title:\"X\"});\ninnerIn_6ove2a7zx.on(\"change\", (a,v) => { port_6ove2a7zx.set(a); });\n\nconst innerIn_zs6h90vhr = addedOps[i].inFloat(\"innerIn_zs6h90vhr\");\ninnerIn_zs6h90vhr.setUiAttribs({title:\"Y\"});\ninnerIn_zs6h90vhr.on(\"change\", (a,v) => { port_zs6h90vhr.set(a); });\n\nconst innerIn_icxd5s8my = addedOps[i].inFloat(\"innerIn_icxd5s8my\");\ninnerIn_icxd5s8my.setUiAttribs({title:\"Z\"});\ninnerIn_icxd5s8my.on(\"change\", (a,v) => { port_icxd5s8my.set(a); });\n\n}\n}\n};\n","ports_json":"{\n    \"ports\": [\n        {\n            \"id\": \"6ove2a7zx\",\n            \"title\": \"X\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1000\n        },\n        {\n            \"id\": \"zs6h90vhr\",\n            \"title\": \"Y\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1001\n        },\n        {\n            \"id\": \"icxd5s8my\",\n            \"title\": \"Z\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1002\n        }\n    ]\n}","subpatch_json":"{\n  \"ops\": [\n    {\n      \"opId\": \"421f5b52-c0fa-47c4-8b7a-012b9e1c864a\",\n      \"id\": \"ahbedt19c\",\n      \"uiAttribs\": {\n        \"title\": \"var get\",\n        \"translate\": {\n          \"x\": 3492,\n          \"y\": 320\n        },\n        \"color\": \"#5dc0fd\",\n        \"subPatch\": \"cx0344yun\",\n        \"extendTitle\": \"#ui_hitY\",\n        \"tempSubOldOpId\": \"xid18k4gz\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Variable\",\n          \"value\": \"ui_hitY\"\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Value\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_zs6h90vhr\",\n              \"portOut\": \"Value\",\n              \"objIn\": \"gr5gazx56\",\n              \"objOut\": \"ahbedt19c\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"421f5b52-c0fa-47c4-8b7a-012b9e1c864a\",\n      \"id\": \"sfsix9jui\",\n      \"uiAttribs\": {\n        \"title\": \"var get\",\n        \"translate\": {\n          \"x\": 3492,\n          \"y\": 360\n        },\n        \"color\": \"#db88ff\",\n        \"subPatch\": \"cx0344yun\",\n        \"extendTitle\": \"#ui_hitX\",\n        \"tempSubOldOpId\": \"trci8b3af\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Variable\",\n          \"value\": \"ui_hitX\"\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Value\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_6ove2a7zx\",\n              \"portOut\": \"Value\",\n              \"objIn\": \"gr5gazx56\",\n              \"objOut\": \"sfsix9jui\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"421f5b52-c0fa-47c4-8b7a-012b9e1c864a\",\n      \"id\": \"l4hk64j6y\",\n      \"uiAttribs\": {\n        \"title\": \"var get\",\n        \"translate\": {\n          \"x\": 3492,\n          \"y\": 280\n        },\n        \"color\": \"#07F78C\",\n        \"subPatch\": \"cx0344yun\",\n        \"extendTitle\": \"##ui_hitZ\",\n        \"tempSubOldOpId\": \"09d20wtmp\",\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"Variable\",\n          \"value\": \"#ui_hitZ\"\n        }\n      ],\n      \"portsOut\": [\n        {\n          \"name\": \"Value\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_icxd5s8my\",\n              \"portOut\": \"Value\",\n              \"objIn\": \"gr5gazx56\",\n              \"objOut\": \"l4hk64j6y\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"c4e4e933-136e-479e-8de8-0b35b75d9217\",\n      \"id\": \"qb4l32noj\",\n      \"uiAttribs\": {\n        \"subPatch\": \"cx0344yun\",\n        \"translate\": {\n          \"x\": 3492,\n          \"y\": 200\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {}\n    },\n    {\n      \"opId\": \"02d45073-7936-4830-81ad-59a162febf1f\",\n      \"id\": \"gr5gazx56\",\n      \"uiAttribs\": {\n        \"subPatch\": \"cx0344yun\",\n        \"translate\": {\n          \"x\": 3492,\n          \"y\": 440\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"innerIn_6ove2a7zx\",\n          \"title\": \"X\"\n        },\n        {\n          \"name\": \"innerIn_zs6h90vhr\",\n          \"title\": \"Y\"\n        },\n        {\n          \"name\": \"innerIn_icxd5s8my\",\n          \"title\": \"Z\"\n        }\n      ]\n    }\n  ]\n}",};
const port_6ove2a7zx=op.outNumber("6ove2a7zx");
port_6ove2a7zx.setUiAttribs({title:"X",});

const port_zs6h90vhr=op.outNumber("zs6h90vhr");
port_zs6h90vhr.setUiAttribs({title:"Y",});

const port_icxd5s8my=op.outNumber("icxd5s8my");
port_icxd5s8my.setUiAttribs({title:"Z",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
    }
if(addedOps[i].innerOutput)
{
const innerIn_6ove2a7zx = addedOps[i].inFloat("innerIn_6ove2a7zx");
innerIn_6ove2a7zx.setUiAttribs({title:"X"});
innerIn_6ove2a7zx.on("change", (a,v) => { port_6ove2a7zx.set(a); });

const innerIn_zs6h90vhr = addedOps[i].inFloat("innerIn_zs6h90vhr");
innerIn_zs6h90vhr.setUiAttribs({title:"Y"});
innerIn_zs6h90vhr.on("change", (a,v) => { port_zs6h90vhr.set(a); });

const innerIn_icxd5s8my = addedOps[i].inFloat("innerIn_icxd5s8my");
innerIn_icxd5s8my.setUiAttribs({title:"Z"});
innerIn_icxd5s8my.on("change", (a,v) => { port_icxd5s8my.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
    if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
    op.patch.emitEvent("subpatchExpose", patchId);
    op.setStorage({ "blueprintVer": 2 });
    op.patch.emitEvent("subpatchExpose", patchId);
}


};

Ops.Patch.PL3eri4.SubPatch2.prototype = new CABLES.Op();
CABLES.OPS["ca5e20be-81aa-4f52-9014-f84071c08844"]={f:Ops.Patch.PL3eri4.SubPatch2,objName:"Ops.Patch.PL3eri4.SubPatch2"};




// **************************************************************
// 
// Ops.User.cristianvogel.RGBHSBAdjust
// 
// **************************************************************

Ops.User.cristianvogel.RGBHSBAdjust = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_bv3dr3wey=op.inFloat(\"bv3dr3wey\",0.4745098054409027);\nport_bv3dr3wey.setUiAttribs({title:\"R\",display:\"range\",});\n\nconst port_5w3hfcu2f=op.inFloat(\"5w3hfcu2f\",0.7372549176216125);\nport_5w3hfcu2f.setUiAttribs({title:\"G\",display:\"range\",});\n\nconst port_ytx8sx5p6=op.inFloat(\"ytx8sx5p6\",0.5137255191802979);\nport_ytx8sx5p6.setUiAttribs({title:\"B\",display:\"range\",});\n\nconst port_iihqp1pix=op.inFloat(\"iihqp1pix\",0);\nport_iihqp1pix.setUiAttribs({title:\"adjust hue +\",});\n\nconst port_kp4wy4e6s=op.inFloat(\"kp4wy4e6s\",1);\nport_kp4wy4e6s.setUiAttribs({title:\"adjust sat *\",});\n\nconst port_yp58oixtq=op.inFloat(\"yp58oixtq\",1);\nport_yp58oixtq.setUiAttribs({title:\"adjust bright *\",});\n\nconst port_m3nphmb8k=op.outNumber(\"m3nphmb8k\");\nport_m3nphmb8k.setUiAttribs({title:\"R\",});\n\nconst port_cg08y1buw=op.outNumber(\"cg08y1buw\");\nport_cg08y1buw.setUiAttribs({title:\"G\",});\n\nconst port_pmtcdzefz=op.outNumber(\"pmtcdzefz\");\nport_pmtcdzefz.setUiAttribs({title:\"B\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_bv3dr3wey = addedOps[i].outNumber(\"innerOut_bv3dr3wey\");\ninnerOut_bv3dr3wey.set(port_bv3dr3wey.get() );\ninnerOut_bv3dr3wey.setUiAttribs({title:\"R\"});\nport_bv3dr3wey.on(\"change\", (a,v) => { innerOut_bv3dr3wey.set(a); });\n\nconst innerOut_5w3hfcu2f = addedOps[i].outNumber(\"innerOut_5w3hfcu2f\");\ninnerOut_5w3hfcu2f.set(port_5w3hfcu2f.get() );\ninnerOut_5w3hfcu2f.setUiAttribs({title:\"G\"});\nport_5w3hfcu2f.on(\"change\", (a,v) => { innerOut_5w3hfcu2f.set(a); });\n\nconst innerOut_ytx8sx5p6 = addedOps[i].outNumber(\"innerOut_ytx8sx5p6\");\ninnerOut_ytx8sx5p6.set(port_ytx8sx5p6.get() );\ninnerOut_ytx8sx5p6.setUiAttribs({title:\"B\"});\nport_ytx8sx5p6.on(\"change\", (a,v) => { innerOut_ytx8sx5p6.set(a); });\n\nconst innerOut_iihqp1pix = addedOps[i].outNumber(\"innerOut_iihqp1pix\");\ninnerOut_iihqp1pix.set(port_iihqp1pix.get() );\ninnerOut_iihqp1pix.setUiAttribs({title:\"adjust hue +\"});\nport_iihqp1pix.on(\"change\", (a,v) => { innerOut_iihqp1pix.set(a); });\n\nconst innerOut_kp4wy4e6s = addedOps[i].outNumber(\"innerOut_kp4wy4e6s\");\ninnerOut_kp4wy4e6s.set(port_kp4wy4e6s.get() );\ninnerOut_kp4wy4e6s.setUiAttribs({title:\"adjust sat *\"});\nport_kp4wy4e6s.on(\"change\", (a,v) => { innerOut_kp4wy4e6s.set(a); });\n\nconst innerOut_yp58oixtq = addedOps[i].outNumber(\"innerOut_yp58oixtq\");\ninnerOut_yp58oixtq.set(port_yp58oixtq.get() );\ninnerOut_yp58oixtq.setUiAttribs({title:\"adjust bright *\"});\nport_yp58oixtq.on(\"change\", (a,v) => { innerOut_yp58oixtq.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_m3nphmb8k = addedOps[i].inFloat(\"innerIn_m3nphmb8k\");\ninnerIn_m3nphmb8k.setUiAttribs({title:\"R\"});\ninnerIn_m3nphmb8k.on(\"change\", (a,v) => { port_m3nphmb8k.set(a); });\n\nconst innerIn_cg08y1buw = addedOps[i].inFloat(\"innerIn_cg08y1buw\");\ninnerIn_cg08y1buw.setUiAttribs({title:\"G\"});\ninnerIn_cg08y1buw.on(\"change\", (a,v) => { port_cg08y1buw.set(a); });\n\nconst innerIn_pmtcdzefz = addedOps[i].inFloat(\"innerIn_pmtcdzefz\");\ninnerIn_pmtcdzefz.setUiAttribs({title:\"B\"});\ninnerIn_pmtcdzefz.on(\"change\", (a,v) => { port_pmtcdzefz.set(a); });\n\n}\n}\n};\n","ports_json":"{\n    \"ports\": [\n        {\n            \"id\": \"bv3dr3wey\",\n            \"title\": \"R\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"uiDisplay\": \"range\",\n            \"value\": 0.4745098054409027,\n            \"order\": 0\n        },\n        {\n            \"id\": \"5w3hfcu2f\",\n            \"title\": \"G\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"uiDisplay\": \"range\",\n            \"value\": 0.7372549176216125,\n            \"order\": 1\n        },\n        {\n            \"id\": \"ytx8sx5p6\",\n            \"title\": \"B\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"uiDisplay\": \"range\",\n            \"value\": 0.5137255191802979,\n            \"order\": 2\n        },\n        {\n            \"id\": \"iihqp1pix\",\n            \"title\": \"adjust hue +\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 3\n        },\n        {\n            \"id\": \"kp4wy4e6s\",\n            \"title\": \"adjust sat *\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 1,\n            \"order\": 4\n        },\n        {\n            \"id\": \"yp58oixtq\",\n            \"title\": \"adjust bright *\",\n            \"dir\": 0,\n            \"type\": 0,\n            \"value\": 1,\n            \"order\": 5\n        },\n        {\n            \"id\": \"m3nphmb8k\",\n            \"title\": \"R\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1006\n        },\n        {\n            \"id\": \"cg08y1buw\",\n            \"title\": \"G\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1007\n        },\n        {\n            \"id\": \"pmtcdzefz\",\n            \"title\": \"B\",\n            \"dir\": 1,\n            \"type\": 0,\n            \"value\": 0,\n            \"order\": 1008\n        }\n    ]\n}","subpatch_json":"{\n  \"ops\": [\n    {\n      \"opId\": \"22dd3a12-79ff-49ce-abe6-d3b5a3b06ff3\",\n      \"id\": \"8pmozgqwm\",\n      \"uiAttribs\": {\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1536,\n          \"y\": 2140\n        },\n        \"tempSubOldOpId\": null,\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"Hue\",\n          \"links\": [\n            {\n              \"portIn\": \"number1\",\n              \"portOut\": \"Hue\",\n              \"objIn\": \"at23kn1qw\",\n              \"objOut\": \"8pmozgqwm\"\n            }\n          ]\n        },\n        {\n          \"name\": \"Saturation\",\n          \"links\": [\n            {\n              \"portIn\": \"number1\",\n              \"portOut\": \"Saturation\",\n              \"objIn\": \"4er8p1ur1\",\n              \"objOut\": \"8pmozgqwm\"\n            }\n          ]\n        },\n        {\n          \"name\": \"Brightness\",\n          \"links\": [\n            {\n              \"portIn\": \"number1\",\n              \"portOut\": \"Brightness\",\n              \"objIn\": \"nsmkcxoaq\",\n              \"objOut\": \"8pmozgqwm\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"909ee871-b0f3-477f-bee2-d0ab40bb5804\",\n      \"id\": \"7ktdxbhsg\",\n      \"uiAttribs\": {\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1536,\n          \"y\": 2240\n        },\n        \"tempSubOldOpId\": null,\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"R\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_m3nphmb8k\",\n              \"portOut\": \"R\",\n              \"objIn\": \"ujigv234v\",\n              \"objOut\": \"7ktdxbhsg\"\n            }\n          ]\n        },\n        {\n          \"name\": \"G\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_cg08y1buw\",\n              \"portOut\": \"G\",\n              \"objIn\": \"ujigv234v\",\n              \"objOut\": \"7ktdxbhsg\"\n            }\n          ]\n        },\n        {\n          \"name\": \"B\",\n          \"links\": [\n            {\n              \"portIn\": \"innerIn_pmtcdzefz\",\n              \"portOut\": \"B\",\n              \"objIn\": \"ujigv234v\",\n              \"objOut\": \"7ktdxbhsg\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"1bbdae06-fbb2-489b-9bcc-36c9d65bd441\",\n      \"id\": \"nsmkcxoaq\",\n      \"uiAttribs\": {\n        \"title\": \"*\",\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1620,\n          \"y\": 2200\n        },\n        \"extendTitlePort\": \"result\",\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"result\",\n          \"links\": [\n            {\n              \"portIn\": \"Brightness\",\n              \"portOut\": \"result\",\n              \"objIn\": \"7ktdxbhsg\",\n              \"objOut\": \"nsmkcxoaq\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"c4e4e933-136e-479e-8de8-0b35b75d9217\",\n      \"id\": \"5lraqelsv\",\n      \"uiAttribs\": {\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1464,\n          \"y\": 2060\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"innerOut_bv3dr3wey\",\n          \"title\": \"R\",\n          \"links\": [\n            {\n              \"portIn\": \"R\",\n              \"portOut\": \"innerOut_bv3dr3wey\",\n              \"objIn\": \"8pmozgqwm\",\n              \"objOut\": \"5lraqelsv\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_5w3hfcu2f\",\n          \"title\": \"G\",\n          \"links\": [\n            {\n              \"portIn\": \"G\",\n              \"portOut\": \"innerOut_5w3hfcu2f\",\n              \"objIn\": \"8pmozgqwm\",\n              \"objOut\": \"5lraqelsv\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_ytx8sx5p6\",\n          \"title\": \"B\",\n          \"links\": [\n            {\n              \"portIn\": \"B\",\n              \"portOut\": \"innerOut_ytx8sx5p6\",\n              \"objIn\": \"8pmozgqwm\",\n              \"objOut\": \"5lraqelsv\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_iihqp1pix\",\n          \"title\": \"number2\",\n          \"links\": [\n            {\n              \"portIn\": \"number2\",\n              \"portOut\": \"innerOut_iihqp1pix\",\n              \"objIn\": \"at23kn1qw\",\n              \"objOut\": \"5lraqelsv\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_kp4wy4e6s\",\n          \"title\": \"number2\",\n          \"links\": [\n            {\n              \"portIn\": \"number2\",\n              \"portOut\": \"innerOut_kp4wy4e6s\",\n              \"objIn\": \"4er8p1ur1\",\n              \"objOut\": \"5lraqelsv\"\n            }\n          ]\n        },\n        {\n          \"name\": \"innerOut_yp58oixtq\",\n          \"title\": \"number2\",\n          \"links\": [\n            {\n              \"portIn\": \"number2\",\n              \"portOut\": \"innerOut_yp58oixtq\",\n              \"objIn\": \"nsmkcxoaq\",\n              \"objOut\": \"5lraqelsv\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"02d45073-7936-4830-81ad-59a162febf1f\",\n      \"id\": \"ujigv234v\",\n      \"uiAttribs\": {\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1464,\n          \"y\": 2320\n        },\n        \"blueprintSubpatch2\": true,\n        \"tempSubOldOpId\": null\n      },\n      \"storage\": {},\n      \"portsIn\": [\n        {\n          \"name\": \"innerIn_m3nphmb8k\",\n          \"title\": \"R\"\n        },\n        {\n          \"name\": \"innerIn_cg08y1buw\",\n          \"title\": \"G\"\n        },\n        {\n          \"name\": \"innerIn_pmtcdzefz\",\n          \"title\": \"B\"\n        }\n      ]\n    },\n    {\n      \"opId\": \"c8fb181e-0b03-4b41-9e55-06b6267bc634\",\n      \"id\": \"at23kn1qw\",\n      \"uiAttribs\": {\n        \"title\": \"+\",\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1464,\n          \"y\": 2200\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"result\",\n          \"links\": [\n            {\n              \"portIn\": \"Hue\",\n              \"portOut\": \"result\",\n              \"objIn\": \"7ktdxbhsg\",\n              \"objOut\": \"at23kn1qw\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"opId\": \"1bbdae06-fbb2-489b-9bcc-36c9d65bd441\",\n      \"id\": \"4er8p1ur1\",\n      \"uiAttribs\": {\n        \"title\": \"*\",\n        \"subPatch\": \"y26qyrb2t\",\n        \"translate\": {\n          \"x\": 1536,\n          \"y\": 2200\n        },\n        \"blueprintSubpatch2\": true\n      },\n      \"storage\": {},\n      \"portsOut\": [\n        {\n          \"name\": \"result\",\n          \"links\": [\n            {\n              \"portIn\": \"Saturation\",\n              \"portOut\": \"result\",\n              \"objIn\": \"7ktdxbhsg\",\n              \"objOut\": \"4er8p1ur1\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}",};
const port_bv3dr3wey=op.inFloat("bv3dr3wey",0.4745098054409027);
port_bv3dr3wey.setUiAttribs({title:"R",display:"range",});

const port_5w3hfcu2f=op.inFloat("5w3hfcu2f",0.7372549176216125);
port_5w3hfcu2f.setUiAttribs({title:"G",display:"range",});

const port_ytx8sx5p6=op.inFloat("ytx8sx5p6",0.5137255191802979);
port_ytx8sx5p6.setUiAttribs({title:"B",display:"range",});

const port_iihqp1pix=op.inFloat("iihqp1pix",0);
port_iihqp1pix.setUiAttribs({title:"adjust hue +",});

const port_kp4wy4e6s=op.inFloat("kp4wy4e6s",1);
port_kp4wy4e6s.setUiAttribs({title:"adjust sat *",});

const port_yp58oixtq=op.inFloat("yp58oixtq",1);
port_yp58oixtq.setUiAttribs({title:"adjust bright *",});

const port_m3nphmb8k=op.outNumber("m3nphmb8k");
port_m3nphmb8k.setUiAttribs({title:"R",});

const port_cg08y1buw=op.outNumber("cg08y1buw");
port_cg08y1buw.setUiAttribs({title:"G",});

const port_pmtcdzefz=op.outNumber("pmtcdzefz");
port_pmtcdzefz.setUiAttribs({title:"B",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_bv3dr3wey = addedOps[i].outNumber("innerOut_bv3dr3wey");
innerOut_bv3dr3wey.set(port_bv3dr3wey.get() );
innerOut_bv3dr3wey.setUiAttribs({title:"R"});
port_bv3dr3wey.on("change", (a,v) => { innerOut_bv3dr3wey.set(a); });

const innerOut_5w3hfcu2f = addedOps[i].outNumber("innerOut_5w3hfcu2f");
innerOut_5w3hfcu2f.set(port_5w3hfcu2f.get() );
innerOut_5w3hfcu2f.setUiAttribs({title:"G"});
port_5w3hfcu2f.on("change", (a,v) => { innerOut_5w3hfcu2f.set(a); });

const innerOut_ytx8sx5p6 = addedOps[i].outNumber("innerOut_ytx8sx5p6");
innerOut_ytx8sx5p6.set(port_ytx8sx5p6.get() );
innerOut_ytx8sx5p6.setUiAttribs({title:"B"});
port_ytx8sx5p6.on("change", (a,v) => { innerOut_ytx8sx5p6.set(a); });

const innerOut_iihqp1pix = addedOps[i].outNumber("innerOut_iihqp1pix");
innerOut_iihqp1pix.set(port_iihqp1pix.get() );
innerOut_iihqp1pix.setUiAttribs({title:"adjust hue +"});
port_iihqp1pix.on("change", (a,v) => { innerOut_iihqp1pix.set(a); });

const innerOut_kp4wy4e6s = addedOps[i].outNumber("innerOut_kp4wy4e6s");
innerOut_kp4wy4e6s.set(port_kp4wy4e6s.get() );
innerOut_kp4wy4e6s.setUiAttribs({title:"adjust sat *"});
port_kp4wy4e6s.on("change", (a,v) => { innerOut_kp4wy4e6s.set(a); });

const innerOut_yp58oixtq = addedOps[i].outNumber("innerOut_yp58oixtq");
innerOut_yp58oixtq.set(port_yp58oixtq.get() );
innerOut_yp58oixtq.setUiAttribs({title:"adjust bright *"});
port_yp58oixtq.on("change", (a,v) => { innerOut_yp58oixtq.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_m3nphmb8k = addedOps[i].inFloat("innerIn_m3nphmb8k");
innerIn_m3nphmb8k.setUiAttribs({title:"R"});
innerIn_m3nphmb8k.on("change", (a,v) => { port_m3nphmb8k.set(a); });

const innerIn_cg08y1buw = addedOps[i].inFloat("innerIn_cg08y1buw");
innerIn_cg08y1buw.setUiAttribs({title:"G"});
innerIn_cg08y1buw.on("change", (a,v) => { port_cg08y1buw.set(a); });

const innerIn_pmtcdzefz = addedOps[i].inFloat("innerIn_pmtcdzefz");
innerIn_pmtcdzefz.setUiAttribs({title:"B"});
innerIn_pmtcdzefz.on("change", (a,v) => { port_pmtcdzefz.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
    if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
    op.patch.emitEvent("subpatchExpose", patchId);
    op.setStorage({ "blueprintVer": 2 });
    op.patch.emitEvent("subpatchExpose", patchId);
}


};

Ops.User.cristianvogel.RGBHSBAdjust.prototype = new CABLES.Op();
CABLES.OPS["4c8fd236-53fa-4c3b-8f03-45d15e752625"]={f:Ops.User.cristianvogel.RGBHSBAdjust,objName:"Ops.User.cristianvogel.RGBHSBAdjust"};




// **************************************************************
// 
// Ops.Gl.GradientTexture
// 
// **************************************************************

Ops.Gl.GradientTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const inGrad = op.inGradient("Gradient"),
    inDir = op.inValueSelect("Direction", ["X", "Y", "Radial"], "X"),
    inSmoothstep = op.inValueBool("Smoothstep", false),
    inStep = op.inBool("Step", false),
    inFlip = op.inBool("Flip", false),
    inSRGB = op.inBool("sRGB", false),
    inOklab = op.inBool("Oklab", false),
    inSize = op.inValueInt("Size", 256),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),
    inGradArray = op.inArray("Gradient Array"),
    inRandom = op.inTriggerButton("Randomize Colors"),
    outTex = op.outTexture("Texture"),
    outColors = op.outArray("Colors", null, 3),
    outColorPos = op.outArray("Colors Pos", null, 1);

const cgl = op.patch.cgl;

inGrad.setUiAttribs({ "editShortcut": true });

twrap.onChange =
    tfilter.onChange =
    inStep.onChange =
    inFlip.onChange =
    inSRGB.onChange =
    inOklab.onChange =
    inSize.onChange = inGrad.onChange = inSmoothstep.onChange = inDir.onChange = inGradArray.onChange = update;

inGrad.set("{\"keys\" : [{\"pos\":0,\"r\":0,\"g\":0,\"b\":0},{\"pos\":1,\"r\":1,\"g\":1,\"b\":1}]}");

op.onLoaded = update;

inRandom.onTriggered = () =>
{
    const keys = parseKeys();
    if (keys)
    {
        keys.forEach((key) =>
        {
            key.r = Math.random();
            key.g = Math.random();
            key.b = Math.random();
        });
        const newKeys = JSON.stringify({ "keys": keys });
        inGrad.set(newKeys);
    }
};

function rgbToOklab(r, g, b)
{
    let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    l = Math.cbrt(l); m = Math.cbrt(m); s = Math.cbrt(s);
    return [
        l * +0.2104542553 + m * +0.7936177850 + s * -0.0040720468,
        l * +1.9779984951 + m * -2.4285922050 + s * +0.4505937099,
        l * +0.0259040371 + m * +0.7827717662 + s * -0.8086757660
    ];
}

function oklabToRGB(L, a, b)
{
    let l = L + a * +0.3963377774 + b * +0.2158037573;
    let m = L + a * -0.1055613458 + b * -0.0638541728;
    let s = L + a * -0.0894841775 + b * -1.2914855480;
    l **= 3; m **= 3; s **= 3;
    let rgb_r = l * +4.0767416621 + m * -3.3077115913 + s * +0.2309699292;
    let rgb_g = l * -1.2684380046 + m * +2.6097574011 + s * -0.3413193965;
    let rgb_b = l * -0.0041960863 + m * -0.7034186147 + s * +1.7076147010;
    rgb_r = CABLES.clamp(rgb_r, 0, 1); rgb_g = CABLES.clamp(rgb_g, 0, 1); rgb_b = CABLES.clamp(rgb_b, 0, 1);
    return [rgb_r, rgb_g, rgb_b];
}

function lin2srgb(r, g, b)
{
    r /= 255;
    const thr = 0.0031308;
    let c_loR = 12.92 * r;
    let c_hiR = 1.055 * Math.pow(r, 0.41666) - 0.055;
    return ((r < thr) ? c_loR : c_hiR) * 255;
}

function update()
{
    const keys = parseKeys();
    if (keys) updateGradient(keys);
}

function parseKeys()
{
    let keys = null;
    op.setUiError("nodata", null);
    op.setUiError("parse", null);

    if (Array.isArray(inGradArray.get()))
    {
        keys = inGradArray.get();
    }
    else
    {
        let grad = null;
        if (!inGrad.get() || inGrad.get() === "")
        {
            op.setUiError("nodata", "gradient no data");
            return null;
        }

        try
        {
            grad = JSON.parse(inGrad.get());
        }
        catch (e)
        {
            op.setUiError("parse", "could not parse gradient data");
        }

        if (!grad || !grad.keys)
        {
            op.setUiError("nodata", "gradient no data");
            return null;
        }
        keys = grad.keys;
    }
    return keys;
}

function updateGradient(keys)
{
    let width = Math.round(inSize.get());
    if (width < 4) width = 4;

    inGrad.setUiAttribs(
        {
            "editShortcut": true,
            "gradEditSmoothstep": inSmoothstep.get(),
            "gradEditStep": inStep.get(),
            "gradOklab": inOklab.get(),

        });

    let selectedWrap = 0;
    let selectedFilter = 0;
    if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
    else if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (twrap.get() == "clamp to edge") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    if (tfilter.get() == "nearest") selectedFilter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") selectedFilter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") selectedFilter = CGL.Texture.FILTER_MIPMAP;

    const tex = new CGL.Texture(cgl);

    if (inDir.get() == "X" || inDir.get() == "Y")
    {
        const pixels = new Uint8Array(width * 4);

        for (let i = 0; i < keys.length - 1; i++)
        {
            const keyA = keys[i];
            const keyB = keys[i + 1];

            for (let x = keyA.pos * width; x < keyB.pos * width; x++)
            {
                let p = CABLES.map(x, keyA.pos * width, keyB.pos * width, 0, 1);
                if (inStep.get())p = Math.round(p);
                if (inSmoothstep.get()) p = CABLES.smoothStep(p);
                x = Math.round(x);

                let xx = x;
                if (inFlip.get())xx = width - x - 1;

                if (inOklab.get())
                {
                    const klabA = rgbToOklab(keyA.r, keyA.g, keyA.b);
                    const labA_r = klabA[0];
                    const labA_g = klabA[1];
                    const labA_b = klabA[2];

                    const klabB = rgbToOklab(keyB.r, keyB.g, keyB.b);
                    const labB_r = klabB[0];
                    const labB_g = klabB[1];
                    const labB_b = klabB[2];

                    const l = ((p * labB_r + (1.0 - p) * labA_r));
                    const a = ((p * labB_g + (1.0 - p) * labA_g));
                    const b = ((p * labB_b + (1.0 - p) * labA_b));

                    const pixCol = oklabToRGB(l, a, b);
                    pixels[xx * 4 + 0] = Math.round(pixCol[0] * 255);
                    pixels[xx * 4 + 1] = Math.round(pixCol[1] * 255);
                    pixels[xx * 4 + 2] = Math.round(pixCol[2] * 255);
                }
                else
                {
                    pixels[xx * 4 + 0] = Math.round((p * keyB.r + (1.0 - p) * keyA.r) * 255);
                    pixels[xx * 4 + 1] = Math.round((p * keyB.g + (1.0 - p) * keyA.g) * 255);
                    pixels[xx * 4 + 2] = Math.round((p * keyB.b + (1.0 - p) * keyA.b) * 255);
                }

                if (typeof keyA.a !== "undefined" && typeof keyB.a !== "undefined")
                {
                    const alpha = Math.round((p * keyB.a + (1.0 - p) * keyA.a) * 255);
                    pixels[xx * 4 + 3] = alpha;
                }
                else
                {
                    pixels[xx * 4 + 3] = Math.round(255);
                }
            }
        }

        if (inSRGB.get())
            for (let i = 0; i < pixels.length; i += 4)
            {
                pixels[i + 0] = lin2srgb(pixels[i + 0]);
                pixels[i + 1] = lin2srgb(pixels[i + 1]);
                pixels[i + 2] = lin2srgb(pixels[i + 2]);
            }

        if (inDir.get() == "X") tex.initFromData(pixels, width, 1, selectedFilter, selectedWrap);
        if (inDir.get() == "Y") tex.initFromData(pixels, 1, width, selectedFilter, selectedWrap);
    }

    if (inDir.get() == "Radial")
    {
        const pixels = new Uint8Array(width * width * 4);

        const animR = new CABLES.Anim();
        const animG = new CABLES.Anim();
        const animB = new CABLES.Anim();

        for (let i = 0; i < keys.length - 1; i++)
        {
            animR.setValue(keys[i].pos, keys[i].r);
            animG.setValue(keys[i].pos, keys[i].g);
            animB.setValue(keys[i].pos, keys[i].b);
        }

        for (let x = 0; x < width; x++)
        {
            for (let y = 0; y < width; y++)
            {
                const dx = x - (width - 1) / 2;
                const dy = y - (width - 1) / 2;
                let pos = Math.sqrt(dx * dx + dy * dy) / (width) * 2;

                if (inSmoothstep.get()) pos = CABLES.smoothStep(pos);

                pixels[(x * 4) + (y * 4 * width) + 0] = animR.getValue(pos) * 255;
                pixels[(x * 4) + (y * 4 * width) + 1] = animG.getValue(pos) * 255;
                pixels[(x * 4) + (y * 4 * width) + 2] = animB.getValue(pos) * 255;
                pixels[(x * 4) + (y * 4 * width) + 3] = Math.round(255);
            }
        }

        if (inSRGB.get())
            for (let i = 0; i < pixels.length; i += 4)
            {
                pixels[i + 0] = lin2srgb(pixels[i + 0]);
                pixels[i + 1] = lin2srgb(pixels[i + 1]);
                pixels[i + 2] = lin2srgb(pixels[i + 2]);
            }

        tex.initFromData(pixels, width, width, selectedFilter, selectedWrap);
    }

    const colorArr = [];
    for (let i = 0; i < keys.length - 1; i++)
    {
        colorArr.push(keys[i].r, keys[i].g, keys[i].b);
    }

    const colorPosArr = [];
    for (let i = 0; i < keys.length - 1; i++)
    {
        colorPosArr.push(keys[i].pos);
    }

    outColors.set(colorArr);
    outColorPos.set(colorPosArr);

    // outTex.set(null);
    outTex.setRef(tex);
}


};

Ops.Gl.GradientTexture.prototype = new CABLES.Op();
CABLES.OPS["01380a50-2dbb-4465-ae80-86349b0b717a"]={f:Ops.Gl.GradientTexture,objName:"Ops.Gl.GradientTexture"};




// **************************************************************
// 
// Ops.User.cristianvogel.SwitchTexturesShort_v2
// 
// **************************************************************

Ops.User.cristianvogel.SwitchTexturesShort_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exec = op.inTrigger("exec"),
    num = this.inValueInt("num"),
    defaultTransparent = op.inValueBool("Default Texture Transparent", true),
    next = op.outTrigger("Next"),
    textureOut = this.outTexture("texture");

const cgl = op.patch.cgl;
const texturePorts = [];
let index = 0;
let lastIndex = -1;
let tempTexture = CGL.Texture.getEmptyTexture(cgl);

op.toWorkPortsNeedToBeLinked(exec);
exec.onTriggered = function () { updateTexture(); next.trigger(); };

defaultTransparent.onChange = function ()
{
    if (defaultTransparent.get()) tempTexture = CGL.Texture.getEmptyTexture(cgl);
    else tempTexture = CGL.Texture.getTempTexture(cgl);

    updateTexture(true);
};

for (let i = 0; i < 3; i++)
{
    const tex = op.inTexture("texture" + i);
    texturePorts.push(tex);
    tex.onChange = forceUpdateTexture;
}

function forceUpdateTexture()
{
    updateTexture(true);
}

function updateTexture(force)
{
    index = parseInt(num.get(), 10);
    if (!force)
    {
        if (index == lastIndex) return;
        if (index != index) return;
    }
    if (
	    isNaN(index) ||
	    index < 0 ||
	    index > texturePorts.length - 1
    )
        index = 0;

    if (texturePorts[index].get()) textureOut.set(texturePorts[index].get());
    else textureOut.set(tempTexture);

    lastIndex = index;
}


};

Ops.User.cristianvogel.SwitchTexturesShort_v2.prototype = new CABLES.Op();
CABLES.OPS["e63cbdbe-0c03-4d3d-be9d-fafa8324ac53"]={f:Ops.User.cristianvogel.SwitchTexturesShort_v2,objName:"Ops.User.cristianvogel.SwitchTexturesShort_v2"};




// **************************************************************
// 
// Ops.Ui.SubPatchInput
// 
// **************************************************************

Ops.Ui.SubPatchInput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
op.innerInput = true;

const goto = op.inTriggerButton("Goto SubPatchOp");
goto.setUiAttribs({ "hidePort": true });
goto.onTriggered = () =>
{
    const parent = op.patch.getSubPatchOuterOp(op.uiAttribs.subPatch);
    gui.patchView.centerSelectOp(parent.id);
};


};

Ops.Ui.SubPatchInput.prototype = new CABLES.Op();
CABLES.OPS["c4e4e933-136e-479e-8de8-0b35b75d9217"]={f:Ops.Ui.SubPatchInput,objName:"Ops.Ui.SubPatchInput"};




// **************************************************************
// 
// Ops.Ui.SubPatchOutput
// 
// **************************************************************

Ops.Ui.SubPatchOutput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
op.innerOutput = true;


};

Ops.Ui.SubPatchOutput.prototype = new CABLES.Op();
CABLES.OPS["02d45073-7936-4830-81ad-59a162febf1f"]={f:Ops.Ui.SubPatchOutput,objName:"Ops.Ui.SubPatchOutput"};




// **************************************************************
// 
// Ops.Vars.VarGetNumber_v2
// 
// **************************************************************

Ops.Vars.VarGetNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outNumber("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "number", op.varName, val);


};

Ops.Vars.VarGetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["421f5b52-c0fa-47c4-8b7a-012b9e1c864a"]={f:Ops.Vars.VarGetNumber_v2,objName:"Ops.Vars.VarGetNumber_v2"};




// **************************************************************
// 
// Ops.User.cristianvogel.TrackAndHold
// 
// **************************************************************

Ops.User.cristianvogel.TrackAndHold = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
let valuePort = op.inValue("Value");
let trackPort = op.inBool("Track", true);
let lastValuePort = op.outNumber("LastValue");

let lastValue = null;

trackPort.onChange = trackAndHold;
valuePort.onChange = update;

function update()
{
    if (trackPort.get())
    {
        lastValue = valuePort.get();
        lastValuePort.set(lastValue);
    }
}

function trackAndHold()
{
    if (!trackPort.get() && lastValue !== null)
    {
        lastValuePort.set(lastValue);
    }
}


};

Ops.User.cristianvogel.TrackAndHold.prototype = new CABLES.Op();
CABLES.OPS["dd4ac797-c309-42d1-b3c0-b62564bc6885"]={f:Ops.User.cristianvogel.TrackAndHold,objName:"Ops.User.cristianvogel.TrackAndHold"};




// **************************************************************
// 
// Ops.Math.Compare.LessThan
// 
// **************************************************************

Ops.Math.Compare.LessThan = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const number1 = op.inValue("number1");
const number2 = op.inValue("number2");
const result = op.outBoolNum("result");

op.setTitle("<");

number1.onChange = exec;
number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() < number2.get());
}


};

Ops.Math.Compare.LessThan.prototype = new CABLES.Op();
CABLES.OPS["04fd113f-ade1-43fb-99fa-f8825f8814c0"]={f:Ops.Math.Compare.LessThan,objName:"Ops.Math.Compare.LessThan"};




// **************************************************************
// 
// Ops.Anim.Smooth
// 
// **************************************************************

Ops.Anim.Smooth = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exec = op.inTrigger("Update"),
    inMode = op.inBool("Separate inc/dec", false),
    inVal = op.inValue("Value"),
    next = op.outTrigger("Next"),
    inDivisorUp = op.inValue("Inc factor", 4),
    inDivisorDown = op.inValue("Dec factor", 4),
    result = op.outNumber("Result", 0);

let val = 0;
let goal = 0;
let oldVal = 0;
let lastTrigger = 0;

op.toWorkPortsNeedToBeLinked(exec);

let divisorUp;
let divisorDown;
let divisor = 4;
let finished = true;

let selectIndex = 0;
const MODE_SINGLE = 0;
const MODE_UP_DOWN = 1;

onFilterChange();
getDivisors();

inMode.setUiAttribs({ "hidePort": true });

inDivisorUp.onChange = inDivisorDown.onChange = getDivisors;
inMode.onChange = onFilterChange;
update();

function onFilterChange()
{
    const selectedMode = inMode.get();
    if (!selectedMode) selectIndex = MODE_SINGLE;
    else selectIndex = MODE_UP_DOWN;

    if (selectIndex == MODE_SINGLE)
    {
        inDivisorDown.setUiAttribs({ "greyout": true });
        inDivisorUp.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else if (selectIndex == MODE_UP_DOWN)
    {
        inDivisorDown.setUiAttribs({ "greyout": false });
        inDivisorUp.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    if (selectIndex == MODE_SINGLE)
    {
        divisorUp = inDivisorUp.get();
        divisorDown = inDivisorUp.get();
    }
    else if (selectIndex == MODE_UP_DOWN)
    {
        divisorUp = inDivisorUp.get();
        divisorDown = inDivisorDown.get();
    }

    if (divisorUp <= 0.2 || divisorUp != divisorUp)divisorUp = 0.2;
    if (divisorDown <= 0.2 || divisorDown != divisorDown)divisorDown = 0.2;
}

inVal.onChange = function ()
{
    finished = false;
    let oldGoal = goal;
    goal = inVal.get();
};

inDivisorUp.onChange = function ()
{
    getDivisors();
};

function update()
{
    let tm = 1;
    if (performance.now() - lastTrigger > 500 || lastTrigger === 0) val = inVal.get() || 0;
    else tm = (performance.now() - lastTrigger) / (performance.now() - lastTrigger);
    lastTrigger = performance.now();

    if (val != val)val = 0;

    if (divisor <= 0)divisor = 0.0001;

    const diff = goal - val;

    if (diff >= 0) val += (diff) / (divisorDown * tm);
    else val += (diff) / (divisorUp * tm);

    if (Math.abs(diff) < 0.00001)val = goal;

    if (divisor != divisor)val = 0;
    if (val != val || val == -Infinity || val == Infinity)val = inVal.get();

    if (oldVal != val)
    {
        result.set(val);
        oldVal = val;
    }

    if (val == goal && !finished)
    {
        finished = true;
        result.set(val);
    }

    next.trigger();
}

exec.onTriggered = function ()
{
    update();
};


};

Ops.Anim.Smooth.prototype = new CABLES.Op();
CABLES.OPS["5677b5b5-753a-4fbf-9e91-64c81ec68a2f"]={f:Ops.Anim.Smooth,objName:"Ops.Anim.Smooth"};




// **************************************************************
// 
// Ops.Math.GaussianRandomArray
// 
// **************************************************************

Ops.Math.GaussianRandomArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inNum = op.inValueInt("Num", 100),
    outArr = op.outArray("Array"),
    inDev = op.inValue("Deviation", 1),
    seed = op.inValueFloat("Random Seed");

let arr = [];
let stdDev = 1;
let previous = false;
let nextGaussian = null;
let y2;

seed.onChange = inDev.onChange = inNum.onChange = update;
update();

// from https://github.com/processing/p5.js/blob/master/src/math/random.js

function randomGaussian(mean, sd)
{
    let y1, x1, x2, w;
    if (previous)
    {
        y1 = y2;
        previous = false;
    }
    else
    {
        do
        {
            x1 = Math.seededRandom() * 2 - 1;
            x2 = Math.seededRandom() * 2 - 1;
            w = x1 * x1 + x2 * x2;
        } while (w >= 1);
        w = Math.sqrt((-2 * Math.log(w)) / w);
        y1 = x1 * w;
        y2 = x2 * w;
        previous = true;
    }

    let m = mean || 0;
    let s = sd || 1;
    return y1 * s + m;
}

function update()
{
    stdDev = inDev.get();
    Math.randomSeed = seed.get();

    arr.length = Math.floor(inNum.get()) || 0;
    for (let i = 0; i < arr.length; i++)
    {
        arr[i] = randomGaussian(0, stdDev);
    }

    outArr.set(null);
    outArr.set(arr);
}


};

Ops.Math.GaussianRandomArray.prototype = new CABLES.Op();
CABLES.OPS["1a8c3535-6fce-4cba-8601-ddb7a5dd7656"]={f:Ops.Math.GaussianRandomArray,objName:"Ops.Math.GaussianRandomArray"};




// **************************************************************
// 
// Ops.Ui.Area
// 
// **************************************************************

Ops.Ui.Area = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const inTitle = op.inString("Title", "");

inTitle.setUiAttribs({ "hidePort": true });

op.setUiAttrib({ "hasArea": true });

op.init =
    inTitle.onChange =
    op.onLoaded = update;

update();

function update()
{
    if (CABLES.UI)
    {
        gui.savedState.setUnSaved("areaOp");
        op.uiAttr(
            {
                "comment_title": inTitle.get() || " "
            });

        op.name = inTitle.get();
    }
}


};

Ops.Ui.Area.prototype = new CABLES.Op();
CABLES.OPS["38f79614-b0de-4960-8da5-2827e7f43415"]={f:Ops.Ui.Area,objName:"Ops.Ui.Area"};




// **************************************************************
// 
// Ops.Array.RotateArray
// 
// **************************************************************

Ops.Array.RotateArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const inArray = op.inArray("Array in");
const count = op.inValueInt("Rotate amount", 0);
const outArray = op.outArray("ArrayOut");

let newArr = [];
outArray.set(newArr);

count.onChange =
inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let rotateIndex = -count.get();

    newArr = rotate(inArray.get(), rotateIndex, 0);
    outArray.set(null);
    outArray.set(newArr);
};

// https://gist.github.com/aubergene/7ecfe624199e68f60258
function rotate(array, n, guard)
{
    let head, tail;
    n = (n === null) || guard ? 1 : n;
    n %= array.length;
    tail = array.slice(n) || [];

    if (!tail || !tail.concat) return [];

    head = array.slice(0, n) || [];
    return tail.concat(head);
}


};

Ops.Array.RotateArray.prototype = new CABLES.Op();
CABLES.OPS["e435d07b-8545-4469-befb-868510adcb76"]={f:Ops.Array.RotateArray,objName:"Ops.Array.RotateArray"};




// **************************************************************
// 
// Ops.Vars.VarGetArray_v2
// 
// **************************************************************

Ops.Vars.VarGetArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outArray("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "array", op.varName, val);


};

Ops.Vars.VarGetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["afa79294-aa9c-43bc-a49a-cade000a1de5"]={f:Ops.Vars.VarGetArray_v2,objName:"Ops.Vars.VarGetArray_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetArray_v2
// 
// **************************************************************

Ops.Vars.VarSetArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inArray("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "array", val, op.varName);


};

Ops.Vars.VarSetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["8088290f-45d4-4312-b4ca-184d34ca4667"]={f:Ops.Vars.VarSetArray_v2,objName:"Ops.Vars.VarSetArray_v2"};




// **************************************************************
// 
// Ops.Array.ArrayLogic
// 
// **************************************************************

Ops.Array.ArrayLogic = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// The user can  pick a
// logical comparison which will be applied to the array.
// if it evaulates to true then it outputs 1 else 0 or defined value
// pass mode (p) allows the value from array 0 through if the
// comparison evaulates to true else its the value assigned to if false

const inArray_0 = op.inArray("array 0"),
    mathSelect = op.inValueSelect("Comparison mode", [">", "<", ">=", "<=", "==", "!=",
        ">pass", "<pass", ">=pass", "<=pass", "==pass", "!=pass"], ">"),
    numberIn = op.inValueFloat("Number for comparison", 0.5),
    inValueIfTrue = op.inFloat("value if true", 1.0),
    inValueIfFalse = op.inFloat("value if false", 0.0),
    outArray = op.outArray("Array result"),
    outArrayLength = op.outNumber("Array length");

op.toWorkPortsNeedToBeLinked(inArray_0);

let logicFunc;
let showingError = false;

let mathArray = [];
let selectIndex = 0;

mathSelect.onChange = onFilterChange;

inArray_0.onChange = numberIn.onChange = inValueIfFalse.onChange =
inValueIfTrue.onChange = update;

onFilterChange();

function onFilterChange()
{
    let mathSelectValue = mathSelect.get();
    if (mathSelectValue === ">") logicFunc = function (val, comp, t, f) { if (val > comp) return t; return f; };
    else if (mathSelectValue === "<") logicFunc = function (val, comp, t, f) { if (val < comp) return t; return f; };
    else if (mathSelectValue === ">=") logicFunc = function (val, comp, t, f) { if (val >= comp) return t; return f; };
    else if (mathSelectValue === "<=") logicFunc = function (val, comp, t, f) { if (val <= comp) return t; return f; };
    else if (mathSelectValue === "==") logicFunc = function (val, comp, t, f) { if (val === comp) return t; return f; };
    else if (mathSelectValue === "!=") logicFunc = function (val, comp, t, f) { if (val !== comp) return t; return f; };
    else if (mathSelectValue === ">pass") logicFunc = function (val, comp, t, f) { if (val > comp) return val; return f; };
    else if (mathSelectValue === "<pass") logicFunc = function (val, comp, t, f) { if (val < comp) return val; return f; };
    else if (mathSelectValue === ">=pass") logicFunc = function (val, comp, t, f) { if (val >= comp) return val; return f; };
    else if (mathSelectValue === "<=pass") logicFunc = function (val, comp, t, f) { if (val <= comp) return val; return f; };
    else if (mathSelectValue === "==pass") logicFunc = function (val, comp, t, f) { if (val === comp) return val; return f; };
    else if (mathSelectValue === "!=pass") logicFunc = function (val, comp, t, f) { if (val !== comp) return val; return f; };
    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    let array0 = inArray_0.get();

    let mathNumberIn = numberIn.get();
    let valueFalse = inValueIfFalse.get();
    let valueTrue = inValueIfTrue.get();

    mathArray.length = 0;

    if (!array0)
    {
        outArray.set(null);
        outArrayLength.set(0);
        return;
    }

    mathArray.length = array0.length;

    let i = 0;

    for (i = 0; i < array0.length; i++)
    {
        mathArray[i] = logicFunc(array0[i], mathNumberIn, valueTrue, valueFalse);
    }

    outArray.setRef(mathArray);
    outArrayLength.set(mathArray.length);
}


};

Ops.Array.ArrayLogic.prototype = new CABLES.Op();
CABLES.OPS["502083f2-8ade-4cb5-b1c5-e5b60eb3255f"]={f:Ops.Array.ArrayLogic,objName:"Ops.Array.ArrayLogic"};




// **************************************************************
// 
// Ops.Array.GateArray_v2
// 
// **************************************************************

Ops.Array.GateArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    arrayIn = op.inArray("Array in"),
    passThrough = op.inValueBool("Pass Through", true),
    arrayOut = op.outArray("Array Out");

let oldArr = null;

function copyArray(source)
{
    if (!source) return null;
    const dest = [];
    dest.length = source.length;
    for (let i = 0; i < source.length; i++)
    {
        dest[i] = source[i];
    }
    return dest;
}

arrayIn.onChange = passThrough.onChange = function ()
{
    if (passThrough.get())
    {
        oldArr = copyArray(arrayIn.get());
        arrayOut.set(oldArr);
    }
    // else
    // {
    //     arrayOut.set(oldArr);
    // }
};


};

Ops.Array.GateArray_v2.prototype = new CABLES.Op();
CABLES.OPS["e28a489c-46b6-4279-928c-6b0cbaaaae2a"]={f:Ops.Array.GateArray_v2,objName:"Ops.Array.GateArray_v2"};




// **************************************************************
// 
// Ops.Array.ArrayChangedTrigger
// 
// **************************************************************

Ops.Array.ArrayChangedTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    next = op.outTrigger("Changed Trigger"),
    outArr = op.outArray("New Array");

inArr.onChange = function ()
{
    outArr.setRef(inArr.get());
    next.trigger();
};


};

Ops.Array.ArrayChangedTrigger.prototype = new CABLES.Op();
CABLES.OPS["bb55860d-a186-4e39-9542-8d21185e7e12"]={f:Ops.Array.ArrayChangedTrigger,objName:"Ops.Array.ArrayChangedTrigger"};




// **************************************************************
// 
// Ops.Trigger.TriggerNumber
// 
// **************************************************************

Ops.Trigger.TriggerNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    setValuePort = op.inTriggerButton("Set"),
    valuePort = op.inValueFloat("Number"),
    outNext = op.outTrigger("Next"),
    outValuePort = op.outNumber("Out Value");

outValuePort.changeAlways = true;

setValuePort.onTriggered = function ()
{
    outValuePort.set(valuePort.get());
    outNext.trigger();
};


};

Ops.Trigger.TriggerNumber.prototype = new CABLES.Op();
CABLES.OPS["9989b1c0-1073-4d5f-bfa0-36dd98b66e27"]={f:Ops.Trigger.TriggerNumber,objName:"Ops.Trigger.TriggerNumber"};




// **************************************************************
// 
// Ops.Array.SmoothArray
// 
// **************************************************************

Ops.Array.SmoothArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// look at http://sol.gfxile.net/interpolation/
const exec = op.inTrigger("Execute"),
    inArray = op.inArray("Array In"),
    inModeBool = op.inBool("Separate inc/dec", false),
    incFactor = op.inValue("Inc factor", 4),
    decFactor = op.inValue("Dec factor", 4),
    next = op.outTrigger("Next"),
    outArray = op.outArray("Array Out");

let goal = [];
let reset = false;
let lastTrigger = 0;

let newArr = [];
outArray.set(newArr);

let divisorUp;
let divisorDown;

let selectedMode = false;

onFilterChange();
getDivisors();
function onFilterChange()
{
    selectedMode = inModeBool.get();

    if (!selectedMode)
    {
        decFactor.setUiAttribs({ "greyout": true });
        incFactor.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else
    {
        decFactor.setUiAttribs({ "greyout": false });
        incFactor.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    divisorUp = incFactor.get();

    if (selectedMode == false) divisorDown = incFactor.get();
    else divisorDown = decFactor.get();

    if (divisorUp <= 0 || divisorUp != divisorUp)divisorUp = 0.0001;
    if (divisorDown <= 0 || divisorDown != divisorDown)divisorDown = 0.0001;
    if (divisorUp <= 1.0) divisorUp = 1.0;
    if (divisorDown <= 1.0) divisorDown = 1.0;
}

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    for (let i = 0; i < arr.length; i++)
    {
        goal[i] = arr[i] || 0;
    }
};

let oldVal = 0;

function update()
{
    let arr = inArray.get();
    if (!arr) return;

    if (newArr.length != arr.length)
    {
        newArr.length = arr.length || 0;
        reset = true;
    }

    let tm = 1;
    if (CABLES.now() - lastTrigger > 500 || lastTrigger === 0)reset = true;
    else tm = (CABLES.now() - lastTrigger) / 17;
    lastTrigger = CABLES.now();

    if (reset)
    {
        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = arr[i];
        }
        reset = false;
    }

    for (var i = 0; i < arr.length; i++)
    {
        let val = newArr[i];

        let diff = goal[i] - val;

        if (diff >= 0)
            val += (diff) / (divisorDown * tm);
        else
            val += (diff) / (divisorUp * tm);

        if (val > 0 && val < 0.000000001)val = 0;
        if (!val) val = 0;

        if (newArr[i] != val)
        {
            newArr[i] = val;
            oldVal = val;
        }
    }
    // outArray.set(null);
    outArray.setRef(newArr);

    next.trigger();
}

exec.onTriggered = function ()
{
    update();
};

incFactor.onChange = decFactor.onChange = getDivisors;
inModeBool.onChange = onFilterChange;
update();


};

Ops.Array.SmoothArray.prototype = new CABLES.Op();
CABLES.OPS["8fd2ed9b-02e5-4349-b7bc-6665ca240ffa"]={f:Ops.Array.SmoothArray,objName:"Ops.Array.SmoothArray"};




// **************************************************************
// 
// Ops.Trigger.TriggerReceive
// 
// **************************************************************

Ops.Trigger.TriggerReceive = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const next = op.outTrigger("Triggered");
op.varName = op.inValueSelect("Named Trigger", [], "", true);

updateVarNamesDropdown();
op.patch.addEventListener("namedTriggersChanged", updateVarNamesDropdown);

let oldName = null;

function doTrigger()
{
    next.trigger();
}

function updateVarNamesDropdown()
{
    if (CABLES.UI)
    {
        let varnames = [];
        let vars = op.patch.namedTriggers;
        // varnames.push('+ create new one');
        for (let i in vars) varnames.push(i);
        op.varName.uiAttribs.values = varnames;
    }
}

op.varName.onChange = function ()
{
    if (oldName)
    {
        let oldCbs = op.patch.namedTriggers[oldName];
        let a = oldCbs.indexOf(doTrigger);
        if (a != -1) oldCbs.splice(a, 1);
    }

    op.setTitle(">" + op.varName.get());
    op.patch.namedTriggers[op.varName.get()] = op.patch.namedTriggers[op.varName.get()] || [];
    let cbs = op.patch.namedTriggers[op.varName.get()];

    cbs.push(doTrigger);
    oldName = op.varName.get();
    updateError();
    op.patch.emitEvent("opTriggerNameChanged", op, op.varName.get());
};

op.on("uiParamPanel", updateError);

function updateError()
{
    if (!op.varName.get())
    {
        op.setUiError("unknowntrigger", "unknown trigger");
    }
    else op.setUiError("unknowntrigger", null);
}


};

Ops.Trigger.TriggerReceive.prototype = new CABLES.Op();
CABLES.OPS["0816c999-f2db-466b-9777-2814573574c5"]={f:Ops.Trigger.TriggerReceive,objName:"Ops.Trigger.TriggerReceive"};




// **************************************************************
// 
// Ops.Color.RGBtoHSB
// 
// **************************************************************

Ops.Color.RGBtoHSB = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inR = op.inValueSlider("R", 0),
    inG = op.inValueSlider("G", 0),
    inB = op.inValueSlider("B", 0),
    outH = op.outNumber("Hue"),
    outS = op.outNumber("Saturation"),
    outB = op.outNumber("Brightness");

inR.setUiAttribs({ "colorPick": true });
inR.onChange = inG.onChange = inB.onChange = update;

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 *
 * @param   Number  r       The red color value
 * @param   Number  g       The green color value
 * @param   Number  b       The blue color value
 * @return  Array           The HSV representation
 */

function update()
{
    let r = (inR.get());
    let g = (inG.get());
    let b = (inB.get());

    // public static float[] RGBtoHSB(var r, var g, var b, float[] hsbvals) {
    let hue, saturation, brightness;
    //   if (hsbvals == null) {
    //       hsbvals = [];
    //   }
    let cmax = (r > g) ? r : g;
    if (b > cmax) cmax = b;
    let cmin = (r < g) ? r : g;
    if (b < cmin) cmin = b;

    brightness = (cmax);
    if (cmax != 0)
        saturation = ((cmax - cmin)) / (cmax);
    else
        saturation = 0;
    if (saturation == 0)
        hue = 0;
    else
    {
        let redc = ((cmax - r)) / ((cmax - cmin));
        let greenc = ((cmax - g)) / ((cmax - cmin));
        let bluec = ((cmax - b)) / ((cmax - cmin));
        if (r == cmax)
            hue = bluec - greenc;
        else if (g == cmax)
            hue = 2.0 + redc - bluec;
        else
            hue = 4.0 + greenc - redc;
        hue /= 6.0;
        if (hue < 0)
            hue += 1.0;
    }

    //   hsbvals[0] = hue;
    //   hsbvals[1] = saturation;
    //   hsbvals[2] = brightness;
    //   return hsbvals;
    //   942       }
    // var max = Math.max(r, g, b), min = Math.min(r, g, b);
    // var h, s, v = max;

    // var d = max - min;
    // s = max == 0 ? 0 : d / max;

    // if (max == min) {
    //     h = 0; // achromatic
    // } else {
    //     switch (max) {
    //     case r: h = (g - b) / d + (g < b ? 6 : 0); break;
    //     case g: h = (b - r) / d + 2; break;
    //     case b: h = (r - g) / d + 4; break;
    //     }

    //     h /= 6;
    // }

    outH.set(hue);
    outS.set(saturation);
    outB.set(brightness / 2.0);
}

update();


};

Ops.Color.RGBtoHSB.prototype = new CABLES.Op();
CABLES.OPS["22dd3a12-79ff-49ce-abe6-d3b5a3b06ff3"]={f:Ops.Color.RGBtoHSB,objName:"Ops.Color.RGBtoHSB"};




// **************************************************************
// 
// Ops.Color.HSBtoRGB
// 
// **************************************************************

Ops.Color.HSBtoRGB = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inH = op.inValueSlider("Hue"),
    inS = op.inValueSlider("Saturation", 1),
    inV = op.inValueSlider("Brightness", 0.5),
    outR = op.outNumber("R"),
    outG = op.outNumber("G"),
    outB = op.outNumber("B");

inH.onChange = inS.onChange = inV.onChange = update;
update();

function update()
{
    let hue = (inH.get());
    let saturation = (inS.get());
    let lightness = (inV.get());

    // based on algorithm from http://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB

    let chroma = (1 - Math.abs((2 * lightness) - 1)) * saturation;
    let huePrime = hue * 6; // / 60;
    let secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));

    huePrime = Math.floor(huePrime) || 0;
    let red = 0;
    let green = 0;
    let blue = 0;

    if (huePrime === 0)
    {
        red = chroma;
        green = secondComponent;
        blue = 0;
    }
    else if (huePrime === 1)
    {
        red = secondComponent;
        green = chroma;
        blue = 0;
    }
    else if (huePrime === 2)
    {
        red = 0;
        green = chroma;
        blue = secondComponent;
    }
    else if (huePrime === 3)
    {
        red = 0;
        green = secondComponent;
        blue = chroma;
    }
    else if (huePrime === 4)
    {
        red = secondComponent;
        green = 0;
        blue = chroma;
    }
    else if (huePrime >= 5)
    {
        red = chroma;
        green = 0;
        blue = secondComponent;
    }
    let lightnessAdjustment = (lightness - (chroma / 2));
    red += lightnessAdjustment;
    green += lightnessAdjustment;
    blue += lightnessAdjustment;

    outR.set(red);
    outG.set(green);
    outB.set(blue);

    //   return [Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255)];
}


};

Ops.Color.HSBtoRGB.prototype = new CABLES.Op();
CABLES.OPS["909ee871-b0f3-477f-bee2-d0ab40bb5804"]={f:Ops.Color.HSBtoRGB,objName:"Ops.Color.HSBtoRGB"};




// **************************************************************
// 
// Ops.Math.Multiply
// 
// **************************************************************

Ops.Math.Multiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 1),
    result = op.outNumber("result");

op.setTitle("*");

number1.onChange = number2.onChange = update;
update();

function update()
{
    const n1 = number1.get();
    const n2 = number2.get();

    result.set(n1 * n2);
}


};

Ops.Math.Multiply.prototype = new CABLES.Op();
CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"]={f:Ops.Math.Multiply,objName:"Ops.Math.Multiply"};




// **************************************************************
// 
// Ops.Math.Sum
// 
// **************************************************************

Ops.Math.Sum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1", 0),
    number2 = op.inValueFloat("number2", 0),
    result = op.outNumber("result");

op.setTitle("+");

number1.onChange =
number2.onChange = exec;
exec();

function exec()
{
    const v = number1.get() + number2.get();
    if (!isNaN(v))
        result.set(v);
}


};

Ops.Math.Sum.prototype = new CABLES.Op();
CABLES.OPS["c8fb181e-0b03-4b41-9e55-06b6267bc634"]={f:Ops.Math.Sum,objName:"Ops.Math.Sum"};




// **************************************************************
// 
// Ops.Devices.Mouse.MouseButtons
// 
// **************************************************************

Ops.Devices.Mouse.MouseButtons = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    mouseClickLeft = op.outTrigger("Click Left"),
    mouseClickRight = op.outTrigger("Click Right"),
    mouseDoubleClick = op.outTrigger("Double Click"),
    mouseDownLeft = op.outBoolNum("Button pressed Left", false),
    mouseDownMiddle = op.outBoolNum("Button pressed Middle", false),
    mouseDownRight = op.outBoolNum("Button pressed Right", false),
    triggerMouseDownLeft = op.outTrigger("Mouse Down Left"),
    triggerMouseDownMiddle = op.outTrigger("Mouse Down Middle"),
    triggerMouseDownRight = op.outTrigger("Mouse Down Right"),
    triggerMouseUpLeft = op.outTrigger("Mouse Up Left"),
    triggerMouseUpMiddle = op.outTrigger("Mouse Up Middle"),
    triggerMouseUpRight = op.outTrigger("Mouse Up Right"),
    area = op.inValueSelect("Area", ["Canvas", "Document"], "Canvas"),
    active = op.inValueBool("Active", true);

const cgl = op.patch.cgl;
let listenerElement = null;
area.onChange = updateListeners;
op.onDelete = removeListeners;
updateListeners();

function onMouseDown(e)
{
    if (e.which == 1)
    {
        mouseDownLeft.set(true);
        triggerMouseDownLeft.trigger();
    }
    else if (e.which == 2)
    {
        mouseDownMiddle.set(true);
        triggerMouseDownMiddle.trigger();
    }
    else if (e.which == 3)
    {
        mouseDownRight.set(true);
        triggerMouseDownRight.trigger();
    }
}

function onMouseUp(e)
{
    if (e.which == 1)
    {
        mouseDownLeft.set(false);
        triggerMouseUpLeft.trigger();
    }
    else if (e.which == 2)
    {
        mouseDownMiddle.set(false);
        triggerMouseUpMiddle.trigger();
    }
    else if (e.which == 3)
    {
        mouseDownRight.set(false);
        triggerMouseUpRight.trigger();
    }
}

function onClickRight(e)
{
    mouseClickRight.trigger();
    e.preventDefault();
}

function onDoubleClick(e)
{
    mouseDoubleClick.trigger();
}

function onmouseclick(e)
{
    mouseClickLeft.trigger();
}

function ontouchstart(event)
{
    if (event.touches && event.touches.length > 0)
    {
        event.touches[0].which = 1;
        onMouseDown(event.touches[0]);
    }
}

function ontouchend(event)
{
    onMouseUp({ "which": 1 });
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("touchend", ontouchend);
    listenerElement.removeEventListener("touchcancel", ontouchend);
    listenerElement.removeEventListener("touchstart", ontouchstart);
    listenerElement.removeEventListener("dblclick", onDoubleClick);
    listenerElement.removeEventListener("click", onmouseclick);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("contextmenu", onClickRight);
    listenerElement.removeEventListener("mouseleave", onMouseUp);
    listenerElement = null;
}

function addListeners()
{
    if (listenerElement)removeListeners();

    listenerElement = cgl.canvas;
    if (area.get() == "Document") listenerElement = document.body;

    listenerElement.addEventListener("touchend", ontouchend);
    listenerElement.addEventListener("touchcancel", ontouchend);
    listenerElement.addEventListener("touchstart", ontouchstart);
    listenerElement.addEventListener("dblclick", onDoubleClick);
    listenerElement.addEventListener("click", onmouseclick);
    listenerElement.addEventListener("mousedown", onMouseDown);
    listenerElement.addEventListener("mouseup", onMouseUp);
    listenerElement.addEventListener("contextmenu", onClickRight);
    listenerElement.addEventListener("mouseleave", onMouseUp);
}

op.onLoaded = updateListeners;

active.onChange = updateListeners;

function updateListeners()
{
    removeListeners();
    if (active.get()) addListeners();
}


};

Ops.Devices.Mouse.MouseButtons.prototype = new CABLES.Op();
CABLES.OPS["c7e5e545-c8a1-4fef-85c2-45422b947f0d"]={f:Ops.Devices.Mouse.MouseButtons,objName:"Ops.Devices.Mouse.MouseButtons"};




// **************************************************************
// 
// Ops.Trigger.TriggerSend
// 
// **************************************************************

Ops.Trigger.TriggerSend = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const trigger = op.inTriggerButton("Trigger");
op.varName = op.inValueSelect("Named Trigger", [], "", true);

op.varName.onChange = updateName;

trigger.onTriggered = doTrigger;

op.patch.addEventListener("namedTriggersChanged", updateVarNamesDropdown);

updateVarNamesDropdown();

function updateVarNamesDropdown()
{
    if (CABLES.UI)
    {
        const varnames = [];
        const vars = op.patch.namedTriggers;
        varnames.push("+ create new one");
        for (const i in vars) varnames.push(i);
        op.varName.uiAttribs.values = varnames;
    }
}

function updateName()
{
    if (CABLES.UI)
    {
        if (op.varName.get() == "+ create new one")
        {
            new CABLES.UI.ModalDialog({
                "prompt": true,
                "title": "New Trigger",
                "text": "Enter a name for the new trigger",
                "promptValue": "",
                "promptOk": (str) =>
                {
                    op.varName.set(str);
                    op.patch.namedTriggers[str] = op.patch.namedTriggers[str] || [];
                    updateVarNamesDropdown();
                }
            });
            return;
        }

        op.refreshParams();
    }

    if (!op.patch.namedTriggers[op.varName.get()])
    {
        op.patch.namedTriggers[op.varName.get()] = op.patch.namedTriggers[op.varName.get()] || [];
        op.patch.emitEvent("namedTriggersChanged");
    }

    op.setTitle(">" + op.varName.get());

    op.refreshParams();
    op.patch.emitEvent("opTriggerNameChanged", op, op.varName.get());
}

function doTrigger()
{
    const arr = op.patch.namedTriggers[op.varName.get()];
    // fire an event even if noone is receiving this trigger
    // this way TriggerReceiveFilter can still handle it
    op.patch.emitEvent("namedTriggerSent", op.varName.get());

    if (!arr)
    {
        op.setUiError("unknowntrigger", "unknown trigger");
        return;
    }
    else op.setUiError("unknowntrigger", null);

    for (let i = 0; i < arr.length; i++)
    {
        arr[i]();
    }
}


};

Ops.Trigger.TriggerSend.prototype = new CABLES.Op();
CABLES.OPS["ce1eaf2b-943b-4dc0-ab5e-ee11b63c9ed0"]={f:Ops.Trigger.TriggerSend,objName:"Ops.Trigger.TriggerSend"};




// **************************************************************
// 
// Ops.Anim.InOutInAnim
// 
// **************************************************************

Ops.Anim.InOutInAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const anim = new CABLES.Anim();

const
    update = op.inTrigger("Update"),
    duration1 = op.inValue("Duration Out", 0.25),
    easing1 = anim.createPort(op, "Easing Out"),
    value1 = op.inValue("Value Out", 0),
    holdDuration = op.inValue("Hold duration", 0.0),
    duration2 = op.inValue("Duration In", 0.25),
    easing2 = anim.createPort(op, "Easing In"),
    value2 = op.inValue("Value In", 1),
    trigger = op.inTriggerButton("Start"),
    next = op.outTrigger("Next"),
    outVal = op.outNumber("Result", 0),
    started = op.outTrigger("Started"),
    middle = op.outTrigger("Middle"),
    finished = op.outTrigger("finished");

let time = 0;
trigger.onTriggered = setupAnim;

update.onTriggered = function ()
{
    time = CABLES.now() / 1000.0;
    if (anim.isStarted(time)) outVal.set(anim.getValue(time));
    else outVal.set(value2.get());

    next.trigger();
};

value2.onChange = function ()
{
    outVal.set(value2.get());
};

function setupAnim()
{
    anim.clear();
    // start
    anim.setValue(time, value2.get(), function ()
    {
        started.trigger();
    });
    // attack
    anim.setValue(time +
                        duration1.get(), value1.get(), function ()
    {

    });
    // Hold
    anim.setValue(time +
                        duration1.get() + holdDuration.get(), value1.get(), function ()
    {
        middle.trigger();
    });
    // release
    anim.setValue(time +
                        duration1.get() +
                        duration2.get() + holdDuration.get(), value2.get(), function ()
    {
        finished.trigger();
    });

    anim.keys[0].setEasing(
        anim.easingFromString(easing1.get()));

    anim.keys[2].setEasing(
        anim.easingFromString(easing2.get()));
}


};

Ops.Anim.InOutInAnim.prototype = new CABLES.Op();
CABLES.OPS["ae46d30d-9ea6-417b-968b-e7b5726afdde"]={f:Ops.Anim.InOutInAnim,objName:"Ops.Anim.InOutInAnim"};




// **************************************************************
// 
// Ops.Vars.VarSetNumber_v2
// 
// **************************************************************

Ops.Vars.VarSetNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inValueFloat("Value", 0);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "number", val, op.varName);


};

Ops.Vars.VarSetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["b5249226-6095-4828-8a1c-080654e192fa"]={f:Ops.Vars.VarSetNumber_v2,objName:"Ops.Vars.VarSetNumber_v2"};




// **************************************************************
// 
// Ops.Sidebar.Sidebar
// 
// **************************************************************

Ops.Sidebar.Sidebar = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"style_css":" /*\n * SIDEBAR\n  http://danielstern.ca/range.css/#/\n  https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-progress-value\n */\n\n.sidebar-icon-undo\n{\n    width:10px;\n    height:10px;\n    background-image: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 7v6h6'/%3E%3Cpath d='M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13'/%3E%3C/svg%3E\");\n    background-size: 19px;\n    background-repeat: no-repeat;\n    top: -19px;\n    margin-top: -7px;\n}\n\n.icon-chevron-down {\n    top: 2px;\n    right: 9px;\n}\n\n.iconsidebar-chevron-up,.sidebar__close-button {\n\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n}\n\n.iconsidebar-minimizebutton {\n    background-position: 98% center;\n    background-repeat: no-repeat;\n}\n\n.sidebar-cables-right\n{\n    right: 15px;\n    left: initial !important;\n}\n\n.sidebar-cables *\n{\n    color: #BBBBBB !important;\n    font-family: Arial;\n}\n\n.sidebar-cables {\n    --sidebar-color: #07f78c;\n    --sidebar-width: 220px;\n    --sidebar-border-radius: 10px;\n    --sidebar-monospace-font-stack: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n    --sidebar-hover-transition-time: .2s;\n\n    position: absolute;\n    top: 15px;\n    left: 15px;\n    border-radius: var(--sidebar-border-radius);\n    z-index: 100000;\n    width: var(--sidebar-width);\n    max-height: 100%;\n    box-sizing: border-box;\n    overflow-y: auto;\n    overflow-x: hidden;\n    font-size: 13px;\n    line-height: 1em; /* prevent emojis from breaking height of the title */\n}\n\n.sidebar-cables::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar-cables::-webkit-scrollbar {\n    background-color: transparent;\n    --cables-scrollbar-width: 8px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-track {\n    background-color: transparent;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-thumb {\n    background-color: #333333;\n    border-radius: 4px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables--closed {\n    width: auto;\n}\n\n.sidebar__close-button {\n    background-color: #222;\n    /*-webkit-user-select: none;  */\n    /*-moz-user-select: none;     */\n    /*-ms-user-select: none;      */\n    /*user-select: none;          */\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    /*color: #CCCCCC;*/\n    height: 2px;\n    /*border-bottom:20px solid #222;*/\n\n    /*box-sizing: border-box;*/\n    /*padding-top: 2px;*/\n    /*text-align: center;*/\n    /*cursor: pointer;*/\n    /*border-radius: 0 0 var(--sidebar-border-radius) var(--sidebar-border-radius);*/\n    /*opacity: 1.0;*/\n    /*transition: opacity 0.3s;*/\n    /*overflow: hidden;*/\n}\n\n.sidebar__close-button-icon {\n    display: inline-block;\n    /*opacity: 0;*/\n    width: 20px;\n    height: 20px;\n    /*position: relative;*/\n    /*top: -1px;*/\n\n\n}\n\n.sidebar--closed {\n    width: auto;\n    margin-right: 20px;\n}\n\n.sidebar--closed .sidebar__close-button {\n    margin-top: 8px;\n    margin-left: 8px;\n    padding:10px;\n\n    height: 25px;\n    width:25px;\n    border-radius: 50%;\n    cursor: pointer;\n    opacity: 0.3;\n    background-repeat: no-repeat;\n    background-position: center center;\n    transform:rotate(180deg);\n}\n\n.sidebar--closed .sidebar__group\n{\n    display:none;\n\n}\n.sidebar--closed .sidebar__close-button-icon {\n    background-position: 0px 0px;\n}\n\n.sidebar__close-button:hover {\n    background-color: #111111;\n    opacity: 1.0 !important;\n}\n\n/*\n * SIDEBAR ITEMS\n */\n\n.sidebar__items {\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5;*/\n    background-color: #222;\n    padding-bottom: 20px;\n}\n\n.sidebar--closed .sidebar__items {\n    /* max-height: 0; */\n    height: 0;\n    display: none;\n    pointer-interactions: none;\n}\n\n.sidebar__item__right {\n    float: right;\n}\n\n/*\n * SIDEBAR GROUP\n */\n\n.sidebar__group {\n    /*background-color: #1A1A1A;*/\n    overflow: hidden;\n    box-sizing: border-box;\n    animate: height;\n    /*background-color: #151515;*/\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5s; */\n--sidebar-group-header-height: 33px;\n}\n\n.sidebar__group-items\n{\n    padding-top: 15px;\n    padding-bottom: 15px;\n}\n\n.sidebar__group--closed {\n    /* max-height: 13px; */\n    height: var(--sidebar-group-header-height);\n}\n\n.sidebar__group-header {\n    box-sizing: border-box;\n    color: #EEEEEE;\n    background-color: #151515;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n\n    /*height: 100%;//var(--sidebar-group-header-height);*/\n\n    padding-top: 7px;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    cursor: pointer;\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    position: relative;\n}\n\n.sidebar__group-header:hover {\n  background-color: #111111;\n}\n\n.sidebar__group-header-title {\n  /*float: left;*/\n  overflow: hidden;\n  padding: 0 15px;\n  padding-top:5px;\n  padding-bottom:10px;\n  font-weight:bold;\n}\n\n.sidebar__group-header-undo {\n    float: right;\n    overflow: hidden;\n    padding-right: 15px;\n    padding-top:5px;\n    font-weight:bold;\n  }\n\n.sidebar__group-header-icon {\n    width: 17px;\n    height: 14px;\n    background-repeat: no-repeat;\n    display: inline-block;\n    position: absolute;\n    background-size: cover;\n\n    /* icon open */\n    /* feather icon: chevron up */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n    top: 4px;\n    right: 5px;\n    opacity: 0.0;\n    transition: opacity 0.3;\n}\n\n.sidebar__group-header:hover .sidebar__group-header-icon {\n    opacity: 1.0;\n}\n\n/* icon closed */\n.sidebar__group--closed .sidebar__group-header-icon {\n    /* feather icon: chevron down */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);\n    top: 4px;\n    right: 5px;\n}\n\n/*\n * SIDEBAR ITEM\n */\n\n.sidebar__item\n{\n    box-sizing: border-box;\n    padding: 7px;\n    padding-left:15px;\n    padding-right:15px;\n\n    overflow: hidden;\n    position: relative;\n}\n\n.sidebar__item-label {\n    display: inline-block;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    width: calc(50% - 7px);\n    margin-right: 7px;\n    margin-top: 2px;\n    text-overflow: ellipsis;\n    /* overflow: hidden; */\n}\n\n.sidebar__item-value-label {\n    font-family: var(--sidebar-monospace-font-stack);\n    display: inline-block;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    max-width: 60%;\n}\n\n.sidebar__item-value-label::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar__item + .sidebar__item,\n.sidebar__item + .sidebar__group,\n.sidebar__group + .sidebar__item,\n.sidebar__group + .sidebar__group {\n    /*border-top: 1px solid #272727;*/\n}\n\n/*\n * SIDEBAR ITEM TOGGLE\n */\n\n/*.sidebar__toggle */\n.icon_toggle{\n    cursor: pointer;\n}\n\n.sidebar__toggle-input {\n    --sidebar-toggle-input-color: #CCCCCC;\n    --sidebar-toggle-input-color-hover: #EEEEEE;\n    --sidebar-toggle-input-border-size: 2px;\n    display: inline;\n    float: right;\n    box-sizing: border-box;\n    border-radius: 50%;\n    cursor: pointer;\n    --toggle-size: 11px;\n    margin-top: 2px;\n    background-color: transparent !important;\n    border: var(--sidebar-toggle-input-border-size) solid var(--sidebar-toggle-input-color);\n    width: var(--toggle-size);\n    height: var(--toggle-size);\n    transition: background-color var(--sidebar-hover-transition-time);\n    transition: border-color var(--sidebar-hover-transition-time);\n}\n.sidebar__toggle:hover .sidebar__toggle-input {\n    border-color: var(--sidebar-toggle-input-color-hover);\n}\n\n.sidebar__toggle .sidebar__item-value-label {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    max-width: calc(50% - 12px);\n}\n.sidebar__toggle-input::after { clear: both; }\n\n.sidebar__toggle--active .icon_toggle\n{\n\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjMDZmNzhiIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzA2Zjc4YiIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjMDZmNzhiIiBzdHJva2U9IiMwNmY3OGIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNmY3OGIiIHN0cm9rZT0iIzA2Zjc4YiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    opacity: 1;\n    transform: rotate(0deg);\n}\n\n\n.icon_toggle\n{\n    float: right;\n    width:40px;\n    height:18px;\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjYWFhYWFhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI2FhYWFhYSIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjYWFhYWFhIiBzdHJva2U9IiNhYWFhYWEiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNhYWFhYWEiIHN0cm9rZT0iI2FhYWFhYSIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    background-size: 50px 37px;\n    background-position: -6px -10px;\n    transform: rotate(180deg);\n    opacity: 0.4;\n}\n\n\n\n/*.sidebar__toggle--active .sidebar__toggle-input {*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    background-color: var(--sidebar-toggle-input-color);*/\n/*}*/\n/*.sidebar__toggle--active .sidebar__toggle-input:hover*/\n/*{*/\n/*    background-color: var(--sidebar-toggle-input-color-hover);*/\n/*    border-color: var(--sidebar-toggle-input-color-hover);*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    transition: border-color var(--sidebar-hover-transition-time);*/\n/*}*/\n\n/*\n * SIDEBAR ITEM BUTTON\n */\n\n.sidebar__button {}\n\n.sidebar__button-input:active\n{\n    background-color: #555 !important;\n}\n\n.sidebar__button-input {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    min-height: 24px;\n    background-color: transparent;\n    color: #CCCCCC;\n    box-sizing: border-box;\n    padding-top: 3px;\n    text-align: center;\n    border-radius: 125px;\n    border:2px solid #555;\n    cursor: pointer;\n    padding-bottom: 3px;\n}\n\n.sidebar__button-input.plus, .sidebar__button-input.minus {\n    display: inline-block;\n    min-width: 20px;\n}\n\n.sidebar__button-input:hover {\n  background-color: #333;\n  border:2px solid var(--sidebar-color);\n}\n\n/*\n * VALUE DISPLAY (shows a value)\n */\n\n.sidebar__value-display {}\n\n/*\n * SLIDER\n */\n\n.sidebar__slider {\n    --sidebar-slider-input-height: 3px;\n}\n\n.sidebar__slider-input-wrapper {\n    width: 100%;\n\n    margin-top: 8px;\n    position: relative;\n}\n\n.sidebar__slider-input {\n    -webkit-appearance: none;\n    appearance: none;\n    margin: 0;\n    width: 100%;\n    height: var(--sidebar-slider-input-height);\n    background: #555;\n    cursor: pointer;\n    outline: 0;\n\n    -webkit-transition: .2s;\n    transition: background-color .2s;\n    border: none;\n}\n\n.sidebar__slider-input:focus, .sidebar__slider-input:hover {\n    border: none;\n}\n\n.sidebar__slider-input-active-track {\n    user-select: none;\n    position: absolute;\n    z-index: 11;\n    top: 0;\n    left: 0;\n    background-color: var(--sidebar-color);\n    pointer-events: none;\n    height: var(--sidebar-slider-input-height);\n    max-width: 100%;\n}\n\n/* Mouse-over effects */\n.sidebar__slider-input:hover {\n    /*background-color: #444444;*/\n}\n\n/*.sidebar__slider-input::-webkit-progress-value {*/\n/*    background-color: green;*/\n/*    color:green;*/\n\n/*    }*/\n\n/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */\n\n.sidebar__slider-input::-moz-range-thumb\n{\n    position: absolute;\n    height: 15px;\n    width: 15px;\n    z-index: 900 !important;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: var(--sidebar-color) !important;\n    user-select: none;\n\n}\n\n.sidebar__slider-input::-webkit-slider-thumb\n{\n    position: relative;\n    appearance: none;\n    -webkit-appearance: none;\n    user-select: none;\n    height: 15px;\n    width: 15px;\n    display: block;\n    z-index: 900 !important;\n    border: 0;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: #777 !important;\n}\n\n.sidebar__slider-input:hover ::-webkit-slider-thumb {\n    background-color: #EEEEEE !important;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb {*/\n\n/*    width: 0 !important;*/\n/*    height: var(--sidebar-slider-input-height);*/\n/*    background: #EEEEEE;*/\n/*    cursor: pointer;*/\n/*    border-radius: 0 !important;*/\n/*    border: none;*/\n/*    outline: 0;*/\n/*    z-index: 100 !important;*/\n/*}*/\n\n.sidebar__slider-input::-moz-range-track {\n    background-color: transparent;\n    z-index: 11;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb:hover {*/\n  /* background-color: #EEEEEE; */\n/*}*/\n\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input-active-track {*/\n/*    background-color: #EEEEEE;*/\n/*}*/\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-moz-range-thumb {*/\n/*    background-color: #fff !important;*/\n/*}*/\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-webkit-slider-thumb {*/\n/*    background-color: #EEEEEE;*/\n/*}*/\n\n.sidebar__slider input[type=text],\n.sidebar__slider input[type=paddword]\n{\n    box-sizing: border-box;\n    /*background-color: #333333;*/\n    text-align: right;\n    color: #BBBBBB;\n    display: inline-block;\n    background-color: transparent !important;\n\n    width: 40%;\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__slider input[type=text]:active,\n.sidebar__slider input[type=text]:focus,\n.sidebar__slider input[type=text]:hover\n.sidebar__slider input[type=password]:active,\n.sidebar__slider input[type=password]:focus,\n.sidebar__slider input[type=password]:hover\n{\n\n    color: #EEEEEE;\n}\n\n/*\n * TEXT / DESCRIPTION\n */\n\n.sidebar__text .sidebar__item-label {\n    width: auto;\n    display: block;\n    max-height: none;\n    margin-right: 0;\n    line-height: 1.1em;\n}\n\n/*\n * SIDEBAR INPUT\n */\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text],\n.sidebar__text-input input[type=password] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: 50%;\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    border:1px solid #666;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__text-input textarea:focus::placeholder {\n  color: transparent;\n}\n\n.sidebar__color-picker .sidebar__item-label\n{\n    width:45%;\n}\n\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text]:active,\n.sidebar__text-input input[type=text]:focus,\n.sidebar__text-input input[type=text]:hover,\n.sidebar__text-input input[type=password]:active,\n.sidebar__text-input input[type=password]:focus,\n.sidebar__text-input input[type=password]:hover {\n    background-color: transparent;\n    color: #EEEEEE;\n}\n\n.sidebar__text-input textarea\n{\n    margin-top:10px;\n    height:60px;\n    width:100%;\n}\n\n/*\n * SIDEBAR SELECT\n */\n\n\n\n .sidebar__select {}\n .sidebar__select-select {\n    color: #BBBBBB;\n    /*-webkit-appearance: none;*/\n    /*-moz-appearance: none;*/\n    appearance: none;\n    /*box-sizing: border-box;*/\n    width: 50%;\n    /*height: 20px;*/\n    background-color: #333333;\n    /*background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);*/\n    background-repeat: no-repeat;\n    background-position: right center;\n    background-size: 16px 16px;\n    margin: 0;\n    /*padding: 0 2 2 6px;*/\n    border-radius: 5px;\n    border: 1px solid #777;\n    background-color: #444;\n    cursor: pointer;\n    outline: none;\n    padding-left: 5px;\n\n }\n\n.sidebar__select-select:hover,\n.sidebar__select-select:active,\n.sidebar__select-select:inactive {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\n/*.sidebar__select-select option*/\n/*{*/\n/*    background-color: #444444;*/\n/*    color: #bbb;*/\n/*}*/\n\n.sidebar__select-select option:checked\n{\n    background-color: #000;\n    color: #FFF;\n}\n\n\n/*\n * COLOR PICKER\n */\n\n\n .sidebar__color-picker input[type=text] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: calc(50% - 21px); /* 50% minus space of picker circle */\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    margin-right: 7px;\n}\n\n.sidebar__color-picker input[type=text]:active,\n.sidebar__color-picker input[type=text]:focus,\n.sidebar__color-picker input[type=text]:hover {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\ndiv.sidebar__color-picker-color-input,\n.sidebar__color-picker input[type=color],\n.sidebar__palette-picker input[type=color] {\n    display: inline-block;\n    border-radius: 100%;\n    height: 14px;\n    width: 14px;\n\n    padding: 0;\n    border: none;\n    /*border:2px solid red;*/\n    border-color: transparent;\n    outline: none;\n    background: none;\n    appearance: none;\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    cursor: pointer;\n    position: relative;\n    top: 3px;\n}\n.sidebar__color-picker input[type=color]:focus,\n.sidebar__palette-picker input[type=color]:focus {\n    outline: none;\n}\n.sidebar__color-picker input[type=color]::-moz-color-swatch,\n.sidebar__palette-picker input[type=color]::-moz-color-swatch {\n    border: none;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch-wrapper,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch-wrapper {\n    padding: 0;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch {\n    border: none;\n    border-radius: 100%;\n}\n\n/*\n * Palette Picker\n */\n.sidebar__palette-picker .sidebar__palette-picker-color-input.first {\n    margin-left: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input.last {\n    margin-right: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input {\n    margin: 0 4px;\n}\n\n.sidebar__palette-picker .circlebutton {\n    width: 14px;\n    height: 14px;\n    border-radius: 1em;\n    display: inline-block;\n    top: 3px;\n    position: relative;\n}\n\n/*\n * Preset\n */\n.sidebar__item-presets-preset\n{\n    padding:4px;\n    cursor:pointer;\n    padding-left:8px;\n    padding-right:8px;\n    margin-right:4px;\n    background-color:#444;\n}\n\n.sidebar__item-presets-preset:hover\n{\n    background-color:#666;\n}\n\n.sidebar__greyout\n{\n    background: #222;\n    opacity: 0.8;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 1000;\n    right: 0;\n    top: 0;\n}\n\n.sidebar_tabs\n{\n    background-color: #151515;\n    padding-bottom: 0px;\n}\n\n.sidebar_switchs\n{\n    float: right;\n}\n\n.sidebar_tab\n{\n    float:left;\n    background-color: #151515;\n    border-bottom:1px solid transparent;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_tab_active\n{\n    background-color: #272727;\n    color:white;\n}\n\n.sidebar_tab:hover\n{\n    border-bottom:1px solid #777;\n    color:white;\n}\n\n\n.sidebar_switch\n{\n    float:left;\n    background-color: #444;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_switch:last-child\n{\n    border-top-right-radius: 7px;\n    border-bottom-right-radius: 7px;\n}\n\n.sidebar_switch:first-child\n{\n    border-top-left-radius: 7px;\n    border-bottom-left-radius: 7px;\n}\n\n\n.sidebar_switch_active\n{\n    background-color: #999;\n    color:white;\n}\n\n.sidebar_switch:hover\n{\n    color:white;\n}\n\n",};
// vars
const CSS_ELEMENT_CLASS = "cables-sidebar-style"; /* class for the style element to be generated */
const CSS_ELEMENT_DYNAMIC_CLASS = "cables-sidebar-dynamic-style"; /* things which can be set via op-port, but not attached to the elements themselves, e.g. minimized opacity */
const SIDEBAR_CLASS = "sidebar-cables";
const SIDEBAR_ID = "sidebar" + CABLES.uuid();
const SIDEBAR_ITEMS_CLASS = "sidebar__items";
const SIDEBAR_OPEN_CLOSE_BTN_CLASS = "sidebar__close-button";

const BTN_TEXT_OPEN = ""; // 'Close';
const BTN_TEXT_CLOSED = ""; // 'Show Controls';

let openCloseBtn = null;
let openCloseBtnIcon = null;
let headerTitleText = null;

// inputs
const visiblePort = op.inValueBool("Visible", true);
const opacityPort = op.inValueSlider("Opacity", 1);
const defaultMinimizedPort = op.inValueBool("Default Minimized");
const minimizedOpacityPort = op.inValueSlider("Minimized Opacity", 0.5);
const undoButtonPort = op.inValueBool("Show undo button", false);
const inMinimize = op.inValueBool("Show Minimize", false);

const inTitle = op.inString("Title", "");
const side = op.inValueBool("Side");
const addCss = op.inValueBool("Default CSS", true);

let doc = op.patch.cgl.canvas.ownerDocument;

// outputs
const childrenPort = op.outObject("childs");
childrenPort.setUiAttribs({ "title": "Children" });

const isOpenOut = op.outBool("Opfened");
isOpenOut.setUiAttribs({ "title": "Opened" });

let sidebarEl = doc.querySelector("." + SIDEBAR_ID);
if (!sidebarEl) sidebarEl = initSidebarElement();

const sidebarItemsEl = sidebarEl.querySelector("." + SIDEBAR_ITEMS_CLASS);
childrenPort.set({
    "parentElement": sidebarItemsEl,
    "parentOp": op,
});
onDefaultMinimizedPortChanged();
initSidebarCss();
updateDynamicStyles();

addCss.onChange = () =>
{
    initSidebarCss();
    updateDynamicStyles();
};
visiblePort.onChange = onVisiblePortChange;
opacityPort.onChange = onOpacityPortChange;
defaultMinimizedPort.onChange = onDefaultMinimizedPortChanged;
minimizedOpacityPort.onChange = onMinimizedOpacityPortChanged;
undoButtonPort.onChange = onUndoButtonChange;
op.onDelete = onDelete;

function onMinimizedOpacityPortChanged()
{
    updateDynamicStyles();
}

inMinimize.onChange = updateMinimize;

function updateMinimize(header)
{
    if (!header || header.uiAttribs) header = doc.querySelector(".sidebar-cables .sidebar__group-header");
    if (!header) return;

    const undoButton = doc.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");

    if (inMinimize.get())
    {
        header.classList.add("iconsidebar-chevron-up");
        header.classList.add("iconsidebar-minimizebutton");

        if (undoButton)undoButton.style.marginRight = "20px";
    }
    else
    {
        header.classList.remove("iconsidebar-chevron-up");
        header.classList.remove("iconsidebar-minimizebutton");

        if (undoButton)undoButton.style.marginRight = "initial";
    }
}

side.onChange = function ()
{
    if (!sidebarEl) return;
    if (side.get()) sidebarEl.classList.add("sidebar-cables-right");
    else sidebarEl.classList.remove("sidebar-cables-right");
};

function onUndoButtonChange()
{
    const header = doc.querySelector(".sidebar-cables .sidebar__group-header");
    if (header)
    {
        initUndoButton(header);
    }
}

function initUndoButton(header)
{
    if (header)
    {
        const undoButton = doc.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
        if (undoButton)
        {
            if (!undoButtonPort.get())
            {
                // header.removeChild(undoButton);
                undoButton.remove();
            }
        }
        else
        {
            if (undoButtonPort.get())
            {
                const headerUndo = doc.createElement("span");
                headerUndo.classList.add("sidebar__group-header-undo");
                headerUndo.classList.add("sidebar-icon-undo");

                headerUndo.addEventListener("click", function (event)
                {
                    event.stopPropagation();
                    const reloadables = doc.querySelectorAll(".sidebar-cables .sidebar__reloadable");
                    const doubleClickEvent = doc.createEvent("MouseEvents");
                    doubleClickEvent.initEvent("dblclick", true, true);
                    reloadables.forEach((reloadable) =>
                    {
                        reloadable.dispatchEvent(doubleClickEvent);
                    });
                });
                header.appendChild(headerUndo);
            }
        }
    }
    updateMinimize(header);
}

function onDefaultMinimizedPortChanged()
{
    if (!openCloseBtn) { return; }
    if (defaultMinimizedPort.get())
    {
        sidebarEl.classList.add("sidebar--closed");
        if (visiblePort.get()) isOpenOut.set(false);
    }
    else
    {
        sidebarEl.classList.remove("sidebar--closed");
        if (visiblePort.get()) isOpenOut.set(true);
    }
}

function onOpacityPortChange()
{
    const opacity = opacityPort.get();
    sidebarEl.style.opacity = opacity;
}

function onVisiblePortChange()
{
    if (!sidebarEl) return;
    if (visiblePort.get())
    {
        sidebarEl.style.display = "block";
        if (!sidebarEl.classList.contains("sidebar--closed")) isOpenOut.set(true);
    }
    else
    {
        sidebarEl.style.display = "none";
        isOpenOut.set(false);
    }
}

side.onChanged = function ()
{

};

/**
 * Some styles cannot be set directly inline, so a dynamic stylesheet is needed.
 * Here hover states can be set later on e.g.
 */
function updateDynamicStyles()
{
    const dynamicStyles = doc.querySelectorAll("." + CSS_ELEMENT_DYNAMIC_CLASS);
    if (dynamicStyles)
    {
        dynamicStyles.forEach(function (e)
        {
            e.parentNode.removeChild(e);
        });
    }

    if (!addCss.get()) return;

    const newDynamicStyle = doc.createElement("style");
    newDynamicStyle.classList.add("cablesEle");
    newDynamicStyle.classList.add(CSS_ELEMENT_DYNAMIC_CLASS);
    let cssText = ".sidebar--closed .sidebar__close-button { ";
    cssText += "opacity: " + minimizedOpacityPort.get();
    cssText += "}";
    const cssTextEl = doc.createTextNode(cssText);
    newDynamicStyle.appendChild(cssTextEl);
    doc.body.appendChild(newDynamicStyle);
}

function initSidebarElement()
{
    const element = doc.createElement("div");
    element.classList.add(SIDEBAR_CLASS);
    element.classList.add(SIDEBAR_ID);
    const canvasWrapper = op.patch.cgl.canvas.parentElement; /* maybe this is bad outside cables!? */

    // header...
    const headerGroup = doc.createElement("div");
    headerGroup.classList.add("sidebar__group");

    element.appendChild(headerGroup);
    const header = doc.createElement("div");
    header.classList.add("sidebar__group-header");

    element.appendChild(header);
    const headerTitle = doc.createElement("span");
    headerTitle.classList.add("sidebar__group-header-title");
    headerTitleText = doc.createElement("span");
    headerTitleText.classList.add("sidebar__group-header-title-text");
    headerTitleText.innerHTML = inTitle.get();
    headerTitle.appendChild(headerTitleText);
    header.appendChild(headerTitle);

    initUndoButton(header);
    updateMinimize(header);

    headerGroup.appendChild(header);
    element.appendChild(headerGroup);
    headerGroup.addEventListener("click", onOpenCloseBtnClick);

    if (!canvasWrapper)
    {
        op.warn("[sidebar] no canvas parentelement found...");
        return;
    }
    canvasWrapper.appendChild(element);
    const items = doc.createElement("div");
    items.classList.add(SIDEBAR_ITEMS_CLASS);
    element.appendChild(items);
    openCloseBtn = doc.createElement("div");
    openCloseBtn.classList.add(SIDEBAR_OPEN_CLOSE_BTN_CLASS);
    openCloseBtn.addEventListener("click", onOpenCloseBtnClick);
    element.appendChild(openCloseBtn);

    return element;
}

inTitle.onChange = function ()
{
    if (headerTitleText)headerTitleText.innerHTML = inTitle.get();
};

function setClosed(b)
{

}

function onOpenCloseBtnClick(ev)
{
    ev.stopPropagation();
    if (!sidebarEl) { op.logError("Sidebar could not be closed..."); return; }
    sidebarEl.classList.toggle("sidebar--closed");
    const btn = ev.target;
    let btnText = BTN_TEXT_OPEN;
    if (sidebarEl.classList.contains("sidebar--closed"))
    {
        btnText = BTN_TEXT_CLOSED;
        isOpenOut.set(false);
    }
    else
    {
        isOpenOut.set(true);
    }
}

function initSidebarCss()
{
    const cssElements = doc.querySelectorAll("." + CSS_ELEMENT_CLASS);
    // remove old script tag
    if (cssElements)
    {
        cssElements.forEach((e) =>
        {
            e.parentNode.removeChild(e);
        });
    }

    if (!addCss.get()) return;

    const newStyle = doc.createElement("style");

    newStyle.innerHTML = attachments.style_css;
    newStyle.classList.add(CSS_ELEMENT_CLASS);
    newStyle.classList.add("cablesEle");
    doc.body.appendChild(newStyle);
}

function onDelete()
{
    removeElementFromDOM(sidebarEl);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}


};

Ops.Sidebar.Sidebar.prototype = new CABLES.Op();
CABLES.OPS["5a681c35-78ce-4cb3-9858-bc79c34c6819"]={f:Ops.Sidebar.Sidebar,objName:"Ops.Sidebar.Sidebar"};




// **************************************************************
// 
// Ops.Sidebar.SideBarStyle
// 
// **************************************************************

Ops.Sidebar.SideBarStyle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const parentPort = op.inObject("link"),
    inWidth = op.inInt("Width", 220),
    inBorderRadius = op.inFloat("Round Corners", 10),
    inColorSpecial = op.inString("Special Color", "#07f78c"),

    siblingsPort = op.outObject("childs");

inColorSpecial.onChange =
inBorderRadius.onChange =
inWidth.onChange = setStyle;

parentPort.onChange = onParentChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

let sideBarEle = null;

function setStyle()
{
    if (!sideBarEle) return;

    sideBarEle.style.setProperty("--sidebar-width", inWidth.get() + "px");

    sideBarEle.style.setProperty("--sidebar-color", inColorSpecial.get());

    sideBarEle.style.setProperty("--sidebar-border-radius", Math.round(inBorderRadius.get()) + "px");

    op.patch.emitEvent("sidebarStylesChanged");
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        siblingsPort.set(parent);
        sideBarEle = parent.parentElement.parentElement;
        setStyle();
    }
    else
    {
        sideBarEle = null;
    }
}

function showElement(el)
{
    if (!el) return;
    el.style.display = "block";
}

function hideElement(el)
{
    if (!el) return;
    el.style.display = "none";
}

function onDelete()
{
}


};

Ops.Sidebar.SideBarStyle.prototype = new CABLES.Op();
CABLES.OPS["87d78a59-c8d4-4269-a3f8-af273741aae4"]={f:Ops.Sidebar.SideBarStyle,objName:"Ops.Sidebar.SideBarStyle"};




// **************************************************************
// 
// Ops.Anim.Timer_v2
// 
// **************************************************************

Ops.Anim.Timer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inSpeed = op.inValue("Speed", 1),
    playPause = op.inValueBool("Play", true),
    reset = op.inTriggerButton("Reset"),
    inSyncTimeline = op.inValueBool("Sync to timeline", false),
    outTime = op.outNumber("Time");

op.setPortGroup("Controls", [playPause, reset, inSpeed]);

const timer = new CABLES.Timer();
let lastTime = null;
let time = 0;
let syncTimeline = false;

playPause.onChange = setState;
setState();

function setState()
{
    if (playPause.get())
    {
        timer.play();
        op.patch.addOnAnimFrame(op);
    }
    else
    {
        timer.pause();
        op.patch.removeOnAnimFrame(op);
    }
}

reset.onTriggered = doReset;

function doReset()
{
    time = 0;
    lastTime = null;
    timer.setTime(0);
    outTime.set(0);
}

inSyncTimeline.onChange = function ()
{
    syncTimeline = inSyncTimeline.get();
    playPause.setUiAttribs({ "greyout": syncTimeline });
    reset.setUiAttribs({ "greyout": syncTimeline });
};

op.onAnimFrame = function (tt, frameNum, deltaMs)
{
    if (timer.isPlaying())
    {
        if (CABLES.overwriteTime !== undefined)
        {
            outTime.set(CABLES.overwriteTime * inSpeed.get());
        }
        else

        if (syncTimeline)
        {
            outTime.set(tt * inSpeed.get());
        }
        else
        {
            timer.update();
            const timerVal = timer.get();

            if (lastTime === null)
            {
                lastTime = timerVal;
                return;
            }

            const t = Math.abs(timerVal - lastTime);
            lastTime = timerVal;

            time += t * inSpeed.get();
            if (time != time)time = 0;
            outTime.set(time);
        }
    }
};


};

Ops.Anim.Timer_v2.prototype = new CABLES.Op();
CABLES.OPS["aac7f721-208f-411a-adb3-79adae2e471a"]={f:Ops.Anim.Timer_v2,objName:"Ops.Anim.Timer_v2"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnce
// 
// **************************************************************

Ops.Trigger.TriggerOnce = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTriggerButton("Exec"),
    reset = op.inTriggerButton("Reset"),
    next = op.outTrigger("Next"),
    outTriggered = op.outBoolNum("Was Triggered");

let triggered = false;

op.toWorkPortsNeedToBeLinked(exe);

reset.onTriggered = function ()
{
    triggered = false;
    outTriggered.set(triggered);
};

exe.onTriggered = function ()
{
    if (triggered) return;

    triggered = true;
    next.trigger();
    outTriggered.set(triggered);
};


};

Ops.Trigger.TriggerOnce.prototype = new CABLES.Op();
CABLES.OPS["cf3544e4-e392-432b-89fd-fcfb5c974388"]={f:Ops.Trigger.TriggerOnce,objName:"Ops.Trigger.TriggerOnce"};




// **************************************************************
// 
// Ops.Math.Ease
// 
// **************************************************************

Ops.Math.Ease = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inVal = op.inValue("Value"),
    inMin = op.inValue("Min", 0),
    inMax = op.inValue("Max", 1),
    result = op.outNumber("Result"),
    anim = new CABLES.Anim();

anim.createPort(op, "Easing", updateAnimEasing);
anim.setValue(0, 0);
anim.setValue(1, 1);

op.onLoaded = inMin.onChange = inMax.onChange = updateMinMax;

function updateMinMax()
{
    anim.keys[0].time = anim.keys[0].value = Math.min(inMin.get(), inMax.get());
    anim.keys[1].time = anim.keys[1].value = Math.max(inMin.get(), inMax.get());
}

function updateAnimEasing()
{
    anim.keys[0].setEasing(anim.defaultEasing);
}

inVal.onChange = function ()
{
    const r = anim.getValue(inVal.get());
    result.set(r);
};


};

Ops.Math.Ease.prototype = new CABLES.Op();
CABLES.OPS["8f6e4a08-33e6-408f-ac4a-198bd03b417b"]={f:Ops.Math.Ease,objName:"Ops.Math.Ease"};




// **************************************************************
// 
// Ops.Ui.PatchInput
// 
// **************************************************************

Ops.Ui.PatchInput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const dyn = op.addOutPort(new CABLES.Port(op, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));

function getPatchOp()
{
    for (let i in op.patch.ops)
    {
        if (op.patch.ops[i].patchId)
        {
            if (op.patch.ops[i].patchId.get() == op.uiAttribs.subPatch)
            {
                return op.patch.ops[i];
            }
        }
    }
}

dyn.onLinkChanged = () =>
{
    const mySubPatchOp = getPatchOp();

    if (!dyn.links.length || !mySubPatchOp || !mySubPatchOp.addNewInPort) return;


    const otherPort = dyn.links[0].getOtherPort(dyn);
    dyn.removeLinks();

    const newPortName = mySubPatchOp.addNewInPort(otherPort);

    const l = gui.scene().link(
        otherPort.parent,
        otherPort.getName(),
        op,
        newPortName);

    mySubPatchOp.saveData();
};


};

Ops.Ui.PatchInput.prototype = new CABLES.Op();
CABLES.OPS["e3f68bc3-892a-4c78-9974-aca25c27025d"]={f:Ops.Ui.PatchInput,objName:"Ops.Ui.PatchInput"};




// **************************************************************
// 
// Ops.Ui.PatchOutput
// 
// **************************************************************

Ops.Ui.PatchOutput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const dyn = op.addInPort(new CABLES.Port(op, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));

function getPatchOp()
{
    for (let i in op.patch.ops)
    {
        if (op.patch.ops[i].patchId)
        {
            if (op.patch.ops[i].patchId.get() == op.uiAttribs.subPatch)
            {
                return op.patch.ops[i];
            }
        }
    }
}

dyn.onLinkChanged = () =>
{
    const mySubPatchOp = getPatchOp();

    if (!dyn.links.length) return;

    const otherPort = dyn.links[0].getOtherPort(dyn);
    dyn.removeLinks();

    const newPortName = mySubPatchOp.addNewOutPort(otherPort);

    const l = gui.scene().link(
        otherPort.parent,
        otherPort.getName(),
        op,
        newPortName);

    mySubPatchOp.saveData();
};


};

Ops.Ui.PatchOutput.prototype = new CABLES.Op();
CABLES.OPS["851b44cb-5667-4140-9800-5aeb7031f1d7"]={f:Ops.Ui.PatchOutput,objName:"Ops.Ui.PatchOutput"};




// **************************************************************
// 
// Ops.Ui.SubPatch
// 
// **************************************************************

Ops.Ui.SubPatch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
op.dyn = op.addInPort(new CABLES.Port(op, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));
op.dynOut = op.addOutPort(new CABLES.Port(op, "create port out", CABLES.OP_PORT_TYPE_DYNAMIC));

const dataStr = op.addInPort(new CABLES.Port(op, "dataStr", CABLES.OP_PORT_TYPE_VALUE, { "display": "readonly" }));
op.patchId = op.addInPort(new CABLES.Port(op, "patchId", CABLES.OP_PORT_TYPE_VALUE, { "display": "readonly" }));

// if (CABLES.UI && CABLES.sandbox.isDevEnv())
// {
//     const inMakeBp = op.inTriggerButton("Create Blueprint");
//     inMakeBp.setUiAttribs({ "hidePort": true });
//     inMakeBp.onTriggered = makeBlueprint;
// }

dataStr.setUiAttribs({ "hideParam": true });
op.patchId.setUiAttribs({ "hidePort": true });

let data = { "ports": [], "portsOut": [] };
let oldPatchId = CABLES.generateUUID();
op.patchId.set(oldPatchId);
getSubPatchInputOp();
getSubPatchOutputOp();

let dataLoaded = false;

op.saveData = saveData;

op.init = () =>
{
    op.setStorage({ "subPatchVer": 1 });
};

op.patchId.onChange = function ()
{
    if (!op.patch.isEditorMode()) return;
    const oldPatchOps = op.patch.getSubPatchOps(oldPatchId);
    if (oldPatchOps.length === 2)
    {
        if (op.patch.isEditorMode() && CABLES.UI.DEFAULTOPS.isInBlueprint(op)) CABLES.UI.undo.pause();
        for (let i = 0; i < oldPatchOps.length; i++)
        {
            op.patch.deleteOp(oldPatchOps[i].id);
        }
        if (op.patch.isEditorMode() && CABLES.UI.DEFAULTOPS.isInBlueprint(op)) CABLES.UI.undo.resume();
    }
};

op.onLoaded = function ()
{
};

op.onLoadedValueSet = function ()
{
    data = JSON.parse(dataStr.get());
    if (!data)
    {
        data = { "ports": [], "portsOut": [] };
    }
    setupPorts();
};

function loadData()
{
}

dataStr.onChange = function ()
{
    if (dataLoaded) return;

    if (!dataStr.get()) return;
    try
    {
        loadData();
    }
    catch (e)
    {
        op.logError("cannot load subpatch data...");
        op.logError(e);
    }
};

function saveData()
{
    try
    {
        dataStr.set(JSON.stringify(data));
    }
    catch (e)
    {
        op.log(e);
    }
}

op.addPortListener = addPortListener;
function addPortListener(newPort, newPortInPatch)
{
    if (!newPort.hasSubpatchLstener)
    {
        newPort.hasSubpatchLstener = true;
        newPort.addEventListener("onUiAttrChange", function (attribs)
        {
            if (attribs.title)
            {
                let i = 0;
                for (i = 0; i < data.portsOut.length; i++)
                    if (data.portsOut[i].name == newPort.name)
                        data.portsOut[i].title = attribs.title;

                for (i = 0; i < data.ports.length; i++)
                    if (data.ports[i].name == newPort.name)
                        data.ports[i].title = attribs.title;

                saveData();
            }
        });
    }

    if (newPort.direction == CABLES.PORT_DIR_IN)
    {
        if (newPort.type == CABLES.OP_PORT_TYPE_FUNCTION)
        {
            newPort.onTriggered = function ()
            {
                if (newPortInPatch.isLinked())
                    newPortInPatch.trigger();
            };
        }
        else
        {
            newPort.onChange = function ()
            {
                newPortInPatch.set(newPort.get());
                if (!newPort.isLinked())
                {
                    for (let i = 0; i < data.ports.length; i++)
                    {
                        if (data.ports[i].name === newPort.name)
                        {
                            data.ports[i].value = newPort.get();
                        }
                    }
                    saveData();
                }
            };
        }
    }
}

op.setupPorts = setupPorts;
function setupPorts()
{
    if (!op.patchId.get()) return;
    const ports = data.ports || [];
    const portsOut = data.portsOut || [];
    let i = 0;

    for (i = 0; i < ports.length; i++)
    {
        if (!op.getPortByName(ports[i].name))
        {
            const newPort = op.addInPort(new CABLES.Port(op, ports[i].name, ports[i].type));

            const patchInputOp = getSubPatchInputOp();
            const newPortInPatch = patchInputOp.addOutPort(new CABLES.Port(patchInputOp, ports[i].name, ports[i].type));

            newPort.ignoreValueSerialize = true;
            newPort.setUiAttribs({ "editableTitle": true });
            if (ports[i].title)
            {
                newPort.setUiAttribs({ "title": ports[i].title });
                newPortInPatch.setUiAttribs({ "title": ports[i].title });
            }
            if (ports[i].objType)
            {
                newPort.setUiAttribs({ "objType": ports[i].objType });
                newPortInPatch.setUiAttribs({ "objType": ports[i].objType });
            }
            if (ports[i].value)
            {
                newPort.set(ports[i].value);
                newPortInPatch.set(ports[i].value);
            }
            addPortListener(newPort, newPortInPatch);
        }
    }

    for (i = 0; i < portsOut.length; i++)
    {
        if (!op.getPortByName(portsOut[i].name))
        {
            const newPortOut = op.addOutPort(new CABLES.Port(op, portsOut[i].name, portsOut[i].type));
            const patchOutputOp = getSubPatchOutputOp();
            const newPortOutPatch = patchOutputOp.addInPort(new CABLES.Port(patchOutputOp, portsOut[i].name, portsOut[i].type));

            newPortOut.ignoreValueSerialize = true;
            newPortOut.setUiAttribs({ "editableTitle": true });

            if (portsOut[i].title)
            {
                newPortOut.setUiAttribs({ "title": portsOut[i].title });
                newPortOutPatch.setUiAttribs({ "title": portsOut[i].title });
            }
            if (portsOut[i].objType)
            {
                newPortOut.setUiAttribs({ "objType": portsOut[i].objType });
                newPortOutPatch.setUiAttribs({ "objType": portsOut[i].objType });
            }

            // addPortListener(newPortOut,newPortOutPatch);
            addPortListener(newPortOutPatch, newPortOut);
        }
    }

    dataLoaded = true;
}

op.addNewInPort = function (otherPort, type, objType)
{
    const newName = "in" + data.ports.length + " " + otherPort.op.name + " " + otherPort.name;

    const o = { "name": newName, "type": otherPort.type };
    if (otherPort.uiAttribs.objType)o.objType = otherPort.uiAttribs.objType;

    data.ports.push(o);
    setupPorts();
    return newName;
};

op.dyn.onLinkChanged = function ()
{
    if (op.dyn.isLinked())
    {
        const otherPort = op.dyn.links[0].getOtherPort(op.dyn);
        op.dyn.removeLinks();
        otherPort.removeLinkTo(op.dyn);

        op.log("dyn link changed!!!");

        // const newName = "in" + data.ports.length + " " + otherPort.op.name + " " + otherPort.name;

        // const o = { "name": newName, "type": otherPort.type };
        // if (otherPort.uiAttribs.objType)o.objType = otherPort.uiAttribs.objType;
        // data.ports.push(o);

        // setupPorts();

        const newName = op.addNewInPort(otherPort);

        const l = gui.scene().link(
            otherPort.op,
            otherPort.getName(),
            op,
            newName
        );

        dataLoaded = true;
        saveData();
    }
    else
    {
        setTimeout(function ()
        {
            op.dyn.removeLinks();
        }, 100);
    }
};

op.addNewOutPort = function (otherPort, type, objType)
{
    const newName = "out" + data.portsOut.length + " " + otherPort.op.name + " " + otherPort.name;

    const o = { "name": newName, "type": otherPort.type };
    if (otherPort.uiAttribs.objType)o.objType = otherPort.uiAttribs.objType;

    data.portsOut.push(o);
    setupPorts();
    return newName;
};

op.dynOut.onLinkChanged = function ()
{
    if (op.dynOut.isLinked())
    {
        const otherPort = op.dynOut.links[0].getOtherPort(op.dynOut);
        op.dynOut.removeLinks();
        otherPort.removeLinkTo(op.dynOut);

        const newName = op.addNewOutPort(otherPort);

        gui.scene().link(
            otherPort.op,
            otherPort.getName(),
            op,
            newName
        );

        dataLoaded = true;
        saveData();
    }
    else
    {
        setTimeout(function ()
        {
            op.dynOut.removeLinks();
        }, 100);

        op.log("dynOut unlinked...");
    }
};

function getSubPatchOutputOp()
{
    let patchOutputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchOutput");

    if (!patchOutputOP)
    {
        op.patch.addOp("Ops.Ui.PatchOutput", { "subPatch": op.patchId.get(), "translate": { "x": 0, "y": 0 } });
        patchOutputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchOutput");
        if (!patchOutputOP) op.warn("no patchoutput!");
    }
    return patchOutputOP;
}

function getSubPatchInputOp()
{
    let patchInputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchInput");

    if (!patchInputOP)
    {
        op.patch.addOp("Ops.Ui.PatchInput", { "subPatch": op.patchId.get(), "translate": { "x": 0, "y": 0 } });
        patchInputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchInput");
        if (!patchInputOP) op.warn("no patchinput2!");
    }

    return patchInputOP;
}

op.addSubLink = function (p, p2)
{
    const num = data.ports.length;
    const sublPortname = "in" + (num - 1) + " " + p2.op.name + " " + p2.name;

    if (p.direction == CABLES.PORT_DIR_IN)
    {
        gui.scene().link(
            p.op,
            p.getName(),
            getSubPatchInputOp(),
            sublPortname
        );
    }
    else
    {
        const numOut = data.portsOut.length;
        gui.scene().link(
            p.op,
            p.getName(),
            getSubPatchOutputOp(),
            "out" + (numOut - 1) + " " + p2.op.name + " " + p2.name
        );
    }

    const bounds = gui.patchView.getSubPatchBounds(op.patchId.get());

    getSubPatchInputOp().uiAttr(
        {
            "translate":
            {
                "x": bounds.minx,
                "y": bounds.miny - 100
            }
        });

    getSubPatchOutputOp().uiAttr(
        {
            "translate":
            {
                "x": bounds.minx,
                "y": bounds.maxy + 100
            }
        });
    saveData();
    return sublPortname;
};

op.onDelete = function ()
{
    for (let i = op.patch.ops.length - 1; i >= 0; i--)
    {
        if (op.patch.ops[i] && op.patch.ops[i].uiAttribs && op.patch.ops[i].uiAttribs.subPatch == op.patchId.get())
        {
            op.patch.deleteOp(op.patch.ops[i].id);
        }
    }
};

function makeBlueprint()
{
    let attribs = {
        "pasted": true,
        "translate": {
            "x": op.uiAttribs.translate.x - 150,
            "y": op.uiAttribs.translate.y
        }
    };

    if (CABLES.UI) attribs.subPatch = gui.patchView.getCurrentSubPatch();

    const bpOp = op.patch.addOp(CABLES.UI.DEFAULTOPNAMES.blueprint, attribs);
    bpOp.createBlueprint(gui.patchId, op.patchId.get(), true);
}

op.rebuildListeners = () =>
{
    op.log("rebuild listeners...");

    const outop = getSubPatchOutputOp();
    for (let i = 0; i < outop.portsIn.length; i++)
    {
        if (outop.portsIn[i].isLinked())
        {
            addPortListener(outop.portsIn[i], this.portsOut[i]);
        }
    }
};


};

Ops.Ui.SubPatch.prototype = new CABLES.Op();
CABLES.OPS["84d9a6f0-ed7a-466d-b386-225ed9e89c60"]={f:Ops.Ui.SubPatch,objName:"Ops.Ui.SubPatch"};




// **************************************************************
// 
// Ops.Array.ArrayGetArray
// 
// **************************************************************

Ops.Array.ArrayGetArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArrays = op.inArray("Array of Arrays"),
    index = op.inValueInt("Index"),
    result = op.outArray("Result Array");

inArrays.onChange =
index.onChange = update;

function update()
{
    let theArray = inArrays.get();
    if (!theArray)
    {
        result.set(null);
        return;
    }

    let ind = Math.floor(index.get());
    if (ind < 0 || ind > theArray.length - 1)
    {
        result.set(null);
        op.log("index wrong");
        return;
    }

    result.set(null);
    result.set(theArray[ind]);
}


};

Ops.Array.ArrayGetArray.prototype = new CABLES.Op();
CABLES.OPS["b9d3f42b-3fbf-4522-9df2-a5c769a92d66"]={f:Ops.Array.ArrayGetArray,objName:"Ops.Array.ArrayGetArray"};




// **************************************************************
// 
// Ops.Gl.Meshes.Rectangle_v4
// 
// **************************************************************

Ops.Gl.Meshes.Rectangle_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    doRender = op.inValueBool("Render Mesh", true),
    width = op.inValue("width", 1),
    height = op.inValue("height", 1),
    pivotX = op.inSwitch("pivot x", ["left", "center", "right"], "center"),
    pivotY = op.inSwitch("pivot y", ["top", "center", "bottom"], "center"),
    axis = op.inSwitch("axis", ["xy", "xz"], "xy"),
    flipTcX = op.inBool("Flip TexCoord X", false),
    flipTcY = op.inBool("Flip TexCoord Y", true),
    nColumns = op.inValueInt("num columns", 1),
    nRows = op.inValueInt("num rows", 1),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry", null, "geometry");

geomOut.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
const geom = new CGL.Geometry("rectangle");

doRender.setUiAttribs({ "title": "Render" });
render.setUiAttribs({ "title": "Trigger" });
trigger.setUiAttribs({ "title": "Next" });
op.setPortGroup("Pivot", [pivotX, pivotY, axis]);
op.setPortGroup("Size", [width, height]);
op.setPortGroup("Structure", [nColumns, nRows]);
op.toWorkPortsNeedToBeLinked(render);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_TRIGGER);

const AXIS_XY = 0;
const AXIS_XZ = 1;

let curAxis = AXIS_XY;
let mesh = null;
let needsRebuild = true;
let doScale = true;

const vScale = vec3.create();
vec3.set(vScale, 1, 1, 1);

axis.onChange =
    pivotX.onChange =
    pivotY.onChange =
    flipTcX.onChange =
    flipTcY.onChange =
    nRows.onChange =
    nColumns.onChange = rebuildLater;
updateScale();

width.onChange =
    height.onChange =
    () =>
    {
        if (doScale) updateScale();
        else needsRebuild = true;
    };

function updateScale()
{
    if (curAxis === AXIS_XY) vec3.set(vScale, width.get(), height.get(), 1);
    if (curAxis === AXIS_XZ) vec3.set(vScale, width.get(), 1, height.get());
}

geomOut.onLinkChanged = () =>
{
    doScale = !geomOut.isLinked();
    updateScale();
    needsRebuild = true;
};

function rebuildLater()
{
    needsRebuild = true;
}

render.onTriggered = () =>
{
    if (needsRebuild) rebuild();
    const cg = op.patch.cg;
    if (mesh && doRender.get())
    {
        if (doScale)
        {
            cg.pushModelMatrix();
            mat4.scale(cg.mMatrix, cg.mMatrix, vScale);
        }

        mesh.render(cg.getShader());

        if (doScale) cg.popModelMatrix();
    }

    trigger.trigger();
};

op.onDelete = () =>
{
    if (mesh) mesh.dispose();
    rebuildLater();
};

function rebuild()
{
    if (axis.get() == "xy") curAxis = AXIS_XY;
    if (axis.get() == "xz") curAxis = AXIS_XZ;

    updateScale();
    let w = width.get();
    let h = height.get();

    if (doScale) w = h = 1;

    let x = 0;
    let y = 0;

    if (pivotX.get() == "center") x = 0;
    else if (pivotX.get() == "right") x = -w / 2;
    else if (pivotX.get() == "left") x = +w / 2;

    if (pivotY.get() == "center") y = 0;
    else if (pivotY.get() == "top") y = -h / 2;
    else if (pivotY.get() == "bottom") y = +h / 2;

    const numRows = Math.max(1, Math.round(nRows.get()));
    const numColumns = Math.max(1, Math.round(nColumns.get()));

    const stepColumn = w / numColumns;
    const stepRow = h / numRows;

    const indices = [];
    const tc = new Float32Array((numColumns + 1) * (numRows + 1) * 2);
    const verts = new Float32Array((numColumns + 1) * (numRows + 1) * 3);
    const norms = new Float32Array((numColumns + 1) * (numRows + 1) * 3);
    const tangents = new Float32Array((numColumns + 1) * (numRows + 1) * 3);
    const biTangents = new Float32Array((numColumns + 1) * (numRows + 1) * 3);

    let idxTc = 0;
    let idxVert = 0;
    let idxNorms = 0;
    let idxTangent = 0;
    let idxBiTangent = 0;

    for (let r = 0; r <= numRows; r++)
    {
        for (let c = 0; c <= numColumns; c++)
        {
            verts[idxVert++] = c * stepColumn - w / 2 + x;
            if (curAxis == AXIS_XZ) verts[idxVert++] = 0;
            verts[idxVert++] = r * stepRow - h / 2 + y;

            if (curAxis == AXIS_XY)verts[idxVert++] = 0;

            tc[idxTc++] = c / numColumns;
            tc[idxTc++] = r / numRows;

            if (curAxis == AXIS_XY) // default
            {
                norms[idxNorms++] = 0;
                norms[idxNorms++] = 0;
                norms[idxNorms++] = 1;

                tangents[idxTangent++] = 1;
                tangents[idxTangent++] = 0;
                tangents[idxTangent++] = 0;

                biTangents[idxBiTangent++] = 0;
                biTangents[idxBiTangent++] = 1;
                biTangents[idxBiTangent++] = 0;
            }
            else if (curAxis == AXIS_XZ)
            {
                norms[idxNorms++] = 0;
                norms[idxNorms++] = 1;
                norms[idxNorms++] = 0;

                biTangents[idxBiTangent++] = 0;
                biTangents[idxBiTangent++] = 0;
                biTangents[idxBiTangent++] = 1;
            }
        }
    }

    indices.length = numColumns * numRows * 6;
    let idx = 0;

    for (let c = 0; c < numColumns; c++)
    {
        for (let r = 0; r < numRows; r++)
        {
            const ind = c + (numColumns + 1) * r;
            const v1 = ind;
            const v2 = ind + 1;
            const v3 = ind + numColumns + 1;
            const v4 = ind + 1 + numColumns + 1;

            if (curAxis == AXIS_XY) // default
            {
                indices[idx++] = v1;
                indices[idx++] = v2;
                indices[idx++] = v3;

                indices[idx++] = v3;
                indices[idx++] = v2;
                indices[idx++] = v4;
            }
            else
            if (curAxis == AXIS_XZ)
            {
                indices[idx++] = v1;
                indices[idx++] = v3;
                indices[idx++] = v2;

                indices[idx++] = v2;
                indices[idx++] = v3;
                indices[idx++] = v4;
            }
        }
    }

    if (flipTcY.get()) for (let i = 0; i < tc.length; i += 2)tc[i + 1] = 1.0 - tc[i + 1];
    if (flipTcX.get()) for (let i = 0; i < tc.length; i += 2)tc[i] = 1.0 - tc[i];

    geom.clear();
    geom.vertices = verts;
    geom.texCoords = tc;
    geom.verticesIndices = indices;
    geom.vertexNormals = norms;
    geom.tangents = tangents;
    geom.biTangents = biTangents;

    if (!mesh) mesh = op.patch.cg.createMesh(geom, { "opId": op.id });
    else mesh.setGeom(geom);

    geomOut.setRef(geom);
    needsRebuild = false;
}


};

Ops.Gl.Meshes.Rectangle_v4.prototype = new CABLES.Op();
CABLES.OPS["cc8c3ede-7103-410b-849f-a645793cab39"]={f:Ops.Gl.Meshes.Rectangle_v4,objName:"Ops.Gl.Meshes.Rectangle_v4"};




// **************************************************************
// 
// Ops.Trigger.Sequence
// 
// **************************************************************

Ops.Trigger.Sequence = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    cleanup = op.inTriggerButton("Clean up connections");

const
    exes = [],
    triggers = [],
    num = 16;

let
    updateTimeout = null,
    connectedOuts = [];

exe.onTriggered = triggerAll;
cleanup.onTriggered = clean;
cleanup.setUiAttribs({ "hideParam": true, "hidePort": true });

for (let i = 0; i < num; i++)
{
    const p = op.outTrigger("trigger " + i);
    triggers.push(p);
    p.onLinkChanged = updateButton;

    if (i < num - 1)
    {
        let newExe = op.inTrigger("exe " + i);
        newExe.onTriggered = triggerAll;
        exes.push(newExe);
    }
}

updateConnected();

function updateConnected()
{
    connectedOuts.length = 0;
    for (let i = 0; i < triggers.length; i++)
        if (triggers[i].links.length > 0) connectedOuts.push(triggers[i]);
}

function updateButton()
{
    updateConnected();
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() =>
    {
        let show = false;
        for (let i = 0; i < triggers.length; i++)
            if (triggers[i].links.length > 1) show = true;

        cleanup.setUiAttribs({ "hideParam": !show });

        if (op.isCurrentUiOp()) op.refreshParams();
    }, 60);
}

function triggerAll()
{
    // for (let i = 0; i < triggers.length; i++) triggers[i].trigger();
    for (let i = 0; i < connectedOuts.length; i++) connectedOuts[i].trigger();
}

function clean()
{
    let count = 0;
    for (let i = 0; i < triggers.length; i++)
    {
        let removeLinks = [];

        if (triggers[i].links.length > 1)
            for (let j = 1; j < triggers[i].links.length; j++)
            {
                while (triggers[count].links.length > 0) count++;

                removeLinks.push(triggers[i].links[j]);
                const otherPort = triggers[i].links[j].getOtherPort(triggers[i]);
                op.patch.link(op, "trigger " + count, otherPort.op, otherPort.name);
                count++;
            }

        for (let j = 0; j < removeLinks.length; j++) removeLinks[j].remove();
    }
    updateButton();
    updateConnected();
}


};

Ops.Trigger.Sequence.prototype = new CABLES.Op();
CABLES.OPS["a466bc1f-06e9-4595-8849-bffb9fe22f99"]={f:Ops.Trigger.Sequence,objName:"Ops.Trigger.Sequence"};




// **************************************************************
// 
// Ops.Array.FilterValidArray
// 
// **************************************************************

Ops.Array.FilterValidArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inLength = op.inBool("Invalid when length is 0", true),

    outArray = op.outArray("Last Valid Array"),
    outValid = op.outBoolNum("Is Valid");

inLength.onChange =
inArr.onChange =
    update;

function update()
{
    const arr = inArr.get();

    let r = true;

    if (!arr || !arr.length) r = false;
    else if (inLength.get() && arr.length == 0) r = false;

    if (r) outArray.setRef(arr);

    outValid.set(r);
}


};

Ops.Array.FilterValidArray.prototype = new CABLES.Op();
CABLES.OPS["f2669593-eb06-48a6-b94c-4bc243747ee1"]={f:Ops.Array.FilterValidArray,objName:"Ops.Array.FilterValidArray"};




// **************************************************************
// 
// Ops.Trigger.Repeat_v2
// 
// **************************************************************

Ops.Trigger.Repeat_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe=op.inTrigger("Execute"),
    num=op.inValueInt("Repeats",5),
    dir=op.inSwitch("Direction",['Forward','Backward'],'Forward'),
    next=op.outTrigger("Next"),
    idx=op.addOutPort(new CABLES.Port(op,"index"));

dir.onChange=updateDir;
updateDir();

function updateDir()
{
    if(dir.get()=="Forward") exe.onTriggered=forward;
    else exe.onTriggered=backward;
}

function forward()
{
    const max=Math.floor(num.get());

    for(var i=0;i<max;i++)
    {
        idx.set(i);
        next.trigger();
    }
}

function backward()
{
    const numi=Math.floor(num.get());
    for(var i=numi-1;i>-1;i--)
    {
        idx.set(i);
        next.trigger();
    }
}


};

Ops.Trigger.Repeat_v2.prototype = new CABLES.Op();
CABLES.OPS["a4deea80-db97-478f-ad1a-5ee30f2f47cc"]={f:Ops.Trigger.Repeat_v2,objName:"Ops.Trigger.Repeat_v2"};




// **************************************************************
// 
// Ops.Gl.Matrix.Transform
// 
// **************************************************************

Ops.Gl.Matrix.Transform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    posX = op.inValue("posX", 0),
    posY = op.inValue("posY", 0),
    posZ = op.inValue("posZ", 0),
    scale = op.inValue("scale", 1),
    rotX = op.inValue("rotX", 0),
    rotY = op.inValue("rotY", 0),
    rotZ = op.inValue("rotZ", 0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Rotation", [rotX, rotY, rotZ]);
op.setPortGroup("Position", [posX, posY, posZ]);
op.setPortGroup("Scale", [scale]);
op.setUiAxisPorts(posX, posY, posZ);

op.toWorkPortsNeedToBeLinked(render, trigger);

const vPos = vec3.create();
const vScale = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

let
    doScale = false,
    doTranslate = false,
    translationChanged = true,
    scaleChanged = true,
    rotChanged = true;

rotX.onChange = rotY.onChange = rotZ.onChange = setRotChanged;
posX.onChange = posY.onChange = posZ.onChange = setTranslateChanged;
scale.onChange = setScaleChanged;

render.onTriggered = function ()
{
    // if(!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    let updateMatrix = false;
    if (translationChanged)
    {
        updateTranslation();
        updateMatrix = true;
    }
    if (scaleChanged)
    {
        updateScale();
        updateMatrix = true;
    }
    if (rotChanged) updateMatrix = true;

    if (updateMatrix) doUpdateMatrix();

    const cg = op.patch.cg || op.patch.cgl;
    cg.pushModelMatrix();
    mat4.multiply(cg.mMatrix, cg.mMatrix, transMatrix);

    trigger.trigger();
    cg.popModelMatrix();

    if (CABLES.UI && CABLES.UI.showCanvasTransforms) gui.setTransform(op.id, posX.get(), posY.get(), posZ.get());

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": posX,
                "posY": posY,
                "posZ": posZ,
            });
};

op.transform3d = function ()
{
    return { "pos": [posX, posY, posZ] };
};

function doUpdateMatrix()
{
    mat4.identity(transMatrix);
    if (doTranslate)mat4.translate(transMatrix, transMatrix, vPos);

    if (rotX.get() !== 0)mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    if (rotY.get() !== 0)mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    if (rotZ.get() !== 0)mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    if (doScale)mat4.scale(transMatrix, transMatrix, vScale);
    rotChanged = false;
}

function updateTranslation()
{
    doTranslate = false;
    if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0) doTranslate = true;
    vec3.set(vPos, posX.get(), posY.get(), posZ.get());
    translationChanged = false;
}

function updateScale()
{
    // doScale=false;
    // if(scale.get()!==0.0)
    doScale = true;
    vec3.set(vScale, scale.get(), scale.get(), scale.get());
    scaleChanged = false;
}

function setTranslateChanged()
{
    translationChanged = true;
}

function setScaleChanged()
{
    scaleChanged = true;
}

function setRotChanged()
{
    rotChanged = true;
}

doUpdateMatrix();


};

Ops.Gl.Matrix.Transform.prototype = new CABLES.Op();
CABLES.OPS["650baeb1-db2d-4781-9af6-ab4e9d4277be"]={f:Ops.Gl.Matrix.Transform,objName:"Ops.Gl.Matrix.Transform"};




// **************************************************************
// 
// Ops.Array.ArrayGetNumber
// 
// **************************************************************

Ops.Array.ArrayGetNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value = op.outNumber("value");

array.ignoreValueSerialize = true;

index.onChange = array.onChange = update;

function update()
{
    if (array.get())
    {
        let input = array.get()[index.get()];
        if (isNaN(input))
        {
            value.set(0);
            return;
        }
        value.set(parseFloat(input));
    }
}


};

Ops.Array.ArrayGetNumber.prototype = new CABLES.Op();
CABLES.OPS["d1189078-70cf-437d-9a37-b2ebe89acdaf"]={f:Ops.Array.ArrayGetNumber,objName:"Ops.Array.ArrayGetNumber"};




// **************************************************************
// 
// Ops.Gl.Matrix.ScaleXYZ
// 
// **************************************************************

Ops.Gl.Matrix.ScaleXYZ = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    scaleX = op.inValueFloat("x", 1),
    scaleY = op.inValueFloat("y", 1),
    scaleZ = op.inValueFloat("z", 1),
    trigger = op.outTrigger("trigger");

const vScale = vec3.create();

let hasChanged = true;

scaleX.onChange = scaleY.onChange = scaleZ.onChange = scaleChanged;

scaleChanged();

render.onTriggered = execrender;

function execrender()
{
    const cgl = op.patch.cg || op.patch.cgl;

    if (hasChanged)
    {
        vec3.set(vScale, scaleX.get(), scaleY.get(), scaleZ.get());
        hasChanged = false;
    }

    cgl.pushModelMatrix();
    mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);
    trigger.trigger();
    cgl.popModelMatrix();
}

function scaleChanged()
{
    hasChanged = true;
}


};

Ops.Gl.Matrix.ScaleXYZ.prototype = new CABLES.Op();
CABLES.OPS["9ba52457-5f0d-4b20-a97c-4ec4856b8e29"]={f:Ops.Gl.Matrix.ScaleXYZ,objName:"Ops.Gl.Matrix.ScaleXYZ"};




// **************************************************************
// 
// Ops.Gl.Shader.BasicMaterial_v3
// 
// **************************************************************

Ops.Gl.Shader.BasicMaterial_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"basicmaterial_frag":"{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IR\n                col.a*=1.0-texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n","basicmaterial_vert":"\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       mvMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        mvMatrix=viewMatrix * mMatrix;\n    #endif\n\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * mvMatrix * pos;\n    #endif\n}\n",};
const render = op.inTrigger("render");

const trigger = op.outTrigger("trigger");
const shaderOut = op.outObject("shader", null, "shader");

shaderOut.ignoreValueSerialize = true;

op.toWorkPortsNeedToBeLinked(render);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "basicmaterialnew", this);
shader.addAttribute({ "type": "vec3", "name": "vPosition" });
shader.addAttribute({ "type": "vec2", "name": "attrTexCoord" });
shader.addAttribute({ "type": "vec3", "name": "attrVertNormal", "nameFrag": "norm" });
shader.addAttribute({ "type": "float", "name": "attrVertIndex" });

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

shader.setSource(attachments.basicmaterial_vert, attachments.basicmaterial_frag);

shaderOut.setRef(shader);

render.onTriggered = doRender;

// rgba colors
const r = op.inValueSlider("r", Math.random());
const g = op.inValueSlider("g", Math.random());
const b = op.inValueSlider("b", Math.random());
const a = op.inValueSlider("a", 1);
r.setUiAttribs({ "colorPick": true });

// const uniColor=new CGL.Uniform(shader,'4f','color',r,g,b,a);
const colUni = shader.addUniformFrag("4f", "color", r, g, b, a);

shader.uniformColorDiffuse = colUni;

// diffuse outTexture

const diffuseTexture = op.inTexture("texture");
let diffuseTextureUniform = null;
diffuseTexture.onChange = updateDiffuseTexture;

const colorizeTexture = op.inValueBool("colorizeTexture", false);
const vertexColors = op.inValueBool("Vertex Colors", false);

// opacity texture
const textureOpacity = op.inTexture("textureOpacity");
let textureOpacityUniform = null;

const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A", "1-A", "1-R"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });
textureOpacity.onChange = updateOpacity;

const texCoordAlpha = op.inValueBool("Opacity TexCoords Transform", false);
const discardTransPxl = op.inValueBool("Discard Transparent Pixels");

// texture coords
const
    diffuseRepeatX = op.inValue("diffuseRepeatX", 1),
    diffuseRepeatY = op.inValue("diffuseRepeatY", 1),
    diffuseOffsetX = op.inValue("Tex Offset X", 0),
    diffuseOffsetY = op.inValue("Tex Offset Y", 0),
    cropRepeat = op.inBool("Crop TexCoords", false);

shader.addUniformFrag("f", "diffuseRepeatX", diffuseRepeatX);
shader.addUniformFrag("f", "diffuseRepeatY", diffuseRepeatY);
shader.addUniformFrag("f", "texOffsetX", diffuseOffsetX);
shader.addUniformFrag("f", "texOffsetY", diffuseOffsetY);

const doBillboard = op.inValueBool("billboard", false);

alphaMaskSource.onChange =
    doBillboard.onChange =
    discardTransPxl.onChange =
    texCoordAlpha.onChange =
    cropRepeat.onChange =
    vertexColors.onChange =
    colorizeTexture.onChange = updateDefines;

op.setPortGroup("Color", [r, g, b, a]);
op.setPortGroup("Color Texture", [diffuseTexture, vertexColors, colorizeTexture]);
op.setPortGroup("Opacity", [textureOpacity, alphaMaskSource, discardTransPxl, texCoordAlpha]);
op.setPortGroup("Texture Transform", [diffuseRepeatX, diffuseRepeatY, diffuseOffsetX, diffuseOffsetY, cropRepeat]);

updateOpacity();
updateDiffuseTexture();

op.preRender = function ()
{
    shader.bind();
    doRender();
};

function doRender()
{
    if (!shader) return;

    cgl.pushShader(shader);
    shader.popTextures();

    if (diffuseTextureUniform && diffuseTexture.get()) shader.pushTexture(diffuseTextureUniform, diffuseTexture.get());
    if (textureOpacityUniform && textureOpacity.get()) shader.pushTexture(textureOpacityUniform, textureOpacity.get());

    trigger.trigger();

    cgl.popShader();
}

function updateOpacity()
{
    if (textureOpacity.get())
    {
        if (textureOpacityUniform !== null) return;
        shader.removeUniform("texOpacity");
        shader.define("HAS_TEXTURE_OPACITY");
        if (!textureOpacityUniform)textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity");
    }
    else
    {
        shader.removeUniform("texOpacity");
        shader.removeDefine("HAS_TEXTURE_OPACITY");
        textureOpacityUniform = null;
    }

    updateDefines();
}

function updateDiffuseTexture()
{
    if (diffuseTexture.get())
    {
        if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))shader.define("HAS_TEXTURE_DIFFUSE");
        if (!diffuseTextureUniform)diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse");
    }
    else
    {
        shader.removeUniform("texDiffuse");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        diffuseTextureUniform = null;
    }
    updateUi();
}

function updateUi()
{
    diffuseRepeatX.setUiAttribs({ "greyout": !diffuseTexture.get() });
    diffuseRepeatY.setUiAttribs({ "greyout": !diffuseTexture.get() });
    diffuseOffsetX.setUiAttribs({ "greyout": !diffuseTexture.get() });
    diffuseOffsetY.setUiAttribs({ "greyout": !diffuseTexture.get() });
    colorizeTexture.setUiAttribs({ "greyout": !diffuseTexture.get() });

    alphaMaskSource.setUiAttribs({ "greyout": !textureOpacity.get() });
    texCoordAlpha.setUiAttribs({ "greyout": !textureOpacity.get() });

    let notUsingColor = true;
    notUsingColor = diffuseTexture.get() && !colorizeTexture.get();
    r.setUiAttribs({ "greyout": notUsingColor });
    g.setUiAttribs({ "greyout": notUsingColor });
    b.setUiAttribs({ "greyout": notUsingColor });
}

function updateDefines()
{
    shader.toggleDefine("VERTEX_COLORS", vertexColors.get());
    shader.toggleDefine("CROP_TEXCOORDS", cropRepeat.get());
    shader.toggleDefine("COLORIZE_TEXTURE", colorizeTexture.get());
    shader.toggleDefine("TRANSFORMALPHATEXCOORDS", texCoordAlpha.get());
    shader.toggleDefine("DISCARDTRANS", discardTransPxl.get());
    shader.toggleDefine("BILLBOARD", doBillboard.get());

    shader.toggleDefine("ALPHA_MASK_ALPHA", alphaMaskSource.get() == "A");
    shader.toggleDefine("ALPHA_MASK_IALPHA", alphaMaskSource.get() == "1-A");
    shader.toggleDefine("ALPHA_MASK_IR", alphaMaskSource.get() == "1-R");
    shader.toggleDefine("ALPHA_MASK_LUMI", alphaMaskSource.get() == "Luminance");
    shader.toggleDefine("ALPHA_MASK_R", alphaMaskSource.get() == "R");
    shader.toggleDefine("ALPHA_MASK_G", alphaMaskSource.get() == "G");
    shader.toggleDefine("ALPHA_MASK_B", alphaMaskSource.get() == "B");
    updateUi();
}


};

Ops.Gl.Shader.BasicMaterial_v3.prototype = new CABLES.Op();
CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"]={f:Ops.Gl.Shader.BasicMaterial_v3,objName:"Ops.Gl.Shader.BasicMaterial_v3"};




// **************************************************************
// 
// Ops.Array.RandomNumbersArray_v4
// 
// **************************************************************

Ops.Array.RandomNumbersArray_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    numValues = op.inValueInt("Num Values", 100),
    inModeSwitch = op.inSwitch("Mode", ["A", "AB", "ABC", "ABCD"], "A"),
    inSeed = op.inValueFloat("Random Seed ", 0),
    inInteger = op.inBool("Integer", false),
    inClosed = op.inValueBool("Last == First"),
    outValues = op.outArray("Array Out"),
    outTotalPoints = op.outNumber("Chunks Amount"),
    outArrayLength = op.outNumber("Array length");

const letters = ["A", "B", "C", "D"];
const arr = [];

const inArray = letters.map(function (value)
{
    return {
        "min": op.inValueFloat("Min " + value, -1),
        "max": op.inValueFloat("Max " + value, 1),
    };
});

for (let i = 0; i < inArray.length; i += 1)
{
    const portObj = inArray[i];
    const keys = Object.keys(portObj);

    op.setPortGroup("Value Range " + letters[i], keys.map(function (key) { return portObj[key]; }));

    if (i > 0) keys.forEach(function (key) { portObj[key].setUiAttribs({ "greyout": true }); });
}

inModeSwitch.onChange = function ()
{
    const mode = inModeSwitch.get();
    const modes = inModeSwitch.uiAttribs.values;

    outValues.setUiAttribs({ "stride": inModeSwitch.get().length });

    const index = modes.indexOf(mode);

    inArray.forEach(function (portObj, i)
    {
        const keys = Object.keys(portObj);
        keys.forEach(function (key, j)
        {
            if (i <= index) portObj[key].setUiAttribs({ "greyout": false });
            else portObj[key].setUiAttribs({ "greyout": true });
        });
    });
    init();
};

outValues.ignoreValueSerialize = true;

inClosed.onChange =
    numValues.onChange =
    inSeed.onChange =
    inInteger.onChange = init;

const minMaxArray = [];

init();

function init()
{
    const mode = inModeSwitch.get();
    const modes = inModeSwitch.uiAttribs.values;
    const index = modes.indexOf(mode);

    const n = Math.floor(Math.abs(numValues.get()));
    Math.randomSeed = inSeed.get();

    op.setUiAttrib({ "extendTitle": n + "*" + mode.length });

    const dimension = index + 1;
    const length = n * dimension;

    arr.length = length;
    const tupleLength = length / dimension;
    const isInteger = inInteger.get();

    // optimization: we only need to fetch the max min for each component once
    for (let i = 0; i < dimension; i += 1)
    {
        const portObj = inArray[i];
        const max = portObj.max.get();
        const min = portObj.min.get();
        minMaxArray[i] = [min, max];
    }

    for (let j = 0; j < tupleLength; j += 1)
    {
        for (let k = 0; k < dimension; k += 1)
        {
            const min = minMaxArray[k][0];
            const max = minMaxArray[k][1];
            const index = j * dimension + k;

            if (isInteger) arr[index] = Math.floor(Math.seededRandom() * ((max + 1) - min) + min);
            else arr[index] = Math.seededRandom() * (max - min) + min;
        }
    }

    if (inClosed.get() && arr.length > dimension)
    {
        for (let i = 0; i < dimension; i++)
            arr[arr.length - 3 + i] = arr[i];
    }

    outValues.setRef(arr);
    outTotalPoints.set(arr.length / dimension);
    outArrayLength.set(arr.length);
}

// assign change handler
inArray.forEach(function (obj)
{
    Object.keys(obj).forEach(function (key)
    {
        const x = obj[key];
        x.onChange = init;
    });
});


};

Ops.Array.RandomNumbersArray_v4.prototype = new CABLES.Op();
CABLES.OPS["8a9fa2c6-c229-49a9-9dc8-247001539217"]={f:Ops.Array.RandomNumbersArray_v4,objName:"Ops.Array.RandomNumbersArray_v4"};




// **************************************************************
// 
// Ops.Array.ArrayToArrays
// 
// **************************************************************

Ops.Array.ArrayToArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inStride = op.inInt("Stride", 6),
    outArr = op.outArray("Result");

inStride.onChange =
inArr.onChange = () =>
{
    const stride = inStride.get();

    const result = [];
    const arr = inArr.get();
    if (!arr || stride <= 0) return outArr.set(null);

    let count = 0;
    for (let i = 0; i < arr.length; i += stride)
    {
        const newArr = [];
        for (let j = 0; j < stride; j++)
        {
            newArr[j] = arr[i + j] || 0;
        }
        result[count] = newArr;
        count++;
    }

    outArr.setRef(result);
};


};

Ops.Array.ArrayToArrays.prototype = new CABLES.Op();
CABLES.OPS["037a9886-c185-4ab2-8c7e-b9f85b1e678c"]={f:Ops.Array.ArrayToArrays,objName:"Ops.Array.ArrayToArrays"};




// **************************************************************
// 
// Ops.Vars.VariablesAsObject
// 
// **************************************************************

Ops.Vars.VariablesAsObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exec = op.inTriggerButton("Execute"),
    prefix = op.inString("Filter Prefix", ""),
    result = op.outObject("Result");

exec.onTriggered = update;

function update()
{
    let r = {};
    const vars = op.patch.getVars();
    const pre = prefix.get();
    for (let i in vars)
    {
        if (i.indexOf(pre) === 0 && typeof (vars[i].getValue()) != "object")
        {
            const newName = i.substr(pre.length);
            r[newName] = vars[i].getValue();
        }
    }

    result.setRef(r);
}


};

Ops.Vars.VariablesAsObject.prototype = new CABLES.Op();
CABLES.OPS["b8726368-9628-42e1-8d98-d88469c1c475"]={f:Ops.Vars.VariablesAsObject,objName:"Ops.Vars.VariablesAsObject"};




// **************************************************************
// 
// Ops.Json.ObjectValuesAsArray
// 
// **************************************************************

Ops.Json.ObjectValuesAsArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inObj = op.inObject("Object"),
    outValues = op.outArray("Values"),
    outNumValues = op.outNumber("Num values");

inObj.onChange = () =>
{
    const sourceObj = inObj.get();
    if (!sourceObj)
    {
        outNumValues.set(0);
        outValues.set([]);
        return;
    }

    const values = Object.values(sourceObj);
    outNumValues.set(values.length);
    outValues.set(values);
};


};

Ops.Json.ObjectValuesAsArray.prototype = new CABLES.Op();
CABLES.OPS["32ff73f5-7947-42b0-83fa-e079af7beb5c"]={f:Ops.Json.ObjectValuesAsArray,objName:"Ops.Json.ObjectValuesAsArray"};




// **************************************************************
// 
// Ops.Array.ArraySetArray
// 
// **************************************************************

Ops.Array.ArraySetArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const exe=op.inTriggerButton("exe"),
    array=op.inArray("array"),
    index=op.inValueInt("index"),
    value=op.inArray("new Array"),
    values=op.outArray("values");

values.ignoreValueSerialize=true;

function updateIndex()
{
    if(exe.isLinked())return;
    update();
}

function copyArray(source)
{
    var dest=[];
    dest.length=source.length;
    for (var i = 0, n = source.length; i < n; i++) dest[i] = source[i];

    return dest;
}


function update()
{
    if(!array.get() || !value.get())return;
    array.get()[index.get()]=copyArray(value.get());

    values.set(null);
    values.set(array.get());
}

exe.onTriggered=update;


};

Ops.Array.ArraySetArray.prototype = new CABLES.Op();
CABLES.OPS["58ddcecb-3917-4118-81d3-344ee2b75469"]={f:Ops.Array.ArraySetArray,objName:"Ops.Array.ArraySetArray"};




// **************************************************************
// 
// Ops.Ui.VizArrayTable
// 
// **************************************************************

Ops.Ui.VizArrayTable = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inOffset = op.inInt("Start Row", 0);

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true, "vizLayerMaxZoom": 2500 });

function getCellValue(v)
{
    let str = "";

    if (typeof v == "string")
    {
        // if (CABLES.UTILS.isNumeric(v)) str = "\"" + v + "\"";
        // else str = v;
        str = "\"" + v + "\"";
    }
    else if (CABLES.UTILS.isNumeric(v)) str = String(Math.round(v * 10000) / 10000);
    else if (Array.isArray(v))
    {
        let preview = "...";
        if (v.length == 0) preview = "";
        str = "[" + preview + "] (" + v.length + ")";
    }
    else if (typeof v == "object")
    {
        try
        {
            str = JSON.stringify(v, true, 1);
        }
        catch (e)
        {
            str = "{???}";
        }
    }
    else if (v != v || v === undefined)
    {
        str += String(v);
    }
    else
    {
        str += String(v);
    }

    return str;
}

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";

    const arr = inArr.get() || [];
    let stride = 1;

    if (inArr.get() === null) op.setUiAttrib({ "extendTitle": "null" });
    else if (inArr.get() === undefined) op.setUiAttrib({ "extendTitle": "undefined" });
    else op.setUiAttrib({ "extendTitle": "length: " + arr.length });

    if (inArr.links.length > 0 && inArr.links[0].getOtherPort(inArr))
        stride = inArr.links[0].getOtherPort(inArr).uiAttribs.stride || 1;

    let lines = Math.floor(layer.height / layer.scale / 10 - 1);
    let padding = 4;
    let offset = inOffset.get() * stride;
    let columnsWidth = [];

    for (let i = 0; i < stride; i++)columnsWidth[i] = 0;

    for (let i = offset; i < offset + lines * stride; i += stride)
    {
        for (let s = 0; s < stride; s++)
        {
            const v = arr[i + s];

            columnsWidth[s] = Math.max(columnsWidth[s], getCellValue(v).length);
        }
    }

    let columsPos = [];
    let addUpPos = 30;
    for (let i = 0; i < stride; i++)
    {
        columsPos[i] = addUpPos;
        addUpPos += (columnsWidth[i] + 1) * 7;
    }

    for (let i = offset; i < offset + lines * stride; i += stride)
    {
        if (i < 0) continue;
        if (i + stride > arr.length) continue;

        ctx.fillStyle = "#666";

        const lineNum = (i) / stride;

        if (lineNum >= 0)
            ctx.fillText(lineNum,
                layer.x / layer.scale + padding,
                layer.y / layer.scale + 10 + (i - offset) / stride * 10 + padding);

        for (let s = 0; s < stride; s++)
        {
            const v = arr[i + s];
            let str = getCellValue(v);

            ctx.fillStyle = "#ccc";

            if (typeof v == "string")
            {
            }
            else if (CABLES.UTILS.isNumeric(v)) str = String(Math.round(v * 10000) / 10000);
            else if (Array.isArray(v))
            {
            }
            else if (typeof v == "object")
            {
            }
            else if (v != v || v === undefined)
            {
                ctx.fillStyle = "#f00";
            }

            ctx.fillText(str,
                layer.x / layer.scale + columsPos[s],
                layer.y / layer.scale + 10 + (i - offset) / stride * 10 + padding);
        }
    }

    if (inArr.get() === null) ctx.fillText("null", layer.x / layer.scale + 10, layer.y / layer.scale + 10 + padding);
    else if (inArr.get() === undefined) ctx.fillText("undefined", layer.x / layer.scale + 10, layer.y / layer.scale + 10 + padding);

    const gradHeight = 30;

    if (layer.scale <= 0) return;
    if (offset > 0)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + 5, 0, layer.y / layer.scale + gradHeight);
        radGrad.addColorStop(0, "#222");
        radGrad.addColorStop(1, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale, 200000, gradHeight);
    }

    if (offset + lines * stride < arr.length)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + 5, 0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + gradHeight);
        radGrad.addColorStop(1, "#222");
        radGrad.addColorStop(0, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale + layer.height / layer.scale - gradHeight, 200000, gradHeight);
    }

    ctx.restore();
};


};

Ops.Ui.VizArrayTable.prototype = new CABLES.Op();
CABLES.OPS["af2eeaaf-ff86-4bfb-9a27-42f05160a5d8"]={f:Ops.Ui.VizArrayTable,objName:"Ops.Ui.VizArrayTable"};




// **************************************************************
// 
// Ops.Array.InfoArray
// 
// **************************************************************

Ops.Array.InfoArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    outMin = op.outNumber("Min"),
    outMax = op.outNumber("Max"),
    outAvg = op.outNumber("Average");

inArr.onChange = function ()
{
    let arr = inArr.get();

    let min = 999999999;
    let max = -999999999;
    let avg = 0;

    if (arr)
    {
        for (let i = 0; i < arr.length; i++)
        {
            avg += arr[i];
            min = Math.min(min, arr[i]);
            max = Math.max(max, arr[i]);
        }
        avg /= arr.length;
    }
    outMin.set(min);
    outMax.set(max);
    outAvg.set(avg);
};


};

Ops.Array.InfoArray.prototype = new CABLES.Op();
CABLES.OPS["1db230c8-212f-4679-87d6-3531659363da"]={f:Ops.Array.InfoArray,objName:"Ops.Array.InfoArray"};




// **************************************************************
// 
// Ops.Math.Round
// 
// **************************************************************

Ops.Math.Round = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number"),
    decPlaces = op.inInt("Decimal Places", 0),
    result = op.outNumber("result");

let decm = 0;

number1.onChange = exec;
decPlaces.onChange = updateDecm;

updateDecm();

function updateDecm()
{
    decm = Math.pow(10, decPlaces.get());
    exec();
}

function exec()
{
    result.set(Math.round(number1.get() * decm) / decm);
}


};

Ops.Math.Round.prototype = new CABLES.Op();
CABLES.OPS["1a1ef636-6d02-42ba-ae1e-627b917d0d2b"]={f:Ops.Math.Round,objName:"Ops.Math.Round"};




// **************************************************************
// 
// Ops.Html.CSS_v2
// 
// **************************************************************

Ops.Html.CSS_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const code = op.inStringEditor("css code");

code.setUiAttribs(
    {
        "editorSyntax": "css",
        "ignoreBigPort": true
    });

let styleEle = null;
const eleId = "css_" + CABLES.uuid();

code.onChange = update;
update();

function getCssContent()
{
    let css = code.get();
    if (css)
    {
        let patchId = null;
        if (op.storage && op.storage.blueprint && op.storage.blueprint.patchId)
        {
            patchId = op.storage.blueprint.patchId;
        }
        css = css.replace(new RegExp("{{ASSETPATH}}", "g"), op.patch.getAssetPath(patchId));
    }
    return css;
}

function update()
{
    styleEle = op.patch.getDocument().getElementById(eleId);

    if (styleEle)
    {
        styleEle.textContent = getCssContent();
    }
    else
    {
        styleEle = op.patch.getDocument().createElement("style");
        styleEle.type = "text/css";
        styleEle.id = eleId;
        styleEle.textContent = attachments.css_spinner;
        styleEle.classList.add("cablesEle");

        const head = op.patch.getDocument().getElementsByTagName("body")[0];
        head.appendChild(styleEle);
    }
}

op.onDelete = function ()
{
    styleEle = op.patch.getDocument().getElementById(eleId);
    if (styleEle)styleEle.remove();
};


};

Ops.Html.CSS_v2.prototype = new CABLES.Op();
CABLES.OPS["a56d3edd-06ad-44ed-9810-dbf714600c67"]={f:Ops.Html.CSS_v2,objName:"Ops.Html.CSS_v2"};




// **************************************************************
// 
// Ops.Ui.VizObject
// 
// **************************************************************

Ops.Ui.VizObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inObj = op.inObject("Object"),
    inConsole = op.inTriggerButton("console log"),
    inZoomText = op.inBool("ZoomText", false),
    inLineNums = op.inBool("Line Numbers", true),
    inFontSize = op.inFloat("Font Size", 10),
    inPos = op.inFloatSlider("Scroll", 0);

let lines = [];
inConsole.setUiAttribs({ "hidePort": true });

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true, "vizLayerMaxZoom": 2500 });

inObj.onChange = () =>
{
    op.checkMainloopExists();
    let obj = inObj.get();
    let str = "???";

    if (obj && obj.getInfo)
    {
        obj = obj.getInfo();
    }

    if (obj && obj.constructor && obj.constructor.name != "Object")
    {
        op.setUiAttribs({ "extendTitle": obj.constructor.name });
    }

    try
    {
        str = JSON.stringify(obj, false, 4);

        if (
            obj.hasOwnProperty("isTrusted") && Object.keys(obj).length == 1 ||
            (str == "{}" && obj && obj.constructor && obj.constructor.name != "Object"))
        {
            str = "could not stringify object: " + obj.constructor.name + "\n";

            const o = {};
            for (const i in obj)
            {
                if (!obj[i]) continue;

                if (obj[i].constructor)
                {
                    if (obj[i].constructor.name == "Number" || obj[i].constructor.name == "String" || obj[i].constructor.name == "Boolean")
                        o[i] = obj[i];
                }
                else
                    o[i] = "{???}";
            }
            obj = o;
            str = JSON.stringify(obj, false, 4);
        }
    }
    catch (e)
    {
        str = "object can not be displayed as string", e.msg;
    }

    if (str === undefined)str = "undefined";
    if (str === null)str = "null";
    str = String(str);
    lines = str.split("\n");
};

inObj.onLinkChanged = () =>
{
    if (inObj.isLinked())
    {
        const p = inObj.links[0].getOtherPort(inObj);

        op.setUiAttrib({ "extendTitle": p.uiAttribs.objType });
    }
};

inConsole.onTriggered = () =>
{
    console.log(inObj.get());
};

op.renderVizLayer = (ctx, layer, viz) =>
{
    viz.clear(ctx, layer);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    viz.renderText(ctx, layer, lines, {
        "zoomText": inZoomText.get(),
        "showLineNum": inLineNums.get(),
        "syntax": "json",
        "fontSize": inFontSize.get(),
        "scroll": inPos.get()
    });

    ctx.restore();
};

//


};

Ops.Ui.VizObject.prototype = new CABLES.Op();
CABLES.OPS["d09bc53e-9f52-4872-94c7-4ef777512222"]={f:Ops.Ui.VizObject,objName:"Ops.Ui.VizObject"};




// **************************************************************
// 
// Ops.Sidebar.Group
// 
// **************************************************************

Ops.Sidebar.Group = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// inputs
let parentPort = op.inObject("link");
let labelPort = op.inString("Text", "Group");
const inShowTitle = op.inBool("Show Title", true);
let defaultMinimizedPort = op.inValueBool("Default Minimized");
const inVisible = op.inBool("Visible", true);

// outputs
let nextPort = op.outObject("next");
let childrenPort = op.outObject("childs");

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// vars
let el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("sidebar__group");
onDefaultMinimizedPortChanged();
let header = document.createElement("div");
header.classList.add("sidebar__group-header");
header.classList.add("cablesEle");
el.appendChild(header);
header.addEventListener("click", onClick);
let headerTitle = document.createElement("div");
headerTitle.classList.add("sidebar__group-header-title");
// headerTitle.textContent = labelPort.get();
header.appendChild(headerTitle);
let headerTitleText = document.createElement("span");
headerTitleText.textContent = labelPort.get();
headerTitleText.classList.add("sidebar__group-header-title-text");
headerTitle.appendChild(headerTitleText);
let icon = document.createElement("span");
icon.classList.add("sidebar__group-header-icon");
icon.classList.add("iconsidebar-chevron-up");
headerTitle.appendChild(icon);
let groupItems = document.createElement("div");
groupItems.classList.add("sidebar__group-items");
el.appendChild(groupItems);
op.toWorkPortsNeedToBeLinked(parentPort);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultMinimizedPort.onChange = onDefaultMinimizedPortChanged;
op.onDelete = onDelete;

// functions

inShowTitle.onChange = () =>
{
    if (inShowTitle.get())header.style.display = "block";
    else header.style.display = "none";
};

function onDefaultMinimizedPortChanged()
{
    if (defaultMinimizedPort.get())
    {
        el.classList.add("sidebar__group--closed");
    }
    else
    {
        el.classList.remove("sidebar__group--closed");
    }
}

function onClick(ev)
{
    ev.stopPropagation();
    el.classList.toggle("sidebar__group--closed");
}

function onLabelTextChanged()
{
    let labelText = labelPort.get();
    headerTitleText.textContent = labelText;
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": labelText });
}

function onParentChanged()
{
    childrenPort.set(null);
    let parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        childrenPort.set({
            "parentElement": groupItems,
            "parentOp": op,
        });
        nextPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.Group.prototype = new CABLES.Op();
CABLES.OPS["86ea2333-b51c-48ed-94c2-8b7b6e9ff34c"]={f:Ops.Sidebar.Group,objName:"Ops.Sidebar.Group"};




// **************************************************************
// 
// Ops.Vars.VarSetString_v2
// 
// **************************************************************

Ops.Vars.VarSetString_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val=op.inString("Value","New String");
op.varName=op.inDropDown("Variable",[],"",true);

new CABLES.VarSetOpWrapper(op,"string",val,op.varName);




};

Ops.Vars.VarSetString_v2.prototype = new CABLES.Op();
CABLES.OPS["0b4d9229-8024-4a30-9cc0-f6653942c2e4"]={f:Ops.Vars.VarSetString_v2,objName:"Ops.Vars.VarSetString_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetString
// 
// **************************************************************

Ops.Vars.VarGetString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
var val=op.outString("Value");
op.varName=op.inValueSelect("Variable",[],"",true);

new CABLES.VarGetOpWrapper(op,"string",op.varName,val);


};

Ops.Vars.VarGetString.prototype = new CABLES.Op();
CABLES.OPS["3ad08cfc-bce6-4175-9746-fef2817a3b12"]={f:Ops.Vars.VarGetString,objName:"Ops.Vars.VarGetString"};




// **************************************************************
// 
// Ops.String.ParseFloat
// 
// **************************************************************

Ops.String.ParseFloat = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    str = op.inString("String", 5711),
    outNum = op.outNumber("Number");

str.onChange = function ()
{
    let num = parseFloat(str.get());
    if (num != num) num = 0;
    outNum.set(num);
};


};

Ops.String.ParseFloat.prototype = new CABLES.Op();
CABLES.OPS["fa36a56b-a64d-4269-9a9e-addc16493006"]={f:Ops.String.ParseFloat,objName:"Ops.String.ParseFloat"};




// **************************************************************
// 
// Ops.Devices.Keyboard.KeyPressLearn
// 
// **************************************************************

Ops.Devices.Keyboard.KeyPressLearn = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const learnedKeyCode = op.inValueInt("key code");
const canvasOnly = op.inValueBool("canvas only", true);
const modKey = op.inValueSelect("Mod Key", ["none", "alt"], "none");
const inEnable = op.inValueBool("Enabled", true);
const preventDefault = op.inValueBool("Prevent Default");
const learn = op.inTriggerButton("learn");
const onPress = op.outTrigger("on press");
const onRelease = op.outTrigger("on release");
const outPressed = op.outBoolNum("Pressed", false);
const outKey = op.outString("Key");

const cgl = op.patch.cgl;
let learning = false;

modKey.onChange = learnedKeyCode.onChange = updateKeyName;

function onKeyDown(e)
{
    if (learning)
    {
        learnedKeyCode.set(e.keyCode);
        if (CABLES.UI)
        {
            op.refreshParams();
        }
        // op.log("Learned key code: " + learnedKeyCode.get());
        learning = false;
        removeListeners();
        addListener();

        if (CABLES.UI)gui.emitEvent("portValueEdited", op, learnedKeyCode, learnedKeyCode.get());
    }
    else
    {
        if (e.keyCode == learnedKeyCode.get())
        {
            if (modKey.get() == "alt")
            {
                if (e.altKey === true)
                {
                    onPress.trigger();
                    outPressed.set(true);
                    if (preventDefault.get())e.preventDefault();
                }
            }
            else
            {
                onPress.trigger();
                outPressed.set(true);
                if (preventDefault.get())e.preventDefault();
            }
        }
    }
}

function onKeyUp(e)
{
    if (e.keyCode == learnedKeyCode.get())
    {
        let doTrigger = true;
        if (modKey.get() == "alt" && e.altKey != true) doTrigger = false;

        if (doTrigger)
        {
            onRelease.trigger();
            outPressed.set(false);
        }
    }
}

op.onDelete = function ()
{
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    document.removeEventListener("keydown", onKeyDown, false);
};

learn.onTriggered = function ()
{
    // op.log("Listening for key...");
    learning = true;
    addDocumentListener();

    setTimeout(function ()
    {
        learning = false;
        removeListeners();
        addListener();
    }, 3000);
};

function addListener()
{
    if (canvasOnly.get()) addCanvasListener();
    else addDocumentListener();
}

function removeListeners()
{
    document.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
    outPressed.set(false);
}

function addCanvasListener()
{
    if (!CABLES.UTILS.isNumeric(cgl.canvas.getAttribute("tabindex"))) cgl.canvas.setAttribute("tabindex", 1);

    cgl.canvas.addEventListener("keydown", onKeyDown, false);
    cgl.canvas.addEventListener("keyup", onKeyUp, false);
}

function addDocumentListener()
{
    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("keyup", onKeyUp, false);
}

inEnable.onChange = function ()
{
    if (!inEnable.get())
    {
        removeListeners();
    }
    else
    {
        addListener();
    }
};

canvasOnly.onChange = function ()
{
    removeListeners();
    addListener();
};

function updateKeyName()
{
    let keyName = CABLES.keyCodeToName(learnedKeyCode.get());
    const modKeyName = modKey.get();
    if (modKeyName && modKeyName !== "none")
    {
        keyName = modKeyName.charAt(0).toUpperCase() + modKeyName.slice(1) + "-" + keyName;
    }
    op.setUiAttribs({ "extendTitle": keyName });
    outKey.set(keyName);
}

addCanvasListener();


};

Ops.Devices.Keyboard.KeyPressLearn.prototype = new CABLES.Op();
CABLES.OPS["f069c0db-4051-4eae-989e-6ef7953787fd"]={f:Ops.Devices.Keyboard.KeyPressLearn,objName:"Ops.Devices.Keyboard.KeyPressLearn"};




// **************************************************************
// 
// Ops.String.NumberToString_v2
// 
// **************************************************************

Ops.String.NumberToString_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    val = op.inValue("Number"),
    result = op.outString("Result");

val.onChange = update;
update();

function update()
{
    result.set(String(val.get() || 0));
}


};

Ops.String.NumberToString_v2.prototype = new CABLES.Op();
CABLES.OPS["5c6d375a-82db-4366-8013-93f56b4061a9"]={f:Ops.String.NumberToString_v2,objName:"Ops.String.NumberToString_v2"};




// **************************************************************
// 
// Ops.Sidebar.SidebarText_v2
// 
// **************************************************************

Ops.Sidebar.SidebarText_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Value");
const inId = op.inValueString("Id", "");

// outputs
const siblingsPort = op.outObject("childs");

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createElement("div");// document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inId.onChange = onIdChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// functions

function onIdChanged()
{
    el.id = inId.get();
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.innerHTML = labelText;
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.SidebarText_v2.prototype = new CABLES.Op();
CABLES.OPS["cc591cc3-ff23-4817-907c-e5be7d5c059d"]={f:Ops.Sidebar.SidebarText_v2,objName:"Ops.Sidebar.SidebarText_v2"};




// **************************************************************
// 
// Ops.Number.GateNumber
// 
// **************************************************************

Ops.Number.GateNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const valueInPort = op.inValue("Value In", 0);
const passThroughPort = op.inValueBool("Pass Through");
const valueOutPort = op.outNumber("Value Out");

valueInPort.onChange = update;
passThroughPort.onChange = update;

valueInPort.changeAlways = true;
valueOutPort.changeAlways = true;

function update()
{
    if (passThroughPort.get())
    {
        valueOutPort.set(valueInPort.get());
    }
}


};

Ops.Number.GateNumber.prototype = new CABLES.Op();
CABLES.OPS["594105c8-1fdb-4f3c-bbd5-29b9ad6b33e0"]={f:Ops.Number.GateNumber,objName:"Ops.Number.GateNumber"};




// **************************************************************
// 
// Ops.Html.DivElement_v3
// 
// **************************************************************

Ops.Html.DivElement_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inText = op.inString("Text", "Hello Div"),
    inId = op.inString("Id"),
    inClass = op.inString("Class"),
    inStyle = op.inStringEditor("Style", "position:absolute;\nz-index:100;", "inline-css"),
    inInteractive = op.inValueBool("Interactive", false),
    inVisible = op.inValueBool("Visible", true),
    inBreaks = op.inValueBool("Convert Line Breaks", false),
    inPropagation = op.inValueBool("Propagate Click-Events", true),
    outElement = op.outObject("DOM Element", null, "element"),
    outHover = op.outBoolNum("Hover"),
    outClicked = op.outTrigger("Clicked");

let listenerElement = null;
let oldStr = null;
let prevDisplay = "block";
let div = null;

const canvas = op.patch.cgl.canvas.parentElement;

createElement();

inClass.onChange = updateClass;
inBreaks.onChange = inText.onChange = updateText;
inStyle.onChange = updateStyle;
inInteractive.onChange = updateInteractive;
inVisible.onChange = updateVisibility;

updateText();
updateStyle();
warning();
updateInteractive();

op.onDelete = removeElement;

outElement.onLinkChanged = updateStyle;

function createElement()
{
    div = op.patch.getDocument().createElement("div");
    div.dataset.op = op.id;
    div.classList.add("cablesEle");

    if (inId.get()) div.id = inId.get();

    canvas.appendChild(div);
    outElement.set(div);
}

function removeElement()
{
    if (div) removeClasses();
    if (div && div.parentNode) div.parentNode.removeChild(div);
    oldStr = null;
    div = null;
}

function setCSSVisible(visible)
{
    if (!visible)
    {
        div.style.visibility = "hidden";
        prevDisplay = div.style.display || "block";
        div.style.display = "none";
    }
    else
    {
        // prevDisplay=div.style.display||'block';
        if (prevDisplay == "none") prevDisplay = "block";
        div.style.visibility = "visible";
        div.style.display = prevDisplay;
    }
}

function updateVisibility()
{
    setCSSVisible(inVisible.get());
}

function updateText()
{
    let str = inText.get();

    if (oldStr === str) return;
    oldStr = str;

    if (str && inBreaks.get()) str = str.replace(/(?:\r\n|\r|\n)/g, "<br>");

    if (div.innerHTML != str) div.innerHTML = str;
    outElement.set(null);
    outElement.set(div);
}

// inline css inisde div
function updateStyle()
{
    if (!div) return;
    // if (inStyle.get() != div.style)
    // {
    div.setAttribute("style", inStyle.get());
    updateVisibility();
    outElement.set(null);
    outElement.set(div);
    // }

    if (!div.parentElement)
    {
        canvas.appendChild(div);
    }

    warning();
}

let oldClassesStr = "";

function removeClasses()
{
    if (!div) return;

    const classes = (inClass.get() || "").split(" ");
    for (let i = 0; i < classes.length; i++)
    {
        if (classes[i]) div.classList.remove(classes[i]);
    }
    oldClassesStr = "";
}

function updateClass()
{
    const classes = (inClass.get() || "").split(" ");
    const oldClasses = (oldClassesStr || "").split(" ");

    let found = false;

    for (let i = 0; i < oldClasses.length; i++)
    {
        if (
            oldClasses[i] &&
            classes.indexOf(oldClasses[i].trim()) == -1)
        {
            found = true;
            div.classList.remove(oldClasses[i]);
        }
    }

    for (let i = 0; i < classes.length; i++)
    {
        if (classes[i])
        {
            div.classList.add(classes[i].trim());
        }
    }

    oldClassesStr = inClass.get();
    warning();
}

function onMouseEnter(e)
{
    outHover.set(true);
}

function onMouseLeave(e)
{
    outHover.set(false);
}

function onMouseClick(e)
{
    if (!inPropagation.get())
    {
        e.stopPropagation();
    }
    outClicked.trigger();
}

function updateInteractive()
{
    removeListeners();
    if (inInteractive.get()) addListeners();
}

inId.onChange = function ()
{
    div.id = inId.get();
};

function removeListeners()
{
    if (listenerElement)
    {
        listenerElement.removeEventListener("pointerdown", onMouseClick);
        listenerElement.removeEventListener("pointerleave", onMouseLeave);
        listenerElement.removeEventListener("pointerenter", onMouseEnter);
        listenerElement = null;
    }
}

function addListeners()
{
    if (listenerElement)removeListeners();

    listenerElement = div;

    if (listenerElement)
    {
        listenerElement.addEventListener("pointerdown", onMouseClick);
        listenerElement.addEventListener("pointerleave", onMouseLeave);
        listenerElement.addEventListener("pointerenter", onMouseEnter);
    }
}

op.addEventListener("onEnabledChange", function (enabled)
{
    removeElement();
    if (enabled)
    {
        createElement();
        updateStyle();
        updateClass();
        updateText();
        updateInteractive();
    }
    // if(enabled) updateVisibility();
    // else setCSSVisible(false);
});

function warning()
{
    if (inClass.get() && inStyle.get())
    {
        op.setUiError("error", "Element uses external and inline CSS", 1);
    }
    else
    {
        op.setUiError("error", null);
    }
}


};

Ops.Html.DivElement_v3.prototype = new CABLES.Op();
CABLES.OPS["d55d398c-e68e-486b-b0ce-d9c4bdf7df05"]={f:Ops.Html.DivElement_v3,objName:"Ops.Html.DivElement_v3"};




// **************************************************************
// 
// Ops.String.StringEditor
// 
// **************************************************************

Ops.String.StringEditor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inStringEditor("value", ""),
    syntax = op.inValueSelect("Syntax", ["text", "glsl", "css", "html", "xml", "json", "javascript", "inline-css", "sql"], "text"),
    result = op.outString("Result");

syntax.onChange = updateSyntax;

function updateSyntax()
{
    let s = syntax.get();
    if (s == "javascript")s = "js";
    v.setUiAttribs({ "editorSyntax": s });
}

v.onChange = function ()
{
    result.set(v.get());
};


};

Ops.String.StringEditor.prototype = new CABLES.Op();
CABLES.OPS["6468b7c1-f63e-4db4-b809-4b203d27ead3"]={f:Ops.String.StringEditor,objName:"Ops.String.StringEditor"};




// **************************************************************
// 
// Ops.Html.ElementFadeInOut
// 
// **************************************************************

Ops.Html.ElementFadeInOut = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"fadeInOut_css":"\n.CABLES_animFadedOut_$CLASSES_ID\n{\n    display:none !important;\n    opacity:0;\n}\n\n.CABLES_animFadeOut_$CLASSES_ID\n{\n    animation: CABLES_keysFadeOut_$CLASSES_ID $LENGTHs normal forwards ease-in-out;\n}\n\n.CABLES_animFadeIn_$CLASSES_ID\n{\n    animation: CABLES_keysFadeIn_$CLASSES_ID $LENGTHs normal forwards ease-in-out;\n}\n\n@keyframes CABLES_keysFadeIn_$CLASSES_ID {\n    from { opacity: 0; }\n    to   { opacity: $FULLOPACITY; }\n}\n\n@keyframes CABLES_keysFadeOut_$CLASSES_ID {\n    from { opacity: $FULLOPACITY; }\n    to   { opacity: 0; }\n}\n",};
const
    inEle = op.inObject("HTML Element"),
    inVisible = op.inValueBool("Visible", true),
    inDuration = op.inValue("Duration", 0.5),
    inOpacity = op.inValue("Opacity", 1),
    outShowing = op.outBoolNum("Is Showing", false);

let theTimeout = null;
let oldEle = null;
let loaded = true;
const oldvis = null;
loaded = true;

inDuration.onChange =
    inOpacity.onChange = update;

inVisible.onChange =
    inEle.onChange = updateVisibility;

let styleEle = null;
const eleId = "css_" + CABLES.uuid();
const cssClassesId = CABLES.shortId();

const animFadeInClass = "CABLES_animFadeIn_" + cssClassesId;
const animFadedOutClass = "CABLES_animFadedOut_" + cssClassesId;
const animFadeOutClass = "CABLES_animFadeOut_" + cssClassesId;

update();

op.onLoaded = function ()
{
    loaded = true;
    updateVisibility();
    outShowing.set(inVisible.get());
};

function updateVisibility()
{
    const ele = inEle.get();

    if (!loaded)
    {
        setTimeout(updateVisibility, 50);
        return;
    }

    if (styleEle && ele)
    {
        // if (ele == oldEle) return;
        // oldEle = ele;
        if (inVisible.get())
        {
            outShowing.set(true);
            if (ele && ele.classList && !ele.classList.contains(animFadeInClass))
            {
                clearTimeout(theTimeout);
                ele.classList.remove(animFadedOutClass);
                ele.classList.remove(animFadeOutClass);
                ele.classList.add(animFadeInClass);
                theTimeout = setTimeout(function ()
                {
                    ele.classList.remove(animFadeInClass);
                    outShowing.set(true);
                }, inDuration.get() * 1000);
            }
        }
        else
        {
            outShowing.set(true);
            if (ele && ele.classList && !ele.classList.contains(animFadedOutClass))
            {
                clearTimeout(theTimeout);
                ele.classList.remove(animFadeInClass);
                ele.classList.add(animFadeOutClass);
                theTimeout = setTimeout(function ()
                {
                    ele.classList.add(animFadedOutClass);
                    outShowing.set(false);
                }, inDuration.get() * 1000);
            }
        }
    }
    else
    {
        // op.logError("no html element");
    }
}

function getCssContent()
{
    let css = attachments.fadeInOut_css;

    while (css.indexOf("$LENGTH") > -1)css = css.replace("$LENGTH", inDuration.get());
    while (css.indexOf("$FULLOPACITY") > -1)css = css.replace("$FULLOPACITY", inOpacity.get());
    while (css.indexOf("$CLASSES_ID") > -1)css = css.replace("$CLASSES_ID", cssClassesId);

    return css;
}

function update()
{
    styleEle = document.getElementById(eleId);

    if (styleEle)
    {
        styleEle.textContent = getCssContent();
    }
    else
    {
        styleEle = document.createElement("style");
        styleEle.type = "text/css";
        styleEle.id = eleId;
        styleEle.classList.add("cablesEle");
        styleEle.textContent = getCssContent();

        const head = document.getElementsByTagName("body")[0];
        head.appendChild(styleEle);
    }
}

op.onDelete = function ()
{
    const ele = inEle.get();

    if (ele && ele.classList)
    {
        ele.classList.remove(animFadeInClass);
        ele.classList.remove(animFadedOutClass);
        ele.classList.remove(animFadeOutClass);
    }

    styleEle = document.getElementById(eleId);
    if (styleEle)styleEle.remove();
};


};

Ops.Html.ElementFadeInOut.prototype = new CABLES.Op();
CABLES.OPS["392e65eb-4ebe-4adb-8711-e4cfe059c6c9"]={f:Ops.Html.ElementFadeInOut,objName:"Ops.Html.ElementFadeInOut"};




// **************************************************************
// 
// Ops.Html.TransformCSS3DElement
// 
// **************************************************************

Ops.Html.TransformCSS3DElement = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    cgl = op.patch.cgl,
    origins = [
	    "top-left", "top-middle", "top-right",
	    "center-left", "center-middle", "center-right",
	    "bottom-left", "bottom-middle", "bottom-right"
    ],
    trigger = op.inTrigger("trigger"),
    inElement = op.inObject("DOMElement"),
    inOrigin = op.inValueSelect("origin", origins, "center-middle"),
    next = op.outTrigger("next"),
    sCSSMatrix = mat4.create(),
    sScalingVector = vec3.create();
op.uuid = CABLES.uuid();
let oldEle = null;

let elProjection = cgl.canvas.parentElement.querySelector("[data-provide=\"css3d\"]");
if (!elProjection)
{
    elProjection = document.createElement("div");
    elProjection.dataset.op = op.id;
    elProjection.style.position = "absolute";
    elProjection.style.top = elProjection.style.left = 0;
    elProjection.style.width = elProjection.style.height = "100%";
    elProjection.dataset.provide = "css3d";
    elProjection.style.zIndex = 1000;
    elProjection.style.pointerEvents = "none";
    elProjection.style.perspectiveOrigin = "center center";
    cgl.canvas.parentElement.appendChild(elProjection);

    let style = document.createElement("style");
    style.dataset.op = op.id;
    style.type = "text/css";
    style.textContent = [
	    ".cables-loading .cables-css3dview {visibility:hidden;pointer-events:none;backface-visibility:hidden;}",
	    ".cables-css3dview {position:absolute;left:0;top:0;width:100%;height:100%;transform-style:preserve-3d;}",
        ".cables-css3dview > * {pointer-events:auto;}",
        ".cables-css3dview.origin-top-left > * {}",
        ".cables-css3dview.origin-top-middle > * {transform:translate3d(-50%,0,0);}",
        ".cables-css3dview.origin-top-right > * {transform:translate3d(-100%,0,0);}",
        ".cables-css3dview.origin-center-left > * {transform:translate3d(0,-50%,0);}",
        ".cables-css3dview.origin-center-middle > * {transform:translate3d(-50%,-50%,0);}",
        ".cables-css3dview.origin-center-right > * {transform:translate3d(-100%,-50%,0);}",
        ".cables-css3dview.origin-bottom-left > * {transform:translate3d(0,-100%,0);}",
        ".cables-css3dview.origin-bottom-middle > * {transform:translate3d(-50%,-100%,0);}",
        ".cables-css3dview.origin-bottom-right > * {transform:translate3d(-100%,-100%,0);}"
    ].join("\n");
    elProjection.appendChild(style);
}

op.onDelete = function ()
{
    let el = elProjection.querySelector("[data-ccs3did=\"" + op.uuid + "\"]");
    if (el && el.parentElement) el.parentElement.removeChild(el);
};

function wrap(el)
{
    let view = document.createElement("div");
    view.classList.add("cables-css3dview");
    view.dataset.css3did = op.uuid;
    view.appendChild(el);
    return view;
}

inElement.onChange = function (self, el)
{
    op.onDelete();
    if (!el) return;
    elProjection.appendChild(wrap(el));
    inOrigin.onChange();
};
inOrigin.onChange = function ()
{
    let el = inElement.get();
    if (!el || !el.parentElement) return;
    DOMTokenList.prototype.remove.apply(el.parentElement.classList, origins.map(function (o) { return "origin-" + o; }));
    el.parentElement.classList.add("origin-" + inOrigin.get());
};
trigger.onTriggered = function ()
{
    let pxfov = 0.5 / (1 / cgl.pMatrix[5]) * cgl.gl.drawingBufferHeight / op.patch.cgl.pixelDensity;
    elProjection.style.perspective = pxfov + "px";
    let a = -2 * cgl.gl.drawingBufferWidth / cgl.gl.drawingBufferHeight;
    vec3.set(
        sScalingVector,
        a / cgl.gl.drawingBufferWidth / op.patch.cgl.pixelDensity,
        -2 / cgl.gl.drawingBufferHeight / op.patch.cgl.pixelDensity,
        1
    );
    let el = inElement.get();
    if (el)
    {
        mat4.multiply(
            sCSSMatrix,
            cgl.vMatrix,
            cgl.mMatrix
        );
        mat4.scale(
            sCSSMatrix,
            sCSSMatrix,
            sScalingVector
        );
        if (el.parentElement)
    		el.parentElement.style.transform = "translateZ(" + pxfov + "px) matrix3d(" +
    			sCSSMatrix[0] + "," +
    			-sCSSMatrix[1] + "," +
    			sCSSMatrix[2] + "," +
    			sCSSMatrix[3] + "," +
    			sCSSMatrix[4] + "," +
    			-sCSSMatrix[5] + "," +
    			sCSSMatrix[6] + "," +
    			sCSSMatrix[7] + "," +
    			sCSSMatrix[8] + "," +
    			-sCSSMatrix[9] + "," +
    			sCSSMatrix[10] + "," +
    			sCSSMatrix[11] + "," +
    			sCSSMatrix[12] + "," +
    			-sCSSMatrix[13] + "," +
    			sCSSMatrix[14] + "," +
    			sCSSMatrix[15] +
    		") scaleX(-1) translate3d(" +
    			cgl.gl.drawingBufferWidth / 2 / op.patch.cgl.pixelDensity + "px," +
    			cgl.gl.drawingBufferHeight / 2 / op.patch.cgl.pixelDensity + "px" +
    			",0" +
    		")";
    }
    next.trigger();
    oldEle = el;
};
inOrigin.onChange();

function removeProperties(el)
{
    if (!el)el = inElement.get();
    if (el && el.parentElement)el.parentElement.style.transform = "";
}

op.onDelete = function ()
{
    removeProperties(oldEle);
};

inElement.onLinkChanged = function ()
{
    if (!inElement.isLinked())
        removeProperties(oldEle);
};

op.addEventListener("onEnabledChange", function (enabled)
{
    if (!enabled) removeProperties();
});


};

Ops.Html.TransformCSS3DElement.prototype = new CABLES.Op();
CABLES.OPS["7b81ed97-6fb9-4044-a731-962a2a11db27"]={f:Ops.Html.TransformCSS3DElement,objName:"Ops.Html.TransformCSS3DElement"};




// **************************************************************
// 
// Ops.Boolean.ToggleBool_v2
// 
// **************************************************************

Ops.Boolean.ToggleBool_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    trigger = op.inTriggerButton("trigger"),
    reset = op.inTriggerButton("reset"),
    inDefault = op.inBool("Default", false),
    outBool = op.outBoolNum("result");

let theBool = false;

op.onLoadedValueSet = () =>
{
    outBool.set(inDefault.get());
};

trigger.onTriggered = function ()
{
    theBool = !theBool;
    outBool.set(theBool);
};

reset.onTriggered = function ()
{
    theBool = inDefault.get();
    outBool.set(theBool);
};


};

Ops.Boolean.ToggleBool_v2.prototype = new CABLES.Op();
CABLES.OPS["4313d9bb-96b6-43bc-9190-6068cfb2593c"]={f:Ops.Boolean.ToggleBool_v2,objName:"Ops.Boolean.ToggleBool_v2"};




// **************************************************************
// 
// Ops.Array.ArrayAbs
// 
// **************************************************************

Ops.Array.ArrayAbs = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
let inArray = op.inArray("In");
let outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inArray.onChange = function ()
{
    let arr = inArray.get();

    if (!arr) return;

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.abs(arr[i]);
    }
    outArray.setRef(newArr);
};


};

Ops.Array.ArrayAbs.prototype = new CABLES.Op();
CABLES.OPS["f3629406-f393-4b2d-970e-cf47a0c5ca75"]={f:Ops.Array.ArrayAbs,objName:"Ops.Array.ArrayAbs"};




// **************************************************************
// 
// Ops.Number.TriggerOnChangeNumber
// 
// **************************************************************

Ops.Number.TriggerOnChangeNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inval = op.inFloat("Value"),
    next = op.outTrigger("Next"),
    number = op.outNumber("Number");

inval.onChange = function ()
{
    number.set(inval.get());
    next.trigger();
};


};

Ops.Number.TriggerOnChangeNumber.prototype = new CABLES.Op();
CABLES.OPS["f5c8c433-ce13-49c4-9a33-74e98f110ed0"]={f:Ops.Number.TriggerOnChangeNumber,objName:"Ops.Number.TriggerOnChangeNumber"};




// **************************************************************
// 
// Ops.Gl.MainLoop
// 
// **************************************************************

Ops.Gl.MainLoop = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    fpsLimit = op.inValue("FPS Limit", 0),
    trigger = op.outTrigger("trigger"),
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    reduceFocusFPS = op.inValueBool("Reduce FPS not focussed", true),
    reduceLoadingFPS = op.inValueBool("Reduce FPS loading"),
    clear = op.inValueBool("Clear", true),
    clearAlpha = op.inValueBool("ClearAlpha", true),
    fullscreen = op.inValueBool("Fullscreen Button", false),
    active = op.inValueBool("Active", true),
    hdpi = op.inValueBool("Hires Displays", false),
    inUnit = op.inSwitch("Pixel Unit", ["Display", "CSS"], "Display");

op.onAnimFrame = render;
hdpi.onChange = function ()
{
    if (hdpi.get()) op.patch.cgl.pixelDensity = window.devicePixelRatio;
    else op.patch.cgl.pixelDensity = 1;

    op.patch.cgl.updateSize();
    if (CABLES.UI) gui.setLayout();
};

active.onChange = function ()
{
    op.patch.removeOnAnimFrame(op);

    if (active.get())
    {
        op.setUiAttrib({ "extendTitle": "" });
        op.onAnimFrame = render;
        op.patch.addOnAnimFrame(op);
        op.log("adding again!");
    }
    else
    {
        op.setUiAttrib({ "extendTitle": "Inactive" });
    }
};

const cgl = op.patch.cgl;
let rframes = 0;
let rframeStart = 0;
let timeOutTest = null;
let addedListener = false;

if (!op.patch.cgl) op.uiAttr({ "error": "No webgl cgl context" });

const identTranslate = vec3.create();
vec3.set(identTranslate, 0, 0, 0);
const identTranslateView = vec3.create();
vec3.set(identTranslateView, 0, 0, -2);

fullscreen.onChange = updateFullscreenButton;
setTimeout(updateFullscreenButton, 100);
let fsElement = null;

let winhasFocus = true;
let winVisible = true;

window.addEventListener("blur", () => { winhasFocus = false; });
window.addEventListener("focus", () => { winhasFocus = true; });
document.addEventListener("visibilitychange", () => { winVisible = !document.hidden; });
testMultiMainloop();

cgl.mainloopOp = this;

inUnit.onChange = () =>
{
    width.set(0);
    height.set(0);
};

function getFpsLimit()
{
    if (reduceLoadingFPS.get() && op.patch.loading.getProgress() < 1.0) return 5;

    if (reduceFocusFPS.get())
    {
        if (!winVisible) return 10;
        if (!winhasFocus) return 30;
    }

    return fpsLimit.get();
}

function updateFullscreenButton()
{
    function onMouseEnter()
    {
        if (fsElement)fsElement.style.display = "block";
    }

    function onMouseLeave()
    {
        if (fsElement)fsElement.style.display = "none";
    }

    op.patch.cgl.canvas.addEventListener("mouseleave", onMouseLeave);
    op.patch.cgl.canvas.addEventListener("mouseenter", onMouseEnter);

    if (fullscreen.get())
    {
        if (!fsElement)
        {
            fsElement = document.createElement("div");

            const container = op.patch.cgl.canvas.parentElement;
            if (container)container.appendChild(fsElement);

            fsElement.addEventListener("mouseenter", onMouseEnter);
            fsElement.addEventListener("click", function (e)
            {
                if (CABLES.UI && !e.shiftKey) gui.cycleFullscreen();
                else cgl.fullScreen();
            });
        }

        fsElement.style.padding = "10px";
        fsElement.style.position = "absolute";
        fsElement.style.right = "5px";
        fsElement.style.top = "5px";
        fsElement.style.width = "20px";
        fsElement.style.height = "20px";
        fsElement.style.cursor = "pointer";
        fsElement.style["border-radius"] = "40px";
        fsElement.style.background = "#444";
        fsElement.style["z-index"] = "9999";
        fsElement.style.display = "none";
        fsElement.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 490 490\" style=\"width:20px;height:20px;\" xml:space=\"preserve\" width=\"512px\" height=\"512px\"><g><path d=\"M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z\" fill=\"#FFFFFF\"/><path d=\"M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z\" fill=\"#FFFFFF\"/><path d=\"M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z\" fill=\"#FFFFFF\"/><path d=\"M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z\" fill=\"#FFFFFF\"/></g></svg>";
    }
    else
    {
        if (fsElement)
        {
            fsElement.style.display = "none";
            fsElement.remove();
            fsElement = null;
        }
    }
}

op.onDelete = function ()
{
    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
};

function render(time)
{
    if (!active.get()) return;
    if (cgl.aborted || cgl.canvas.clientWidth === 0 || cgl.canvas.clientHeight === 0) return;

    op.patch.cg = cgl;

    if (hdpi.get())op.patch.cgl.pixelDensity = window.devicePixelRatio;

    const startTime = performance.now();

    op.patch.config.fpsLimit = getFpsLimit();

    if (cgl.canvasWidth == -1)
    {
        cgl.setCanvas(op.patch.config.glCanvasId);
        return;
    }

    if (cgl.canvasWidth != width.get() || cgl.canvasHeight != height.get())
    {
        let div = 1;
        if (inUnit.get() == "CSS")div = op.patch.cgl.pixelDensity;

        width.set(cgl.canvasWidth / div);
        height.set(cgl.canvasHeight / div);
    }

    if (CABLES.now() - rframeStart > 1000)
    {
        CGL.fpsReport = CGL.fpsReport || [];
        if (op.patch.loading.getProgress() >= 1.0 && rframeStart !== 0)CGL.fpsReport.push(rframes);
        rframes = 0;
        rframeStart = CABLES.now();
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;

    cgl.renderStart(cgl, identTranslate, identTranslateView);

    if (clear.get())
    {
        cgl.gl.clearColor(0, 0, 0, 1);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    }

    trigger.trigger();

    if (CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();

    if (CGL.Texture.previewTexture)
    {
        if (!CGL.Texture.texturePreviewer) CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(cgl);
        CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture);
    }
    cgl.renderEnd(cgl);

    op.patch.cg = null;

    if (clearAlpha.get())
    {
        cgl.gl.clearColor(1, 1, 1, 1);
        cgl.gl.colorMask(false, false, false, true);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        cgl.gl.colorMask(true, true, true, true);
    }

    if (!cgl.frameStore.phong)cgl.frameStore.phong = {};
    rframes++;

    op.patch.cgl.profileData.profileMainloopMs = performance.now() - startTime;
}

function testMultiMainloop()
{
    clearTimeout(timeOutTest);
    timeOutTest = setTimeout(
        () =>
        {
            if (op.patch.getOpsByObjName(op.name).length > 1)
            {
                op.setUiError("multimainloop", "there should only be one mainloop op!");
                if (!addedListener)addedListener = op.patch.addEventListener("onOpDelete", testMultiMainloop);
            }
            else op.setUiError("multimainloop", null, 1);
        }, 500);
}


};

Ops.Gl.MainLoop.prototype = new CABLES.Op();
CABLES.OPS["b0472a1d-db16-4ba6-8787-f300fbdc77bb"]={f:Ops.Gl.MainLoop,objName:"Ops.Gl.MainLoop"};




// **************************************************************
// 
// Ops.Gl.MeshInstancer_v4
// 
// **************************************************************

Ops.Gl.MeshInstancer_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"instancer_body_frag":"#define INSTANCING\n#ifdef COLORIZE_INSTANCES\n    #ifdef BLEND_MODE_MULTIPLY\n        col.rgb *= frag_instColor.rgb;\n        col.a *= frag_instColor.a;\n    #endif\n\n    #ifdef BLEND_MODE_ADD\n        col.rgb += frag_instColor.rgb;\n        col.a += frag_instColor.a;\n    #endif\n\n    #ifdef BLEND_MODE_NONE\n        col.rgb = frag_instColor.rgb;\n        col.a = frag_instColor.a;\n    #endif\n#endif\n","instancer_body_vert":"\n\n#ifdef HAS_TEXCOORDS\ntexCoord=(texCoord*instTexCoords.zw)+instTexCoords.xy;\n#endif\n\nmMatrix*=instMat;\npos.xyz*=MOD_scale;\n\n#ifdef HAS_COLORS\nfrag_instColor=instColor;\n#endif\n#ifndef HAS_COLORS\nfrag_instColor=vec4(1.0);\n#endif\n\n\nfrag_instIndex=instanceIndex;\n","instancer_head_frag":"IN vec4 frag_instColor;\n\n#ifdef WEBGL2\n    flat IN float frag_instIndex;\n#endif\n#ifdef WEBGL1\n    IN float frag_instIndex;\n#endif\n","instancer_head_vert":"\nIN vec4 instColor;\nIN mat4 instMat;\nIN vec4 instTexCoords;\nIN float instanceIndex;\nOUT mat4 instModelMat;\nOUT vec4 frag_instColor;\n\n#ifdef WEBGL2\n    flat OUT float frag_instIndex;\n#endif\n#ifdef WEBGL1\n    OUT float frag_instIndex;\n#endif\n\n\n\n#define INSTANCING\n\n",};
const
    exe = op.inTrigger("exe"),
    geom = op.inObject("geom", null, "geometry"),
    inScale = op.inValue("Scale", 1),
    doLimit = op.inValueBool("Limit Instances", false),
    inLimit = op.inValueInt("Limit", 100),
    inTranslates = op.inArray("positions", 3),
    inScales = op.inArray("Scale Array", 3),
    inRot = op.inArray("Rotations", 3),
    inRotMeth = op.inSwitch("Rotation Type", ["Euler", "Quaternions", "Normals"], "Euler"),
    inBlendMode = op.inSwitch("Material blend mode", ["Multiply", "Add", "Normal"], "Multiply"),
    inColor = op.inArray("Colors", 4),
    inTexCoords = op.inArray("TexCoords", 4),
    outTrigger = op.outTrigger("Trigger Out"),
    outNum = op.outNumber("Num");

op.setPortGroup("Limit Number of Instances", [inLimit, doLimit]);
op.setPortGroup("Parameters", [inScales, inRot, inTranslates, inRotMeth]);
op.toWorkPortsNeedToBeLinked(geom);
op.toWorkPortsNeedToBeLinked(exe);

geom.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
const m = mat4.create();
let
    matrixArray = new Float32Array(1),
    instColorArray = new Float32Array(1),
    instTexcoordArray = new Float32Array(1),
    mesh = null,
    recalc = true,
    num = 0,
    arrayChangedColor = true,
    arrayChangedTexcoords = true,
    arrayChangedTrans = true;

const mod = new CGL.ShaderModifier(cgl, op.name, { "opId": op.id });
mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "title": op.name,
    "priority": -2,
    "srcHeadVert": attachments.instancer_head_vert,
    "srcBodyVert": attachments.instancer_body_vert
});

mod.addModule({
    "name": "MODULE_COLOR",
    "priority": -2,
    "title": op.name,
    "srcHeadFrag": attachments.instancer_head_frag,
    "srcBodyFrag": attachments.instancer_body_frag,
});

mod.addUniformVert("f", "MOD_scale", inScale);

let needsUpdateDefines = true;
inBlendMode.onChange = () => { needsUpdateDefines = true; };
doLimit.onChange = updateLimit;
exe.onTriggered = doRender;
exe.onLinkChanged = function ()
{
    if (!exe.isLinked()) removeModule();
};

updateLimit();

inRot.onChange =
inScales.onChange =
inTranslates.onChange =
inRotMeth.onChange =
    function ()
    {
        arrayChangedTrans = true;
        recalc = true;
    };

inTexCoords.onChange = function ()
{
    arrayChangedTexcoords = true;
    recalc = true;
    needsUpdateDefines = true;
};

inColor.onChange = function ()
{
    arrayChangedColor = true;
    recalc = true;
    needsUpdateDefines = true;
};

function reset()
{
    arrayChangedColor = true,
    arrayChangedTrans = true;
    recalc = true;
}

function updateDefines()
{
    mod.toggleDefine("COLORIZE_INSTANCES", inColor.get());
    mod.toggleDefine("TEXCOORDS_INSTANCES", inTexCoords.get());
    mod.toggleDefine("BLEND_MODE_MULTIPLY", inBlendMode.get() === "Multiply");
    mod.toggleDefine("BLEND_MODE_ADD", inBlendMode.get() === "Add");
    mod.toggleDefine("BLEND_MODE_NONE", inBlendMode.get() === "Normal");
    needsUpdateDefines = false;
}

geom.onChange = function ()
{
    if (mesh)mesh.dispose();
    if (!geom.get())
    {
        mesh = null;
        return;
    }

    mesh = new CGL.Mesh(cgl, geom.get());
    reset();
};

function removeModule()
{

}

function setupArray()
{
    if (!mesh) return;

    let transforms = inTranslates.get();
    if (!transforms) transforms = [0, 0, 0];

    num = Math.floor(transforms.length / 3);

    if (needsUpdateDefines)updateDefines();

    const colArr = inColor.get();
    const tcArr = inTexCoords.get();
    const scales = inScales.get();
    const useQuats = inRotMeth.get() == "Quaternions";
    const useEuler = inRotMeth.get() == "Euler";
    const useNormals = inRotMeth.get() == "Normals";

    let stride = 3;
    if (useQuats)stride = 4;
    inRot.setUiAttribs({ "stride": stride });

    if (scales && scales.length != transforms.length) op.setUiError("lengthScales", "Scales array has wrong length");
    else op.setUiError("lengthScales", null);

    if (matrixArray.length != num * 16) matrixArray = new Float32Array(num * 16);
    if (instColorArray.length != num * 4)
    {
        arrayChangedColor = true;
        instColorArray = new Float32Array(num * 4);
    }
    if (instTexcoordArray.length != num * 4)
    {
        arrayChangedTexcoords = true;
        instTexcoordArray = new Float32Array(num * 4);
    }

    const rotArr = inRot.get();

    for (let i = 0; i < num; i++)
    {
        mat4.identity(m);

        mat4.translate(m, m, [
            transforms[i * 3],
            transforms[i * 3 + 1],
            transforms[i * 3 + 2]
        ]);

        if (rotArr)
        {
            if (useQuats)
            {
                const mq = mat4.create();
                const q = [rotArr[i * 4 + 0], rotArr[i * 4 + 1], rotArr[i * 4 + 2], rotArr[i * 4 + 3]];
                quat.normalize(q, q);
                mat4.fromQuat(mq, q);
                mat4.mul(m, m, mq);
            }
            else
            if (useNormals)
            {
                const n = [rotArr[i * 3 + 0], rotArr[i * 3 + 1], rotArr[i * 3 + 2]];
                const up = [1, 0, 0];
                const v = vec3.create();

                vec3.cross(v, up, n);
                vec3.normalize(v, v);

                const angle = Math.acos(vec3.dot(up, n));
                const q = quat.create();

                quat.setAxisAngle(q, v, angle);
                quat.normalize(q, q);

                const mq = mat4.create();

                mat4.fromQuat(mq, q);
                mat4.mul(m, m, mq);
            }
            if (useEuler)
            {
                mat4.rotateX(m, m, rotArr[i * 3 + 0] * CGL.DEG2RAD);
                mat4.rotateY(m, m, rotArr[i * 3 + 1] * CGL.DEG2RAD);
                mat4.rotateZ(m, m, rotArr[i * 3 + 2] * CGL.DEG2RAD);
            }
        }

        if (arrayChangedColor && colArr)
        {
            instColorArray[i * 4 + 0] = colArr[i * 4 + 0];
            instColorArray[i * 4 + 1] = colArr[i * 4 + 1];
            instColorArray[i * 4 + 2] = colArr[i * 4 + 2];
            instColorArray[i * 4 + 3] = colArr[i * 4 + 3];
        }

        if (arrayChangedTexcoords && tcArr)
        {
            instTexcoordArray[i * 4 + 0] = tcArr[i * 4 + 0];
            instTexcoordArray[i * 4 + 1] = tcArr[i * 4 + 1];
            instTexcoordArray[i * 4 + 2] = tcArr[i * 4 + 2];
            instTexcoordArray[i * 4 + 3] = tcArr[i * 4 + 3];
        }

        if (scales && scales.length > i) mat4.scale(m, m, [scales[i * 3], scales[i * 3 + 1], scales[i * 3 + 2]]);
        else mat4.scale(m, m, [1, 1, 1]);

        for (let a = 0; a < 16; a++) matrixArray[i * 16 + a] = m[a];
    }

    // mesh.numInstances = num;
    mesh.setNumInstances(num);

    if (arrayChangedTrans) mesh.addAttribute("instMat", matrixArray, 16);
    if (arrayChangedColor) mesh.addAttribute("instColor", instColorArray, 4, { "instanced": true });
    if (arrayChangedTexcoords) mesh.addAttribute("instTexCoords", instTexcoordArray, 4, { "instanced": true });

    mod.toggleDefine("HAS_TEXCOORDS", tcArr);
    mod.toggleDefine("HAS_COLORS", colArr);

    arrayChangedColor = false;
    recalc = false;
}

function updateLimit()
{
    inLimit.setUiAttribs({ "greyout": !doLimit.get() });
}

function doRender()
{
    if (!mesh) return;
    if (recalc) setupArray();

    mod.bind();

    if (doLimit.get()) mesh.setNumInstances(Math.min(num, inLimit.get()));
    else mesh.setNumInstances(num);

    outNum.set(mesh.numInstances);

    if (mesh.numInstances > 0) mesh.render(cgl.getShader());

    outTrigger.trigger();

    mod.unbind();
}


};

Ops.Gl.MeshInstancer_v4.prototype = new CABLES.Op();
CABLES.OPS["cb58f461-a0bd-4159-a3cb-5e396198b4e9"]={f:Ops.Gl.MeshInstancer_v4,objName:"Ops.Gl.MeshInstancer_v4"};




// **************************************************************
// 
// Ops.Gl.Meshes.Circle_v3
// 
// **************************************************************

Ops.Gl.Meshes.Circle_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    radius = op.inValue("radius", 0.5),
    innerRadius = op.inValueSlider("innerRadius", 0),
    segments = op.inValueInt("segments", 40),
    percent = op.inValueSlider("percent", 1),
    steps = op.inValue("steps", 0),
    invertSteps = op.inValueBool("invertSteps", false),
    mapping = op.inSwitch("mapping", ["flat", "round"]),
    drawSpline = op.inValueBool("Spline", false),
    inDraw = op.inValueBool("Draw", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry", null, "geometry");

op.setPortGroup("Size", [radius, innerRadius]);
op.setPortGroup("Display", [percent, steps, invertSteps]);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);

inDraw.setUiAttribs({ "title": "Render mesh" });

mapping.set("flat");

mapping.onChange =
    segments.onChange =
    radius.onChange =
    innerRadius.onChange =
    percent.onChange =
    steps.onChange =
    invertSteps.onChange =
    drawSpline.onChange = calcLater;

geomOut.ignoreValueSerialize = true;
const cgl = op.patch.cgl;

let geom = new CGL.Geometry("circle");
let mesh = null;
const lastSegs = -1;

let oldPrim = 0;
let shader = null;
let needsCalc = true;

render.onTriggered = renderMesh;

op.preRender = () =>
{
    renderMesh();
};

render.onLinkChanged = function ()
{
    if (!render.isLinked()) geomOut.set(null);
    else geomOut.setRef(geom);
};

function renderMesh()
{
    if (needsCalc)calc();

    if (!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    shader = op.patch.cg.getShader();
    if (!shader) return;
    oldPrim = shader.glPrimitive;

    if (drawSpline.get()) shader.glPrimitive = cgl.gl.LINE_STRIP;

    if (inDraw.get() && mesh)mesh.render(shader);
    trigger.trigger();

    shader.glPrimitive = oldPrim;
}

function calc()
{
    const segs = Math.max(3, Math.floor(segments.get()));

    geom.clear();

    const faces = [];
    const texCoords = [];
    const vertexNormals = [];
    const tangents = [];
    const biTangents = [];

    let i = 0, degInRad = 0;
    let oldPosX = 0, oldPosY = 0;
    let oldPosXTexCoord = 0, oldPosYTexCoord = 0;

    let oldPosXIn = 0, oldPosYIn = 0;
    let oldPosXTexCoordIn = 0, oldPosYTexCoordIn = 0;

    let posxTexCoordIn = 0, posyTexCoordIn = 0;
    let posxTexCoord = 0, posyTexCoord = 0;
    let posx = 0, posy = 0;

    const perc = Math.max(0.0, percent.get());
    const verts = [];

    if (drawSpline.get())
    {
        let lastX = 0;
        let lastY = 0;
        const tc = [];
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            posyTexCoord = 0.5;

            if (i > 0)
            {
                verts.push(lastX);
                verts.push(lastY);
                verts.push(0);
                posxTexCoord = 1.0 - (i - 1) / segs;

                tc.push(posxTexCoord, posyTexCoord);
            }
            verts.push(posx);
            verts.push(posy);
            verts.push(0);

            lastX = posx;
            lastY = posy;
        }
        geom.setPointVertices(verts);
    }
    else
    if (innerRadius.get() <= 0)
    {
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            if (mapping.get() == "flat")
            {
                posxTexCoord = (Math.cos(degInRad) + 1.0) / 2;
                posyTexCoord = 1.0 - (Math.sin(degInRad) + 1.0) / 2;
                posxTexCoordIn = 0.5;
                posyTexCoordIn = 0.5;
            }
            else if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            faces.push(
                [0, 0, 0],
                [oldPosX, oldPosY, 0],
                [posx, posy, 0]
            );

            texCoords.push(
                posxTexCoordIn, posyTexCoordIn, oldPosXTexCoord, oldPosYTexCoord, posxTexCoord, posyTexCoord
            );
            vertexNormals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
            biTangents.push(0, -1, 0, 0, -1, 0, 0, -1, 0);

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;
        geom.texCoords = texCoords;
    }
    else
    {
        let count = 0;
        const numSteps = segs * perc;
        const pos = 0;

        for (i = 0; i <= numSteps; i++)
        {
            count++;

            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            const posxIn = Math.cos(degInRad) * innerRadius.get() * radius.get();
            const posyIn = Math.sin(degInRad) * innerRadius.get() * radius.get();

            if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            if (steps.get() === 0.0 ||
                (count % parseInt(steps.get(), 10) === 0 && !invertSteps.get()) ||
                (count % parseInt(steps.get(), 10) !== 0 && invertSteps.get()))
            {
                faces.push(
                    [posxIn, posyIn, 0],
                    [oldPosX, oldPosY, 0],
                    [posx, posy, 0]
                );

                faces.push(
                    [oldPosXIn, oldPosYIn, 0],
                    [oldPosX, oldPosY, 0],
                    [posxIn, posyIn, 0]
                );

                texCoords.push(
                    posxTexCoord, 0, oldPosXTexCoord, 0, posxTexCoordIn, 1, posxTexCoord, 1, oldPosXTexCoord, 0, oldPosXTexCoordIn, 1);

                vertexNormals.push(
                    0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1
                );
                tangents.push(
                    1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0
                );
                biTangents.push(
                    0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1
                );
            }

            oldPosXTexCoordIn = posxTexCoordIn;
            oldPosYTexCoordIn = posyTexCoordIn;

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;

            oldPosXIn = posxIn;
            oldPosYIn = posyIn;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;

        if (mapping.get() == "flat") geom.mapTexCoords2d();
        else geom.texCoords = texCoords;
    }

    geomOut.setRef(geom);

    if (geom.vertices.length == 0) return;
    if (mesh) mesh.dispose();
    mesh = null;
    mesh = op.patch.cg.createMesh(geom, { "opId": op.id });
    needsCalc = false;
}

function calcLater()
{
    needsCalc = true;
}

op.onDelete = function ()
{
    if (mesh)mesh.dispose();
};


};

Ops.Gl.Meshes.Circle_v3.prototype = new CABLES.Op();
CABLES.OPS["ae07830b-91c3-4cbe-a7d6-d3b737392c16"]={f:Ops.Gl.Meshes.Circle_v3,objName:"Ops.Gl.Meshes.Circle_v3"};




// **************************************************************
// 
// Ops.Array.PointArray.PointsPlane_v2
// 
// **************************************************************

Ops.Array.PointArray.PointsPlane_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inNumX = op.inValueInt("Rows", 32),
    inNumY = op.inValueInt("Columns", 32),
    inHeight = op.inFloat("Width", 2),
    inWidth = op.inFloat("Height", 2),
    inRowOffset = op.inFloat("Row Offset", 0),
    inCenter = op.inValueBool("Center", true),
    outArr = op.outArray("Result", [], 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length"),
    outRowNums = op.outArray("Row Numbers", [], 1),
    outColNums = op.outArray("Column Numbers", [], 1);

inNumX.onChange =
    inNumY.onChange =
    inCenter.onChange =
    inWidth.onChange =
    inRowOffset.onChange =
    inHeight.onChange = generate;

const arr = [];
const arrRowNums = [];
const arrColNums = [];
outArr.setRef(arr);
generate();

function generate()
{
    arr.length = 0;
    const numX = Math.floor(Math.max(0, inNumX.get()));
    const numY = Math.floor(Math.max(0, inNumY.get()));

    if (!CABLES.UTILS.isNumeric(numX) || !CABLES.UTILS.isNumeric(numY) || numX < 0 || numY < 0)
    {
        outRowNums.setRef(0);
        outColNums.setRef(0);
        outArr.setRef([]);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }

    let stepX = 0;
    let stepY = 0;

    // to avoid divide by zero
    if (numX == 1)
    {
        stepX = inWidth.get() / (numX);
    }
    else
    {
        stepX = inWidth.get() / (numX - 1);
    }
    if (numY == 1)
    {
        stepY = inHeight.get() / (numY);
    }
    else
    {
        stepY = inHeight.get() / (numY - 1);
    }

    let i = 0;

    let centerX = 0;
    let centerY = 0;

    if (inCenter.get())
    {
        centerX = inWidth.get() / 2;
        centerY = inHeight.get() / 2;
    }

    const l = Math.floor(numX) * Math.floor(numY) * 3;

    arr.length = l;
    arrColNums.length = l / 3;
    arrRowNums.length = l / 3;

    let offRow = inRowOffset.get();
    let off = 0;
    for (let y = 0; y < numY; y++)
    {
        for (let x = 0; x < numX; x++)
        {
            off = 0;
            if (x % 2 == 0 && offRow)off = offRow;

            arrColNums[i / 3] = y;
            arrRowNums[i / 3] = x;

            arr[i++] = stepY * y - centerY + off;
            arr[i++] = stepX * x - centerX;

            arr[i++] = 0;
        }
    }

    outRowNums.setRef(arrRowNums);
    outColNums.setRef(arrColNums);
    outArr.setRef(arr);
    outTotalPoints.set(arr.length / 3);
    outArrayLength.set(arr.length);
}


};

Ops.Array.PointArray.PointsPlane_v2.prototype = new CABLES.Op();
CABLES.OPS["d453f898-17d4-4e2c-b8c7-7b7b34c0ff68"]={f:Ops.Array.PointArray.PointsPlane_v2,objName:"Ops.Array.PointArray.PointsPlane_v2"};




// **************************************************************
// 
// Ops.Gl.Texture2ColorArray_v2
// 
// **************************************************************

Ops.Gl.Texture2ColorArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    cgl = op.patch.cgl,
    pUpdate = op.inTrigger("update"),
    tex = op.inObject("texture"),
    inFormat = op.inSwitch("Format", ["RGBA", "RGB", "RG", "R", "G", "B", "A"], "RGBA"),
    outTrigger = op.outTrigger("trigger"),

    outColors = op.outArray("Colors", null, 4),
    outIsFloatingPoint = op.outBoolNum("Floating Point");

let
    fb = null,
    texChanged = false;
tex.onChange = function () { needsUpdate = true; texChanged = true; };

op.toWorkPortsNeedToBeLinked(tex, outColors);

let isFloatingPoint = false;
let channelType = op.patch.cgl.gl.UNSIGNED_BYTE;

let convertedpixel = null;

let lastFloatingPoint = false;
let lastWidth = 0;
let lastHeight = 0;
let pixelReader = new CGL.PixelReader();
let needsUpdate = true;

function getNumChannels()
{
    const f = inFormat.get();
    if (f == "RGBA") return 4;
    else if (f == "RGB") return 3;
    else if (f == "RG") return 2;
    else if (f == "R") return 1;
    else if (f == "G") return 1;
    else if (f == "B") return 1;
    else if (f == "A") return 1;
}

inFormat.onChange = () =>
{
    outColors.setUiAttribs({ "stride": getNumChannels() });
    needsUpdate = true;
};

pUpdate.onTriggered = function ()
{
    if (needsUpdate) updateArray();
    outTrigger.trigger();
};

function updateArray()
{
    const realTexture = tex.get(), gl = cgl.gl;

    if (!realTexture) return;
    if (!fb) fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    if (texChanged)
    {
        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, realTexture.tex, 0
        );

        isFloatingPoint = realTexture.textureType == CGL.Texture.TYPE_FLOAT;

        if (isFloatingPoint) channelType = gl.FLOAT;
        else channelType = gl.UNSIGNED_BYTE;

        outIsFloatingPoint.set(isFloatingPoint);

        if (
            lastFloatingPoint != isFloatingPoint ||
            lastWidth != realTexture.width ||
            lastHeight != realTexture.height)
        {
            lastFloatingPoint = isFloatingPoint;
            lastWidth = realTexture.width;
            lastHeight = realTexture.height;
        }

        texChanged = false;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    pixelReader.read(cgl, fb, realTexture.pixelFormat, 0, 0, realTexture.width, realTexture.height, (pixel) =>
    {
        let numItems = pixel.length;
        numItems = numItems / 4 * getNumChannels();

        if (inFormat.get() === "R")
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i += 4)
                convertedpixel[i / 4] = pixel[i + 0];
        }
        else
        if (inFormat.get() === "G")
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i += 4)
                convertedpixel[i / 4] = pixel[i + 1];
        }
        else
        if (inFormat.get() === "B")
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i += 4)
                convertedpixel[i / 4] = pixel[i + 2];
        }
        else
        if (inFormat.get() === "A")
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i += 4)
                convertedpixel[i / 4] = pixel[i + 3];
        }
        else if (inFormat.get() === "RGB")
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i += 4)
            {
                convertedpixel[i / 4 * 3 + 0] = pixel[i + 0];
                convertedpixel[i / 4 * 3 + 1] = pixel[i + 1];
                convertedpixel[i / 4 * 3 + 2] = pixel[i + 2];
            }
        }
        else if (inFormat.get() === "RG")
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i += 4)
            {
                convertedpixel[i / 4 * 2 + 0] = pixel[i + 0];
                convertedpixel[i / 4 * 2 + 1] = pixel[i + 1];
            }
        }
        else if (inFormat.get() === "RGBA" && !isFloatingPoint)
        {
            if (!convertedpixel || convertedpixel.length != numItems) convertedpixel = new Float32Array(numItems);

            for (let i = 0; i < pixel.length; i++)
                convertedpixel[i] = pixel[i];
        }
        else convertedpixel = null;

        if (!isFloatingPoint && convertedpixel)
        {
            for (let i = 0; i < convertedpixel.length; i++)convertedpixel[i] /= 255;
        }

        outColors.setRef(convertedpixel || pixel);
        needsUpdate = false;
    });
}


};

Ops.Gl.Texture2ColorArray_v2.prototype = new CABLES.Op();
CABLES.OPS["549efc37-c037-4915-9ec6-c8584c0f1def"]={f:Ops.Gl.Texture2ColorArray_v2,objName:"Ops.Gl.Texture2ColorArray_v2"};




// **************************************************************
// 
// Ops.Graphics.Intersection.IntersectWorld
// 
// **************************************************************

Ops.Graphics.Intersection.IntersectWorld = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    trigger = op.inTrigger("Trigger"),
    render = op.inBool("Render", true),
    inTextCol = op.inBool("Check Body Collisions", false),
    next = op.outTrigger("Next"),
    outNum = op.outNumber("Total Bodies"),
    outCollisions = op.outArray("Collisions", []);

trigger.onTriggered = doRender;

const cgl = op.patch.cgl;

function doRender()
{
    cgl.frameStore.collisionWorld = { "bodies": [] };
    next.trigger();

    outNum.set(cgl.frameStore.collisionWorld.bodies.length);

    if (inTextCol.get()) checkCollisions();

    if (render.get())renderBodies();
}

function renderBodies()
{
    if (!CABLES.UI) return;
    const collisions = [];
    const bodies = cgl.frameStore.collisionWorld.bodies;

    for (let i = 0; i < bodies.length; i++)
    {
        const body = bodies[i];

        if (body.type === 1)
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, body.pos);
            CABLES.GL_MARKER.drawSphere(op, body.radius);
            cgl.popModelMatrix();
        }
        else if (body.type === 2)
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, body.pos);
            CABLES.GL_MARKER.drawCube(op, body.size[0] / 2, body.size[1] / 2, body.size[2] / 2);
            cgl.popModelMatrix();
        }
        else console.warn("[intersectWorld] unknown col shape");
    }
}

function checkCollisions()
{
    const collisions = [];
    const bodies = cgl.frameStore.collisionWorld.bodies;

    for (let j = 0; j < bodies.length; j++)
    {
        for (let i = j + 1; i < bodies.length; i++)
        {
            if (i != j)
            {
                const bodyA = bodies[i];
                const bodyB = bodies[j];

                /// //////////
                // SPHERE vs SPHERE
                if (bodyA.type == 1 && bodyB.type == 1)
                {
                    const dist = vec3.distance(bodyA.pos, bodyB.pos);

                    if (dist < bodyA.radius + bodyB.radius)
                    {
                        collisions.push({
                            "body0": bodyA,
                            "name0": bodyA.name,
                            "body1": bodyB,
                            "name1": bodyB.name
                        });
                    }
                }
                else
                if ((bodyA.type == 1 && bodyB.type == 2) || (bodyA.type == 2 && bodyB.type == 1))
                {
                    let bBox = bodyA;
                    let bSphere = bodyB;
                    if (bodyB.type == 2)
                    {
                        bBox = bodyB;
                        bSphere = bodyA;
                    }

                    let r2 = bSphere.radius * bSphere.radius;
                    let dmin = 0;

                    let dist_squared = bSphere.radius * bSphere.radius;
                    /* assume bBox.minand C2 are element-wise sorted, if not, do that now */
                    if (bSphere.pos[0] < bBox.minX) dist_squared -= (bSphere.pos[0] - bBox.minX) ** 2;
                    else if (bSphere.pos[0] > bBox.maxX) dist_squared -= (bSphere.pos[0] - bBox.maxX) ** 2;
                    if (bSphere.pos[1] < bBox.minY) dist_squared -= (bSphere.pos[1] - bBox.minY) ** 2;
                    else if (bSphere.pos[1] > bBox.maxY) dist_squared -= (bSphere.pos[1] - bBox.maxY) ** 2;
                    if (bSphere.pos[2] < bBox.minZ) dist_squared -= (bSphere.pos[2] - bBox.minZ) ** 2;
                    else if (bSphere.pos[2] > bBox.maxZ) dist_squared -= (bSphere.pos[2] - bBox.maxZ) ** 2;

                    if (dist_squared > 0)
                    {
                        collisions.push(
                            {
                                "body0": bodyA,
                                "name0": bodyA.name,
                                "body1": bodyB,
                                "name1": bodyB.name
                            });
                    }
                }
                else
                {
                    console.warn("unknown collision pair...", bodyA, bodyB);
                }
            }
        }
    }
    outCollisions.setRef(collisions, []);
}


};

Ops.Graphics.Intersection.IntersectWorld.prototype = new CABLES.Op();
CABLES.OPS["6ebdec23-6e10-48c9-87cf-43d488e4290f"]={f:Ops.Graphics.Intersection.IntersectWorld,objName:"Ops.Graphics.Intersection.IntersectWorld"};




// **************************************************************
// 
// Ops.Graphics.Intersection.IntersectRaycast
// 
// **************************************************************

Ops.Graphics.Intersection.IntersectRaycast = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    trigger = op.inTrigger("Trigger"),
    inCoords = op.inSwitch("Coordinate Format", ["-1 to 1", "XYZ-XYZ"], "-1 to 1"),
    inX = op.inValueFloat("X"),
    inY = op.inValueFloat("Y"),

    inZ = op.inValueFloat("Z"),

    inToX = op.inValueFloat("To X"),
    inToY = op.inValueFloat("To Y"),
    inToZ = op.inValueFloat("To Z"),

    active = op.inBool("Active", true),
    inCursor = op.inBool("Change Cursor", true),
    next = op.outTrigger("Next"),
    outHasHit = op.outBoolNum("Has Hit", false),
    outName = op.outString("Hit Body Name", ""),
    outX = op.outNumber("Hit X"),
    outY = op.outNumber("Hit Y"),
    outZ = op.outNumber("Hit Z");

const cgl = op.patch.cgl;
const oc = vec3.create();
const mat = mat4.create();
const dir = vec3.create();
let didsetCursor = false;
let isScreenCoords = true;

op.toWorkPortsNeedToBeLinked(trigger);

trigger.onTriggered = doRender;

inCoords.onChange = updateUi;
updateUi();

function updateUi()
{
    inZ.setUiAttribs({ "greyout": inCoords.get() != "XYZ-XYZ" });

    inToX.setUiAttribs({ "greyout": inCoords.get() != "XYZ-XYZ" });
    inToY.setUiAttribs({ "greyout": inCoords.get() != "XYZ-XYZ" });
    inToZ.setUiAttribs({ "greyout": inCoords.get() != "XYZ-XYZ" });
}

function doRender()
{
    next.trigger();

    if (cgl.frameStore.collisionWorld)
    {
        let origin = vec3.create();

        if (inCoords.get() == "-1 to 1")
        {
            origin = vec3.fromValues(inX.get(), inY.get(), -1);
            mat4.mul(mat, cgl.pMatrix, cgl.vMatrix);
            mat4.invert(mat, mat);
            vec3.transformMat4(origin, origin, mat);
        }

        if (inCoords.get() == "XYZ-XYZ")
        {
            origin = vec3.fromValues(inX.get(), inY.get(), inZ.get());
        }

        // -----------

        let to = vec3.create();

        if (inCoords.get() == "-1 to 1")
        {
            to = vec3.fromValues(inX.get(), inY.get(), 1);
            mat4.mul(mat, cgl.pMatrix, cgl.vMatrix);
            mat4.invert(mat, mat);
            vec3.transformMat4(to, to, mat);
        }

        if (inCoords.get() == "XYZ-XYZ")
        {
            to = vec3.fromValues(inToX.get(), inToY.get(), inToZ.get());
        }

        vec3.sub(dir, to, origin);
        vec3.normalize(dir, dir);
        const a = vec3.dot(dir, dir);

        let found = false;
        const bodies = cgl.frameStore.collisionWorld.bodies;
        for (let i = 0; i < bodies.length; i++)
        {
            if (found) break;

            const body = bodies[i];
            if (body.type == 1) // sphere
            {
                vec3.sub(oc, origin, body.pos);
                const b = 2 * vec3.dot(oc, dir);
                const c = vec3.dot(oc, oc) - (body.radius * body.radius);
                const discriminant = b * b - 4 * a * c;

                if (discriminant > 0)
                {
                    found = true;
                    outName.set(body.name);
                    outHasHit.set(true);

                    const dist = (-b - Math.sqrt(discriminant)) / (2 + a);

                    vec3.mul(oc, dir, [dist, dist, dist]);
                    vec3.add(oc, oc, origin);

                    outX.set(oc[0]);
                    outY.set(oc[1]);
                    outZ.set(oc[2]);
                }
            }
            else if (body.type == 2) // aabb
            {
                const t1 = (body.minX - origin[0]) / dir[0];
                const t2 = (body.maxX - origin[0]) / dir[0];

                const t3 = (body.minY - origin[1]) / dir[1];
                const t4 = (body.maxY - origin[1]) / dir[1];

                const t5 = (body.minZ - origin[2]) / dir[2];
                const t6 = (body.maxZ - origin[2]) / dir[2];

                const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
                const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

                // // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
                if (tmax < 0) continue;

                // if tmin > tmax, ray doesn't intersect AABB
                if (tmin > tmax) continue;

                found = true;
                outName.set(body.name);
                outHasHit.set(true);

                vec3.mul(oc, dir, [tmin, tmin, tmin]);
                vec3.add(oc, oc, origin);

                outX.set(oc[0]);
                outY.set(oc[1]);
                outZ.set(oc[2]);
            }
        }

        if (!found)
        {
            outName.set("");
            outHasHit.set(false);
            outX.set(0);
            outY.set(0);
            outZ.set(0);
        }
    }
}


};

Ops.Graphics.Intersection.IntersectRaycast.prototype = new CABLES.Op();
CABLES.OPS["dd5d9b39-75c2-40b1-98a4-7a0fdafdb5cb"]={f:Ops.Graphics.Intersection.IntersectRaycast,objName:"Ops.Graphics.Intersection.IntersectRaycast"};




// **************************************************************
// 
// Ops.Graphics.Intersection.IntersectBody
// 
// **************************************************************

Ops.Graphics.Intersection.IntersectBody = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    shapes = ["Sphere", "BoxAA"],
    trigger = op.inTrigger("Trigger"),
    inArea = op.inSwitch("Shape", shapes, "Sphere"),
    inName = op.inString("Name", ""),
    inRadius = op.inFloat("Radius", 0.5),
    inSizeX = op.inFloat("Size X", 1),
    inSizeY = op.inFloat("Size Y", 1),
    inSizeZ = op.inFloat("Size Z", 1),
    inPositions = op.inArray("Positions", null, 3),
    inPosIndex = op.inBool("Append Index to name", true),
    next = op.outTrigger("Next");

op.setPortGroup("Array", [inPositions, inPosIndex]);

const cgl = op.patch.cgl;
const pos = vec3.create();
// const scale = vec3.create();
const empty = vec3.create();
updateUi();

let objs = [];
let obj =
{
    "name": "???",
    "type": 1,
};

trigger.onTriggered = render;

inArea.onChange = () =>
{
    obj.type = shapes.indexOf(inArea.get()) + 1;
    updateUi();
};

function updateUi()
{
    inRadius.setUiAttribs({ "greyout": inArea.get() != "Sphere" });
    inSizeX.setUiAttribs({ "greyout": inArea.get() != "BoxAA" });
    inSizeY.setUiAttribs({ "greyout": inArea.get() != "BoxAA" });
    inSizeZ.setUiAttribs({ "greyout": inArea.get() != "BoxAA" });
}

function setBox(o)
{
    o.minX = o.pos[0] - o.size[0] / 2;
    o.maxX = o.pos[0] + o.size[0] / 2;

    o.minY = o.pos[1] - o.size[1] / 2;
    o.maxY = o.pos[1] + o.size[1] / 2;

    o.minZ = o.pos[2] - o.size[2] / 2;
    o.maxZ = o.pos[2] + o.size[2] / 2;
}

function render()
{
    if (!cgl.frameStore || !cgl.frameStore.collisionWorld) return;
    const cg = op.patch.cgl;

    // vec3.transformMat4(pos, empty, cg.mMatrix);
    // mat4.getScaling(scale, cg.mMatrix);

    const posArr = inPositions.get();
    const radius = inRadius.get();

    if (posArr && posArr.length > 0 && posArr.length % 3 == 0)
    {
        objs.length = posArr.length / 3;
        for (let i = 0; i < posArr.length; i += 3)
        {
            const o = objs[i / 3] || {};
            if (inPosIndex.get()) o.name = inName.get() + "." + i / 3;
            else o.name = inName.get();

            o.pos = [posArr[i + 0], posArr[i + 1], posArr[i + 2]];
            vec3.transformMat4(o.pos, o.pos, cg.mMatrix);

            // vec3.mul(o.pos, o.pos, scale);
            o.type = obj.type;
            o.size = [inSizeX.get(), inSizeY.get(), inSizeZ.get()];

            if (o.type == 2)setBox(o);
            if (o.type == 1)o.radius = radius;

            cgl.frameStore.collisionWorld.bodies.push(o);
        }
    }
    else
    {
        cgl.frameStore.collisionWorld.bodies.push(obj);
        obj.name = inName.get();
        obj.pos = [0, 0, 0];

        vec3.transformMat4(obj.pos, obj.pos, cg.mMatrix);

        obj.size = [inSizeX.get(), inSizeY.get(), inSizeZ.get()];

        if (obj.type == 2)setBox(obj);
        if (obj.type == 1)obj.radius = radius;
    }

    next.trigger();
}


};

Ops.Graphics.Intersection.IntersectBody.prototype = new CABLES.Op();
CABLES.OPS["b2e39096-8a02-4a50-b2f5-3e68f2c16ad7"]={f:Ops.Graphics.Intersection.IntersectBody,objName:"Ops.Graphics.Intersection.IntersectBody"};




// **************************************************************
// 
// Ops.Extension.OpenType.OpentypeFont
// 
// **************************************************************

Ops.Extension.OpenType.OpentypeFont = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    filename = op.inUrl("Font File", [".otf", ".ttf", ".woff", ".woff2"]),
    outFont = op.outObject("Opentype Font", null, "opentype");

filename.onChange = async function ()
{
    const font = await opentype.load(filename.get());
    outFont.set(font);
};


};

Ops.Extension.OpenType.OpentypeFont.prototype = new CABLES.Op();
CABLES.OPS["f85574bb-3869-4a14-8dcc-70414bd8cfcd"]={f:Ops.Extension.OpenType.OpentypeFont,objName:"Ops.Extension.OpenType.OpentypeFont"};




// **************************************************************
// 
// Ops.Extension.OpenType.OpentypeToSvgPath
// 
// **************************************************************

Ops.Extension.OpenType.OpentypeToSvgPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inFont = op.inObject("Opentype Font"),
    inStr = op.inString("Text", "cables"),
    inLs = op.inFloat("Letter Spacing", 0),
    outPathStr = op.outString("Path String");

inStr.onChange =
inLs.onChange =
inFont.onChange = async function ()
{
    const font = inFont.get();
    if (!font || !font.getPath)
    {
        outPathStr.set("");
        return;
    }

    const paths = font.getPaths(inStr.get(), 0, 0, 72);
    let str = "";

    let ls = inLs.get();

    for (let i = 0; i < paths.length; i++)
    {
        for (let j = 0; j < paths[i].commands.length; j++)
        {
            if (paths[i].commands[j].hasOwnProperty("x"))
                paths[i].commands[j].x += i * ls;
            if (paths[i].commands[j].hasOwnProperty("x1"))
                paths[i].commands[j].x1 += i * ls;
        }
        str += paths[i].toPathData();
    }

    outPathStr.set(str);
};


};

Ops.Extension.OpenType.OpentypeToSvgPath.prototype = new CABLES.Op();
CABLES.OPS["4d901c72-b8dc-45dc-ac2e-608e5da40677"]={f:Ops.Extension.OpenType.OpentypeToSvgPath,objName:"Ops.Extension.OpenType.OpentypeToSvgPath"};




// **************************************************************
// 
// Ops.Graphics.Geometry.SvgPathToGeometry_v2
// 
// **************************************************************

Ops.Graphics.Geometry.SvgPathToGeometry_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inStr = op.inString("SVG Path"),
    inStepSize = op.inFloat("Bezier Stepsize", 3),
    inRescale = op.inFloat("Rescale", 1),
    outGeom = op.outObject("Geometry", null, "geometry");

inStepSize.onChange =
inRescale.onChange =
inStr.onChange = () =>
{
    let str = inStr.get();

    if (!str || str.length < 2)
    {
        outGeom.set(null);
        return;
    }

    str = str.replace(/([A-Z,a-z])/g, " $1 ");

    const cmds = fromPathToArray(str);

    // create a list of closed contours
    const polys = [];
    cmds.forEach(({ type, x, y, x1, y1, x2, y2 }) =>
    {
        switch (type)
        {
        case "M":
            polys.push(new Polygon());
            polys[polys.length - 1].moveTo({ x, y });
            break;
        case "L":
            polys[polys.length - 1].moveTo({ x, y });
            break;
        case "C":
            polys[polys.length - 1].cubicTo({ x, y }, { "x": x1, "y": y1 }, { "x": x2, "y": y2 });
            break;
        case "Q":
            polys[polys.length - 1].conicTo({ x, y }, { "x": x1, "y": y1 });
            break;
        case "Z":
            polys[polys.length - 1].close();
            break;
        }
    });

    // sort contours by descending area
    polys.sort((a, b) => { return Math.abs(b.area) - Math.abs(a.area); });
    // classify contours to find holes and their 'parents'
    const root = [];
    for (let i = 0; i < polys.length; ++i)
    {
        let parent = null;
        for (let j = i - 1; j >= 0; --j)
        {
            // a contour is a hole if it is inside its parent and has different winding
            if (polys[j].inside(polys[i].points[0]) && polys[i].area * polys[j].area < 0)
            {
                parent = polys[j];
                break;
            }
        }
        if (parent)
        {
            parent.children.push(polys[i]);
        }
        else
        {
            root.push(polys[i]);
        }
    }

    const totalPoints = polys.reduce((sum, p) => { return sum + p.points.length; }, 0);
    const vertexData = new Float32Array(totalPoints * 2);
    let vertexCount = 0;
    const indices = [];

    function process(poly)
    {
        // construct input for earcut
        const coords = [];
        const holes = [];

        poly.points.forEach(({ x, y }) => { return coords.push(x, y); });

        poly.children.forEach((child) =>
        {
            // children's children are new, separate shapes
            child.children.forEach(process);

            holes.push(coords.length / 2);
            child.points.forEach(({ x, y }) => { return coords.push(x, y); });
        });

        // add vertex data
        vertexData.set(coords, vertexCount * 2);
        // add index data
        earcut(coords, holes).forEach((i) => { return indices.push(i + vertexCount); });
        vertexCount += coords.length / 2;
    }

    root.forEach(process);

    const finalVertexData = new Float32Array(totalPoints * 3);

    let max = -99999;

    for (let i = 0; i < finalVertexData.length / 3; i++)
    {
        finalVertexData[i * 3 + 0] = vertexData[i * 2 + 0];
        finalVertexData[i * 3 + 1] = vertexData[i * 2 + 1] * -1;
        max = Math.max(finalVertexData[i * 3 + 1], max);

        finalVertexData[i * 3 + 2] = 0;
    }

    let resc = inRescale.get();

    let geom = new CGL.Geometry("circle");
    geom.setVertices(finalVertexData);
    geom.verticesIndices = indices;

    if (resc != 0)
    {
        const bounds = geom.getBounds();
        for (let i = 0; i < finalVertexData.length / 3; i++)
        {
            finalVertexData[i * 3 + 0] = (finalVertexData[i * 3 + 0] / (bounds.size[0] / 2)) * resc;
            finalVertexData[i * 3 + 1] = (finalVertexData[i * 3 + 1] / (bounds.size[0] / 2)) * resc;
        }
        geom.setVertices(finalVertexData);
    }

    geom.mapTexCoords2d();
    geom.flipVertDir();
    geom.calculateNormals();
    geom.calcTangentsBitangents();

    outGeom.set(geom);
};

const PATH_COMMANDS = {
    "M": ["x", "y"],
    "m": ["dx", "dy"],
    "H": ["x"],
    "h": ["dx"],
    "V": ["y"],
    "v": ["dy"],
    "L": ["x", "y"],
    "l": ["dx", "dy"],
    "Z": [],
    "C": ["x1", "y1", "x2", "y2", "x", "y"],
    "c": ["dx1", "dy1", "dx2", "dy2", "dx", "dy"],
    "S": ["x2", "y2", "x", "y"],
    "s": ["dx2", "dy2", "dx", "dy"],
    "Q": ["x1", "y1", "x", "y"],
    "q": ["dx1", "dy1", "dx", "dy"],
    "T": ["x", "y"],
    "t": ["dx", "dy"],
    "A": ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"],
    "a": ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"]
};

function fromPathToArray(path)
{
    const items = path.replace(/[\n\r]/g, "")
        .replace(/-/g, " -")
        .replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ")
        .trim()
        .split(/\s*,|\s+/);

    const segments = [];
    let currentCommand = "";
    let currentElement = {};
    while (items.length > 0)
    {
        let it = items.shift();
        if (PATH_COMMANDS.hasOwnProperty(it))
        {
            currentCommand = it;
        }
        else
        {
            items.unshift(it);
        }

        currentElement = { "type": currentCommand };
        PATH_COMMANDS[currentCommand].forEach((prop) =>
        {
            it = items.shift(); // TODO sanity check
            currentElement[prop] = parseFloat(it);
        });
        if (currentCommand === "M")
        {
            currentCommand = "L";
        }
        else if (currentCommand === "m")
        {
            currentCommand = "l";
        }
        segments.push(currentElement);
    }
    return segments;
}

// https://stackoverflow.com/questions/50554803/triangulate-path-data-from-opentype-js-using-earcut

const MAX_BEZIER_STEPS = 15;
// this is for inside checks - doesn't have to be particularly
// small because glyphs have finite resolution
const EPSILON = 1e-6;

class Polygon
{
    constructor()
    {
        this.points = [];
        this.children = [];
        this.area = 0.0;

        this.BEZIER_STEP_SIZE = inStepSize.get();
    }

    moveTo(p)
    {
        this.points.push(p);
    }

    lineTo(p)
    {
        this.points.push(p);
    }

    close()
    {
        let cur = this.points[this.points.length - 1];
        this.points.forEach((next) =>
        {
            this.area += 0.5 * cross(cur, next);
            cur = next;
        });
    }

    conicTo(p, p1)
    {
        const p0 = this.points[this.points.length - 1];
        const dist = distance(p0, p1) + distance(p1, p);
        const steps = Math.max(2, Math.min(MAX_BEZIER_STEPS, dist / this.BEZIER_STEP_SIZE));
        for (let i = 1; i <= steps; ++i)
        {
            const t = i / steps;
            this.points.push(lerp(lerp(p0, p1, t), lerp(p1, p, t), t));
        }
    }

    cubicTo(p, p1, p2)
    {
        const p0 = this.points[this.points.length - 1];
        const dist = distance(p0, p1) + distance(p1, p2) + distance(p2, p);
        const steps = Math.max(2, Math.min(MAX_BEZIER_STEPS, dist / this.BEZIER_STEP_SIZE));
        for (let i = 1; i <= steps; ++i)
        {
            const t = i / steps;
            const a = lerp(lerp(p0, p1, t), lerp(p1, p2, t), t);
            const b = lerp(lerp(p1, p2, t), lerp(p2, p, t), t);
            this.points.push(lerp(a, b, t));
        }
    }

    inside(p)
    {
        let count = 0, cur = this.points[this.points.length - 1];
        this.points.forEach((next) =>
        {
            const p0 = (cur.y < next.y ? cur : next);
            const p1 = (cur.y < next.y ? next : cur);
            if (p0.y < p.y + EPSILON && p1.y > p.y + EPSILON)
            {
                if ((p1.x - p0.x) * (p.y - p0.y) > (p.x - p0.x) * (p1.y - p0.y))
                {
                    count += 1;
                }
            }
            cur = next;
        });
        return (count % 2) !== 0;
    }
}

function distance(p1, p2)
{
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

function lerp(p1, p2, t)
{
    return { "x": (1 - t) * p1.x + t * p2.x, "y": (1 - t) * p1.y + t * p2.y };
}

function cross(p1, p2)
{
    return p1.x * p2.y - p1.y * p2.x;
}


};

Ops.Graphics.Geometry.SvgPathToGeometry_v2.prototype = new CABLES.Op();
CABLES.OPS["4267b3e7-1285-4a3e-acc8-ea92a72a6bc0"]={f:Ops.Graphics.Geometry.SvgPathToGeometry_v2,objName:"Ops.Graphics.Geometry.SvgPathToGeometry_v2"};




// **************************************************************
// 
// Ops.Gl.Performance
// 
// **************************************************************

Ops.Gl.Performance = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    inShow = op.inValueBool("Visible", true),
    inDoGpu = op.inValueBool("Measure GPU", true),
    next = op.outTrigger("childs"),
    position = op.inSwitch("Position", ["top", "bottom"], "top"),
    openDefault = op.inBool("Open", false),
    smoothGraph = op.inBool("Smooth Graph", true),
    inScaleGraph = op.inFloat("Scale", 3),
    inSizeGraph = op.inFloat("Size", 128),
    outCanv = op.outObject("Canvas"),
    outFPS = op.outNumber("FPS");

const cgl = op.patch.cgl;
const element = document.createElement("div");

let elementMeasures = null;
let ctx = null;
let opened = false;
let frameCount = 0;
let fps = 0;
let fpsStartTime = 0;
let childsTime = 0;
let avgMsChilds = 0;
const queue = [];
const timesMainloop = [];
const timesOnFrame = [];
const timesGPU = [];
let avgMs = 0;
let selfTime = 0;
let canvas = null;
let lastTime = 0;
let loadingCounter = 0;
const loadingChars = ["|", "/", "-", "\\"];
let initMeasures = true;

const colorRAFSlow = "#007f9c";
const colorRAFVeruSlow = "#aaaaaa";

const colorBg = "#222222";
const colorRAF = "#003f5c"; // color: https://learnui.design/tools/data-color-picker.html
const colorMainloop = "#7a5195";
const colorOnFrame = "#ef5675";
const colorGPU = "#ffa600";

let startedQuery = false;

let currentTimeGPU = 0;
let currentTimeMainloop = 0;
let currentTimeOnFrame = 0;

op.toWorkPortsNeedToBeLinked(exe, next);

const gl = op.patch.cgl.gl;
const glQueryExt = gl.getExtension("EXT_disjoint_timer_query_webgl2");

exe.onLinkChanged =
    inShow.onChange = () =>
    {
        updateOpened();
        updateVisibility();
    };

position.onChange = updatePos;
inSizeGraph.onChange = updateSize;

element.id = "performance";
element.style.position = "absolute";
element.style.left = "0px";
element.style.opacity = "0.8";
element.style.padding = "10px";
element.style.cursor = "pointer";
element.style.background = "#222";
element.style.color = "white";
element.style["font-family"] = "monospace";
element.style["font-size"] = "12px";
element.style["z-index"] = "99999";

element.innerHTML = "&nbsp;";
element.addEventListener("click", toggleOpened);

const container = op.patch.cgl.canvas.parentElement;
container.appendChild(element);

updateSize();
updateOpened();
updatePos();
updateVisibility();

op.onDelete = function ()
{
    if (canvas)canvas.remove();
    if (element)element.remove();
};

function updatePos()
{
    canvas.style["pointer-events"] = "none";
    if (position.get() == "top")
    {
        canvas.style.top = element.style.top = "0px";
        canvas.style.bottom = element.style.bottom = "initial";
    }
    else
    {
        canvas.style.bottom = element.style.bottom = "0px";
        canvas.style.top = element.style.top = "initial";
    }
}

function updateVisibility()
{
    if (!inShow.get() || !exe.isLinked())
    {
        element.style.display = "none";
        element.style.opacity = 0;
        canvas.style.display = "none";
    }
    else
    {
        element.style.display = "block";
        element.style.opacity = 1;
        canvas.style.display = "block";
    }
}

function updateSize()
{
    if (!canvas) return;

    const num = Math.max(0, parseInt(inSizeGraph.get()));

    canvas.width = num;
    canvas.height = num;
    element.style.left = num + "px";

    queue.length = 0;
    timesMainloop.length = 0;
    timesOnFrame.length = 0;
    timesGPU.length = 0;

    for (let i = 0; i < num; i++)
    {
        queue[i] = -1;
        timesMainloop[i] = -1;
        timesOnFrame[i] = -1;
        timesGPU[i] = -1;
    }
}

openDefault.onChange = function ()
{
    opened = openDefault.get();
    updateOpened();
};

function toggleOpened()
{
    if (!inShow.get()) return;
    element.style.opacity = 1;
    opened = !opened;
    updateOpened();
}

function updateOpened()
{
    updateText();
    if (!canvas)createCanvas();
    if (opened)
    {
        canvas.style.display = "block";
        element.style.left = inSizeGraph.get() + "px";
        element.style["min-height"] = "56px";
    }
    else
    {
        canvas.style.display = "none";
        element.style.left = "0px";
        element.style["min-height"] = "auto";
    }
}

function updateCanvas()
{
    const height = canvas.height;
    const hmul = inScaleGraph.get();

    ctx.fillStyle = colorBg;
    ctx.fillRect(0, 0, canvas.width, height);

    ctx.fillStyle = colorRAF;

    let k = 0;
    const numBars = Math.max(0, parseInt(inSizeGraph.get()));

    for (k = numBars; k >= 0; k--)
    {
        if (queue[k] > 30) ctx.fillStyle = colorRAFSlow;
        if (queue[k] > 60) ctx.fillStyle = colorRAFVeruSlow;

        ctx.fillRect(numBars - k, height - queue[k] * hmul, 1, queue[k] * hmul);
        if (queue[k] > 30)ctx.fillStyle = colorRAF;
    }

    for (k = numBars; k >= 0; k--)
    {
        let sum = 0;
        ctx.fillStyle = colorMainloop;
        sum = timesMainloop[k];
        ctx.fillRect(numBars - k, height - sum * hmul, 1, timesMainloop[k] * hmul);

        ctx.fillStyle = colorOnFrame;
        sum += timesOnFrame[k];
        ctx.fillRect(numBars - k, height - sum * hmul, 1, timesOnFrame[k] * hmul);

        ctx.fillStyle = colorGPU;
        sum += timesGPU[k];
        ctx.fillRect(numBars - k, height - sum * hmul, 1, timesGPU[k] * hmul);
    }

    for (let i = 10; i < height; i += 10)
    {
        ctx.fillStyle = "#888";
        const y = height - (i * hmul);
        ctx.fillRect(canvas.width - 5, y, 5, 1);
        ctx.font = "8px arial";

        ctx.fillText(i + "ms", canvas.width - 27, y + 3);
    }

    ctx.fillStyle = "#fff";
    ctx.fillRect(canvas.width - 5, height - (1000 / fps * hmul), 5, 1);
    ctx.fillText(Math.round(1000 / fps) + "ms", canvas.width - 27, height - (1000 / fps * hmul));
}

function createCanvas()
{
    canvas = document.createElement("canvas");
    canvas.id = "performance_" + op.patch.config.glCanvasId;
    canvas.width = inSizeGraph.get();
    canvas.height = inSizeGraph.get();
    canvas.style.display = "block";
    canvas.style.opacity = 0.9;
    canvas.style.position = "absolute";
    canvas.style.left = "0px";
    canvas.style.cursor = "pointer";
    canvas.style.top = "-64px";
    canvas.style["z-index"] = "99998";
    container.appendChild(canvas);
    ctx = canvas.getContext("2d");

    canvas.addEventListener("click", toggleOpened);

    updateSize();
}

function updateText()
{
    if (!inShow.get()) return;
    let warn = "";

    if (op.patch.cgl.profileData.profileShaderCompiles > 0)warn += "Shader compile (" + op.patch.cgl.profileData.profileShaderCompileName + ") ";
    if (op.patch.cgl.profileData.profileShaderGetUniform > 0)warn += "Shader get uni loc! (" + op.patch.cgl.profileData.profileShaderGetUniformName + ")";
    if (op.patch.cgl.profileData.profileTextureResize > 0)warn += "Texture resize! ";
    if (op.patch.cgl.profileData.profileFrameBuffercreate > 0)warn += "Framebuffer create! ";
    if (op.patch.cgl.profileData.profileEffectBuffercreate > 0)warn += "Effectbuffer create! ";
    if (op.patch.cgl.profileData.profileTextureDelete > 0)warn += "Texture delete! ";
    if (op.patch.cgl.profileData.profileNonTypedAttrib > 0)warn += "Not-Typed Buffer Attrib! " + op.patch.cgl.profileData.profileNonTypedAttribNames;
    if (op.patch.cgl.profileData.profileTextureNew > 0)warn += "new texture created! ";
    if (op.patch.cgl.profileData.profileGenMipMap > 0)warn += "generating mip maps!";

    if (warn.length > 0)
    {
        warn = "| <span style=\"color:#f80;\">WARNING: " + warn + "<span>";
    }

    let html = "";

    if (opened)
    {
        html += "<span style=\"color:" + colorRAF + "\">■</span> " + fps + " fps ";
        html += "<span style=\"color:" + colorMainloop + "\">■</span> " + Math.round(currentTimeMainloop * 100) / 100 + "ms mainloop ";
        html += "<span style=\"color:" + colorOnFrame + "\">■</span> " + Math.round((currentTimeOnFrame) * 100) / 100 + "ms onframe ";
        if (currentTimeGPU) html += "<span style=\"color:" + colorGPU + "\">■</span> " + Math.round(currentTimeGPU * 100) / 100 + "ms GPU";
        html += warn;
        element.innerHTML = html;
    }
    else
    {
        html += fps + " fps / ";
        html += "CPU: " + Math.round((op.patch.cgl.profileData.profileOnAnimFrameOps) * 100) / 100 + "ms / ";
        if (currentTimeGPU)html += "GPU: " + Math.round(currentTimeGPU * 100) / 100 + "ms  ";
        element.innerHTML = html;
    }

    if (op.patch.loading.getProgress() != 1.0)
    {
        element.innerHTML += "<br/>loading " + Math.round(op.patch.loading.getProgress() * 100) + "% " + loadingChars[(++loadingCounter) % loadingChars.length];
    }

    if (opened)
    {
        let count = 0;
        avgMs = 0;
        avgMsChilds = 0;
        for (let i = queue.length; i > queue.length - queue.length / 3; i--)
        {
            if (queue[i] > -1)
            {
                avgMs += queue[i];
                count++;
            }

            if (timesMainloop[i] > -1) avgMsChilds += timesMainloop[i];
        }

        avgMs /= count;
        avgMsChilds /= count;

        element.innerHTML += "<br/> " + cgl.canvasWidth + " x " + cgl.canvasHeight + " (x" + cgl.pixelDensity + ") ";
        element.innerHTML += "<br/>frame avg: " + Math.round(avgMsChilds * 100) / 100 + " ms (" + Math.round(avgMsChilds / avgMs * 100) + "%) / " + Math.round(avgMs * 100) / 100 + " ms";
        element.innerHTML += " (self: " + Math.round((selfTime) * 100) / 100 + " ms) ";

        element.innerHTML += "<br/>shader binds: " + Math.ceil(op.patch.cgl.profileData.profileShaderBinds / fps) +
            " uniforms: " + Math.ceil(op.patch.cgl.profileData.profileUniformCount / fps) +
            " mvp_uni_mat4: " + Math.ceil(op.patch.cgl.profileData.profileMVPMatrixCount / fps) +
            " num glPrimitives: " + Math.ceil(op.patch.cgl.profileData.profileMeshNumElements / (fps)) +

            " fenced pixelread: " + Math.ceil(op.patch.cgl.profileData.profileFencedPixelRead) +

            " mesh.setGeom: " + op.patch.cgl.profileData.profileMeshSetGeom +
            " videos: " + op.patch.cgl.profileData.profileVideosPlaying +
            " tex preview: " + op.patch.cgl.profileData.profileTexPreviews;

        element.innerHTML +=
        " draw meshes: " + Math.ceil(op.patch.cgl.profileData.profileMeshDraw / fps) +
        " framebuffer blit: " + Math.ceil(op.patch.cgl.profileData.profileFramebuffer / fps) +
        " texeffect blit: " + Math.ceil(op.patch.cgl.profileData.profileTextureEffect / fps);

        element.innerHTML += " all shader compiletime: " + Math.round(op.patch.cgl.profileData.shaderCompileTime * 100) / 100;
    }

    op.patch.cgl.profileData.clear();
}

function styleMeasureEle(ele)
{
    ele.style.padding = "0px";
    ele.style.margin = "0px";
}

function addMeasureChild(m, parentEle, timeSum, level)
{
    const height = 20;
    m.usedAvg = (m.usedAvg || m.used);

    if (!m.ele || initMeasures)
    {
        const newEle = document.createElement("div");
        m.ele = newEle;

        if (m.childs && m.childs.length > 0) newEle.style.height = "500px";
        else newEle.style.height = height + "px";

        newEle.style.overflow = "hidden";
        newEle.style.display = "inline-block";

        if (!m.isRoot)
        {
            newEle.innerHTML = "<div style=\"min-height:" + height + "px;width:100%;overflow:hidden;color:black;position:relative\">&nbsp;" + m.name + "</div>";
            newEle.style["background-color"] = "rgb(" + m.colR + "," + m.colG + "," + m.colB + ")";
            newEle.style["border-left"] = "1px solid black";
        }

        parentEle.appendChild(newEle);
    }

    if (!m.isRoot)
    {
        if (performance.now() - m.lastTime > 200)
        {
            m.ele.style.display = "none";
            m.hidden = true;
        }
        else
        {
            if (m.hidden)
            {
                m.ele.style.display = "inline-block";
                m.hidden = false;
            }
        }

        m.ele.style.float = "left";
        m.ele.style.width = Math.floor((m.usedAvg / timeSum) * 98.0) + "%";
    }
    else
    {
        m.ele.style.width = "100%";
        m.ele.style.clear = "both";
        m.ele.style.float = "none";
    }

    if (m && m.childs && m.childs.length > 0)
    {
        let thisTimeSum = 0;
        for (var i = 0; i < m.childs.length; i++)
        {
            m.childs[i].usedAvg = (m.childs[i].usedAvg || m.childs[i].used) * 0.95 + m.childs[i].used * 0.05;
            thisTimeSum += m.childs[i].usedAvg;
        }
        for (var i = 0; i < m.childs.length; i++)
        {
            addMeasureChild(m.childs[i], m.ele, thisTimeSum, level + 1);
        }
    }
}

function clearMeasures(p)
{
    for (let i = 0; i < p.childs.length; i++) clearMeasures(p.childs[i]);
    p.childs.length = 0;
}

function measures()
{
    if (!CGL.performanceMeasures) return;

    if (!elementMeasures)
    {
        op.log("create measure ele");
        elementMeasures = document.createElement("div");
        elementMeasures.style.width = "100%";
        elementMeasures.style["background-color"] = "#444";
        elementMeasures.style.bottom = "10px";
        elementMeasures.style.height = "100px";
        elementMeasures.style.opacity = "1";
        elementMeasures.style.position = "absolute";
        elementMeasures.style["z-index"] = "99999";
        elementMeasures.innerHTML = "";
        container.appendChild(elementMeasures);
    }

    let timeSum = 0;
    const root = CGL.performanceMeasures[0];

    for (let i = 0; i < root.childs.length; i++) timeSum += root.childs[i].used;

    addMeasureChild(CGL.performanceMeasures[0], elementMeasures, timeSum, 0);

    root.childs.length = 0;

    clearMeasures(CGL.performanceMeasures[0]);

    CGL.performanceMeasures.length = 0;
    initMeasures = false;
}

exe.onTriggered = render;

function render()
{
    const selfTimeStart = performance.now();
    frameCount++;

    if (glQueryExt && inDoGpu.get() && inShow.get())op.patch.cgl.profileData.doProfileGlQuery = true;
    else op.patch.cgl.profileData.doProfileGlQuery = false;

    if (fpsStartTime === 0)fpsStartTime = Date.now();
    if (Date.now() - fpsStartTime >= 1000)
    {
        // query=null;
        fps = frameCount;
        frameCount = 0;
        // frames = 0;
        outFPS.set(fps);
        if (inShow.get())updateText();

        fpsStartTime = Date.now();
    }

    const glQueryData = op.patch.cgl.profileData.glQueryData;
    currentTimeGPU = 0;
    if (glQueryData)
    {
        let count = 0;
        for (let i in glQueryData)
        {
            count++;
            if (glQueryData[i].time)
                currentTimeGPU += glQueryData[i].time;
        }
    }

    if (inShow.get())
    {
        measures();

        if (opened && !op.patch.cgl.profileData.pause)
        {
            // const timeUsed = performance.now() - lastTime;
            queue.push(op.patch.cgl.profileData.profileFrameDelta);
            queue.shift();

            timesMainloop.push(childsTime);
            timesMainloop.shift();

            timesOnFrame.push(op.patch.cgl.profileData.profileOnAnimFrameOps - op.patch.cgl.profileData.profileMainloopMs);
            timesOnFrame.shift();

            timesGPU.push(currentTimeGPU);
            timesGPU.shift();

            updateCanvas();
        }
    }

    lastTime = performance.now();
    selfTime = performance.now() - selfTimeStart;
    const startTimeChilds = performance.now();

    outCanv.setRef(canvas);

    next.trigger();

    const nChildsTime = performance.now() - startTimeChilds;
    const nCurrentTimeMainloop = op.patch.cgl.profileData.profileMainloopMs;
    const nCurrentTimeOnFrame = op.patch.cgl.profileData.profileOnAnimFrameOps - op.patch.cgl.profileData.profileMainloopMs;

    if (smoothGraph.get())
    {
        childsTime = childsTime * 0.9 + nChildsTime * 0.1;
        currentTimeMainloop = currentTimeMainloop * 0.5 + nCurrentTimeMainloop * 0.5;
        currentTimeOnFrame = currentTimeOnFrame * 0.5 + nCurrentTimeOnFrame * 0.5;
    }
    else
    {
        childsTime = nChildsTime;
        currentTimeMainloop = nCurrentTimeMainloop;
        currentTimeOnFrame = nCurrentTimeOnFrame;
    }

    op.patch.cgl.profileData.clearGlQuery();
}


};

Ops.Gl.Performance.prototype = new CABLES.Op();
CABLES.OPS["9cd2d9de-000f-4a14-bd13-e7d5f057583c"]={f:Ops.Gl.Performance,objName:"Ops.Gl.Performance"};




// **************************************************************
// 
// Ops.Gl.Matrix.Camera
// 
// **************************************************************

Ops.Gl.Matrix.Camera = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

/* Inputs */
// projection | prespective & ortogonal
const projectionMode = op.inValueSelect("projection mode", ["prespective", "ortogonal"], "prespective");
const zNear = op.inValue("frustum near", 0.01);
const zFar = op.inValue("frustum far", 5000.0);

const fov = op.inValue("fov", 45);
const autoAspect = op.inValueBool("Auto Aspect Ratio", true);
const aspect = op.inValue("Aspect Ratio", 1);

// look at camera
const eyeX = op.inValue("eye X", 0);
const eyeY = op.inValue("eye Y", 0);
const eyeZ = op.inValue("eye Z", 5);

const centerX = op.inValue("center X", 0);
const centerY = op.inValue("center Y", 0);
const centerZ = op.inValue("center Z", 0);

// camera transform and movements
const posX = op.inValue("truck", 0);
const posY = op.inValue("boom", 0);
const posZ = op.inValue("dolly", 0);

const rotX = op.inValue("tilt", 0);
const rotY = op.inValue("pan", 0);
const rotZ = op.inValue("roll", 0);

/* Outputs */
const outAsp = op.outNumber("Aspect");
const outArr = op.outArray("Look At Array");

/* logic */
const cgl = op.patch.cgl;

let asp = 0;

const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

const arr = [];

// Transform and move
const vPos = vec3.create();
const transMatrixMove = mat4.create();
mat4.identity(transMatrixMove);

let updateCameraMovementMatrix = true;

render.onTriggered = function ()
{
    if (cgl.frameStore.shadowPass) return trigger.trigger();

    // Aspect ration
    if (!autoAspect.get()) asp = aspect.get();
    else asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];
    outAsp.set(asp);

    // translation (truck, boom, dolly)
    cgl.pushViewMatrix();

    if (updateCameraMovementMatrix)
    {
        mat4.identity(transMatrixMove);

        vec3.set(vPos, posX.get(), posY.get(), posZ.get());
        if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0)
            mat4.translate(transMatrixMove, transMatrixMove, vPos);

        if (rotX.get() !== 0)
            mat4.rotateX(transMatrixMove, transMatrixMove, rotX.get() * CGL.DEG2RAD);
        if (rotY.get() !== 0)
            mat4.rotateY(transMatrixMove, transMatrixMove, rotY.get() * CGL.DEG2RAD);
        if (rotZ.get() !== 0)
            mat4.rotateZ(transMatrixMove, transMatrixMove, rotZ.get() * CGL.DEG2RAD);

        updateCameraMovementMatrix = false;
    }

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrixMove);

    // projection (prespective / ortogonal)
    cgl.pushPMatrix();

    // look at
    cgl.pushViewMatrix();

    if (projectionMode.get() == "prespective")
    {
        mat4.perspective(
            cgl.pMatrix,
            fov.get() * 0.0174533,
            asp,
            zNear.get(),
            zFar.get()
        );
    }
    else if (projectionMode.get() == "ortogonal")
    {
        mat4.ortho(
            cgl.pMatrix,
            -1 * (fov.get() / 14),
            1 * (fov.get() / 14),
            -1 * (fov.get() / 14) / asp,
            1 * (fov.get() / 14) / asp,
            zNear.get(),
            zFar.get()
        );
    }

    arr[0] = eyeX.get();
    arr[1] = eyeY.get();
    arr[2] = eyeZ.get();

    arr[3] = centerX.get();
    arr[4] = centerY.get();
    arr[5] = centerZ.get();

    arr[6] = 0;
    arr[7] = 1;
    arr[8] = 0;

    outArr.setRef(arr);

    vec3.set(vUp, 0, 1, 0);
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());
    vec3.set(vCenter, centerX.get(), centerY.get(), centerZ.get());

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();

    cgl.popViewMatrix();
    cgl.popPMatrix();

    cgl.popViewMatrix();

    // GUI for dolly, boom and truck
    if (op.isCurrentUiOp())
        gui.setTransformGizmo({
            "posX": posX,
            "posY": posY,
            "posZ": posZ
        });
};

const updateUI = function ()
{
    if (!autoAspect.get())
    {
        aspect.setUiAttribs({ "greyout": false });
    }
    else
    {
        aspect.setUiAttribs({ "greyout": true });
    }
};

const cameraMovementChanged = function ()
{
    updateCameraMovementMatrix = true;
};

// listeners
posX.onChange = cameraMovementChanged;
posY.onChange = cameraMovementChanged;
posZ.onChange = cameraMovementChanged;

rotX.onChange = cameraMovementChanged;
rotY.onChange = cameraMovementChanged;
rotZ.onChange = cameraMovementChanged;

autoAspect.onChange = updateUI;
updateUI();


};

Ops.Gl.Matrix.Camera.prototype = new CABLES.Op();
CABLES.OPS["b24dbfdc-485c-49d2-92a1-7258efd9239a"]={f:Ops.Gl.Matrix.Camera,objName:"Ops.Gl.Matrix.Camera"};




// **************************************************************
// 
// Ops.Gl.RenderGeometry_v2
// 
// **************************************************************

Ops.Gl.RenderGeometry_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    geometry = op.inObject("Geometry", null, "geometry"),
    inActive = op.inBool("Render Mesh", true),

    inVertNums = op.inBool("Add Vertex Numbers", true),
    trigger = op.outTrigger("trigger");

op.toWorkPortsNeedToBeLinked(geometry, render);

geometry.ignoreValueSerialize = true;

let mesh = null;
let needsUpdate = true;

geometry.onLinkChanged =
inVertNums.onChange =
    geometry.onChange = () => { needsUpdate = true; };

render.onTriggered = function ()
{
    if (needsUpdate) update();
    if (mesh && inActive.get()) mesh.render(op.patch.cgl.getShader());
    trigger.trigger();
};

function update()
{
    needsUpdate = false;
    const geom = geometry.get();
    if (geom && geom.isGeometry)
    {
        if (mesh)
        {
            mesh.dispose();
            mesh = null;
        }
        if (!mesh)
        {
            mesh = new CGL.Mesh(op.patch.cgl, geom);
            mesh.addVertexNumbers = inVertNums.get();
            mesh.setGeom(geom);
        }
    }
    else
    {
        mesh = null;
    }
}


};

Ops.Gl.RenderGeometry_v2.prototype = new CABLES.Op();
CABLES.OPS["0a9bdb39-8250-460e-8d99-50fe6825d956"]={f:Ops.Gl.RenderGeometry_v2,objName:"Ops.Gl.RenderGeometry_v2"};




// **************************************************************
// 
// Ops.Gl.Matrix.TransformView
// 
// **************************************************************

Ops.Gl.Matrix.TransformView = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    posX = op.inValueFloat("posX"),
    posY = op.inValueFloat("posY"),
    posZ = op.inValueFloat("posZ"),
    scale = op.inValueFloat("scale"),
    rotX = op.inValueFloat("rotX"),
    rotY = op.inValueFloat("rotY"),
    rotZ = op.inValueFloat("rotZ"),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Position", [posX, posY, posZ]);
op.setPortGroup("Scale", [scale]);
op.setPortGroup("Rotation", [rotX, rotZ, rotY]);

const vPos = vec3.create();
const vScale = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

let doScale = false;
let doTranslate = false;

let translationChanged = true;
let didScaleChanged = true;
let didRotChanged = true;

render.onTriggered = function ()
{
    const cg = op.patch.cgl;

    let updateMatrix = false;
    if (translationChanged)
    {
        updateTranslation();
        updateMatrix = true;
    }
    if (didScaleChanged)
    {
        updateScale();
        updateMatrix = true;
    }
    if (didRotChanged)
    {
        updateMatrix = true;
    }
    if (updateMatrix)doUpdateMatrix();

    cg.pushViewMatrix();
    mat4.multiply(cg.vMatrix, cg.vMatrix, transMatrix);

    trigger.trigger();
    cg.popViewMatrix();

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": posX,
                "posY": posY,
                "posZ": posZ,
            });
};

op.transform3d = function ()
{
    return {
        "pos": [posX, posY, posZ]
    };
};

function doUpdateMatrix()
{
    mat4.identity(transMatrix);
    if (doTranslate)mat4.translate(transMatrix, transMatrix, vPos);

    if (rotX.get() !== 0)mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    if (rotY.get() !== 0)mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    if (rotZ.get() !== 0)mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    if (doScale)mat4.scale(transMatrix, transMatrix, vScale);
    rotChanged = false;
}

function updateTranslation()
{
    doTranslate = false;
    if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0) doTranslate = true;
    vec3.set(vPos, posX.get(), posY.get(), posZ.get());
    translationChanged = false;
}

function updateScale()
{
    doScale = false;
    if (scale.get() !== 0.0)doScale = true;
    vec3.set(vScale, scale.get(), scale.get(), scale.get());
    scaleChanged = false;
}

function translateChanged()
{
    translationChanged = true;
}

function scaleChanged()
{
    didScaleChanged = true;
}

function rotChanged()
{
    didRotChanged = true;
}

rotX.onChange =
rotY.onChange =
rotZ.onChange = rotChanged;

scale.onChange = scaleChanged;

posX.onChange =
posY.onChange =
posZ.onChange = translateChanged;

rotX.set(0.0);
rotY.set(0.0);
rotZ.set(0.0);

scale.set(1.0);

posX.set(0.0);
posY.set(0.0);
posZ.set(0.0);

doUpdateMatrix();


};

Ops.Gl.Matrix.TransformView.prototype = new CABLES.Op();
CABLES.OPS["0b3e04f7-323e-4ac8-8a22-a21e2f36e0e9"]={f:Ops.Gl.Matrix.TransformView,objName:"Ops.Gl.Matrix.TransformView"};




// **************************************************************
// 
// Ops.Devices.Mouse.Mouse_v3
// 
// **************************************************************

Ops.Devices.Mouse.Mouse_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inCoords = op.inSwitch("Coordinates", ["-1 to 1", "Pixel Display", "Pixel", "0 to 1"], "-1 to 1"),
    area = op.inValueSelect("Area", ["Canvas", "Document", "Parent Element", "Canvas Area"], "Canvas"),
    flipY = op.inValueBool("flip y", true),
    rightClickPrevDef = op.inBool("right click prevent default", true),
    touchscreen = op.inValueBool("Touch support", true),
    active = op.inValueBool("Active", true),
    outMouseX = op.outNumber("x", 0),
    outMouseY = op.outNumber("y", 0),
    mouseClick = op.outTrigger("click"),
    mouseClickRight = op.outTrigger("click right"),
    mouseDown = op.outBoolNum("Button is down"),
    mouseOver = op.outBoolNum("Mouse is hovering"),
    outMovementX = op.outNumber("Movement X", 0),
    outMovementY = op.outNumber("Movement Y", 0);

const cgl = op.patch.cgl;
let normalize = 1;
let listenerElement = null;
let sizeElement = null;
area.onChange = addListeners;

inCoords.onChange = updateCoordNormalizing;
op.onDelete = removeListeners;

addListeners();

op.on("loadedValueSet",
    () =>
    {
        if (normalize == 0)
        {
            outMouseX.set(sizeElement.clientWidth / 2);
            outMouseY.set(sizeElement.clientHeight / 2);
        }
        if (normalize == 1)
        {
            outMouseX.set(0);
            outMouseY.set(0);
        }
        if (normalize == 2)
        {
            outMouseX.set(0.5);
            outMouseY.set(0.5);
        }
    });

function setValue(x, y)
{
    x = x || 0;
    y = y || 0;

    if (normalize == 0) // pixel
    {
        outMouseX.set(x);
        outMouseY.set(y);
    }
    else
    if (normalize == 3) // pixel css
    {
        outMouseX.set(x * cgl.pixelDensity);
        outMouseY.set(y * cgl.pixelDensity);
    }
    else
    {
        let w = sizeElement.clientWidth / cgl.pixelDensity;
        let h = sizeElement.clientHeight / cgl.pixelDensity;

        w = w || 1;
        h = h || 1;

        if (normalize == 1) // -1 to 1
        {
            let xx = (x / w * 2.0 - 1.0);
            let yy = (y / h * 2.0 - 1.0);
            xx = CABLES.clamp(xx, -1, 1);
            yy = CABLES.clamp(yy, -1, 1);

            outMouseX.set(xx);
            outMouseY.set(yy);
        }
        else if (normalize == 2) // 0 to 1
        {
            let xx = x / w;
            let yy = y / h;

            xx = CABLES.clamp(xx, 0, 1);
            yy = CABLES.clamp(yy, 0, 1);

            outMouseX.set(xx);
            outMouseY.set(yy);
        }
    }
}

function checkHovering(e)
{
    const r = sizeElement.getBoundingClientRect();

    return (
        e.clientX > r.left &&
        e.clientX < r.left + r.width &&
        e.clientY > r.top &&
        e.clientY < r.top + r.height
    );
}

touchscreen.onChange = function ()
{
    removeListeners();
    addListeners();
};

active.onChange = function ()
{
    if (listenerElement)removeListeners();
    if (active.get())addListeners();
};

function updateCoordNormalizing()
{
    if (inCoords.get() == "Pixel") normalize = 0;
    else if (inCoords.get() == "-1 to 1") normalize = 1;
    else if (inCoords.get() == "0 to 1") normalize = 2;
    else if (inCoords.get() == "Pixel Display") normalize = 3;
}

function onMouseEnter(e)
{
    mouseDown.set(false);
    mouseOver.set(checkHovering(e));
}

function onMouseDown(e)
{
    if (!checkHovering(e)) return;
    mouseDown.set(true);
}

function onMouseUp(e)
{
    mouseDown.set(false);
}

function onClickRight(e)
{
    if (!checkHovering(e)) return;
    mouseClickRight.trigger();
    if (rightClickPrevDef.get()) e.preventDefault();
}

function onmouseclick(e)
{
    if (!checkHovering(e)) return;
    mouseClick.trigger();
}

function onMouseLeave(e)
{
    mouseDown.set(false);
    mouseOver.set(checkHovering(e));
}

function setCoords(e)
{
    let x = e.clientX;
    let y = e.clientY;

    if (area.get() != "Document")
    {
        x = e.offsetX;
        y = e.offsetY;
    }
    if (area.get() === "Canvas Area")
    {
        const r = sizeElement.getBoundingClientRect();
        x = e.clientX - r.left;
        y = e.clientY - r.top;
    }

    if (flipY.get()) y = sizeElement.clientHeight - y;

    setValue(x / cgl.pixelDensity, y / cgl.pixelDensity);
}

function onmousemove(e)
{
    mouseOver.set(checkHovering(e));
    setCoords(e);

    outMovementX.set(e.movementX / cgl.pixelDensity);
    outMovementY.set(e.movementY / cgl.pixelDensity);
}

function ontouchmove(e)
{
    if (event.touches && event.touches.length > 0) setCoords(e.touches[0]);
}

function ontouchstart(event)
{
    mouseDown.set(true);

    if (event.touches && event.touches.length > 0) onMouseDown(event.touches[0]);
}

function ontouchend(event)
{
    mouseDown.set(false);
    onMouseUp();
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("touchend", ontouchend);
    listenerElement.removeEventListener("touchstart", ontouchstart);
    listenerElement.removeEventListener("touchmove", ontouchmove);

    listenerElement.removeEventListener("click", onmouseclick);
    listenerElement.removeEventListener("mousemove", onmousemove);
    listenerElement.removeEventListener("mouseleave", onMouseLeave);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("mouseenter", onMouseEnter);
    listenerElement.removeEventListener("contextmenu", onClickRight);
    listenerElement = null;
}

function addListeners()
{
    if (listenerElement || !active.get())removeListeners();
    if (!active.get()) return;

    listenerElement = sizeElement = cgl.canvas;
    if (area.get() == "Canvas Area")
    {
        sizeElement = cgl.canvas.parentElement;
        listenerElement = document.body;
    }
    if (area.get() == "Document") sizeElement = listenerElement = document.body;
    if (area.get() == "Parent Element") listenerElement = sizeElement = cgl.canvas.parentElement;

    if (touchscreen.get())
    {
        listenerElement.addEventListener("touchend", ontouchend, false);
        listenerElement.addEventListener("touchstart", ontouchstart, false);
        listenerElement.addEventListener("touchmove", ontouchmove, false);
    }

    listenerElement.addEventListener("mousemove", onmousemove, false);
    listenerElement.addEventListener("mouseleave", onMouseLeave, false);
    listenerElement.addEventListener("mousedown", onMouseDown, false);
    listenerElement.addEventListener("mouseup", onMouseUp, false);
    listenerElement.addEventListener("mouseenter", onMouseEnter, false);
    listenerElement.addEventListener("contextmenu", onClickRight, false);
    listenerElement.addEventListener("click", onmouseclick, false);
}

//


};

Ops.Devices.Mouse.Mouse_v3.prototype = new CABLES.Op();
CABLES.OPS["6d1edbc0-088a-43d7-9156-918fb3d7f24b"]={f:Ops.Devices.Mouse.Mouse_v3,objName:"Ops.Devices.Mouse.Mouse_v3"};




// **************************************************************
// 
// Ops.Html.Cursor_v2
// 
// **************************************************************

Ops.Html.Cursor_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exec = op.inTriggerButton("Update"),

    cursorPort = op.inDropDown("CSS Cursors", ["auto", "crosshair", "pointer", "hand", "move", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "ew-resize", "text", "wait", "help", "none"], "pointer"),

    next = op.outTrigger("Next");

const cursorStr = "";

exec.onLinkChanged =
next.onLinkChanged = () =>
{
    op.patch.cgl.setCursor("auto");
};

exec.onTriggered = () =>
{
    op.patch.cgl.setCursor(cursorPort.get());
    next.trigger();
};


};

Ops.Html.Cursor_v2.prototype = new CABLES.Op();
CABLES.OPS["39486799-bdad-42d3-a300-4642c23578a8"]={f:Ops.Html.Cursor_v2,objName:"Ops.Html.Cursor_v2"};




// **************************************************************
// 
// Ops.Number.ToggleNumber
// 
// **************************************************************

Ops.Number.ToggleNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    useValue1Port = op.inValueBool("Use Value 1", false),
    value0port = op.inValue("Value 0", 0),
    value1port = op.inValue("Value 1", 1),
    outValuePort = op.outNumber("Out Value", 0);

value0port.onChange =
    value1port.onChange =
    useValue1Port.onChange = setOutput;

function setOutput()
{
    const useValue1 = useValue1Port.get();
    if (useValue1)
    {
        outValuePort.set(value1port.get());
    }
    else
    {
        outValuePort.set(value0port.get());
    }
}


};

Ops.Number.ToggleNumber.prototype = new CABLES.Op();
CABLES.OPS["400eea7d-5a68-4dda-a94d-2bb2ee7c2331"]={f:Ops.Number.ToggleNumber,objName:"Ops.Number.ToggleNumber"};




// **************************************************************
// 
// Ops.Gl.Matrix.Translate
// 
// **************************************************************

Ops.Gl.Matrix.Translate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z");

const vec = vec3.create();

render.onTriggered = function ()
{
    const cgl = op.patch.cg;

    vec3.set(vec, x.get(), y.get(), z.get());
    cgl.pushModelMatrix();
    mat4.translate(cgl.mMatrix, cgl.mMatrix, vec);
    trigger.trigger();
    cgl.popModelMatrix();
};


};

Ops.Gl.Matrix.Translate.prototype = new CABLES.Op();
CABLES.OPS["1f89ba0e-e7eb-46d7-8c66-7814b7c528b9"]={f:Ops.Gl.Matrix.Translate,objName:"Ops.Gl.Matrix.Translate"};




// **************************************************************
// 
// Ops.String.ParseInt_v2
// 
// **************************************************************

Ops.String.ParseInt_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    str = op.inString("String", 5711),
    outNum = op.outNumber("Number");

str.onChange = function ()
{
    let num = parseInt(str.get());
    if (num != num) num = 0;
    outNum.set(num);
};


};

Ops.String.ParseInt_v2.prototype = new CABLES.Op();
CABLES.OPS["6d208424-daf2-4a2b-874f-daac406c1f66"]={f:Ops.String.ParseInt_v2,objName:"Ops.String.ParseInt_v2"};




// **************************************************************
// 
// Ops.String.StringReplace
// 
// **************************************************************

Ops.String.StringReplace = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inStr = op.inString("String"),
    inSearch = op.inString("Search For", "foo"),
    inRepl = op.inString("Replace", "bar"),
    inWhat = op.inSwitch("Replace What", ["All", "First"], "All"),
    outStr = op.outString("Result");

inRepl.onChange =
inStr.onChange =
inWhat.onChange =
inSearch.onChange = update;

function update()
{
    op.setUiError("exception", null);

    let str = "";
    try
    {
        if (inWhat.get() == "All") str = String(inStr.get()).replace(new RegExp(inSearch.get(), "g"), inRepl.get());
        else str = String(inStr.get()).replace(inSearch.get(), inRepl.get());
    }
    catch (e)
    {
        op.setUiError("exception", "exception " + e.message);
    }

    outStr.set(str);
}


};

Ops.String.StringReplace.prototype = new CABLES.Op();
CABLES.OPS["4a053e7a-6b00-4e71-bd51-90cdb190994c"]={f:Ops.String.StringReplace,objName:"Ops.String.StringReplace"};




// **************************************************************
// 
// Ops.Trigger.TriggerExtender
// 
// **************************************************************

Ops.Trigger.TriggerExtender = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inTriggerPort = op.inTriggerButton("Execute"),
    outTriggerPort = op.outTrigger("Next");

inTriggerPort.onTriggered = function ()
{
    outTriggerPort.trigger();
};


};

Ops.Trigger.TriggerExtender.prototype = new CABLES.Op();
CABLES.OPS["7ef594f3-4907-47b0-a2d3-9854eda1679d"]={f:Ops.Trigger.TriggerExtender,objName:"Ops.Trigger.TriggerExtender"};




// **************************************************************
// 
// Ops.Graphics.Geometry.GeometryExtrude
// 
// **************************************************************

Ops.Graphics.Geometry.GeometryExtrude = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inGeom = op.inObject("Geometry", null, "geometry"),
    inHeight = op.inFloat("Height", 0.5),
    inSmooth = op.inBool("Smooth", true),
    inExtrudeWalls = op.inBool("Walls", true),
    inCapTop = op.inBool("Top", true),
    inCapBottom = op.inBool("Bottom", true),
    outGeom = op.outObject("Result Geometry", null, "geometry");

function isClockwise(verts)
{
    let sum = 0.0;
    for (let i = 0; i < verts.length - 3; i += 3)
    {
        // Vector v1 = verts[i];
        // Vector v2 = verts[(i + 1) % verts.length];
        sum += (verts[i + 3] - verts[i]) * (verts[i + 3 + 1] + verts[i]);
    }
    return sum > 0.0;
}

inSmooth.onChange =
inExtrudeWalls.onChange =
inCapTop.onChange =
inCapBottom.onChange =
inHeight.onChange =
inGeom.onChange = () =>
{
    const geom = inGeom.get();

    if (!geom)
    {
        outGeom.set(null);
        return;
    }

    function edgesUsedMulti(idx1, idx2)
    {
        let count = 0;
        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            if (
                (
                    geom.verticesIndices[i] == idx1 ||
                    geom.verticesIndices[i + 1] == idx1 ||
                    geom.verticesIndices[i + 2] == idx1
                ) &&
                (
                    geom.verticesIndices[i] == idx2 ||
                    geom.verticesIndices[i + 1] == idx2 ||
                    geom.verticesIndices[i + 2] == idx2
                ))
            {
                count++;
                if (count == 2) return true;
            }
        }

        return false;
    }

    let verts = [];
    const indices = [];
    const h = inHeight.get();

    if (inExtrudeWalls.get())
        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            const vert1 = geom.verticesIndices[i];
            const vert2 = geom.verticesIndices[i + 1];
            const vert3 = geom.verticesIndices[i + 2];

            // 1
            if (!edgesUsedMulti(vert1, vert2))
            {
                const a = [];
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2]]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());

                a.length = 0;
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2] + h]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());
            }

            // 2
            if (!edgesUsedMulti(vert3, vert2))
            {
                const a = [];
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);

                if (isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());

                a.length = 0;

                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);

                if (isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());
            }
            // 3

            if (!edgesUsedMulti(vert3, vert1))
            {
                const a = [];
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2]]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());

                a.length = 0;

                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2] + h]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());
            }
        }

    const newGeom = CGL.Geometry.buildFromFaces(verts, "extrude", true);

    newGeom.calculateNormals();
    newGeom.calcTangentsBitangents();

    if (inCapBottom.get())
    {
        newGeom.merge(geom);
    }

    if (inCapTop.get())
    {
        const flippedgeo = geom.copy();

        for (let i = 0; i < flippedgeo.vertices.length; i += 3)
            flippedgeo.vertices[i + 2] += h;

        flippedgeo.flipVertDir();
        flippedgeo.flipNormals();
        newGeom.merge(flippedgeo);
    }

    newGeom.flipVertDir();

    if (!inSmooth.get())
    {
        newGeom.unIndex();
        newGeom.calculateNormals({ "forceZUp": true });
        newGeom.flipNormals();
    }

    outGeom.set(null);
    outGeom.set(newGeom);
};


};

Ops.Graphics.Geometry.GeometryExtrude.prototype = new CABLES.Op();
CABLES.OPS["64a34a29-000d-4350-875f-5b72b97a314f"]={f:Ops.Graphics.Geometry.GeometryExtrude,objName:"Ops.Graphics.Geometry.GeometryExtrude"};




// **************************************************************
// 
// Ops.Math.Compare.GreaterThan
// 
// **************************************************************

Ops.Math.Compare.GreaterThan = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1"),
    number2 = op.inValueFloat("number2"),
    result = op.outBoolNum("result");

op.setTitle(">");

number1.onChange = number2.onChange = exec;

function exec()
{
    result.set(number1.get() > number2.get());
}


};

Ops.Math.Compare.GreaterThan.prototype = new CABLES.Op();
CABLES.OPS["b250d606-f7f8-44d3-b099-c29efff2608a"]={f:Ops.Math.Compare.GreaterThan,objName:"Ops.Math.Compare.GreaterThan"};




// **************************************************************
// 
// Ops.User.cristianvogel.ArraySwizzleWithInput
// 
// **************************************************************

Ops.User.cristianvogel.ArraySwizzleWithInput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
let contents = ["X", "Y", "Z", "W", "0", "1", "0,1,2..", "0-1", "lookup"];

const
    inArr = op.inArray("Array"),
    inLookUpArr = op.inArray("LookUpArray"),
    inStride = op.inSwitch("Array Stride", ["1", "2", "3", "4"], "3"),
    inResultStride = op.inSwitch("Result Stride", ["1", "2", "3", "4"], "2"),
    in1 = op.inSwitch("X", contents, "X"),
    in2 = op.inSwitch("Y", contents, "Y"),
    in3 = op.inSwitch("Z", contents, "Z"),
    in4 = op.inSwitch("W", contents, "1"),
    outArr = op.outArray("Result");

op.setPortGroup("Content Result", [in1, in2, in3, in4]);

const result = [];

in1.onChange =
    in2.onChange =
    in3.onChange =
    in4.onChange =

    inStride.onChange =
    inResultStride.onChange = () =>
    {
        convert(true);
    };

inArr.onChange = convert;
inLookUpArr.onChange = convert;

function convert(updateUi)
{
    const arr = inArr.get();
    const refArr = inLookUpArr.get();
    const srcStride = parseInt(inStride.get());
    const targetStride = parseInt(inResultStride.get());

    if (CABLES.UI && updateUi)
    {
        in1.setUiAttribs({ "greyout": targetStride < 1 });
        in2.setUiAttribs({ "greyout": targetStride < 2 });
        in3.setUiAttribs({ "greyout": targetStride < 3 });
        in4.setUiAttribs({ "greyout": targetStride < 4 });

        let str = "";
        if (srcStride == "1")str += "X ";
        if (srcStride == "2")str += "XY ";
        if (srcStride == "3")str += "XYZ ";
        if (srcStride == "4")str += "XYZW ";
        str += " > ";
        str += in1.get();
        if (targetStride >= 2) str += in2.get() + " ";
        if (targetStride >= 3) str += in3.get() + " ";
        if (targetStride >= 4) str += in4.get() + " ";
        // op.setUiAttrib({ "extendTitle": str });
    }

    if (!arr) return outArr.set(null);
    const newLength = arr.length / srcStride * targetStride;

    if (newLength % 1 != 0)
    {
        outArr.set(null);
        op.setUiError("invalidlength", "Invalid array length, is not dividable by stride");
        return;
    }
    op.setUiError("invalidlength", null);

    const step = parseInt(inStride.get());

    result.length = newLength;

    const index1 = contents.indexOf(in1.get());
    const index2 = contents.indexOf(in2.get());
    const index3 = contents.indexOf(in3.get());
    const index4 = contents.indexOf(in4.get());

    let idx = 0;

    for (let i = 0; i < arr.length; i += step)
    {
        outArr.setUiAttribs({ "stride": targetStride });

        if (targetStride >= 1)
        {
            if (index1 === 0)result[idx++] = arr[i + 0];
            else if (index1 === 1)result[idx++] = arr[i + 1];
            else if (index1 === 2)result[idx++] = arr[i + 2];
            else if (index1 === 3)result[idx++] = arr[i + 3];
            else if (index1 === 4)result[idx++] = 0;
            else if (index1 === 5)result[idx++] = 1;
            else if (index1 === 6)result[idx++] = (idx - 1) / (targetStride);
            else if (index1 === 7)result[idx++] = i / arr.length;
            else if (index1 === 8)result[idx++] = refArr ? refArr.at(idx) : arr.at(idx++);
        }

        if (targetStride >= 2)
        {
            if (index2 === 0)result[idx++] = arr[i + 0];
            else if (index2 === 1)result[idx++] = arr[i + 1];
            else if (index2 === 2)result[idx++] = arr[i + 2];
            else if (index2 === 3)result[idx++] = arr[i + 3];
            else if (index2 === 4)result[idx++] = 0;
            else if (index2 === 5)result[idx++] = 1;
            else if (index2 === 6)result[idx++] = (idx - 2) / (targetStride);
            else if (index2 === 7)result[idx++] = i / arr.length;
            else if (index2 === 8)result[idx++] = refArr ? refArr.at(idx) : arr.at(idx++);
        }

        if (targetStride >= 3)
        {
            if (index3 === 0)result[idx++] = arr[i + 0];
            else if (index3 === 1)result[idx++] = arr[i + 1];
            else if (index3 === 2)result[idx++] = arr[i + 2];
            else if (index3 === 3)result[idx++] = arr[i + 3];
            else if (index3 === 4)result[idx++] = 0;
            else if (index3 === 5)result[idx++] = 1;
            else if (index3 === 6)result[idx++] = (idx - 3) / (targetStride);
            else if (index3 === 7)result[idx++] = i / arr.length;
            else if (index3 === 8)result[idx++] = refArr ? refArr.at(idx) : arr.at(idx++);
        }

        if (targetStride >= 4)
        {
            if (index4 === 0)result[idx++] = arr[i + 0];
            else if (index4 === 1)result[idx++] = arr[i + 1];
            else if (index4 === 2)result[idx++] = arr[i + 2];
            else if (index4 === 3)result[idx++] = arr[i + 3];
            else if (index4 === 4)result[idx++] = 0;
            else if (index4 === 5)result[idx++] = 1;
            else if (index4 === 6)result[idx++] = (idx - 4) / (targetStride);
            else if (index4 === 7)result[idx++] = i / arr.length;
            else if (index4 === 8)result[idx++] = refArr ? refArr.at(idx) : arr.at(idx++);
        }
    }

    outArr.setRef(result);
}


};

Ops.User.cristianvogel.ArraySwizzleWithInput.prototype = new CABLES.Op();
CABLES.OPS["b7082c3a-e517-440f-aa53-68669bd75ab6"]={f:Ops.User.cristianvogel.ArraySwizzleWithInput,objName:"Ops.User.cristianvogel.ArraySwizzleWithInput"};




// **************************************************************
// 
// Ops.User.cristianvogel.StretchArray
// 
// **************************************************************

Ops.User.cristianvogel.StretchArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inStretchFactor = op.inInt("Stretch Factor", 1),
    outLength = op.outNumber("Length", 0),
    result = op.outArray("Result");

inArr.onChange = function ()
{
    const arrValue = inArr.get();
    if (!arrValue)
    {
        result.set([]); // Set result to an empty array if input is null or undefined
        outLength.set(0); // Set length to 0 for an empty array
        return; // Exit the function early
    }

    const stretched = stretchArray(arrValue, inStretchFactor.get());
    result.set(stretched); // Set result to the stretched array
    outLength.set(stretched.length); // Set the length of the resulting array
};

function stretchArray(foo, factor)
{
    let bar = [];
    for (let i = 0; i < foo.length; i++)
    {
        for (let j = 0; j < factor; j++)
        {
            bar.push(foo[i]);
        }
    }
    return bar;
}


};

Ops.User.cristianvogel.StretchArray.prototype = new CABLES.Op();
CABLES.OPS["599399cd-9363-4796-91b9-a5f97ff7d2ca"]={f:Ops.User.cristianvogel.StretchArray,objName:"Ops.User.cristianvogel.StretchArray"};




// **************************************************************
// 
// Ops.Trigger.NthTrigger_v2
// 
// **************************************************************

Ops.Trigger.NthTrigger_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
let DEFAULT_NTH = 5;

// inputs
let exePort = op.inTriggerButton("Execute");
let nthPort = op.inValue("Nth", DEFAULT_NTH);

// outputs
let triggerPort = op.outTrigger("Next");

let count = 0;
let nth = DEFAULT_NTH;

exePort.onTriggered = onExeTriggered;
nthPort.onChange = valueChanged;

function onExeTriggered()
{
    count++;
    if (count % nth === 0)
    {
        count = 0;
        triggerPort.trigger();
    }
}

function valueChanged()
{
    nth = nthPort.get();
    count = 0;
}


};

Ops.Trigger.NthTrigger_v2.prototype = new CABLES.Op();
CABLES.OPS["ea43c184-5842-4aa1-b298-5db4515cbed0"]={f:Ops.Trigger.NthTrigger_v2,objName:"Ops.Trigger.NthTrigger_v2"};




// **************************************************************
// 
// Ops.Array.CropArray
// 
// **************************************************************

Ops.Array.CropArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    srcArrayPort = op.inArray("Source Array"),
    inStartIndex = op.inInt("Start Index"),
    newLengthPort = op.inInt("New Length", 20),
    croppedArrayOutPort = op.outArray("Cropped Array"),
    outArrayLength = op.outNumber("Array length");

inStartIndex.onChange = srcArrayPort.onChange = newLengthPort.onChange = setOutPort;

function setOutPort()
{
    const srcArray = srcArrayPort.get();

    if (!srcArray)
    {
        croppedArrayOutPort.set(null);
        outArrayLength.set(0);
        return;
    }
    let newLength = parseInt(newLengthPort.get());
    const start = Math.floor(Math.abs(inStartIndex.get()));

    if (start + newLength >= srcArray.length) newLength = srcArray.length - start;
    if (start + newLength <= srcArray.length)
    {
        let croppedArr = srcArray.slice(start, start + newLength);
        croppedArrayOutPort.set(null);
        croppedArrayOutPort.set(croppedArr);
        outArrayLength.set(croppedArr.length);
    }
}


};

Ops.Array.CropArray.prototype = new CABLES.Op();
CABLES.OPS["d8deecd3-418f-43dd-8edb-dfe238b5327c"]={f:Ops.Array.CropArray,objName:"Ops.Array.CropArray"};




// **************************************************************
// 
// Ops.Gl.Texture_v2
// 
// **************************************************************

Ops.Gl.Texture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    filename = op.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"]),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    aniso = op.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"),
    dataFrmt = op.inSwitch("Data Format", ["R", "RG", "RGB", "RGBA", "SRGBA"], "RGBA"),
    flip = op.inValueBool("Flip", false),
    unpackAlpha = op.inValueBool("Pre Multiplied Alpha", false),
    active = op.inValueBool("Active", true),
    inFreeMemory = op.inBool("Save Memory", true),
    textureOut = op.outTexture("Texture"),
    addCacheBust = op.inBool("Add Cachebuster", true),
    width = op.outNumber("Width"),
    height = op.outNumber("Height"),
    ratio = op.outNumber("Aspect Ratio"),
    loaded = op.outNumber("Loaded", false),
    loading = op.outNumber("Loading", false);

const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(textureOut);
op.setPortGroup("Size", [width, height]);

let loadedFilename = null;
let loadingId = null;
let tex = null;
let cgl_filter = CGL.Texture.FILTER_MIPMAP;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;
let cgl_aniso = 0;
let timedLoader = 0;

unpackAlpha.setUiAttribs({ "hidePort": true });
unpackAlpha.onChange =
    filename.onChange =
    dataFrmt.onChange =
    addCacheBust.onChange =
    flip.onChange = reloadSoon;
aniso.onChange = tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;

tfilter.set("mipmap");
wrap.set("repeat");

textureOut.set(CGL.Texture.getEmptyTexture(cgl));

active.onChange = function ()
{
    if (active.get())
    {
        if (loadedFilename != filename.get() || !tex) reloadSoon();
        else textureOut.set(tex);
    }
    else
    {
        textureOut.set(CGL.Texture.getEmptyTexture(cgl));
        width.set(CGL.Texture.getEmptyTexture(cgl).width);
        height.set(CGL.Texture.getEmptyTexture(cgl).height);
        if (tex)tex.delete();
        op.setUiAttrib({ "extendTitle": "" });
        tex = null;
    }
};

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    textureOut.set(t);
};

function reloadSoon(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

function getPixelFormat()
{
    if (dataFrmt.get() == "R") return CGL.Texture.PFORMATSTR_R8UB;
    if (dataFrmt.get() == "RG") return CGL.Texture.PFORMATSTR_RG8UB;
    if (dataFrmt.get() == "RGB") return CGL.Texture.PFORMATSTR_RGB8UB;
    if (dataFrmt.get() == "SRGBA") return CGL.Texture.PFORMATSTR_SRGBA8;

    return CGL.Texture.PFORMATSTR_RGBA8UB;
}

function realReload(nocache)
{
    op.checkMainloopExists();
    if (!active.get()) return;
    // if (filename.get() === null) return;
    if (loadingId)loadingId = cgl.patch.loading.finished(loadingId);
    loadingId = cgl.patch.loading.start("textureOp", filename.get(), op);

    let url = op.patch.getFilePath(String(filename.get()));

    if ((addCacheBust.get() || nocache) && CABLES.UI)url = CABLES.cacheBust(url);

    if (String(filename.get()).indexOf("data:") == 0) url = filename.get();

    let needsRefresh = false;
    if (loadedFilename != filename.get()) needsRefresh = true;
    loadedFilename = filename.get();

    if ((filename.get() && filename.get().length > 1))
    {
        loaded.set(false);
        loading.set(true);

        const fileToLoad = filename.get();

        op.setUiAttrib({ "extendTitle": CABLES.basename(url) });
        if (needsRefresh) op.refreshParams();

        cgl.patch.loading.addAssetLoadingTask(() =>
        {
            op.setUiError("urlerror", null);
            CGL.Texture.load(cgl, url, function (err, newTex)
            {
                cgl.checkFrameStarted("texture inittexture");

                if (filename.get() != fileToLoad)
                {
                    cgl.patch.loading.finished(loadingId);
                    loadingId = null;
                    return;
                }

                if (tex)tex.delete();

                if (err)
                {
                    const t = CGL.Texture.getErrorTexture(cgl);
                    textureOut.setRef(t);

                    op.setUiError("urlerror", "could not load texture: \"" + filename.get() + "\"", 2);
                    cgl.patch.loading.finished(loadingId);
                    loadingId = null;
                    return;
                }

                // textureOut.setRef(newTex);

                width.set(newTex.width);
                height.set(newTex.height);
                ratio.set(newTex.width / newTex.height);

                // if (!newTex.isPowerOfTwo()) op.setUiError("npot", "Texture dimensions not power of two! - Texture filtering will not work in WebGL 1.", 0);
                // else op.setUiError("npot", null);

                tex = newTex;
                // textureOut.set(null);
                textureOut.setRef(tex);

                loading.set(false);
                loaded.set(true);

                if (inFreeMemory.get()) tex.image = null;

                if (loadingId)
                {
                    cgl.patch.loading.finished(loadingId);
                    loadingId = null;
                }
                op.checkMainloopExists();
            }, {
                "anisotropic": cgl_aniso,
                "wrap": cgl_wrap,
                "flip": flip.get(),
                "unpackAlpha": unpackAlpha.get(),
                "pixelFormat": getPixelFormat(),
                "filter": cgl_filter
            });

            op.checkMainloopExists();
        });
    }
    else
    {
        cgl.patch.loading.finished(loadingId);
        loadingId = null;
        setTempTexture();
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
    else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;

    aniso.setUiAttribs({ "greyout": cgl_filter != CGL.Texture.FILTER_MIPMAP });

    cgl_aniso = parseFloat(aniso.get());

    reloadSoon();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reloadSoon();
}

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().indexOf(fn) > -1)
    {
        textureOut.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
        textureOut.set(CGL.Texture.getTempTexture(cgl));
        realReload(true);
    }
};

// function testTexture()
// {
//     cgl.setTexture(0, tex.tex);

//     const filter = cgl.gl.getTexParameter(cgl.gl.TEXTURE_2D, cgl.gl.TEXTURE_MIN_FILTER);
//     const wrap = cgl.gl.getTexParameter(cgl.gl.TEXTURE_2D, cgl.gl.TEXTURE_WRAP_S);

//     if (cgl_filter === CGL.Texture.FILTER_MIPMAP && filter != cgl.gl.LINEAR_MIPMAP_LINEAR) console.log("wrong texture filter!", filename.get());
//     if (cgl_filter === CGL.Texture.FILTER_NEAREST && filter != cgl.gl.NEAREST) console.log("wrong texture filter!", filename.get());
//     if (cgl_filter === CGL.Texture.FILTER_LINEAR && filter != cgl.gl.LINEAR) console.log("wrong texture filter!", filename.get());

//     if (cgl_wrap === CGL.Texture.WRAP_REPEAT && wrap != cgl.gl.REPEAT) console.log("wrong texture wrap1!", filename.get());
//     if (cgl_wrap === CGL.Texture.WRAP_MIRRORED_REPEAT && wrap != cgl.gl.MIRRORED_REPEAT) console.log("wrong texture wrap2!", filename.get());
//     if (cgl_wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE && wrap != cgl.gl.CLAMP_TO_EDGE) console.log("wrong texture wrap3!", filename.get());
// }


};

Ops.Gl.Texture_v2.prototype = new CABLES.Op();
CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"]={f:Ops.Gl.Texture_v2,objName:"Ops.Gl.Texture_v2"};




// **************************************************************
// 
// Ops.Gl.Shader.MatCapMaterialNew_v3
// 
// **************************************************************

Ops.Gl.Shader.MatCapMaterialNew_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"matcap_frag":"{{MODULES_HEAD}}\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n#endif\n\nIN vec3 transformedNormal;\nIN vec3 viewSpacePosition;\n\nUNI vec4 inColor;\n\nUNI sampler2D texMatcap;\n\n#ifdef HAS_DIFFUSE_TEXTURE\n   UNI sampler2D texDiffuse;\n#endif\n\n#ifdef USE_SPECULAR_TEXTURE\n   UNI sampler2D texSpec;\n   UNI sampler2D texSpecMatCap;\n#endif\n\n#ifdef HAS_AO_TEXTURE\n    UNI sampler2D texAo;\n    UNI float aoIntensity;\n#endif\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 vBiTangent;\n    IN vec3 vTangent;\n    IN mat3 normalMatrix;\n\n    UNI sampler2D texNormal;\n    UNI float normalMapIntensity;\n#endif\n\n#ifdef HAS_TEXTURE_OPACITY\n    UNI sampler2D texOpacity;\n#endif\n\n#ifdef CALC_SSNORMALS\n    IN vec3 eye_relative_pos;\n\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    vec3 CalculateScreenSpaceNormals() {\n    \tvec3 dFdxPos = dFdx(eye_relative_pos);\n    \tvec3 dFdyPos = dFdy(eye_relative_pos);\n    \tvec3 screenSpaceNormal = normalize( cross(dFdxPos, dFdyPos));\n        return normalize(screenSpaceNormal);\n    }\n#endif\n\n// * taken & modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js\nvec2 getMatCapUV(vec3 viewSpacePosition, vec3 normal) {\n    vec3 viewDir = normalize(-viewSpacePosition);\n\tvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\n\tvec3 y = normalize(cross(viewDir, x));\n\tvec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\treturn uv;\n}\n\nvoid main()\n{\n    vec3 viewSpaceNormal = normalize(transformedNormal);\n\n    #ifdef HAS_TEXTURES\n        vec2 texCoords = texCoord;\n        {{MODULE_BEGIN_FRAG}}\n    #endif\n\n\n    #ifdef CALC_SSNORMALS\n        viewSpaceNormal = CalculateScreenSpaceNormals();\n    #endif\n\n\n   #ifdef HAS_NORMAL_TEXTURE\n        vec3 normalFromMap = texture( texNormal, texCoord ).xyz * 2.0 - 1.0;\n        normalFromMap = normalize(normalFromMap);\n\n        vec3 tangent;\n        vec3 binormal;\n\n        #ifdef CALC_TANGENT\n            vec3 c1 = cross(normalFromMap, vec3(0.0, 0.0, 1.0));\n            vec3 c2 = cross(normalFromMap, vec3(0.0, 1.0, 0.0));\n\n            tangent = c1;\n            tangent = normalize(tangent);\n            binormal = cross(viewSpaceNormal, tangent);\n            binormal = normalize(binormal);\n        #endif\n\n        #ifndef CALC_TANGENT\n            tangent = normalize(normalMatrix * vTangent);\n            vec3 bitangent = normalize(normalMatrix * vBiTangent);\n            binormal = normalize(cross(viewSpaceNormal, bitangent));\n        #endif\n\n        normalFromMap = normalize(\n            tangent * normalFromMap.x\n            + binormal * normalFromMap.y\n            + viewSpaceNormal * normalFromMap.z\n        );\n\n        vec3 mixedNormal = normalize(viewSpaceNormal + normalFromMap * normalMapIntensity);\n\n        viewSpaceNormal = mixedNormal;\n    #endif\n\n    vec4 col = texture(texMatcap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n\n    #ifdef HAS_DIFFUSE_TEXTURE\n        col = col*texture(texDiffuse, texCoords);\n    #endif\n\n    col.rgb *= inColor.rgb;\n\n\n    #ifdef HAS_AO_TEXTURE\n        col = col\n            * mix(\n                vec4(1.0,1.0,1.0,1.0),\n                texture(texAo, texCoords),\n                aoIntensity\n            );\n    #endif\n\n    #ifdef USE_SPECULAR_TEXTURE\n        vec4 spec = texture(texSpecMatCap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n        spec *= texture(texSpec, texCoords);\n        col += spec;\n    #endif\n\n    col.a *= inColor.a;\n\n    #ifdef HAS_TEXTURE_OPACITY\n        #ifdef TRANSFORMALPHATEXCOORDS\n            texCoords=vec2(texCoord.s,1.0-texCoord.t);\n            texCoords.y = 1. - texCoords.y;\n        #endif\n        #ifdef ALPHA_MASK_ALPHA\n            col.a*=texture(texOpacity,texCoords).a;\n        #endif\n        #ifdef ALPHA_MASK_LUMI\n            col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,texCoords).rgb);\n        #endif\n        #ifdef ALPHA_MASK_R\n            col.a*=texture(texOpacity,texCoords).r;\n        #endif\n        #ifdef ALPHA_MASK_G\n            col.a*=texture(texOpacity,texCoords).g;\n        #endif\n        #ifdef ALPHA_MASK_B\n            col.a*=texture(texOpacity,texCoords).b;\n        #endif\n\n        #ifdef DISCARDTRANS\n            if(col.a < 0.2) discard;\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}","matcap_vert":"IN vec3 vPosition;\n\n#ifdef HAS_TEXTURES\n    IN vec2 attrTexCoord;\n#endif\n\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 attrTangent;\n    IN vec3 attrBiTangent;\n    OUT vec3 vBiTangent;\n    OUT vec3 vTangent;\n#endif\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI vec3 camPos;\n\n#ifdef HAS_TEXTURES\n    UNI vec2 texOffset;\n    UNI vec2 texRepeat;\n    OUT vec2 texCoord;\n#endif\n\nOUT mat3 normalMatrix;\nOUT vec3 viewSpacePosition;\nOUT vec3 transformedNormal;\n\n{{MODULES_HEAD}}\n\n#ifdef CALC_SSNORMALS\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    OUT vec3 eye_relative_pos;\n#endif\n\nmat3 transposeMat3(mat3 m) {\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\n mat3 inverseMat3(mat3 m) {\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    #ifdef HAS_TEXTURES\n        texCoord = texRepeat * vec2(attrTexCoord.x, attrTexCoord.y) + texOffset;\n        texCoord.y = 1. - texCoord.y;\n    #endif\n\n    mat4 mMatrix = modelMatrix;\n    mat4 mvMatrix;\n\n    #ifdef HAS_NORMAL_TEXTURE\n        vec3 tangent = attrTangent;\n        vec3 bitangent = attrBiTangent;\n        vTangent = attrTangent;\n        vBiTangent = attrBiTangent;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.);\n    vec3 norm = attrVertNormal;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mvMatrix = viewMatrix * mMatrix;\n    vec3 normal = norm;\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mvMatrix)));\n\n    vec3 fragPos = vec3((mvMatrix) * pos);\n    viewSpacePosition = normalize(fragPos);\n\n    #ifdef CALC_SSNORMALS\n        eye_relative_pos = -(vec3(viewMatrix * vec4(camPos, 1.)) - fragPos);\n    #endif\n\n    transformedNormal = normalize(mat3(normalMatrix) * normal);\n\n   gl_Position = projMatrix * mvMatrix * pos;\n\n}",};
const cgl = op.patch.cgl;

const
    render = op.inTrigger("Render"),
    textureMatcap = op.inTexture("MatCap"),
    textureDiffuse = op.inTexture("Diffuse"),
    textureNormal = op.inTexture("Normal"),
    textureSpec = op.inTexture("Specular Mask"),
    textureSpecMatCap = op.inTexture("Specular MatCap"),
    textureAo = op.inTexture("AO Texture"),
    textureOpacity = op.inTexture("Opacity Texture"),
    r = op.inValueSlider("r", 1),
    g = op.inValueSlider("g", 1),
    b = op.inValueSlider("b", 1),
    pOpacity = op.inValueSlider("Opacity", 1),
    aoIntensity = op.inValueSlider("AO Intensity", 1.0),
    normalMapIntensity = op.inFloatSlider("Normal Map Intensity", 1),
    repeatX = op.inValue("Repeat X", 1),
    repeatY = op.inValue("Repeat Y", 1),
    offsetX = op.inValue("Offset X", 0),
    offsetY = op.inValue("Offset Y", 0),
    ssNormals = op.inValueBool("Screen Space Normals"),
    calcTangents = op.inValueBool("Calc normal tangents", true),
    texCoordAlpha = op.inValueBool("Opacity TexCoords Transform", false),
    discardTransPxl = op.inValueBool("Discard Transparent Pixels"),

    next = op.outTrigger("Next"),
    shaderOut = op.outObject("Shader");

r.setUiAttribs({ "colorPick": true });

const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });

op.setPortGroup("Texture Opacity", [alphaMaskSource, texCoordAlpha, discardTransPxl]);
op.setPortGroup("Texture Transforms", [aoIntensity, normalMapIntensity, repeatX, repeatY, offsetX, offsetY, calcTangents, ssNormals]);
op.setPortGroup("Texture Maps", [textureDiffuse, textureNormal, textureSpec, textureSpecMatCap, textureAo, textureOpacity]);
op.setPortGroup("Color", [r, g, b, pOpacity]);

const shader = new CGL.Shader(cgl, "MatCapMaterialNew3");
const uniOpacity = new CGL.Uniform(shader, "f", "opacity", pOpacity);

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.matcap_vert, attachments.matcap_frag);
shaderOut.set(shader);

const textureMatcapUniform = new CGL.Uniform(shader, "t", "texMatcap");
let textureDiffuseUniform = null;
let textureNormalUniform = null;
let normalMapIntensityUniform = null;
let textureSpecUniform = null;
let textureSpecMatCapUniform = null;
let textureAoUniform = null;
const offsetUniform = new CGL.Uniform(shader, "2f", "texOffset", offsetX, offsetY);
const repeatUniform = new CGL.Uniform(shader, "2f", "texRepeat", repeatX, repeatY);

const aoIntensityUniform = new CGL.Uniform(shader, "f", "aoIntensity", aoIntensity);
const colorUniform = new CGL.Uniform(shader, "4f", "inColor", r, g, b, pOpacity);

calcTangents.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    if (calcTangents.get()) shader.define("CALC_TANGENT");
    else shader.removeDefine("CALC_TANGENT");
}

ssNormals.onChange = function ()
{
    if (ssNormals.get())
    {
        if (cgl.glVersion < 2)
        {
            cgl.gl.getExtension("OES_standard_derivatives");
            shader.enableExtension("GL_OES_standard_derivatives");
        }

        shader.define("CALC_SSNORMALS");
    }
    else shader.removeDefine("CALC_SSNORMALS");
};

textureMatcap.onChange = updateMatcap;

function updateMatcap()
{
    if (!cgl.defaultMatcapTex3)
    {
        const pixels = new Uint8Array(256 * 4);
        for (let x = 0; x < 16; x++)
        {
            for (let y = 0; y < 16; y++)
            {
                let c = y * 16;
                c *= Math.min(1, (x + y / 3) / 8);
                pixels[(x + y * 16) * 4 + 0] = pixels[(x + y * 16) * 4 + 1] = pixels[(x + y * 16) * 4 + 2] = c;
                pixels[(x + y * 16) * 4 + 3] = 255;
            }
        }

        cgl.defaultMatcapTex3 = new CGL.Texture(cgl);
        cgl.defaultMatcapTex3.initFromData(pixels, 16, 16, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);
    }
}

textureDiffuse.onChange = function ()
{
    if (textureDiffuse.get())
    {
        if (textureDiffuseUniform !== null) return;
        shader.define("HAS_DIFFUSE_TEXTURE");
        shader.removeUniform("texDiffuse");
        textureDiffuseUniform = new CGL.Uniform(shader, "t", "texDiffuse");
    }
    else
    {
        shader.removeDefine("HAS_DIFFUSE_TEXTURE");
        shader.removeUniform("texDiffuse");
        textureDiffuseUniform = null;
    }
};

textureNormal.onChange = function ()
{
    if (textureNormal.get())
    {
        if (textureNormalUniform !== null) return;
        shader.define("HAS_NORMAL_TEXTURE");
        shader.removeUniform("texNormal");
        textureNormalUniform = new CGL.Uniform(shader, "t", "texNormal");
        if (!normalMapIntensityUniform) normalMapIntensityUniform = new CGL.Uniform(shader, "f", "normalMapIntensity", normalMapIntensity);
    }
    else
    {
        shader.removeDefine("HAS_NORMAL_TEXTURE");
        shader.removeUniform("texNormal");
        textureNormalUniform = null;
    }
};

textureAo.onChange = function ()
{
    if (textureAo.get())
    {
        if (textureAoUniform !== null) return;
        shader.define("HAS_AO_TEXTURE");
        shader.removeUniform("texAo");
        textureAoUniform = new CGL.Uniform(shader, "t", "texAo");
    }
    else
    {
        shader.removeDefine("HAS_AO_TEXTURE");
        shader.removeUniform("texAo");
        textureAoUniform = null;
    }
};

textureSpec.onChange = textureSpecMatCap.onChange = function ()
{
    if (textureSpec.get() && textureSpecMatCap.get())
    {
        if (textureSpecUniform !== null) return;
        shader.define("USE_SPECULAR_TEXTURE");
        shader.removeUniform("texSpec");
        shader.removeUniform("texSpecMatCap");
        textureSpecUniform = new CGL.Uniform(shader, "t", "texSpec");
        textureSpecMatCapUniform = new CGL.Uniform(shader, "t", "texSpecMatCap");
    }
    else
    {
        shader.removeDefine("USE_SPECULAR_TEXTURE");
        shader.removeUniform("texSpec");
        shader.removeUniform("texSpecMatCap");
        textureSpecUniform = null;
        textureSpecMatCapUniform = null;
    }
};

// TEX OPACITY

function updateAlphaMaskMethod()
{
    if (alphaMaskSource.get() == "Alpha Channel") shader.define("ALPHA_MASK_ALPHA");
    else shader.removeDefine("ALPHA_MASK_ALPHA");

    if (alphaMaskSource.get() == "Luminance") shader.define("ALPHA_MASK_LUMI");
    else shader.removeDefine("ALPHA_MASK_LUMI");

    if (alphaMaskSource.get() == "R") shader.define("ALPHA_MASK_R");
    else shader.removeDefine("ALPHA_MASK_R");

    if (alphaMaskSource.get() == "G") shader.define("ALPHA_MASK_G");
    else shader.removeDefine("ALPHA_MASK_G");

    if (alphaMaskSource.get() == "B") shader.define("ALPHA_MASK_B");
    else shader.removeDefine("ALPHA_MASK_B");
}
alphaMaskSource.onChange = updateAlphaMaskMethod;
textureOpacity.onChange = updateOpacity;

let textureOpacityUniform = null;

function updateOpacity()
{
    if (textureOpacity.get())
    {
        if (textureOpacityUniform !== null) return;
        shader.removeUniform("texOpacity");
        shader.define("HAS_TEXTURE_OPACITY");
        if (!textureOpacityUniform) textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity");

        alphaMaskSource.setUiAttribs({ "greyout": false });
        discardTransPxl.setUiAttribs({ "greyout": false });
        texCoordAlpha.setUiAttribs({ "greyout": false });
    }
    else
    {
        shader.removeUniform("texOpacity");
        shader.removeDefine("HAS_TEXTURE_OPACITY");
        textureOpacityUniform = null;

        alphaMaskSource.setUiAttribs({ "greyout": true });
        discardTransPxl.setUiAttribs({ "greyout": true });
        texCoordAlpha.setUiAttribs({ "greyout": true });
    }
    updateAlphaMaskMethod();
}

discardTransPxl.onChange = function ()
{
    if (discardTransPxl.get()) shader.define("DISCARDTRANS");
    else shader.removeDefine("DISCARDTRANS");
};

texCoordAlpha.onChange = function ()
{
    if (texCoordAlpha.get()) shader.define("TRANSFORMALPHATEXCOORDS");
    else shader.removeDefine("TRANSFORMALPHATEXCOORDS");
};

function checkUiErrors()
{
    if (textureSpec.get() && !textureSpecMatCap.get())
    {
        op.setUiError("specNoMatCapSpec", "You connected a specular texture but have not connected a specular matcap texture. You need to connect both texture inputs for the specular input to work.", 1);
        op.setUiError("noSpecMatCapSpec", null);
    }
    else if (!textureSpec.get() && textureSpecMatCap.get())
    {
        op.setUiError("noSpecMatCapSpec", "You connected a specular matcap texture but have not connected a specular texture. You need to connect both texture inputs for the specular input to work.", 1);
        op.setUiError("specNoMatCapSpec", null);
    }
    else if (textureSpec.get() && textureSpecMatCap.get())
    {
        op.setUiError("specNoMatCapSpec", null);
        op.setUiError("noSpecMatCapSpec", null);
    }
    else
    {
        op.setUiError("specNoMatCapSpec", null);
        op.setUiError("noSpecMatCapSpec", null);
    }
}

render.onTriggered = function ()
{
    checkUiErrors();

    if (!cgl.defaultMatcapTex3) updateMatcap();
    shader.popTextures();

    const tex = textureMatcap.get() || cgl.defaultMatcapTex3;
    shader.pushTexture(textureMatcapUniform, tex.tex);

    if (textureDiffuse.get() && textureDiffuseUniform) shader.pushTexture(textureDiffuseUniform, textureDiffuse.get().tex);
    if (textureNormal.get() && textureNormalUniform) shader.pushTexture(textureNormalUniform, textureNormal.get().tex);
    if (textureSpec.get() && textureSpecUniform) shader.pushTexture(textureSpecUniform, textureSpec.get().tex);
    if (textureSpecMatCap.get() && textureSpecMatCapUniform) shader.pushTexture(textureSpecMatCapUniform, textureSpecMatCap.get().tex);
    if (textureAo.get() && textureAoUniform) shader.pushTexture(textureAoUniform, textureAo.get().tex);
    if (textureOpacity.get() && textureOpacityUniform) shader.pushTexture(textureOpacityUniform, textureOpacity.get().tex);

    cgl.pushShader(shader);
    next.trigger();
    cgl.popShader();
};


};

Ops.Gl.Shader.MatCapMaterialNew_v3.prototype = new CABLES.Op();
CABLES.OPS["c1dd6e76-61b4-471a-b8d1-f550a5a9a4f4"]={f:Ops.Gl.Shader.MatCapMaterialNew_v3,objName:"Ops.Gl.Shader.MatCapMaterialNew_v3"};




// **************************************************************
// 
// Ops.Json.ObjectDeleteKey
// 
// **************************************************************

Ops.Json.ObjectDeleteKey = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inObj1 = op.inObject("Object"),
    inKey = op.inString("Key", ""),
    outObj = op.outObject("Object Result");

inObj1.onChange = update;

inKey.onChange = () =>
{
    op.setUiAttrib({ "extendTitle": inKey.get() });
    update();
};

function update()
{
    const o = inObj1.get();

    if (!o)
    {
        outObj.set(null);
        return;
    }

    const newObj = JSON.parse(JSON.stringify(o));
    delete newObj[inKey.get()];

    outObj.setRef(newObj);
}


};

Ops.Json.ObjectDeleteKey.prototype = new CABLES.Op();
CABLES.OPS["57a80386-b565-4915-a365-61b2dccf5ccc"]={f:Ops.Json.ObjectDeleteKey,objName:"Ops.Json.ObjectDeleteKey"};




// **************************************************************
// 
// Ops.Vars.VarGetTexture_v2
// 
// **************************************************************

Ops.Vars.VarGetTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outTexture("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "object", op.varName, val);


};

Ops.Vars.VarGetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["5f8ce5fc-9787-45c9-9a83-0eebd2c6de15"]={f:Ops.Vars.VarGetTexture_v2,objName:"Ops.Vars.VarGetTexture_v2"};




// **************************************************************
// 
// Ops.Ui.VizTexture
// 
// **************************************************************

Ops.Ui.VizTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"viztex_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI samplerCube cubeMap;\nUNI float width;\nUNI float height;\nUNI float type;\nUNI float time;\n\nfloat LinearizeDepth(float d,float zNear,float zFar)\n{\n    float z_n = 2.0 * d - 1.0;\n    return 2.0 * zNear / (zFar + zNear - z_n * (zFar - zNear));\n}\n\nvoid main()\n{\n    vec4 col=vec4(vec3(0.),0.0);\n\n    vec4 colTex=texture(tex,texCoord);\n\n\n\n    if(type==1.0)\n    {\n        vec4 depth=vec4(0.);\n        vec2 localST=texCoord;\n        localST.y = 1. - localST.y;\n\n        localST.t = mod(localST.t*3.,1.);\n        localST.s = mod(localST.s*4.,1.);\n\n        #ifdef WEBGL2\n            #define texCube texture\n        #endif\n        #ifdef WEBGL1\n            #define texCube textureCube\n        #endif\n\n//         //Due to the way my depth-cubeMap is rendered, objects to the -x,y,z side is projected to the positive x,y,z side\n//         //Inside where top/bottom is to be drawn?\n        if (texCoord.s*4.> 1. && texCoord.s*4.<2.)\n        {\n            //Bottom (-y) quad\n            if (texCoord.t*3. < 1.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-1.,-localST.t*2.+1.);//Due to the (arbitrary) way I choose as up in my depth-viewmatrix, i her emultiply the latter coordinate with -1\n                depth = texCube(cubeMap, dir);\n            }\n            //top (+y) quad\n            else if (texCoord.t*3. > 2.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,1.,localST.t*2.-1.);//Get lower y texture, which is projected to the +y part of my cubeMap\n                depth = texCube(cubeMap, dir);\n            }\n            else//Front (-z) quad\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-localST.t*2.+1.,1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n//         //If not, only these ranges should be drawn\n        else if (texCoord.t*3. > 1. && texCoord.t*3. < 2.)\n        {\n            if (texCoord.x*4. < 1.)//left (-x) quad\n            {\n                vec3 dir=vec3(-1.,-localST.t*2.+1.,localST.s*2.-1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else if (texCoord.x*4. < 3.)//right (+x) quad (front was done above)\n            {\n                vec3 dir=vec3(1,-localST.t*2.+1.,-localST.s*2.+1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else //back (+z) quad\n            {\n                vec3 dir=vec3(-localST.s*2.+1.,-localST.t*2.+1.,-1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n        // colTex = vec4(vec3(depth),1.);\n        colTex = vec4(depth);\n    }\n\n    if(type==2.0)\n    {\n       float near = 0.1;\n       float far = 50.;\n       float depth = LinearizeDepth(colTex.r, near, far);\n       colTex.rgb = vec3(depth);\n    }\n\n\n    #ifdef ANIM_RANGE\n\n        if(colTex.r>1.0 || colTex.r<0.0)\n            colTex.r=mod(colTex.r,1.0)*0.5+(sin(colTex.r+mod(colTex.r*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n        if(colTex.g>1.0 || colTex.g<0.0)\n            colTex.g=mod(colTex.g,1.0)*0.5+(sin(colTex.g+mod(colTex.g*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n        if(colTex.b>1.0 || colTex.b<0.0)\n            colTex.b=mod(colTex.b,1.0)*0.5+(sin(colTex.b+mod(colTex.b*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n\n    #endif\n\n\n    // #ifdef ANIM_RANGE\n    //     if(colTex.r>1.0 || colTex.r<0.0)\n    //     {\n    //         float r=mod( time+colTex.r,1.0)*0.5+0.5;\n    //         colTex.r=r;\n    //     }\n    //     if(colTex.g>1.0 || colTex.g<0.0)\n    //     {\n    //         float r=mod( time+colTex.g,1.0)*0.5+0.5;\n    //         colTex.g=r;\n    //     }\n    //     if(colTex.b>1.0 || colTex.b<0.0)\n    //     {\n    //         float r=mod( time+colTex.b,1.0)*0.5+0.5;\n    //         colTex.b=r;\n    //     }\n    // #endif\n\n    outColor = mix(col,colTex,colTex.a);\n}\n\n","viztex_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nvoid main()\n{\n    texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mvMatrix=viewMatrix * modelMatrix;\n    gl_Position = projMatrix * mvMatrix * pos;\n}",};
const
    inTex = op.inTexture("Texture In"),
    inShowInfo = op.inBool("Show Info", false),
    inVizRange = op.inSwitch("Visualize outside 0-1", ["Off", "Anim"], "Anim"),

    inPickColor = op.inBool("Show Color", false),
    inX = op.inFloatSlider("X", 0.5),
    inY = op.inFloatSlider("Y", 0.5),

    outTex = op.outTexture("Texture Out"),
    outInfo = op.outString("Info");

op.setUiAttrib({ "height": 150, "resizable": true });

const timer = new CABLES.Timer();
timer.play();

let shader = null;
let fb = null;
let pixelReader = null;
let colorString = "";

inVizRange.onChange = updateDefines;

inPickColor.onChange = updateUi;
updateUi();

op.checkMainloopExists();

function updateUi()
{
    inX.setUiAttribs({ "greyout": !inPickColor.get() });
    inY.setUiAttribs({ "greyout": !inPickColor.get() });
}

inTex.onChange = () =>
{
    const t = inTex.get();

    outTex.setRef(t);

    let title = "";

    if (inTex.get() && inTex.links[0]) title = inTex.links[0].getOtherPort(inTex).name;

    op.setUiAttrib({ "extendTitle": title });
};

function updateDefines()
{
    if (!shader) return;
    shader.toggleDefine("ANIM_RANGE", inVizRange.get() == "Anim");
    op.checkMainloopExists();
}

op.renderVizLayer = (ctx, layer) =>
{
    const port = inTex;
    const texSlot = 5;
    const texSlotCubemap = texSlot + 1;

    const perf = CABLES.UI.uiProfiler.start("previewlayer texture");
    const cgl = port.op.patch.cgl;

    if (!layer.useGl) return;

    if (!this._emptyCubemap) this._emptyCubemap = CGL.Texture.getEmptyCubemapTexture(cgl);
    port.op.patch.cgl.profileData.profileTexPreviews++;

    const portTex = port.get() || CGL.Texture.getEmptyTexture(cgl);

    if (!this._mesh)
    {
        const geom = new CGL.Geometry("vizTexture rect");
        geom.vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0];
        geom.texCoords = [
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0];
        geom.verticesIndices = [0, 1, 2, 3, 1, 2];
        this._mesh = new CGL.Mesh(cgl, geom);
    }
    if (!this._shader)
    {
        this._shader = new CGL.Shader(cgl, "glpreviewtex");
        this._shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
        this._shader.setSource(attachments.viztex_vert, attachments.viztex_frag);
        this._shaderTexUniform = new CGL.Uniform(this._shader, "t", "tex", texSlot);
        this._shaderTexCubemapUniform = new CGL.Uniform(this._shader, "tc", "cubeMap", texSlotCubemap);
        shader = this._shader;
        updateDefines();

        this._shaderTexUniformW = new CGL.Uniform(this._shader, "f", "width", portTex.width);
        this._shaderTexUniformH = new CGL.Uniform(this._shader, "f", "height", portTex.height);
        this._shaderTypeUniform = new CGL.Uniform(this._shader, "f", "type", 0);
        this._shaderTimeUniform = new CGL.Uniform(this._shader, "f", "time", 0);
    }

    cgl.pushPMatrix();
    const sizeTex = [portTex.width, portTex.height];
    const small = port.op.patch.cgl.canvasWidth > sizeTex[0] && port.op.patch.cgl.canvasHeight > sizeTex[1];

    if (small)
    {
        mat4.ortho(cgl.pMatrix, 0, port.op.patch.cgl.canvasWidth, port.op.patch.cgl.canvasHeight, 0, 0.001, 11);
    }
    else mat4.ortho(cgl.pMatrix, -1, 1, 1, -1, 0.001, 11);

    const oldTex = cgl.getTexture(texSlot);
    const oldTexCubemap = cgl.getTexture(texSlotCubemap);

    let texType = 0;
    if (!portTex) return;
    if (portTex.cubemap) texType = 1;
    if (portTex.textureType == CGL.Texture.TYPE_DEPTH) texType = 2;

    if (texType == 0 || texType == 2)
    {
        cgl.setTexture(texSlot, portTex.tex);
        cgl.setTexture(texSlotCubemap, this._emptyCubemap.cubemap, cgl.gl.TEXTURE_CUBE_MAP);
    }
    else if (texType == 1)
    {
        cgl.setTexture(texSlotCubemap, portTex.cubemap, cgl.gl.TEXTURE_CUBE_MAP);
    }

    timer.update();
    this._shaderTimeUniform.setValue(timer.get());

    this._shaderTypeUniform.setValue(texType);
    let s = [port.op.patch.cgl.canvasWidth, port.op.patch.cgl.canvasHeight];

    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

    cgl.pushModelMatrix();
    if (small)
    {
        s = sizeTex;
        mat4.translate(cgl.mMatrix, cgl.mMatrix, [sizeTex[0] / 2, sizeTex[1] / 2, 0]);
        mat4.scale(cgl.mMatrix, cgl.mMatrix, [sizeTex[0] / 2, sizeTex[1] / 2, 0]);
    }
    this._mesh.render(this._shader);
    cgl.popModelMatrix();

    if (texType == 0) cgl.setTexture(texSlot, oldTex);
    if (texType == 1) cgl.setTexture(texSlotCubemap, oldTexCubemap);

    cgl.popPMatrix();
    cgl.resetViewPort();

    const sizeImg = [layer.width, layer.height];

    const stretch = false;
    if (!stretch)
    {
        if (portTex.width > portTex.height) sizeImg[1] = layer.width * sizeTex[1] / sizeTex[0];
        else
        {
            sizeImg[1] = layer.width * (sizeTex[1] / sizeTex[0]);

            if (sizeImg[1] > layer.height)
            {
                const r = layer.height / sizeImg[1];
                sizeImg[0] *= r;
                sizeImg[1] *= r;
            }
        }
    }

    const scaledDown = sizeImg[0] > sizeTex[0] && sizeImg[1] > sizeTex[1];

    ctx.imageSmoothingEnabled = !small || !scaledDown;

    if (!ctx.imageSmoothingEnabled)
    {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(layer.x, layer.y - 10, 10, 10);
        ctx.fillStyle = "#000000";
        ctx.fillRect(layer.x, layer.y - 10, 5, 5);
        ctx.fillRect(layer.x + 5, layer.y - 10 + 5, 5, 5);
    }

    let layerHeight = layer.height;
    let numX = (10 * layer.width / layerHeight);
    let stepY = (layerHeight / 10);
    let stepX = (layer.width / numX);
    for (let x = 0; x < numX; x++)
        for (let y = 0; y < 10; y++)
        {
            if ((x + y) % 2 == 0)ctx.fillStyle = "#333333";
            else ctx.fillStyle = "#393939";
            ctx.fillRect(layer.x + stepX * x, layer.y + stepY * y, stepX, stepY);
        }

    ctx.fillStyle = "#222";
    const borderLeft = (layer.width - sizeImg[0]) / 2;
    const borderTop = (layerHeight - sizeImg[1]) / 2;

    let imgPosX = layer.x + (layer.width - sizeImg[0]) / 2;
    let imgPosY = layer.y + (layerHeight - sizeImg[1]) / 2;
    let imgSizeW = sizeImg[0];
    let imgSizeH = sizeImg[1];

    if (layerHeight - sizeImg[1] < 0)
    {
        imgPosX = layer.x + (layer.width - sizeImg[0] * layerHeight / sizeImg[1]) / 2;
        imgPosY = layer.y;
        imgSizeW = sizeImg[0] * layerHeight / sizeImg[1];
        imgSizeH = layerHeight;
    }

    ctx.fillRect(layer.x, layer.y, imgPosX - layer.x, layerHeight);
    ctx.fillRect(layer.x + imgSizeW + imgPosX - layer.x, layer.y, layer.x + imgSizeW, layerHeight);
    ctx.fillRect(layer.x, layer.y, layer.width, borderTop);
    ctx.fillRect(layer.x, layer.y + sizeImg[1] + borderTop, layer.width, borderTop);

    if (cgl.canvasWidth > 0 && cgl.canvasHeight > 0)
    {
        if (sizeTex[1] == 1)
            ctx.drawImage(cgl.canvas,
                0,
                0,
                s[0],
                s[1],
                layer.x,
                layer.y,
                layer.width,
                layerHeight * 5);// workaround filtering problems
        if (sizeTex[0] == 1)
            ctx.drawImage(cgl.canvas,
                0,
                0,
                s[0],
                s[1],
                layer.x,
                layer.y,
                layer.width * 5,
                layerHeight); // workaround filtering problems
        else
            try
            {
                if (sizeImg[0] != 0 && sizeImg[1] != 0 && layer.width != 0 && layerHeight != 0 && imgSizeW != 0 && imgSizeH != 0)
                // if(layerHeight - sizeImg[1]>=0)
                    ctx.drawImage(cgl.canvas,
                        0,
                        0,
                        s[0],
                        s[1],
                        imgPosX,
                        imgPosY,
                        imgSizeW,
                        imgSizeH);
            // else
            //     ctx.drawImage(cgl.canvas,
            //         0,
            //         0,
            //         s[0],
            //         s[1],
            //         layer.x + (layer.width - sizeImg[0]*layerHeight/sizeImg[1]) / 2,
            //         layer.y ,
            //         sizeImg[0]*layerHeight/sizeImg[1],
            //         layerHeight);
            }
            catch (e)
            {
                console.error("canvas drawimage exception...", e);
            }
    }

    let info = "";

    if (inShowInfo.get())
    {
        if (port.get() && port.get().getInfoOneLine) info += port.get().getInfoOneLine() + "\n";

        // ctx.save();
        // ctx.scale(layer.scale, layer.scale);
        // ctx.font = "normal 10px sourceCodePro";
        // ctx.fillStyle = "#000";
        // ctx.fillText(info, layer.x / layer.scale + 5 + 0.5, (layer.y + layer.height) / layer.scale - 5 + 0.5);
        // ctx.fillStyle = "#aaa";
        // ctx.fillText(info, layer.x / layer.scale + 5, (layer.y + layer.height) / layer.scale - 5);
        // ctx.restore();
    }

    if (inPickColor.get())
    {
        info += colorString + "\n";

        // ctx.save();
        // ctx.scale(layer.scale, layer.scale);
        // ctx.font = "normal 10px sourceCodePro";
        // ctx.fillStyle = "#000";
        // ctx.fillText("RGBA " + colorString, layer.x / layer.scale + 10 + 0.5, layer.y / layer.scale + 10 + 0.5);
        // ctx.fillStyle = "#aaa";
        // ctx.fillText("RGBA " + colorString, layer.x / layer.scale + 10, layer.y / layer.scale + 10);

        // ctx.restore();

        const x = imgPosX + imgSizeW * inX.get();
        const y = imgPosY + imgSizeH * inY.get();

        ctx.fillStyle = "#000";
        ctx.fillRect(
            x - 1,
            y - 10,
            3,
            20);

        ctx.fillRect(
            x - 10,
            y - 1,
            20,
            3);

        ctx.fillStyle = "#fff";
        ctx.fillRect(
            x - 1,
            y - 10,
            1,
            20);

        ctx.fillRect(
            x - 10,
            y - 1,
            20,
            1);
    }

    op.setUiAttrib({ "comment": info });
    outInfo.set(info);

    if (inPickColor.get())
    {
        const gl = cgl.gl;

        const realTexture = inTex.get();
        if (!realTexture)
        {
            colorString = "";
            return;
        }
        if (!fb) fb = gl.createFramebuffer();
        if (!pixelReader) pixelReader = new CGL.PixelReader();

        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, realTexture.tex, 0
        );

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        pixelReader.read(cgl, fb, realTexture.pixelFormat, inX.get() * realTexture.width, realTexture.height - inY.get() * realTexture.height, 1, 1, (pixel) =>
        {
            if (!CGL.Texture.isPixelFormatFloat(realTexture.pixelFormat))
            {
                colorString = "Pixel Float: " + Math.floor(pixel[0] / 255 * 100) / 100;
                if (!isNaN(pixel[1]))colorString += ", " + Math.floor(pixel[1] / 255 * 100) / 100;
                if (!isNaN(pixel[2]))colorString += ", " + Math.floor(pixel[2] / 255 * 100) / 100;
                if (!isNaN(pixel[3]))colorString += ", " + Math.floor(pixel[3] / 255 * 100) / 100;
                colorString += "\n";

                if (
                    realTexture.pixelFormat.indexOf("ubyte") > 0)
                {
                    colorString += "Pixel UByte: ";
                    colorString += Math.round(pixel[0]);
                    if (!isNaN(pixel[1]))colorString += ", " + Math.round(pixel[1]);
                    if (!isNaN(pixel[2]))colorString += ", " + Math.round(pixel[2]);
                    if (!isNaN(pixel[3]))colorString += ", " + Math.round(pixel[3]);

                    colorString += "\n";
                }
            }
            else
            {
                colorString = "Pixel Float: " + Math.round(pixel[0] * 100) / 100 + ", " + Math.round(pixel[1] * 100) / 100 + ", " + Math.round(pixel[2] * 100) / 100 + ", " + Math.round(pixel[3] * 100) / 100;
                colorString += "\n";
            }
        });
    }

    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

    perf.finish();
};


};

Ops.Ui.VizTexture.prototype = new CABLES.Op();
CABLES.OPS["4ea2d7b0-ca74-45db-962b-4d1965ac20c0"]={f:Ops.Ui.VizTexture,objName:"Ops.Ui.VizTexture"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.TextureProjection_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.TextureProjection_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"maptexture_frag":"IN vec2 MOD_tc;\n\n#ifdef MOD_MAP_TRIPLANAR\n    IN vec2 MOD_tc1;\n    IN vec2 MOD_tc2;\n    IN vec3 MOD_blendingTri;\n#endif\n\n\n{{CGL.BLENDMODES3}}","maptexture_vert":"vec3 MOD_pos;\n\n#ifndef MOD_WORLDSPACE\n   MOD_pos=(vec4(vPosition,1.0)*1.0/MOD_scale).xyz;\n#endif\n#ifdef MOD_WORLDSPACE\n   MOD_pos=(mMatrix*pos).xyz*1.0/MOD_scale;\n#endif\n\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationX(MOD_rotX*MOD_DEG2RAD)).xyz;\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationY(MOD_rotY*MOD_DEG2RAD)).xyz;\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationZ(MOD_rotZ*MOD_DEG2RAD)).xyz;\n\n#ifdef MOD_MAP_XY\n    MOD_tc=MOD_pos.xy;\n#endif\n#ifdef MOD_MAP_XZ\n    MOD_tc=MOD_pos.xz;\n#endif\n#ifdef MOD_MAP_YZ\n    MOD_tc=MOD_pos.yz;\n#endif\n\nMOD_tc.xy+=vec2(0.5,0.5);\nMOD_tc.xy+=MOD_offset;\n\n\n#ifdef MOD_TARGET_POINTSIZE\n\n    gl_PointSize+=(texture(MOD_tex,MOD_tc).x*MOD_amount);\n\n#endif\n\n\n#ifdef MOD_MAP_TRIPLANAR\n    mapTriplanar((mMatrix*vec4(attrVertNormal,1.0)).xyz,MOD_pos);\n#endif\n\n","maptexture_body_frag":"#ifndef MOD_TARGET_POINTSIZE\n\n\n    vec4 MOD_color;\n\n    #ifdef MOD_MAP_TRIPLANAR\n        vec4 xaxis = texture( MOD_tex, MOD_tc);\n        vec4 yaxis = texture( MOD_tex, MOD_tc1);\n        vec4 zaxis = texture( MOD_tex, MOD_tc2);\n        MOD_color = xaxis *MOD_blendingTri.x + yaxis *MOD_blendingTri.y + zaxis *MOD_blendingTri.z;\n        MOD_color.a=1.0;\n    #endif\n\n\n    vec2 MOD_ntc=MOD_tc;\n\n    #ifdef MOD_MAP_SCREEN\n        MOD_ntc=(vec2(gl_FragCoord.x,gl_FragCoord.y)/vec2(MOD_viewPortW,MOD_viewPortH));\n\n        MOD_ntc-=vec2(0.5,0.5);\n        MOD_ntc*=1.0/MOD_scale;\n        MOD_ntc+=vec2(0.5,0.5);\n        MOD_ntc-=MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD\n        MOD_ntc=texCoord*1.0/MOD_scale-MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD1\n        MOD_ntc=texCoord1*1.0/MOD_scale-MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD2\n        MOD_ntc=texCoord2*1.0/MOD_scale-MOD_offset;\n    #endif\n\n\n    #ifdef MOD_DISCARD\n    if(MOD_ntc.x>0.0 && MOD_ntc.x<1.0 && MOD_ntc.y>0.0 && MOD_ntc.y<1.0)\n    {\n    #endif\n\n        #ifndef MOD_MAP_TRIPLANAR\n            MOD_color=texture(MOD_tex,MOD_ntc);\n        #endif\n\n        #ifdef MOD_USE_IMGALPHA\n            col.a=MOD_color.a;\n        #endif\n\n        #ifdef MOD_TARGET_COLOR\n        col=cgl_blendPixel(col,MOD_color,MOD_amount*col.a);\n        #endif\n        #ifdef MOD_TARGET_ALPHA\n        col.a=1.0-MOD_color.r*MOD_amount;\n        #endif\n\n    #ifdef MOD_DISCARD\n    }\n\n    #endif\n#endif\n","maptexture_body_vert":"OUT vec2 MOD_tc;\n\nconst float MOD_DEG2RAD = 0.017453292519943;\n\n#ifdef MOD_MAP_TRIPLANAR\n\n    OUT vec2 MOD_tc1;\n    OUT vec2 MOD_tc2;\n    OUT vec3 MOD_blendingTri;\n\n    void mapTriplanar(vec3 wNorm,vec3 pos)\n    {\n        vec3 blending = abs( wNorm );\n        blending = normalize(max(blending, 0.1));\n        float b = (blending.x + blending.y + blending.z);\n        blending /= vec3(b);\n        MOD_blendingTri=blending;\n\n        MOD_tc = pos.yz;\n        MOD_tc1 = pos.xz;\n        MOD_tc2 = pos.xy;\n    }\n\n#endif\n\nmat4 MOD_rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 MOD_rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 MOD_rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inTex = op.inTexture("Texture"),

    inBlend = CGL.TextureEffect.AddBlendSelect(op, "blendMode"),
    inAmount = op.inValueSlider("Amount", 0.3),

    inTarget = op.inSwitch("Target", ["Color", "Pointsize", "Alpha"], "Color"),
    inScale = op.inValue("Scale", 10),

    inUseTexAlpha = op.inBool("Use Texture Alpha", false),

    inPosX = op.inFloat("Pos X", 0),
    inPosY = op.inFloat("Pos Y", 0),

    inRotX = op.inFloat("Rot X", 0),
    inRotY = op.inFloat("Rot Y", 0),
    inRotZ = op.inFloat("Rot Z", 0),

    inMethod = op.inValueSelect("Mapping", ["Triplanar", "XY", "XZ", "YZ", "Screen", "TexCoords 1", "TexCoords 2", "TexCoords 3"], "XY"),
    inDiscard = op.inValueBool("Discard"),
    inWorldSpace = op.inValueBool("WorldSpace");

const cgl = op.patch.cgl;

inUseTexAlpha.onChange =
    inTarget.onChange =
    inBlend.onChange =
    inDiscard.onChange =
    inWorldSpace.onChange =
    inMethod.onChange = updateDefines;

op.setPortGroup("Rotation", [inRotX, inRotY, inRotZ]);
op.setPortGroup("Position", [inPosX, inPosY]);

const mod = new CGL.ShaderModifier(cgl, op.name, { "opId": op.id });
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.maptexture_body_vert,
    "srcBodyVert": attachments.maptexture_vert,
    "attributes": [
        { "type": "vec2", "name": "attrTexCoord1", "nameFrag": "texCoord1" },
        { "type": "vec2", "name": "attrTexCoord2", "nameFrag": "texCoord2" }]
});

let head_frag = attachments.maptexture_frag;
// head_frag = head_frag.replace("{{BLENDCODE}}", CGL.TextureEffect.getBlendCode(3));

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": head_frag,
    "srcBodyFrag": attachments.maptexture_body_frag
});

mod.addUniformBoth("f", "MOD_rotX", inRotX);
mod.addUniformBoth("f", "MOD_rotY", inRotY);
mod.addUniformBoth("f", "MOD_rotZ", inRotZ);

mod.addUniformBoth("t", "MOD_tex");
mod.addUniformBoth("f", "MOD_scale", inScale);
mod.addUniformBoth("f", "MOD_amount", inAmount);
mod.addUniformBoth("2f", "MOD_offset", inPosX, inPosY);

const uniWidth = mod.addUniformFrag("f", "MOD_viewPortW");
const uniHeight = mod.addUniformFrag("f", "MOD_viewPortH");

CGL.TextureEffect.setupBlending(op, mod, inBlend, inAmount);

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_USE_IMGALPHA", inUseTexAlpha.get());
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());
    mod.toggleDefine("MOD_MAP_XY", inMethod.get() == "XY");
    mod.toggleDefine("MOD_MAP_XZ", inMethod.get() == "XZ");
    mod.toggleDefine("MOD_MAP_YZ", inMethod.get() == "YZ");
    mod.toggleDefine("MOD_MAP_TEXCOORD", inMethod.get() == "TexCoords 1");
    mod.toggleDefine("MOD_MAP_TEXCOORD1", inMethod.get() == "TexCoords 2");
    mod.toggleDefine("MOD_MAP_TEXCOORD2", inMethod.get() == "TexCoords 3");
    mod.toggleDefine("MOD_MAP_SCREEN", inMethod.get() == "Screen");
    mod.toggleDefine("MOD_MAP_TRIPLANAR", inMethod.get() == "Triplanar");
    mod.toggleDefine("MOD_DISCARD", inDiscard.get());

    mod.toggleDefine("MOD_BLEND_NORMAL", inBlend.get() == "Normal");
    mod.toggleDefine("MOD_BLEND_ADD", inBlend.get() == "Add");
    mod.toggleDefine("MOD_BLEND_MUL", inBlend.get() == "Mul");
    mod.toggleDefine("MOD_BLEND_MUL", inBlend.get() == "Mul");

    mod.toggleDefine("MOD_TARGET_ALPHA", inTarget.get() == "Alpha");
    mod.toggleDefine("MOD_TARGET_COLOR", inTarget.get() == "Color");
    mod.toggleDefine("MOD_TARGET_POINTSIZE", inTarget.get() == "Pointsize");

    if (inTarget.get() == "Pointsize" && inMethod.get() == "Screen")op.setUiError("pointscreen", "This combination of Mapping and Target is not possible", 1);
    else op.setUiError("pointscreen", null);
}

render.onTriggered = function ()
{
    const vp = cgl.getViewPort();

    mod.setUniformValue("MOD_viewPortW", vp[2]);
    mod.setUniformValue("MOD_viewPortH", vp[3]);

    mod.bind();
    let tex = inTex.get();
    if (!tex) tex = CGL.Texture.getEmptyTexture(cgl).tex;
    else tex = tex.tex;

    mod.pushTexture("MOD_tex", tex);

    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.TextureProjection_v2.prototype = new CABLES.Op();
CABLES.OPS["9be647c2-7afd-40ed-b669-9826ea6a50ca"]={f:Ops.Gl.ShaderEffects.TextureProjection_v2,objName:"Ops.Gl.ShaderEffects.TextureProjection_v2"};




// **************************************************************
// 
// Ops.Gl.Matrix.Billboard
// 
// **************************************************************

Ops.Gl.Matrix.Billboard = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const exec = op.inTrigger("Exec");
const next = op.outTrigger("Next");

const cgl = op.patch.cgl;

let mm = mat4.create();
let mv = mat4.create();
let m = mat4.create();
let mempty = mat4.create();

exec.onTriggered = function ()
{
    mat4.invert(mm, cgl.mMatrix);
    mat4.invert(mv, cgl.vMatrix);

    mat4.mul(mm, mm, mv);

    mm[12] = 0;
    mm[13] = 0;
    mm[14] = 0;

    cgl.pushModelMatrix();
    cgl.pushViewMatrix();
    mat4.mul(cgl.mMatrix, cgl.mMatrix, mm);
    next.trigger();
    cgl.popViewMatrix();
    cgl.popModelMatrix();
};


};

Ops.Gl.Matrix.Billboard.prototype = new CABLES.Op();
CABLES.OPS["d41e676e-d8a7-4a1e-8abf-f1bddfc982d5"]={f:Ops.Gl.Matrix.Billboard,objName:"Ops.Gl.Matrix.Billboard"};




// **************************************************************
// 
// Ops.Patch.PL3eri4.Slider_hideNumber_v1
// 
// **************************************************************

Ops.Patch.PL3eri4.Slider_hideNumber_v1 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// constants
const STEP_DEFAULT = 0.00001;

// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Slider");
const minPort = op.inValue("Min", 0);
const maxPort = op.inValue("Max", 1);
const stepPort = op.inValue("Step", STEP_DEFAULT);
const labelSuffix = op.inString("Suffix", "");

const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

const inputValuePort = op.inValue("Input", 0.5);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
const reset = op.inTriggerButton("Reset");

let parent = null;

const defaultValuePort = op.inValue("Default", 0.5);
defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });

// outputs
const siblingsPort = op.outObject("childs");
const valuePort = op.outNumber("Result", defaultValuePort.get());

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");
op.setPortGroup("Range", [minPort, maxPort, stepPort]);
op.setPortGroup("Display", [inGreyOut, inVisible]);

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(parseFloat(defaultValuePort.get()));
    inputValuePort.set(parseFloat(defaultValuePort.get()));
    setValueFieldValue(defaultValuePort.get());
});

el.dataset.op = op.id;
el.classList.add("cablesEle");

el.classList.add("sidebar__item");
el.classList.add("sidebar__slider");
el.classList.add("sidebar__reloadable");

op.patch.on("sidebarStylesChanged", () => { updateActiveTrack(); });

const label = document.createElement("div");
label.classList.add("sidebar__item-label");

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const value = document.createElement("input");
value.value = defaultValuePort.get();
value.classList.add("sidebar__text-input-input");
value.setAttribute("type", "text");
value.oninput = onTextInputChanged;
el.appendChild(value);

const suffixEle = document.createElement("span");
// setValueFieldValue(defaultValuePort).get();
// value.setAttribute("type", "text");
// value.oninput = onTextInputChanged;

el.appendChild(suffixEle);

labelSuffix.onChange = () =>
{
    suffixEle.innerHTML = labelSuffix.get();
};

const inputWrapper = document.createElement("div");
inputWrapper.classList.add("sidebar__slider-input-wrapper");
el.appendChild(inputWrapper);

const activeTrack = document.createElement("div");
activeTrack.classList.add("sidebar__slider-input-active-track");
inputWrapper.appendChild(activeTrack);
const input = document.createElement("input");
input.classList.add("sidebar__slider-input");
input.setAttribute("min", minPort.get());
input.setAttribute("max", maxPort.get());
input.setAttribute("type", "range");
input.setAttribute("step", stepPort.get());
input.setAttribute("value", defaultValuePort.get());
input.style.display = "block"; /* needed because offsetWidth returns 0 otherwise */
inputWrapper.appendChild(input);

updateActiveTrack();
input.addEventListener("input", onSliderInput);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inputValuePort.onChange = onInputValuePortChanged;
defaultValuePort.onChange = onDefaultValueChanged;
setDefaultValueButtonPort.onTriggered = onSetDefaultValueButtonPress;
minPort.onChange = onMinPortChange;
maxPort.onChange = onMaxPortChange;
stepPort.onChange = stepPortChanged;
op.onDelete = onDelete;

// op.onLoadedValueSet=function()
op.onLoaded = op.onInit = function ()
{
    if (op.patch.config.sidebar)
    {
        op.patch.config.sidebar[labelPort.get()];
        valuePort.set(op.patch.config.sidebar[labelPort.get()]);
    }
    else
    {
        valuePort.set(parseFloat(defaultValuePort.get()));
        inputValuePort.set(parseFloat(defaultValuePort.get()));
        // onInputValuePortChanged();
    }
};

reset.onTriggered = function ()
{
    const newValue = parseFloat(defaultValuePort.get());
    valuePort.set(newValue);
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    inputValuePort.set(newValue);
    updateActiveTrack();
};

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onTextInputChanged(ev)
{
    let newValue = parseFloat(ev.target.value);
    if (isNaN(newValue)) newValue = 0;
    const min = minPort.get();
    const max = maxPort.get();
    if (newValue < min) { newValue = min; }
    else if (newValue > max) { newValue = max; }
    // setInputFieldValue(newValue);
    valuePort.set(newValue);
    updateActiveTrack();
    inputValuePort.set(newValue);
    op.refreshParams();
}

function onInputValuePortChanged()
{
    let newValue = parseFloat(inputValuePort.get());
    const minValue = minPort.get();
    const maxValue = maxPort.get();
    if (newValue > maxValue) { newValue = maxValue; }
    else if (newValue < minValue) { newValue = minValue; }
    // setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    valuePort.set(newValue);
    updateActiveTrack();
}

function onSetDefaultValueButtonPress()
{
    let newValue = parseFloat(inputValuePort.get());
    const minValue = minPort.get();
    const maxValue = maxPort.get();
    if (newValue > maxValue) { newValue = maxValue; }
    else if (newValue < minValue) { newValue = minValue; }
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    valuePort.set(newValue);
    defaultValuePort.set(newValue);
    op.refreshParams();

    updateActiveTrack();
}

function onSliderInput(ev)
{
    ev.preventDefault();
    ev.stopPropagation();
    setValueFieldValue(ev.target.value);
    const inputFloat = parseFloat(ev.target.value);
    valuePort.set(inputFloat);
    inputValuePort.set(inputFloat);
    op.refreshParams();

    updateActiveTrack();
    return false;
}

function stepPortChanged()
{
    const step = stepPort.get();
    input.setAttribute("step", step);
    updateActiveTrack();
}

function updateActiveTrack(val)
{
    let valueToUse = parseFloat(input.value);
    if (typeof val !== "undefined") valueToUse = val;
    let availableWidth = activeTrack.parentElement.getBoundingClientRect().width || 220;
    if (parent) availableWidth = parseInt(getComputedStyle(parent.parentElement).getPropertyValue("--sidebar-width")) - 20;

    const trackWidth = CABLES.map(
        valueToUse,
        parseFloat(input.min),
        parseFloat(input.max),
        0,
        availableWidth - 16 /* subtract slider thumb width */
    );
    activeTrack.style.width = trackWidth + "px";
}

function onMinPortChange()
{
    const min = minPort.get();
    input.setAttribute("min", min);
    updateActiveTrack();
}

function onMaxPortChange()
{
    const max = maxPort.get();
    input.setAttribute("max", max);
    updateActiveTrack();
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(parseFloat(defaultValue));
    onMinPortChange();
    onMaxPortChange();
    setInputFieldValue(defaultValue);
    setValueFieldValue(defaultValue);

    updateActiveTrack(defaultValue); // needs to be passed as argument, is this async?
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": labelText });
}

function onParentChanged()
{
    siblingsPort.set(null);
    parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else if (el.parentElement) el.parentElement.removeChild(el);

    updateActiveTrack();
}

function setValueFieldValue(v)
{
    value.value = v;
}

function setInputFieldValue(v)
{
    input.value = v;
}

function showElement(el)
{
    if (el)el.style.display = "block";
}

function hideElement(el)
{
    if (el)el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}


};

Ops.Patch.PL3eri4.Slider_hideNumber_v1.prototype = new CABLES.Op();
CABLES.OPS["41844e4f-5425-438f-a877-76eabba4051f"]={f:Ops.Patch.PL3eri4.Slider_hideNumber_v1,objName:"Ops.Patch.PL3eri4.Slider_hideNumber_v1"};




// **************************************************************
// 
// Ops.Vars.VarSetObject_v2
// 
// **************************************************************

Ops.Vars.VarSetObject_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inObject("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "object", val, op.varName);


};

Ops.Vars.VarSetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["c7608375-5b45-4bca-87ef-d0c5e970779a"]={f:Ops.Vars.VarSetObject_v2,objName:"Ops.Vars.VarSetObject_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetObject_v2
// 
// **************************************************************

Ops.Vars.VarGetObject_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outObject("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "object", op.varName, val);


};

Ops.Vars.VarGetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["321419d9-69c7-4310-a327-93d310bc2b8e"]={f:Ops.Vars.VarGetObject_v2,objName:"Ops.Vars.VarGetObject_v2"};




// **************************************************************
// 
// Ops.Cables.CallBack_v2
// 
// **************************************************************

Ops.Cables.CallBack_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const exe = op.inTriggerButton("exe");
const callbackname = op.inString("Callback Name", "myFunction");
const val0 = op.inString("Parameter 1", "");
const val1 = op.inString("Parameter 2", "");
const val2 = op.inString("Parameter 3", "");

let values = [0, 0, 0];

val0.onChange = function () { values[0] = val0.get(); };
val1.onChange = function () { values[1] = val1.get(); };
val2.onChange = function () { values[2] = val2.get(); };

exe.onTriggered = function ()
{
    if (op.patch.config.hasOwnProperty(callbackname.get()))
    {
        op.patch.config[callbackname.get()](values);
    }
    else
    {
        op.log("callback ", callbackname.get(), " not found! Parameters: ", values);
    }
};


};

Ops.Cables.CallBack_v2.prototype = new CABLES.Op();
CABLES.OPS["cfc87cb1-a74b-482f-9fad-e1777cb7ffd4"]={f:Ops.Cables.CallBack_v2,objName:"Ops.Cables.CallBack_v2"};




// **************************************************************
// 
// Ops.Gl.RenderToTexture_v3
// 
// **************************************************************

Ops.Gl.RenderToTexture_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    inSize = op.inSwitch("Size", ["Canvas", "Manual"], "Canvas"),
    width = op.inValueInt("texture width", 512),
    height = op.inValueInt("texture height", 512),
    aspect = op.inBool("Auto Aspect", true),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inSwitch("Wrap", ["Clamp", "Repeat", "Mirror"], "Repeat"),
    msaa = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none"),
    trigger = op.outTrigger("trigger"),
    tex = op.outTexture("texture"),
    texDepth = op.outTexture("textureDepth"),
    inPixelFormat = op.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),
    depth = op.inValueBool("Depth", true),
    clear = op.inValueBool("Clear", true);

const cgl = op.patch.cgl;
let fb = null;
let reInitFb = true;

op.setPortGroup("Size", [inSize, width, height, aspect]);

inPixelFormat.onChange =
    depth.onChange =
    clear.onChange =
    tfilter.onChange =
    twrap.onChange =
    msaa.onChange = initFbLater;

inSize.onChange = updateUi;

render.onTriggered =
    op.preRender = doRender;

updateUi();

function updateUi()
{
    width.setUiAttribs({ "greyout": inSize.get() != "Manual" });
    height.setUiAttribs({ "greyout": inSize.get() != "Manual" });
    aspect.setUiAttribs({ "greyout": inSize.get() != "Manual" });
}

function initFbLater()
{
    reInitFb = true;
}

function doRender()
{
    CGL.TextureEffect.checkOpNotInTextureEffect(op);

    if (!fb || reInitFb)
    {
        if (fb) fb.delete();

        let selectedWrap = CGL.Texture.WRAP_REPEAT;
        if (twrap.get() == "Clamp") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
        else if (twrap.get() == "Mirror") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;

        let selectFilter = CGL.Texture.FILTER_NEAREST;
        if (tfilter.get() == "nearest") selectFilter = CGL.Texture.FILTER_NEAREST;
        else if (tfilter.get() == "linear") selectFilter = CGL.Texture.FILTER_LINEAR;
        else if (tfilter.get() == "mipmap") selectFilter = CGL.Texture.FILTER_MIPMAP;

        if (inPixelFormat.get().indexOf("loat") && tfilter.get() == "mipmap") op.setUiError("fpmipmap", "Can't use mipmap and float texture at the same time");
        else op.setUiError("fpmipmap", null);

        if (cgl.glVersion >= 2)
        {
            let ms = true;
            let msSamples = 4;

            if (msaa.get() == "none")
            {
                msSamples = 0;
                ms = false;
            }
            if (msaa.get() == "2x") msSamples = 2;
            if (msaa.get() == "4x") msSamples = 4;
            if (msaa.get() == "8x") msSamples = 8;

            fb = new CGL.Framebuffer2(cgl, 8, 8,
                {
                    "name": "render2texture " + op.id,
                    "pixelFormat": inPixelFormat.get(),
                    "multisampling": ms,
                    "multisamplingSamples": msSamples,
                    "wrap": selectedWrap,
                    "filter": selectFilter,
                    "depth": depth.get(),
                    "clear": clear.get()
                });
        }
        else
        {
            fb = new CGL.Framebuffer(cgl, 8, 8, { "isFloatingPointTexture": false, "clear": clear.get() });
        }

        if (fb && fb.valid)
        {
            texDepth.set(fb.getTextureDepth());
            reInitFb = false;
        }
        else
        {
            fb = null;
            reInitFb = true;
        }
    }

    let setAspect = aspect.get();

    if (inSize.get() == "Canvas")
    {
        setAspect = true;
        width.set(cgl.canvasWidth);
        height.set(cgl.canvasHeight);
    }

    if (fb.getWidth() != Math.ceil(width.get()) || fb.getHeight() != Math.ceil(height.get()))
    {
        fb.setSize(
            Math.max(1, Math.ceil(width.get())),
            Math.max(1, Math.ceil(height.get())));
    }

    fb.renderStart(cgl);

    cgl.pushViewPort(0, 0, width.get(), height.get());

    if (setAspect) mat4.perspective(cgl.pMatrix, 45, width.get() / height.get(), 0.1, 1000.0);

    trigger.trigger();
    fb.renderEnd(cgl);

    cgl.popViewPort();

    texDepth.setRef(fb.getTextureDepth());
    tex.setRef(fb.getTextureColor());
}

//


};

Ops.Gl.RenderToTexture_v3.prototype = new CABLES.Op();
CABLES.OPS["41eec5c7-c480-477a-be81-04c3efac8357"]={f:Ops.Gl.RenderToTexture_v3,objName:"Ops.Gl.RenderToTexture_v3"};




// **************************************************************
// 
// Ops.Vars.VarSetTexture_v2
// 
// **************************************************************

Ops.Vars.VarSetTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inTexture("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "object", val, op.varName);


};

Ops.Vars.VarSetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["4fbfc71e-1429-439f-8591-ad35961252ed"]={f:Ops.Vars.VarSetTexture_v2,objName:"Ops.Vars.VarSetTexture_v2"};




// **************************************************************
// 
// Ops.User.cristianvogel.IteratorArray4
// 
// **************************************************************

Ops.User.cristianvogel.IteratorArray4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("Execute"),
    arr = op.inArray("Array"),
    index = op.inValue("index"),
    trigger = op.outTrigger("Trigger"),

    valX = op.outNumber("Value 1"),
    valY = op.outNumber("Value 2"),
    valZ = op.outNumber("Value 3"),
    val4 = op.outNumber("Value 4");

let ar = arr.get() || [];

let vstep = 4;

let idx = 0;

arr.onChange = function ()
{
    ar = arr.get() || [];
};

index.onChange = function ()
{
    idx = index.get() || 0;
};

exe.onTriggered = function ()
{
    idx *= vstep;
    valX.set(ar.at(idx));
    valY.set(ar.at(idx + 1));
    valZ.set(ar.at(idx + 2));
    val4.set(ar.at(idx + 3));
    trigger.trigger();
};


};

Ops.User.cristianvogel.IteratorArray4.prototype = new CABLES.Op();
CABLES.OPS["879dc66b-62ad-4abe-b42b-603c2fc94566"]={f:Ops.User.cristianvogel.IteratorArray4,objName:"Ops.User.cristianvogel.IteratorArray4"};




// **************************************************************
// 
// Ops.Sidebar.Button_v2
// 
// **************************************************************

Ops.Sidebar.Button_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// inputs
const parentPort = op.inObject("link");
const buttonTextPort = op.inString("Text", "Button");

// outputs
const siblingsPort = op.outObject("childs");
const buttonPressedPort = op.outTrigger("Pressed Trigger");

const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar--button");
const input = document.createElement("div");
input.classList.add("sidebar__button-input");
el.appendChild(input);
input.addEventListener("click", onButtonClick);
const inputText = document.createTextNode(buttonTextPort.get());
input.appendChild(inputText);
op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// events
parentPort.onChange = onParentChanged;
buttonTextPort.onChange = onButtonTextChanged;
op.onDelete = onDelete;

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onButtonClick()
{
    buttonPressedPort.trigger();
}

function onButtonTextChanged()
{
    const buttonText = buttonTextPort.get();
    input.textContent = buttonText;
    if (CABLES.UI)
    {
        op.setUiAttrib({ "extendTitle": buttonText });
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.Button_v2.prototype = new CABLES.Op();
CABLES.OPS["5e9c6933-0605-4bf7-8671-a016d917f327"]={f:Ops.Sidebar.Button_v2,objName:"Ops.Sidebar.Button_v2"};




// **************************************************************
// 
// Ops.Trigger.TriggerCounter
// 
// **************************************************************

Ops.Trigger.TriggerCounter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTriggerButton("exe"),
    reset = op.inTriggerButton("reset"),
    trigger = op.outTrigger("trigger"),
    num = op.outNumber("timesTriggered");

op.toWorkPortsNeedToBeLinked(exe);

op.setUiAttrib({ "extendTitle": 0 });
let n = 0;

reset.onTriggered =
op.onLoaded =
    doReset;

exe.onTriggered = function ()
{
    n++;
    num.set(n);
    op.setUiAttrib({ "extendTitle": n });
    trigger.trigger();
};

function doReset()
{
    n = 0;
    op.setUiAttrib({ "extendTitle": n });
    num.set(n);
}


};

Ops.Trigger.TriggerCounter.prototype = new CABLES.Op();
CABLES.OPS["e640619f-235c-4543-bbf8-b358e0283180"]={f:Ops.Trigger.TriggerCounter,objName:"Ops.Trigger.TriggerCounter"};




// **************************************************************
// 
// Ops.User.cristianvogel.NewArrayOfArrays
// 
// **************************************************************

Ops.User.cristianvogel.NewArrayOfArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inLength = op.inValueInt("Parent Array length", 10),
    inArrayElementLength = op.inValueInt("Array Element length", 4),
    modeSelect = op.inSwitch("Mode select", ["Number", "1,2,3,4", "0-1"], "Number"),
    inDefaultValue = op.inValueFloat("Default Value"),
    inReverse = op.inBool("Reverse", false),
    outArr = op.outArray("Array"),
    inExecute = op.inTriggerButton("Execute"),
    outArrayLength = op.outNumber("Array length out");

let arr = [];
let selectIndex = 0;
const MODE_NUMBER = 0;
const MODE_1_TO_4 = 1;
const MODE_0_TO_1 = 2;

modeSelect.onChange = onFilterChange;

inReverse.onChange =
    inDefaultValue.onChange =
    inLength.onChange = reset;

onFilterChange();
reset();

function onFilterChange()
{
    let selectedMode = modeSelect.get();
    if (selectedMode === "Number") selectIndex = MODE_NUMBER;
    else if (selectedMode === "1,2,3,4") selectIndex = MODE_1_TO_4;
    else if (selectedMode === "0-1") selectIndex = MODE_0_TO_1;

    inDefaultValue.setUiAttribs({ "greyout": selectIndex !== MODE_NUMBER });

    reset();
}

function reset()
{
    arr.length = 0;

    let arrLength = inLength.get();
    let arrElementLength = inArrayElementLength.get();
    let valueForArray = inDefaultValue.get();
    let i;

    arr = new Array(arrLength).fill(null).map(() => { return padValue(new Array(arrElementLength), selectIndex); });

    function padValue(_arr, mode = selectIndex)
    {
        const arrLength = _arr.length;
        // mode 0 - fill all array values with one number
        if (mode === MODE_NUMBER)
        {
            for (i = 0; i < arrLength; i++)
            {
                _arr[i] = valueForArray;
            }
        }
        // mode 1 Continuous number array - increments up to array length
        else if (mode === MODE_1_TO_4)
        {
            for (i = 0; i < arrLength; i++)
            {
                _arr[i] = i;
            }
        }
        // mode 2 Normalized array
        else if (mode === MODE_0_TO_1)
        {
            for (i = 0; i < arrLength; i++)
            {
                _arr[i] = i / (arrLength - 1);
            }
        }

        if (inReverse.get())_arr = _arr.reverse();

        return _arr;
    }

    outArr.setRef(arr);
    outArrayLength.set(arr.length);
}


};

Ops.User.cristianvogel.NewArrayOfArrays.prototype = new CABLES.Op();
CABLES.OPS["84799d12-93ac-43b5-8717-d1a87e944e60"]={f:Ops.User.cristianvogel.NewArrayOfArrays,objName:"Ops.User.cristianvogel.NewArrayOfArrays"};




// **************************************************************
// 
// Ops.Array.SwitchArray
// 
// **************************************************************

Ops.Array.SwitchArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
let idx = op.inValueInt("Index");
let valuePorts = [];
let result = op.outArray("Result");

idx.onChange = update;

for (let i = 0; i < 10; i++)
{
    let p = op.inArray("Array " + i);
    valuePorts.push(p);
    p.onChange = update;
}

function update()
{
    if (idx.get() >= 0 && valuePorts[idx.get()])
    {
        result.setRef(valuePorts[idx.get()].get());
    }
}


};

Ops.Array.SwitchArray.prototype = new CABLES.Op();
CABLES.OPS["3fab881c-c2cf-42a0-9c42-2d8edfd93f57"]={f:Ops.Array.SwitchArray,objName:"Ops.Array.SwitchArray"};




// **************************************************************
// 
// Ops.Boolean.IfTrueThen_v2
// 
// **************************************************************

Ops.Boolean.IfTrueThen_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    boolean = op.inValueBool("boolean", false),
    triggerThen = op.outTrigger("then"),
    triggerElse = op.outTrigger("else");

exe.onTriggered = exec;

// let b = false;

// boolean.onChange = () =>
// {
//     b = boolean.get();
// };

function exec()
{
    if (boolean.get()) triggerThen.trigger();
    else triggerElse.trigger();
}


};

Ops.Boolean.IfTrueThen_v2.prototype = new CABLES.Op();
CABLES.OPS["9549e2ed-a544-4d33-a672-05c7854ccf5d"]={f:Ops.Boolean.IfTrueThen_v2,objName:"Ops.Boolean.IfTrueThen_v2"};




// **************************************************************
// 
// Ops.User.cristianvogel.ConvertArrayToObject
// 
// **************************************************************

Ops.User.cristianvogel.ConvertArrayToObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inExec = op.inTriggerButton("execute"),
    inArr = op.inArray("Array"),
    inDecimalPoints = op.inInt("Decimal points", 6);
const
    outObj = op.outObject("Object");

const convertArrayToObject = (array) =>
{
    return array.reduce((obj, item, i) =>
    {
        return {
            ...obj,
            [i]: parseFloat(item.toFixed(inDecimalPoints.get()))
        };
    },
    {}
    );
};

inExec.onTriggered = () =>
{
    const arr = inArr.get();
    outObj.set(convertArrayToObject(arr));
};


};

Ops.User.cristianvogel.ConvertArrayToObject.prototype = new CABLES.Op();
CABLES.OPS["50e771f9-4e9f-4ca4-8910-5539ccd15f5c"]={f:Ops.User.cristianvogel.ConvertArrayToObject,objName:"Ops.User.cristianvogel.ConvertArrayToObject"};




// **************************************************************
// 
// Ops.User.cristianvogel.LofiSmoothArray
// 
// **************************************************************

Ops.User.cristianvogel.LofiSmoothArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
// look at http://sol.gfxile.net/interpolation/
const exec = op.inTrigger("Execute"),
    inArray = op.inArray("Array In"),
    inModeBool = op.inBool("Separate inc/dec", false),
    incFactor = op.inValue("Inc factor", 4),
    decFactor = op.inValue("Dec factor", 4),
    next = op.outTrigger("Next"),
    outArray = op.outArray("Array Out");

let goal = [];
let reset = false;
let lastTrigger = 0;

let newArr = [];
outArray.set(newArr);

let divisorUp;
let divisorDown;

let selectedMode = false;

onFilterChange();
getDivisors();
function onFilterChange()
{
    selectedMode = inModeBool.get();

    if (!selectedMode)
    {
        decFactor.setUiAttribs({ "greyout": true });
        incFactor.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else
    {
        decFactor.setUiAttribs({ "greyout": false });
        incFactor.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    divisorUp = incFactor.get();

    if (selectedMode == false) divisorDown = incFactor.get();
    else divisorDown = decFactor.get();

    if (divisorUp <= 0 || divisorUp != divisorUp) divisorUp = 0.0001;
    if (divisorDown <= 0 || divisorDown != divisorDown) divisorDown = 0.0001;
    if (divisorUp <= 1.0) divisorUp = 1.0;
    if (divisorDown <= 1.0) divisorDown = 1.0;
}

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    for (let i = 0; i < arr.length; i++)
    {
        goal[i] = arr[i] || 0;
    }
};

let oldVal = 0;

function update()
{
    let arr = inArray.get();
    if (!arr) return;

    if (newArr.length != arr.length)
    {
        newArr.length = arr.length || 0;
        reset = true;
    }

    let tm = 1;
    if (CABLES.now() - lastTrigger > 500 || lastTrigger === 0) reset = true;
    else tm = (CABLES.now() - lastTrigger) / 17;
    lastTrigger = CABLES.now();

    if (reset)
    {
        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = arr[i];
        }
        reset = false;
    }

    for (var i = 0; i < arr.length; i++)
    {
        let val = newArr[i];

        let diff = goal[i] - val;

        if (diff >= 0)
            val += (diff) / (divisorDown * tm);
        else
            val += (diff) / (divisorUp * tm);

        if (val > 0 && val < 1.0e-5) val = 0;
        if (!val) val = 0;

        if (newArr[i] != val)
        {
            newArr[i] = val;
            oldVal = val;
        }
    }
    // outArray.set(null);
    outArray.setRef(newArr);

    next.trigger();
}

exec.onTriggered = function ()
{
    update();
};

incFactor.onChange = decFactor.onChange = getDivisors;
inModeBool.onChange = onFilterChange;
update();


};

Ops.User.cristianvogel.LofiSmoothArray.prototype = new CABLES.Op();
CABLES.OPS["1823f416-5296-44c1-8caa-2f435da23cd6"]={f:Ops.User.cristianvogel.LofiSmoothArray,objName:"Ops.User.cristianvogel.LofiSmoothArray"};



window.addEventListener('load', function(event) {
CABLES.jsLoaded=new Event('CABLES.jsLoaded');
document.dispatchEvent(CABLES.jsLoaded);
});
// start js/opentype.js
/**
 * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.opentype = {}));
}(this, (function (exports) { 'use strict';

	/*! https://mths.be/codepointat v0.2.0 by @mathias */
	if (!String.prototype.codePointAt) {
		(function() {
			var defineProperty = (function() {
				// IE 8 only supports `Object.defineProperty` on DOM elements
				try {
					var object = {};
					var $defineProperty = Object.defineProperty;
					var result = $defineProperty(object, object, object) && $defineProperty;
				} catch(error) {}
				return result;
			}());
			var codePointAt = function(position) {
				if (this == null) {
					throw TypeError();
				}
				var string = String(this);
				var size = string.length;
				// `ToInteger`
				var index = position ? Number(position) : 0;
				if (index != index) { // better `isNaN`
					index = 0;
				}
				// Account for out-of-bounds indices:
				if (index < 0 || index >= size) {
					return undefined;
				}
				// Get the first code unit
				var first = string.charCodeAt(index);
				var second;
				if ( // check if it’s the start of a surrogate pair
					first >= 0xD800 && first <= 0xDBFF && // high surrogate
					size > index + 1 // there is a next code unit
				) {
					second = string.charCodeAt(index + 1);
					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
					}
				}
				return first;
			};
			if (defineProperty) {
				defineProperty(String.prototype, 'codePointAt', {
					'value': codePointAt,
					'configurable': true,
					'writable': true
				});
			} else {
				String.prototype.codePointAt = codePointAt;
			}
		}());
	}

	var TINF_OK = 0;
	var TINF_DATA_ERROR = -3;

	function Tree() {
	  this.table = new Uint16Array(16);   /* table of code length counts */
	  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
	}

	function Data(source, dest) {
	  this.source = source;
	  this.sourceIndex = 0;
	  this.tag = 0;
	  this.bitcount = 0;
	  
	  this.dest = dest;
	  this.destLen = 0;
	  
	  this.ltree = new Tree();  /* dynamic length/symbol tree */
	  this.dtree = new Tree();  /* dynamic distance tree */
	}

	/* --------------------------------------------------- *
	 * -- uninitialized global data (static structures) -- *
	 * --------------------------------------------------- */

	var sltree = new Tree();
	var sdtree = new Tree();

	/* extra bits and base tables for length codes */
	var length_bits = new Uint8Array(30);
	var length_base = new Uint16Array(30);

	/* extra bits and base tables for distance codes */
	var dist_bits = new Uint8Array(30);
	var dist_base = new Uint16Array(30);

	/* special ordering of code length codes */
	var clcidx = new Uint8Array([
	  16, 17, 18, 0, 8, 7, 9, 6,
	  10, 5, 11, 4, 12, 3, 13, 2,
	  14, 1, 15
	]);

	/* used by tinf_decode_trees, avoids allocations every call */
	var code_tree = new Tree();
	var lengths = new Uint8Array(288 + 32);

	/* ----------------------- *
	 * -- utility functions -- *
	 * ----------------------- */

	/* build extra bits and base tables */
	function tinf_build_bits_base(bits, base, delta, first) {
	  var i, sum;

	  /* build bits table */
	  for (i = 0; i < delta; ++i) { bits[i] = 0; }
	  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

	  /* build base table */
	  for (sum = first, i = 0; i < 30; ++i) {
	    base[i] = sum;
	    sum += 1 << bits[i];
	  }
	}

	/* build the fixed huffman trees */
	function tinf_build_fixed_trees(lt, dt) {
	  var i;

	  /* build fixed length tree */
	  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

	  lt.table[7] = 24;
	  lt.table[8] = 152;
	  lt.table[9] = 112;

	  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
	  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
	  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
	  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

	  /* build fixed distance tree */
	  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

	  dt.table[5] = 32;

	  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
	}

	/* given an array of code lengths, build a tree */
	var offs = new Uint16Array(16);

	function tinf_build_tree(t, lengths, off, num) {
	  var i, sum;

	  /* clear code length count table */
	  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

	  /* scan symbol lengths, and sum code length counts */
	  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

	  t.table[0] = 0;

	  /* compute offset table for distribution sort */
	  for (sum = 0, i = 0; i < 16; ++i) {
	    offs[i] = sum;
	    sum += t.table[i];
	  }

	  /* create code->symbol translation table (symbols sorted by code) */
	  for (i = 0; i < num; ++i) {
	    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
	  }
	}

	/* ---------------------- *
	 * -- decode functions -- *
	 * ---------------------- */

	/* get one bit from source stream */
	function tinf_getbit(d) {
	  /* check if tag is empty */
	  if (!d.bitcount--) {
	    /* load next tag */
	    d.tag = d.source[d.sourceIndex++];
	    d.bitcount = 7;
	  }

	  /* shift bit out of tag */
	  var bit = d.tag & 1;
	  d.tag >>>= 1;

	  return bit;
	}

	/* read a num bit value from a stream and add base */
	function tinf_read_bits(d, num, base) {
	  if (!num)
	    { return base; }

	  while (d.bitcount < 24) {
	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
	    d.bitcount += 8;
	  }

	  var val = d.tag & (0xffff >>> (16 - num));
	  d.tag >>>= num;
	  d.bitcount -= num;
	  return val + base;
	}

	/* given a data stream and a tree, decode a symbol */
	function tinf_decode_symbol(d, t) {
	  while (d.bitcount < 24) {
	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
	    d.bitcount += 8;
	  }
	  
	  var sum = 0, cur = 0, len = 0;
	  var tag = d.tag;

	  /* get more bits while code value is above sum */
	  do {
	    cur = 2 * cur + (tag & 1);
	    tag >>>= 1;
	    ++len;

	    sum += t.table[len];
	    cur -= t.table[len];
	  } while (cur >= 0);
	  
	  d.tag = tag;
	  d.bitcount -= len;

	  return t.trans[sum + cur];
	}

	/* given a data stream, decode dynamic trees from it */
	function tinf_decode_trees(d, lt, dt) {
	  var hlit, hdist, hclen;
	  var i, num, length;

	  /* get 5 bits HLIT (257-286) */
	  hlit = tinf_read_bits(d, 5, 257);

	  /* get 5 bits HDIST (1-32) */
	  hdist = tinf_read_bits(d, 5, 1);

	  /* get 4 bits HCLEN (4-19) */
	  hclen = tinf_read_bits(d, 4, 4);

	  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

	  /* read code lengths for code length alphabet */
	  for (i = 0; i < hclen; ++i) {
	    /* get 3 bits code length (0-7) */
	    var clen = tinf_read_bits(d, 3, 0);
	    lengths[clcidx[i]] = clen;
	  }

	  /* build code length tree */
	  tinf_build_tree(code_tree, lengths, 0, 19);

	  /* decode code lengths for the dynamic trees */
	  for (num = 0; num < hlit + hdist;) {
	    var sym = tinf_decode_symbol(d, code_tree);

	    switch (sym) {
	      case 16:
	        /* copy previous code length 3-6 times (read 2 bits) */
	        var prev = lengths[num - 1];
	        for (length = tinf_read_bits(d, 2, 3); length; --length) {
	          lengths[num++] = prev;
	        }
	        break;
	      case 17:
	        /* repeat code length 0 for 3-10 times (read 3 bits) */
	        for (length = tinf_read_bits(d, 3, 3); length; --length) {
	          lengths[num++] = 0;
	        }
	        break;
	      case 18:
	        /* repeat code length 0 for 11-138 times (read 7 bits) */
	        for (length = tinf_read_bits(d, 7, 11); length; --length) {
	          lengths[num++] = 0;
	        }
	        break;
	      default:
	        /* values 0-15 represent the actual code lengths */
	        lengths[num++] = sym;
	        break;
	    }
	  }

	  /* build dynamic trees */
	  tinf_build_tree(lt, lengths, 0, hlit);
	  tinf_build_tree(dt, lengths, hlit, hdist);
	}

	/* ----------------------------- *
	 * -- block inflate functions -- *
	 * ----------------------------- */

	/* given a stream and two trees, inflate a block of data */
	function tinf_inflate_block_data(d, lt, dt) {
	  while (1) {
	    var sym = tinf_decode_symbol(d, lt);

	    /* check for end of block */
	    if (sym === 256) {
	      return TINF_OK;
	    }

	    if (sym < 256) {
	      d.dest[d.destLen++] = sym;
	    } else {
	      var length, dist, offs;
	      var i;

	      sym -= 257;

	      /* possibly get more bits from length code */
	      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

	      dist = tinf_decode_symbol(d, dt);

	      /* possibly get more bits from distance code */
	      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

	      /* copy match */
	      for (i = offs; i < offs + length; ++i) {
	        d.dest[d.destLen++] = d.dest[i];
	      }
	    }
	  }
	}

	/* inflate an uncompressed block of data */
	function tinf_inflate_uncompressed_block(d) {
	  var length, invlength;
	  var i;
	  
	  /* unread from bitbuffer */
	  while (d.bitcount > 8) {
	    d.sourceIndex--;
	    d.bitcount -= 8;
	  }

	  /* get length */
	  length = d.source[d.sourceIndex + 1];
	  length = 256 * length + d.source[d.sourceIndex];

	  /* get one's complement of length */
	  invlength = d.source[d.sourceIndex + 3];
	  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

	  /* check length */
	  if (length !== (~invlength & 0x0000ffff))
	    { return TINF_DATA_ERROR; }

	  d.sourceIndex += 4;

	  /* copy block */
	  for (i = length; i; --i)
	    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

	  /* make sure we start next block on a byte boundary */
	  d.bitcount = 0;

	  return TINF_OK;
	}

	/* inflate stream from source to dest */
	function tinf_uncompress(source, dest) {
	  var d = new Data(source, dest);
	  var bfinal, btype, res;

	  do {
	    /* read final block flag */
	    bfinal = tinf_getbit(d);

	    /* read block type (2 bits) */
	    btype = tinf_read_bits(d, 2, 0);

	    /* decompress block */
	    switch (btype) {
	      case 0:
	        /* decompress uncompressed block */
	        res = tinf_inflate_uncompressed_block(d);
	        break;
	      case 1:
	        /* decompress block with fixed huffman trees */
	        res = tinf_inflate_block_data(d, sltree, sdtree);
	        break;
	      case 2:
	        /* decompress block with dynamic huffman trees */
	        tinf_decode_trees(d, d.ltree, d.dtree);
	        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
	        break;
	      default:
	        res = TINF_DATA_ERROR;
	    }

	    if (res !== TINF_OK)
	      { throw new Error('Data error'); }

	  } while (!bfinal);

	  if (d.destLen < d.dest.length) {
	    if (typeof d.dest.slice === 'function')
	      { return d.dest.slice(0, d.destLen); }
	    else
	      { return d.dest.subarray(0, d.destLen); }
	  }
	  
	  return d.dest;
	}

	/* -------------------- *
	 * -- initialization -- *
	 * -------------------- */

	/* build fixed huffman trees */
	tinf_build_fixed_trees(sltree, sdtree);

	/* build extra bits and base tables */
	tinf_build_bits_base(length_bits, length_base, 4, 3);
	tinf_build_bits_base(dist_bits, dist_base, 2, 1);

	/* fix a special case */
	length_bits[28] = 0;
	length_base[28] = 258;

	var tinyInflate = tinf_uncompress;

	// The Bounding Box object

	function derive(v0, v1, v2, v3, t) {
	    return Math.pow(1 - t, 3) * v0 +
	        3 * Math.pow(1 - t, 2) * t * v1 +
	        3 * (1 - t) * Math.pow(t, 2) * v2 +
	        Math.pow(t, 3) * v3;
	}
	/**
	 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
	 * It is used to calculate the bounding box of a glyph or text path.
	 *
	 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
	 *
	 * @exports opentype.BoundingBox
	 * @class
	 * @constructor
	 */
	function BoundingBox() {
	    this.x1 = Number.NaN;
	    this.y1 = Number.NaN;
	    this.x2 = Number.NaN;
	    this.y2 = Number.NaN;
	}

	/**
	 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
	 */
	BoundingBox.prototype.isEmpty = function() {
	    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
	};

	/**
	 * Add the point to the bounding box.
	 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
	 * @param {number} x - The X coordinate of the point.
	 * @param {number} y - The Y coordinate of the point.
	 */
	BoundingBox.prototype.addPoint = function(x, y) {
	    if (typeof x === 'number') {
	        if (isNaN(this.x1) || isNaN(this.x2)) {
	            this.x1 = x;
	            this.x2 = x;
	        }
	        if (x < this.x1) {
	            this.x1 = x;
	        }
	        if (x > this.x2) {
	            this.x2 = x;
	        }
	    }
	    if (typeof y === 'number') {
	        if (isNaN(this.y1) || isNaN(this.y2)) {
	            this.y1 = y;
	            this.y2 = y;
	        }
	        if (y < this.y1) {
	            this.y1 = y;
	        }
	        if (y > this.y2) {
	            this.y2 = y;
	        }
	    }
	};

	/**
	 * Add a X coordinate to the bounding box.
	 * This extends the bounding box to include the X coordinate.
	 * This function is used internally inside of addBezier.
	 * @param {number} x - The X coordinate of the point.
	 */
	BoundingBox.prototype.addX = function(x) {
	    this.addPoint(x, null);
	};

	/**
	 * Add a Y coordinate to the bounding box.
	 * This extends the bounding box to include the Y coordinate.
	 * This function is used internally inside of addBezier.
	 * @param {number} y - The Y coordinate of the point.
	 */
	BoundingBox.prototype.addY = function(y) {
	    this.addPoint(null, y);
	};

	/**
	 * Add a Bézier curve to the bounding box.
	 * This extends the bounding box to include the entire Bézier.
	 * @param {number} x0 - The starting X coordinate.
	 * @param {number} y0 - The starting Y coordinate.
	 * @param {number} x1 - The X coordinate of the first control point.
	 * @param {number} y1 - The Y coordinate of the first control point.
	 * @param {number} x2 - The X coordinate of the second control point.
	 * @param {number} y2 - The Y coordinate of the second control point.
	 * @param {number} x - The ending X coordinate.
	 * @param {number} y - The ending Y coordinate.
	 */
	BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
	    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
	    // and https://github.com/icons8/svg-path-bounding-box

	    var p0 = [x0, y0];
	    var p1 = [x1, y1];
	    var p2 = [x2, y2];
	    var p3 = [x, y];

	    this.addPoint(x0, y0);
	    this.addPoint(x, y);

	    for (var i = 0; i <= 1; i++) {
	        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
	        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
	        var c = 3 * p1[i] - 3 * p0[i];

	        if (a === 0) {
	            if (b === 0) { continue; }
	            var t = -c / b;
	            if (0 < t && t < 1) {
	                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
	                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
	            }
	            continue;
	        }

	        var b2ac = Math.pow(b, 2) - 4 * c * a;
	        if (b2ac < 0) { continue; }
	        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
	        if (0 < t1 && t1 < 1) {
	            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
	            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
	        }
	        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
	        if (0 < t2 && t2 < 1) {
	            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
	            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
	        }
	    }
	};

	/**
	 * Add a quadratic curve to the bounding box.
	 * This extends the bounding box to include the entire quadratic curve.
	 * @param {number} x0 - The starting X coordinate.
	 * @param {number} y0 - The starting Y coordinate.
	 * @param {number} x1 - The X coordinate of the control point.
	 * @param {number} y1 - The Y coordinate of the control point.
	 * @param {number} x - The ending X coordinate.
	 * @param {number} y - The ending Y coordinate.
	 */
	BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
	    var cp1x = x0 + 2 / 3 * (x1 - x0);
	    var cp1y = y0 + 2 / 3 * (y1 - y0);
	    var cp2x = cp1x + 1 / 3 * (x - x0);
	    var cp2y = cp1y + 1 / 3 * (y - y0);
	    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
	};

	// Geometric objects

	/**
	 * A bézier path containing a set of path commands similar to a SVG path.
	 * Paths can be drawn on a context using `draw`.
	 * @exports opentype.Path
	 * @class
	 * @constructor
	 */
	function Path() {
	    this.commands = [];
	    this.fill = 'black';
	    this.stroke = null;
	    this.strokeWidth = 1;
	}

	/**
	 * @param  {number} x
	 * @param  {number} y
	 */
	Path.prototype.moveTo = function(x, y) {
	    this.commands.push({
	        type: 'M',
	        x: x,
	        y: y
	    });
	};

	/**
	 * @param  {number} x
	 * @param  {number} y
	 */
	Path.prototype.lineTo = function(x, y) {
	    this.commands.push({
	        type: 'L',
	        x: x,
	        y: y
	    });
	};

	/**
	 * Draws cubic curve
	 * @function
	 * curveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control 1
	 * @param  {number} y1 - y of control 1
	 * @param  {number} x2 - x of control 2
	 * @param  {number} y2 - y of control 2
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */

	/**
	 * Draws cubic curve
	 * @function
	 * bezierCurveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control 1
	 * @param  {number} y1 - y of control 1
	 * @param  {number} x2 - x of control 2
	 * @param  {number} y2 - y of control 2
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 * @see curveTo
	 */
	Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
	    this.commands.push({
	        type: 'C',
	        x1: x1,
	        y1: y1,
	        x2: x2,
	        y2: y2,
	        x: x,
	        y: y
	    });
	};

	/**
	 * Draws quadratic curve
	 * @function
	 * quadraticCurveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control
	 * @param  {number} y1 - y of control
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */

	/**
	 * Draws quadratic curve
	 * @function
	 * quadTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control
	 * @param  {number} y1 - y of control
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */
	Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
	    this.commands.push({
	        type: 'Q',
	        x1: x1,
	        y1: y1,
	        x: x,
	        y: y
	    });
	};

	/**
	 * Closes the path
	 * @function closePath
	 * @memberof opentype.Path.prototype
	 */

	/**
	 * Close the path
	 * @function close
	 * @memberof opentype.Path.prototype
	 */
	Path.prototype.close = Path.prototype.closePath = function() {
	    this.commands.push({
	        type: 'Z'
	    });
	};

	/**
	 * Add the given path or list of commands to the commands of this path.
	 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
	 */
	Path.prototype.extend = function(pathOrCommands) {
	    if (pathOrCommands.commands) {
	        pathOrCommands = pathOrCommands.commands;
	    } else if (pathOrCommands instanceof BoundingBox) {
	        var box = pathOrCommands;
	        this.moveTo(box.x1, box.y1);
	        this.lineTo(box.x2, box.y1);
	        this.lineTo(box.x2, box.y2);
	        this.lineTo(box.x1, box.y2);
	        this.close();
	        return;
	    }

	    Array.prototype.push.apply(this.commands, pathOrCommands);
	};

	/**
	 * Calculate the bounding box of the path.
	 * @returns {opentype.BoundingBox}
	 */
	Path.prototype.getBoundingBox = function() {
	    var box = new BoundingBox();

	    var startX = 0;
	    var startY = 0;
	    var prevX = 0;
	    var prevY = 0;
	    for (var i = 0; i < this.commands.length; i++) {
	        var cmd = this.commands[i];
	        switch (cmd.type) {
	            case 'M':
	                box.addPoint(cmd.x, cmd.y);
	                startX = prevX = cmd.x;
	                startY = prevY = cmd.y;
	                break;
	            case 'L':
	                box.addPoint(cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'Q':
	                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'C':
	                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'Z':
	                prevX = startX;
	                prevY = startY;
	                break;
	            default:
	                throw new Error('Unexpected path command ' + cmd.type);
	        }
	    }
	    if (box.isEmpty()) {
	        box.addPoint(0, 0);
	    }
	    return box;
	};

	/**
	 * Draw the path to a 2D context.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
	 */
	Path.prototype.draw = function(ctx) {
	    ctx.beginPath();
	    for (var i = 0; i < this.commands.length; i += 1) {
	        var cmd = this.commands[i];
	        if (cmd.type === 'M') {
	            ctx.moveTo(cmd.x, cmd.y);
	        } else if (cmd.type === 'L') {
	            ctx.lineTo(cmd.x, cmd.y);
	        } else if (cmd.type === 'C') {
	            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	        } else if (cmd.type === 'Q') {
	            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
	        } else if (cmd.type === 'Z') {
	            ctx.closePath();
	        }
	    }

	    if (this.fill) {
	        ctx.fillStyle = this.fill;
	        ctx.fill();
	    }

	    if (this.stroke) {
	        ctx.strokeStyle = this.stroke;
	        ctx.lineWidth = this.strokeWidth;
	        ctx.stroke();
	    }
	};

	/**
	 * Convert the Path to a string of path data instructions
	 * See http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {string}
	 */
	Path.prototype.toPathData = function(decimalPlaces) {
	    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

	    function floatToString(v) {
	        if (Math.round(v) === v) {
	            return '' + Math.round(v);
	        } else {
	            return v.toFixed(decimalPlaces);
	        }
	    }

	    function packValues() {
	        var arguments$1 = arguments;

	        var s = '';
	        for (var i = 0; i < arguments.length; i += 1) {
	            var v = arguments$1[i];
	            if (v >= 0 && i > 0) {
	                s += ' ';
	            }

	            s += floatToString(v);
	        }

	        return s;
	    }

	    var d = '';
	    for (var i = 0; i < this.commands.length; i += 1) {
	        var cmd = this.commands[i];
	        if (cmd.type === 'M') {
	            d += 'M' + packValues(cmd.x, cmd.y);
	        } else if (cmd.type === 'L') {
	            d += 'L' + packValues(cmd.x, cmd.y);
	        } else if (cmd.type === 'C') {
	            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	        } else if (cmd.type === 'Q') {
	            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
	        } else if (cmd.type === 'Z') {
	            d += 'Z';
	        }
	    }

	    return d;
	};

	/**
	 * Convert the path to an SVG <path> element, as a string.
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {string}
	 */
	Path.prototype.toSVG = function(decimalPlaces) {
	    var svg = '<path d="';
	    svg += this.toPathData(decimalPlaces);
	    svg += '"';
	    if (this.fill && this.fill !== 'black') {
	        if (this.fill === null) {
	            svg += ' fill="none"';
	        } else {
	            svg += ' fill="' + this.fill + '"';
	        }
	    }

	    if (this.stroke) {
	        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
	    }

	    svg += '/>';
	    return svg;
	};

	/**
	 * Convert the path to a DOM element.
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {SVGPathElement}
	 */
	Path.prototype.toDOMElement = function(decimalPlaces) {
	    var temporaryPath = this.toPathData(decimalPlaces);
	    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

	    newPath.setAttribute('d', temporaryPath);

	    return newPath;
	};

	// Run-time checking of preconditions.

	function fail(message) {
	    throw new Error(message);
	}

	// Precondition function that checks if the given predicate is true.
	// If not, it will throw an error.
	function argument(predicate, message) {
	    if (!predicate) {
	        fail(message);
	    }
	}
	var check = { fail: fail, argument: argument, assert: argument };

	// Data types used in the OpenType font file.

	var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
	var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

	/**
	 * @exports opentype.decode
	 * @class
	 */
	var decode = {};
	/**
	 * @exports opentype.encode
	 * @class
	 */
	var encode = {};
	/**
	 * @exports opentype.sizeOf
	 * @class
	 */
	var sizeOf = {};

	// Return a function that always returns the same value.
	function constant(v) {
	    return function() {
	        return v;
	    };
	}

	// OpenType data types //////////////////////////////////////////////////////

	/**
	 * Convert an 8-bit unsigned integer to a list of 1 byte.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.BYTE = function(v) {
	    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
	    return [v];
	};
	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.BYTE = constant(1);

	/**
	 * Convert a 8-bit signed integer to a list of 1 byte.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.CHAR = function(v) {
	    return [v.charCodeAt(0)];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.CHAR = constant(1);

	/**
	 * Convert an ASCII string to a list of bytes.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.CHARARRAY = function(v) {
	    if (typeof v === 'undefined') {
	        v = '';
	        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');
	    }
	    var b = [];
	    for (var i = 0; i < v.length; i += 1) {
	        b[i] = v.charCodeAt(i);
	    }

	    return b;
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.CHARARRAY = function(v) {
	    if (typeof v === 'undefined') {
	        return 0;
	    }
	    return v.length;
	};

	/**
	 * Convert a 16-bit unsigned integer to a list of 2 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.USHORT = function(v) {
	    return [(v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.USHORT = constant(2);

	/**
	 * Convert a 16-bit signed integer to a list of 2 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.SHORT = function(v) {
	    // Two's complement
	    if (v >= LIMIT16) {
	        v = -(2 * LIMIT16 - v);
	    }

	    return [(v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.SHORT = constant(2);

	/**
	 * Convert a 24-bit unsigned integer to a list of 3 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.UINT24 = function(v) {
	    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.UINT24 = constant(3);

	/**
	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.ULONG = function(v) {
	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.ULONG = constant(4);

	/**
	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.LONG = function(v) {
	    // Two's complement
	    if (v >= LIMIT32) {
	        v = -(2 * LIMIT32 - v);
	    }

	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.LONG = constant(4);

	encode.FIXED = encode.ULONG;
	sizeOf.FIXED = sizeOf.ULONG;

	encode.FWORD = encode.SHORT;
	sizeOf.FWORD = sizeOf.SHORT;

	encode.UFWORD = encode.USHORT;
	sizeOf.UFWORD = sizeOf.USHORT;

	/**
	 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.LONGDATETIME = function(v) {
	    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.LONGDATETIME = constant(8);

	/**
	 * Convert a 4-char tag to a list of 4 bytes.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.TAG = function(v) {
	    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
	    return [v.charCodeAt(0),
	            v.charCodeAt(1),
	            v.charCodeAt(2),
	            v.charCodeAt(3)];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.TAG = constant(4);

	// CFF data types ///////////////////////////////////////////////////////////

	encode.Card8 = encode.BYTE;
	sizeOf.Card8 = sizeOf.BYTE;

	encode.Card16 = encode.USHORT;
	sizeOf.Card16 = sizeOf.USHORT;

	encode.OffSize = encode.BYTE;
	sizeOf.OffSize = sizeOf.BYTE;

	encode.SID = encode.USHORT;
	sizeOf.SID = sizeOf.USHORT;

	// Convert a numeric operand or charstring number to a variable-size list of bytes.
	/**
	 * Convert a numeric operand or charstring number to a variable-size list of bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER = function(v) {
	    if (v >= -107 && v <= 107) {
	        return [v + 139];
	    } else if (v >= 108 && v <= 1131) {
	        v = v - 108;
	        return [(v >> 8) + 247, v & 0xFF];
	    } else if (v >= -1131 && v <= -108) {
	        v = -v - 108;
	        return [(v >> 8) + 251, v & 0xFF];
	    } else if (v >= -32768 && v <= 32767) {
	        return encode.NUMBER16(v);
	    } else {
	        return encode.NUMBER32(v);
	    }
	};

	/**
	 * @param {number}
	 * @returns {number}
	 */
	sizeOf.NUMBER = function(v) {
	    return encode.NUMBER(v).length;
	};

	/**
	 * Convert a signed number between -32768 and +32767 to a three-byte value.
	 * This ensures we always use three bytes, but is not the most compact format.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER16 = function(v) {
	    return [28, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.NUMBER16 = constant(3);

	/**
	 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
	 * This is useful if you want to be sure you always use four bytes,
	 * at the expense of wasting a few bytes for smaller numbers.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER32 = function(v) {
	    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.NUMBER32 = constant(5);

	/**
	 * @param {number}
	 * @returns {Array}
	 */
	encode.REAL = function(v) {
	    var value = v.toString();

	    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
	    // This code converts it back to a number without the epsilon.
	    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
	    if (m) {
	        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
	        value = (Math.round(v * epsilon) / epsilon).toString();
	    }

	    var nibbles = '';
	    for (var i = 0, ii = value.length; i < ii; i += 1) {
	        var c = value[i];
	        if (c === 'e') {
	            nibbles += value[++i] === '-' ? 'c' : 'b';
	        } else if (c === '.') {
	            nibbles += 'a';
	        } else if (c === '-') {
	            nibbles += 'e';
	        } else {
	            nibbles += c;
	        }
	    }

	    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
	    var out = [30];
	    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
	        out.push(parseInt(nibbles.substr(i$1, 2), 16));
	    }

	    return out;
	};

	/**
	 * @param {number}
	 * @returns {number}
	 */
	sizeOf.REAL = function(v) {
	    return encode.REAL(v).length;
	};

	encode.NAME = encode.CHARARRAY;
	sizeOf.NAME = sizeOf.CHARARRAY;

	encode.STRING = encode.CHARARRAY;
	sizeOf.STRING = sizeOf.CHARARRAY;

	/**
	 * @param {DataView} data
	 * @param {number} offset
	 * @param {number} numBytes
	 * @returns {string}
	 */
	decode.UTF8 = function(data, offset, numBytes) {
	    var codePoints = [];
	    var numChars = numBytes;
	    for (var j = 0; j < numChars; j++, offset += 1) {
	        codePoints[j] = data.getUint8(offset);
	    }

	    return String.fromCharCode.apply(null, codePoints);
	};

	/**
	 * @param {DataView} data
	 * @param {number} offset
	 * @param {number} numBytes
	 * @returns {string}
	 */
	decode.UTF16 = function(data, offset, numBytes) {
	    var codePoints = [];
	    var numChars = numBytes / 2;
	    for (var j = 0; j < numChars; j++, offset += 2) {
	        codePoints[j] = data.getUint16(offset);
	    }

	    return String.fromCharCode.apply(null, codePoints);
	};

	/**
	 * Convert a JavaScript string to UTF16-BE.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.UTF16 = function(v) {
	    var b = [];
	    for (var i = 0; i < v.length; i += 1) {
	        var codepoint = v.charCodeAt(i);
	        b[b.length] = (codepoint >> 8) & 0xFF;
	        b[b.length] = codepoint & 0xFF;
	    }

	    return b;
	};

	/**
	 * @param {string}
	 * @returns {number}
	 */
	sizeOf.UTF16 = function(v) {
	    return v.length * 2;
	};

	// Data for converting old eight-bit Macintosh encodings to Unicode.
	// This representation is optimized for decoding; encoding is slower
	// and needs more memory. The assumption is that all opentype.js users
	// want to open fonts, but saving a font will be comparatively rare
	// so it can be more expensive. Keyed by IANA character set name.
	//
	// Python script for generating these strings:
	//
	//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
	//     print(s.encode('utf-8'))
	/**
	 * @private
	 */
	var eightBitMacEncodings = {
	    'x-mac-croatian':  // Python: 'mac_croatian'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
	    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
	    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
	    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
	    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
	    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
	    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
	    'x-mac-greek':  // Python: 'mac_greek'
	    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
	    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
	    'x-mac-icelandic':  // Python: 'mac_iceland'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
	    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
	    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
	    'x-mac-ce':  // Python: 'mac_latin2'
	    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
	    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
	    macintosh:  // Python: 'mac_roman'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-romanian':  // Python: 'mac_romanian'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-turkish':  // Python: 'mac_turkish'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
	};

	/**
	 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
	 * string, or 'undefined' if the encoding is unsupported. For example, we do
	 * not support Chinese, Japanese or Korean because these would need large
	 * mapping tables.
	 * @param {DataView} dataView
	 * @param {number} offset
	 * @param {number} dataLength
	 * @param {string} encoding
	 * @returns {string}
	 */
	decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
	    var table = eightBitMacEncodings[encoding];
	    if (table === undefined) {
	        return undefined;
	    }

	    var result = '';
	    for (var i = 0; i < dataLength; i++) {
	        var c = dataView.getUint8(offset + i);
	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
	        // mapped to U+0000..U+007F; we only need to look up the others.
	        if (c <= 0x7F) {
	            result += String.fromCharCode(c);
	        } else {
	            result += table[c & 0x7F];
	        }
	    }

	    return result;
	};

	// Helper function for encode.MACSTRING. Returns a dictionary for mapping
	// Unicode character codes to their 8-bit MacOS equivalent. This table
	// is not exactly a super cheap data structure, but we do not care because
	// encoding Macintosh strings is only rarely needed in typical applications.
	var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
	var macEncodingCacheKeys;
	var getMacEncodingTable = function (encoding) {
	    // Since we use encoding as a cache key for WeakMap, it has to be
	    // a String object and not a literal. And at least on NodeJS 2.10.1,
	    // WeakMap requires that the same String instance is passed for cache hits.
	    if (!macEncodingCacheKeys) {
	        macEncodingCacheKeys = {};
	        for (var e in eightBitMacEncodings) {
	            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
	            macEncodingCacheKeys[e] = new String(e);
	        }
	    }

	    var cacheKey = macEncodingCacheKeys[encoding];
	    if (cacheKey === undefined) {
	        return undefined;
	    }

	    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
	    // since garbage collection may run at any time, it could also kick in
	    // between the calls to cache.has() and cache.get(). In that case,
	    // we would return 'undefined' even though we do support the encoding.
	    if (macEncodingTableCache) {
	        var cachedTable = macEncodingTableCache.get(cacheKey);
	        if (cachedTable !== undefined) {
	            return cachedTable;
	        }
	    }

	    var decodingTable = eightBitMacEncodings[encoding];
	    if (decodingTable === undefined) {
	        return undefined;
	    }

	    var encodingTable = {};
	    for (var i = 0; i < decodingTable.length; i++) {
	        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
	    }

	    if (macEncodingTableCache) {
	        macEncodingTableCache.set(cacheKey, encodingTable);
	    }

	    return encodingTable;
	};

	/**
	 * Encodes an old-style Macintosh string. Returns a byte array upon success.
	 * If the requested encoding is unsupported, or if the input string contains
	 * a character that cannot be expressed in the encoding, the function returns
	 * 'undefined'.
	 * @param {string} str
	 * @param {string} encoding
	 * @returns {Array}
	 */
	encode.MACSTRING = function(str, encoding) {
	    var table = getMacEncodingTable(encoding);
	    if (table === undefined) {
	        return undefined;
	    }

	    var result = [];
	    for (var i = 0; i < str.length; i++) {
	        var c = str.charCodeAt(i);

	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
	        // mapped to U+0000..U+007F; we only need to look up the others.
	        if (c >= 0x80) {
	            c = table[c];
	            if (c === undefined) {
	                // str contains a Unicode character that cannot be encoded
	                // in the requested encoding.
	                return undefined;
	            }
	        }
	        result[i] = c;
	        // result.push(c);
	    }

	    return result;
	};

	/**
	 * @param {string} str
	 * @param {string} encoding
	 * @returns {number}
	 */
	sizeOf.MACSTRING = function(str, encoding) {
	    var b = encode.MACSTRING(str, encoding);
	    if (b !== undefined) {
	        return b.length;
	    } else {
	        return 0;
	    }
	};

	// Helper for encode.VARDELTAS
	function isByteEncodable(value) {
	    return value >= -128 && value <= 127;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
	        ++pos;
	        ++runLength;
	    }
	    result.push(0x80 | (runLength - 1));
	    return pos;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsBytes(deltas, offset, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    var pos = offset;
	    while (pos < numDeltas && runLength < 64) {
	        var value = deltas[pos];
	        if (!isByteEncodable(value)) {
	            break;
	        }

	        // Within a byte-encoded run of deltas, a single zero is best
	        // stored literally as 0x00 value. However, if we have two or
	        // more zeroes in a sequence, it is better to start a new run.
	        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
	        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
	        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
	        // when starting a new run.
	        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
	            break;
	        }

	        ++pos;
	        ++runLength;
	    }
	    result.push(runLength - 1);
	    for (var i = offset; i < pos; ++i) {
	        result.push((deltas[i] + 256) & 0xff);
	    }
	    return pos;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsWords(deltas, offset, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    var pos = offset;
	    while (pos < numDeltas && runLength < 64) {
	        var value = deltas[pos];

	        // Within a word-encoded run of deltas, it is easiest to start
	        // a new run (with a different encoding) whenever we encounter
	        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
	        // needs 7 bytes when storing the zero inside the current run
	        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
	        // new run (40 66 66 80 40 77 77).
	        if (value === 0) {
	            break;
	        }

	        // Within a word-encoded run of deltas, a single value in the
	        // range (-128..127) should be encoded within the current run
	        // because it is more compact. For example, the sequence
	        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
	        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
	        // a new run (40 66 66 00 02 40 77 77).
	        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
	            break;
	        }

	        ++pos;
	        ++runLength;
	    }
	    result.push(0x40 | (runLength - 1));
	    for (var i = offset; i < pos; ++i) {
	        var val = deltas[i];
	        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
	    }
	    return pos;
	}

	/**
	 * Encode a list of variation adjustment deltas.
	 *
	 * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
	 * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
	 * when generating instances of variation fonts.
	 *
	 * @see https://www.microsoft.com/typography/otspec/gvar.htm
	 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
	 * @param {Array}
	 * @return {Array}
	 */
	encode.VARDELTAS = function(deltas) {
	    var pos = 0;
	    var result = [];
	    while (pos < deltas.length) {
	        var value = deltas[pos];
	        if (value === 0) {
	            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
	        } else if (value >= -128 && value <= 127) {
	            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
	        } else {
	            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
	        }
	    }
	    return result;
	};

	// Convert a list of values to a CFF INDEX structure.
	// The values should be objects containing name / type / value.
	/**
	 * @param {Array} l
	 * @returns {Array}
	 */
	encode.INDEX = function(l) {
	    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
	    //    i, v;
	    // Because we have to know which data type to use to encode the offsets,
	    // we have to go through the values twice: once to encode the data and
	    // calculate the offsets, then again to encode the offsets using the fitting data type.
	    var offset = 1; // First offset is always 1.
	    var offsets = [offset];
	    var data = [];
	    for (var i = 0; i < l.length; i += 1) {
	        var v = encode.OBJECT(l[i]);
	        Array.prototype.push.apply(data, v);
	        offset += v.length;
	        offsets.push(offset);
	    }

	    if (data.length === 0) {
	        return [0, 0];
	    }

	    var encodedOffsets = [];
	    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
	    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
	    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
	        var encodedOffset = offsetEncoder(offsets[i$1]);
	        Array.prototype.push.apply(encodedOffsets, encodedOffset);
	    }

	    return Array.prototype.concat(encode.Card16(l.length),
	                           encode.OffSize(offSize),
	                           encodedOffsets,
	                           data);
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.INDEX = function(v) {
	    return encode.INDEX(v).length;
	};

	/**
	 * Convert an object to a CFF DICT structure.
	 * The keys should be numeric.
	 * The values should be objects containing name / type / value.
	 * @param {Object} m
	 * @returns {Array}
	 */
	encode.DICT = function(m) {
	    var d = [];
	    var keys = Object.keys(m);
	    var length = keys.length;

	    for (var i = 0; i < length; i += 1) {
	        // Object.keys() return string keys, but our keys are always numeric.
	        var k = parseInt(keys[i], 0);
	        var v = m[k];
	        // Value comes before the key.
	        d = d.concat(encode.OPERAND(v.value, v.type));
	        d = d.concat(encode.OPERATOR(k));
	    }

	    return d;
	};

	/**
	 * @param {Object}
	 * @returns {number}
	 */
	sizeOf.DICT = function(m) {
	    return encode.DICT(m).length;
	};

	/**
	 * @param {number}
	 * @returns {Array}
	 */
	encode.OPERATOR = function(v) {
	    if (v < 1200) {
	        return [v];
	    } else {
	        return [12, v - 1200];
	    }
	};

	/**
	 * @param {Array} v
	 * @param {string}
	 * @returns {Array}
	 */
	encode.OPERAND = function(v, type) {
	    var d = [];
	    if (Array.isArray(type)) {
	        for (var i = 0; i < type.length; i += 1) {
	            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
	            d = d.concat(encode.OPERAND(v[i], type[i]));
	        }
	    } else {
	        if (type === 'SID') {
	            d = d.concat(encode.NUMBER(v));
	        } else if (type === 'offset') {
	            // We make it easy for ourselves and always encode offsets as
	            // 4 bytes. This makes offset calculation for the top dict easier.
	            d = d.concat(encode.NUMBER32(v));
	        } else if (type === 'number') {
	            d = d.concat(encode.NUMBER(v));
	        } else if (type === 'real') {
	            d = d.concat(encode.REAL(v));
	        } else {
	            throw new Error('Unknown operand type ' + type);
	            // FIXME Add support for booleans
	        }
	    }

	    return d;
	};

	encode.OP = encode.BYTE;
	sizeOf.OP = sizeOf.BYTE;

	// memoize charstring encoding using WeakMap if available
	var wmm = typeof WeakMap === 'function' && new WeakMap();

	/**
	 * Convert a list of CharString operations to bytes.
	 * @param {Array}
	 * @returns {Array}
	 */
	encode.CHARSTRING = function(ops) {
	    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
	    if (wmm) {
	        var cachedValue = wmm.get(ops);
	        if (cachedValue !== undefined) {
	            return cachedValue;
	        }
	    }

	    var d = [];
	    var length = ops.length;

	    for (var i = 0; i < length; i += 1) {
	        var op = ops[i];
	        d = d.concat(encode[op.type](op.value));
	    }

	    if (wmm) {
	        wmm.set(ops, d);
	    }

	    return d;
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.CHARSTRING = function(ops) {
	    return encode.CHARSTRING(ops).length;
	};

	// Utility functions ////////////////////////////////////////////////////////

	/**
	 * Convert an object containing name / type / value to bytes.
	 * @param {Object}
	 * @returns {Array}
	 */
	encode.OBJECT = function(v) {
	    var encodingFunction = encode[v.type];
	    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
	    return encodingFunction(v.value);
	};

	/**
	 * @param {Object}
	 * @returns {number}
	 */
	sizeOf.OBJECT = function(v) {
	    var sizeOfFunction = sizeOf[v.type];
	    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
	    return sizeOfFunction(v.value);
	};

	/**
	 * Convert a table object to bytes.
	 * A table contains a list of fields containing the metadata (name, type and default value).
	 * The table itself has the field values set as attributes.
	 * @param {opentype.Table}
	 * @returns {Array}
	 */
	encode.TABLE = function(table) {
	    var d = [];
	    var length = table.fields.length;
	    var subtables = [];
	    var subtableOffsets = [];

	    for (var i = 0; i < length; i += 1) {
	        var field = table.fields[i];
	        var encodingFunction = encode[field.type];
	        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
	        var value = table[field.name];
	        if (value === undefined) {
	            value = field.value;
	        }

	        var bytes = encodingFunction(value);

	        if (field.type === 'TABLE') {
	            subtableOffsets.push(d.length);
	            d = d.concat([0, 0]);
	            subtables.push(bytes);
	        } else {
	            d = d.concat(bytes);
	        }
	    }

	    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
	        var o = subtableOffsets[i$1];
	        var offset = d.length;
	        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
	        d[o] = offset >> 8;
	        d[o + 1] = offset & 0xff;
	        d = d.concat(subtables[i$1]);
	    }

	    return d;
	};

	/**
	 * @param {opentype.Table}
	 * @returns {number}
	 */
	sizeOf.TABLE = function(table) {
	    var numBytes = 0;
	    var length = table.fields.length;

	    for (var i = 0; i < length; i += 1) {
	        var field = table.fields[i];
	        var sizeOfFunction = sizeOf[field.type];
	        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
	        var value = table[field.name];
	        if (value === undefined) {
	            value = field.value;
	        }

	        numBytes += sizeOfFunction(value);

	        // Subtables take 2 more bytes for offsets.
	        if (field.type === 'TABLE') {
	            numBytes += 2;
	        }
	    }

	    return numBytes;
	};

	encode.RECORD = encode.TABLE;
	sizeOf.RECORD = sizeOf.TABLE;

	// Merge in a list of bytes.
	encode.LITERAL = function(v) {
	    return v;
	};

	sizeOf.LITERAL = function(v) {
	    return v.length;
	};

	// Table metadata

	/**
	 * @exports opentype.Table
	 * @class
	 * @param {string} tableName
	 * @param {Array} fields
	 * @param {Object} options
	 * @constructor
	 */
	function Table(tableName, fields, options) {
	    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,
	    // as this will result in wrong encoding order of the coverage data on serialization to bytes.
	    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.
	    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {
	        for (var i = 0; i < fields.length; i += 1) {
	            var field = fields[i];
	            this[field.name] = field.value;
	        }
	    }

	    this.tableName = tableName;
	    this.fields = fields;
	    if (options) {
	        var optionKeys = Object.keys(options);
	        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
	            var k = optionKeys[i$1];
	            var v = options[k];
	            if (this[k] !== undefined) {
	                this[k] = v;
	            }
	        }
	    }
	}

	/**
	 * Encodes the table and returns an array of bytes
	 * @return {Array}
	 */
	Table.prototype.encode = function() {
	    return encode.TABLE(this);
	};

	/**
	 * Get the size of the table.
	 * @return {number}
	 */
	Table.prototype.sizeOf = function() {
	    return sizeOf.TABLE(this);
	};

	/**
	 * @private
	 */
	function ushortList(itemName, list, count) {
	    if (count === undefined) {
	        count = list.length;
	    }
	    var fields = new Array(list.length + 1);
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < list.length; i++) {
	        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
	    }
	    return fields;
	}

	/**
	 * @private
	 */
	function tableList(itemName, records, itemCallback) {
	    var count = records.length;
	    var fields = new Array(count + 1);
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < count; i++) {
	        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
	    }
	    return fields;
	}

	/**
	 * @private
	 */
	function recordList(itemName, records, itemCallback) {
	    var count = records.length;
	    var fields = [];
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < count; i++) {
	        fields = fields.concat(itemCallback(records[i], i));
	    }
	    return fields;
	}

	// Common Layout Tables

	/**
	 * @exports opentype.Coverage
	 * @class
	 * @param {opentype.Table}
	 * @constructor
	 * @extends opentype.Table
	 */
	function Coverage(coverageTable) {
	    if (coverageTable.format === 1) {
	        Table.call(this, 'coverageTable',
	            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
	            .concat(ushortList('glyph', coverageTable.glyphs))
	        );
	    } else if (coverageTable.format === 2) {
	        Table.call(this, 'coverageTable',
	            [{name: 'coverageFormat', type: 'USHORT', value: 2}]
	            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {
	                return [
	                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},
	                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},
	                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];
	            }))
	        );
	    } else {
	        check.assert(false, 'Coverage format must be 1 or 2.');
	    }
	}
	Coverage.prototype = Object.create(Table.prototype);
	Coverage.prototype.constructor = Coverage;

	function ScriptList(scriptListTable) {
	    Table.call(this, 'scriptListTable',
	        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
	            var script = scriptRecord.script;
	            var defaultLangSys = script.defaultLangSys;
	            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
	            return [
	                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
	                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
	                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
	                        {name: 'lookupOrder', type: 'USHORT', value: 0},
	                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
	                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
	                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
	                        var langSys = langSysRecord.langSys;
	                        return [
	                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
	                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
	                                {name: 'lookupOrder', type: 'USHORT', value: 0},
	                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
	                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
	                        ];
	                    })))}
	            ];
	        })
	    );
	}
	ScriptList.prototype = Object.create(Table.prototype);
	ScriptList.prototype.constructor = ScriptList;

	/**
	 * @exports opentype.FeatureList
	 * @class
	 * @param {opentype.Table}
	 * @constructor
	 * @extends opentype.Table
	 */
	function FeatureList(featureListTable) {
	    Table.call(this, 'featureListTable',
	        recordList('featureRecord', featureListTable, function(featureRecord, i) {
	            var feature = featureRecord.feature;
	            return [
	                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
	                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
	                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
	            ];
	        })
	    );
	}
	FeatureList.prototype = Object.create(Table.prototype);
	FeatureList.prototype.constructor = FeatureList;

	/**
	 * @exports opentype.LookupList
	 * @class
	 * @param {opentype.Table}
	 * @param {Object}
	 * @constructor
	 * @extends opentype.Table
	 */
	function LookupList(lookupListTable, subtableMakers) {
	    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
	        var subtableCallback = subtableMakers[lookupTable.lookupType];
	        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
	        return new Table('lookupTable', [
	            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
	            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
	        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
	    }));
	}
	LookupList.prototype = Object.create(Table.prototype);
	LookupList.prototype.constructor = LookupList;

	// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
	// Don't use offsets inside Records (probable bug), only in Tables.
	var table = {
	    Table: Table,
	    Record: Table,
	    Coverage: Coverage,
	    ScriptList: ScriptList,
	    FeatureList: FeatureList,
	    LookupList: LookupList,
	    ushortList: ushortList,
	    tableList: tableList,
	    recordList: recordList,
	};

	// Parsing utility functions

	// Retrieve an unsigned byte from the DataView.
	function getByte(dataView, offset) {
	    return dataView.getUint8(offset);
	}

	// Retrieve an unsigned 16-bit short from the DataView.
	// The value is stored in big endian.
	function getUShort(dataView, offset) {
	    return dataView.getUint16(offset, false);
	}

	// Retrieve a signed 16-bit short from the DataView.
	// The value is stored in big endian.
	function getShort(dataView, offset) {
	    return dataView.getInt16(offset, false);
	}

	// Retrieve an unsigned 32-bit long from the DataView.
	// The value is stored in big endian.
	function getULong(dataView, offset) {
	    return dataView.getUint32(offset, false);
	}

	// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
	// The value is stored in big endian.
	function getFixed(dataView, offset) {
	    var decimal = dataView.getInt16(offset, false);
	    var fraction = dataView.getUint16(offset + 2, false);
	    return decimal + fraction / 65535;
	}

	// Retrieve a 4-character tag from the DataView.
	// Tags are used to identify tables.
	function getTag(dataView, offset) {
	    var tag = '';
	    for (var i = offset; i < offset + 4; i += 1) {
	        tag += String.fromCharCode(dataView.getInt8(i));
	    }

	    return tag;
	}

	// Retrieve an offset from the DataView.
	// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
	function getOffset(dataView, offset, offSize) {
	    var v = 0;
	    for (var i = 0; i < offSize; i += 1) {
	        v <<= 8;
	        v += dataView.getUint8(offset + i);
	    }

	    return v;
	}

	// Retrieve a number of bytes from start offset to the end offset from the DataView.
	function getBytes(dataView, startOffset, endOffset) {
	    var bytes = [];
	    for (var i = startOffset; i < endOffset; i += 1) {
	        bytes.push(dataView.getUint8(i));
	    }

	    return bytes;
	}

	// Convert the list of bytes to a string.
	function bytesToString(bytes) {
	    var s = '';
	    for (var i = 0; i < bytes.length; i += 1) {
	        s += String.fromCharCode(bytes[i]);
	    }

	    return s;
	}

	var typeOffsets = {
	    byte: 1,
	    uShort: 2,
	    short: 2,
	    uLong: 4,
	    fixed: 4,
	    longDateTime: 8,
	    tag: 4
	};

	// A stateful parser that changes the offset whenever a value is retrieved.
	// The data is a DataView.
	function Parser(data, offset) {
	    this.data = data;
	    this.offset = offset;
	    this.relativeOffset = 0;
	}

	Parser.prototype.parseByte = function() {
	    var v = this.data.getUint8(this.offset + this.relativeOffset);
	    this.relativeOffset += 1;
	    return v;
	};

	Parser.prototype.parseChar = function() {
	    var v = this.data.getInt8(this.offset + this.relativeOffset);
	    this.relativeOffset += 1;
	    return v;
	};

	Parser.prototype.parseCard8 = Parser.prototype.parseByte;

	Parser.prototype.parseUShort = function() {
	    var v = this.data.getUint16(this.offset + this.relativeOffset);
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
	Parser.prototype.parseSID = Parser.prototype.parseUShort;
	Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

	Parser.prototype.parseShort = function() {
	    var v = this.data.getInt16(this.offset + this.relativeOffset);
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseF2Dot14 = function() {
	    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseULong = function() {
	    var v = getULong(this.data, this.offset + this.relativeOffset);
	    this.relativeOffset += 4;
	    return v;
	};

	Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

	Parser.prototype.parseFixed = function() {
	    var v = getFixed(this.data, this.offset + this.relativeOffset);
	    this.relativeOffset += 4;
	    return v;
	};

	Parser.prototype.parseString = function(length) {
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    var string = '';
	    this.relativeOffset += length;
	    for (var i = 0; i < length; i++) {
	        string += String.fromCharCode(dataView.getUint8(offset + i));
	    }

	    return string;
	};

	Parser.prototype.parseTag = function() {
	    return this.parseString(4);
	};

	// LONGDATETIME is a 64-bit integer.
	// JavaScript and unix timestamps traditionally use 32 bits, so we
	// only take the last 32 bits.
	// + Since until 2038 those bits will be filled by zeros we can ignore them.
	Parser.prototype.parseLongDateTime = function() {
	    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
	    // Subtract seconds between 01/01/1904 and 01/01/1970
	    // to convert Apple Mac timestamp to Standard Unix timestamp
	    v -= 2082844800;
	    this.relativeOffset += 8;
	    return v;
	};

	Parser.prototype.parseVersion = function(minorBase) {
	    var major = getUShort(this.data, this.offset + this.relativeOffset);

	    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
	    // Default returns the correct number if minor = 0xN000 where N is 0-9
	    // Set minorBase to 1 for tables that use minor = N where N is 0-9
	    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
	    this.relativeOffset += 4;
	    if (minorBase === undefined) { minorBase = 0x1000; }
	    return major + minor / minorBase / 10;
	};

	Parser.prototype.skip = function(type, amount) {
	    if (amount === undefined) {
	        amount = 1;
	    }

	    this.relativeOffset += typeOffsets[type] * amount;
	};

	///// Parsing lists and records ///////////////////////////////

	// Parse a list of 32 bit unsigned integers.
	Parser.prototype.parseULongList = function(count) {
	    if (count === undefined) { count = this.parseULong(); }
	    var offsets = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        offsets[i] = dataView.getUint32(offset);
	        offset += 4;
	    }

	    this.relativeOffset += count * 4;
	    return offsets;
	};

	// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
	// or provided as an argument.
	Parser.prototype.parseOffset16List =
	Parser.prototype.parseUShortList = function(count) {
	    if (count === undefined) { count = this.parseUShort(); }
	    var offsets = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        offsets[i] = dataView.getUint16(offset);
	        offset += 2;
	    }

	    this.relativeOffset += count * 2;
	    return offsets;
	};

	// Parses a list of 16 bit signed integers.
	Parser.prototype.parseShortList = function(count) {
	    var list = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        list[i] = dataView.getInt16(offset);
	        offset += 2;
	    }

	    this.relativeOffset += count * 2;
	    return list;
	};

	// Parses a list of bytes.
	Parser.prototype.parseByteList = function(count) {
	    var list = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        list[i] = dataView.getUint8(offset++);
	    }

	    this.relativeOffset += count;
	    return list;
	};

	/**
	 * Parse a list of items.
	 * Record count is optional, if omitted it is read from the stream.
	 * itemCallback is one of the Parser methods.
	 */
	Parser.prototype.parseList = function(count, itemCallback) {
	    if (!itemCallback) {
	        itemCallback = count;
	        count = this.parseUShort();
	    }
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        list[i] = itemCallback.call(this);
	    }
	    return list;
	};

	Parser.prototype.parseList32 = function(count, itemCallback) {
	    if (!itemCallback) {
	        itemCallback = count;
	        count = this.parseULong();
	    }
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        list[i] = itemCallback.call(this);
	    }
	    return list;
	};

	/**
	 * Parse a list of records.
	 * Record count is optional, if omitted it is read from the stream.
	 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
	 */
	Parser.prototype.parseRecordList = function(count, recordDescription) {
	    // If the count argument is absent, read it in the stream.
	    if (!recordDescription) {
	        recordDescription = count;
	        count = this.parseUShort();
	    }
	    var records = new Array(count);
	    var fields = Object.keys(recordDescription);
	    for (var i = 0; i < count; i++) {
	        var rec = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = recordDescription[fieldName];
	            rec[fieldName] = fieldType.call(this);
	        }
	        records[i] = rec;
	    }
	    return records;
	};

	Parser.prototype.parseRecordList32 = function(count, recordDescription) {
	    // If the count argument is absent, read it in the stream.
	    if (!recordDescription) {
	        recordDescription = count;
	        count = this.parseULong();
	    }
	    var records = new Array(count);
	    var fields = Object.keys(recordDescription);
	    for (var i = 0; i < count; i++) {
	        var rec = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = recordDescription[fieldName];
	            rec[fieldName] = fieldType.call(this);
	        }
	        records[i] = rec;
	    }
	    return records;
	};

	// Parse a data structure into an object
	// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
	Parser.prototype.parseStruct = function(description) {
	    if (typeof description === 'function') {
	        return description.call(this);
	    } else {
	        var fields = Object.keys(description);
	        var struct = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = description[fieldName];
	            struct[fieldName] = fieldType.call(this);
	        }
	        return struct;
	    }
	};

	/**
	 * Parse a GPOS valueRecord
	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
	 * valueFormat is optional, if omitted it is read from the stream.
	 */
	Parser.prototype.parseValueRecord = function(valueFormat) {
	    if (valueFormat === undefined) {
	        valueFormat = this.parseUShort();
	    }
	    if (valueFormat === 0) {
	        // valueFormat2 in kerning pairs is most often 0
	        // in this case return undefined instead of an empty object, to save space
	        return;
	    }
	    var valueRecord = {};

	    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
	    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
	    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
	    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

	    // Device table (non-variable font) / VariationIndex table (variable font) not supported
	    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
	    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

	    return valueRecord;
	};

	/**
	 * Parse a list of GPOS valueRecords
	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
	 * valueFormat and valueCount are read from the stream.
	 */
	Parser.prototype.parseValueRecordList = function() {
	    var valueFormat = this.parseUShort();
	    var valueCount = this.parseUShort();
	    var values = new Array(valueCount);
	    for (var i = 0; i < valueCount; i++) {
	        values[i] = this.parseValueRecord(valueFormat);
	    }
	    return values;
	};

	Parser.prototype.parsePointer = function(description) {
	    var structOffset = this.parseOffset16();
	    if (structOffset > 0) {
	        // NULL offset => return undefined
	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
	    }
	    return undefined;
	};

	Parser.prototype.parsePointer32 = function(description) {
	    var structOffset = this.parseOffset32();
	    if (structOffset > 0) {
	        // NULL offset => return undefined
	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
	    }
	    return undefined;
	};

	/**
	 * Parse a list of offsets to lists of 16-bit integers,
	 * or a list of offsets to lists of offsets to any kind of items.
	 * If itemCallback is not provided, a list of list of UShort is assumed.
	 * If provided, itemCallback is called on each item and must parse the item.
	 * See examples in tables/gsub.js
	 */
	Parser.prototype.parseListOfLists = function(itemCallback) {
	    var offsets = this.parseOffset16List();
	    var count = offsets.length;
	    var relativeOffset = this.relativeOffset;
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        var start = offsets[i];
	        if (start === 0) {
	            // NULL offset
	            // Add i as owned property to list. Convenient with assert.
	            list[i] = undefined;
	            continue;
	        }
	        this.relativeOffset = start;
	        if (itemCallback) {
	            var subOffsets = this.parseOffset16List();
	            var subList = new Array(subOffsets.length);
	            for (var j = 0; j < subOffsets.length; j++) {
	                this.relativeOffset = start + subOffsets[j];
	                subList[j] = itemCallback.call(this);
	            }
	            list[i] = subList;
	        } else {
	            list[i] = this.parseUShortList();
	        }
	    }
	    this.relativeOffset = relativeOffset;
	    return list;
	};

	///// Complex tables parsing //////////////////////////////////

	// Parse a coverage table in a GSUB, GPOS or GDEF table.
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
	// parser.offset must point to the start of the table containing the coverage.
	Parser.prototype.parseCoverage = function() {
	    var startOffset = this.offset + this.relativeOffset;
	    var format = this.parseUShort();
	    var count = this.parseUShort();
	    if (format === 1) {
	        return {
	            format: 1,
	            glyphs: this.parseUShortList(count)
	        };
	    } else if (format === 2) {
	        var ranges = new Array(count);
	        for (var i = 0; i < count; i++) {
	            ranges[i] = {
	                start: this.parseUShort(),
	                end: this.parseUShort(),
	                index: this.parseUShort()
	            };
	        }
	        return {
	            format: 2,
	            ranges: ranges
	        };
	    }
	    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
	};

	// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
	Parser.prototype.parseClassDef = function() {
	    var startOffset = this.offset + this.relativeOffset;
	    var format = this.parseUShort();
	    if (format === 1) {
	        return {
	            format: 1,
	            startGlyph: this.parseUShort(),
	            classes: this.parseUShortList()
	        };
	    } else if (format === 2) {
	        return {
	            format: 2,
	            ranges: this.parseRecordList({
	                start: Parser.uShort,
	                end: Parser.uShort,
	                classId: Parser.uShort
	            })
	        };
	    }
	    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
	};

	///// Static methods ///////////////////////////////////
	// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

	Parser.list = function(count, itemCallback) {
	    return function() {
	        return this.parseList(count, itemCallback);
	    };
	};

	Parser.list32 = function(count, itemCallback) {
	    return function() {
	        return this.parseList32(count, itemCallback);
	    };
	};

	Parser.recordList = function(count, recordDescription) {
	    return function() {
	        return this.parseRecordList(count, recordDescription);
	    };
	};

	Parser.recordList32 = function(count, recordDescription) {
	    return function() {
	        return this.parseRecordList32(count, recordDescription);
	    };
	};

	Parser.pointer = function(description) {
	    return function() {
	        return this.parsePointer(description);
	    };
	};

	Parser.pointer32 = function(description) {
	    return function() {
	        return this.parsePointer32(description);
	    };
	};

	Parser.tag = Parser.prototype.parseTag;
	Parser.byte = Parser.prototype.parseByte;
	Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
	Parser.uShortList = Parser.prototype.parseUShortList;
	Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
	Parser.uLongList = Parser.prototype.parseULongList;
	Parser.struct = Parser.prototype.parseStruct;
	Parser.coverage = Parser.prototype.parseCoverage;
	Parser.classDef = Parser.prototype.parseClassDef;

	///// Script, Feature, Lookup lists ///////////////////////////////////////////////
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

	var langSysTable = {
	    reserved: Parser.uShort,
	    reqFeatureIndex: Parser.uShort,
	    featureIndexes: Parser.uShortList
	};

	Parser.prototype.parseScriptList = function() {
	    return this.parsePointer(Parser.recordList({
	        tag: Parser.tag,
	        script: Parser.pointer({
	            defaultLangSys: Parser.pointer(langSysTable),
	            langSysRecords: Parser.recordList({
	                tag: Parser.tag,
	                langSys: Parser.pointer(langSysTable)
	            })
	        })
	    })) || [];
	};

	Parser.prototype.parseFeatureList = function() {
	    return this.parsePointer(Parser.recordList({
	        tag: Parser.tag,
	        feature: Parser.pointer({
	            featureParams: Parser.offset16,
	            lookupListIndexes: Parser.uShortList
	        })
	    })) || [];
	};

	Parser.prototype.parseLookupList = function(lookupTableParsers) {
	    return this.parsePointer(Parser.list(Parser.pointer(function() {
	        var lookupType = this.parseUShort();
	        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
	        var lookupFlag = this.parseUShort();
	        var useMarkFilteringSet = lookupFlag & 0x10;
	        return {
	            lookupType: lookupType,
	            lookupFlag: lookupFlag,
	            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
	            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
	        };
	    }))) || [];
	};

	Parser.prototype.parseFeatureVariationsList = function() {
	    return this.parsePointer32(function() {
	        var majorVersion = this.parseUShort();
	        var minorVersion = this.parseUShort();
	        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
	        var featureVariations = this.parseRecordList32({
	            conditionSetOffset: Parser.offset32,
	            featureTableSubstitutionOffset: Parser.offset32
	        });
	        return featureVariations;
	    }) || [];
	};

	var parse = {
	    getByte: getByte,
	    getCard8: getByte,
	    getUShort: getUShort,
	    getCard16: getUShort,
	    getShort: getShort,
	    getULong: getULong,
	    getFixed: getFixed,
	    getTag: getTag,
	    getOffset: getOffset,
	    getBytes: getBytes,
	    bytesToString: bytesToString,
	    Parser: Parser,
	};

	// The `cmap` table stores the mappings from characters to glyphs.

	function parseCmapTableFormat12(cmap, p) {
	    //Skip reserved.
	    p.parseUShort();

	    // Length in bytes of the sub-tables.
	    cmap.length = p.parseULong();
	    cmap.language = p.parseULong();

	    var groupCount;
	    cmap.groupCount = groupCount = p.parseULong();
	    cmap.glyphIndexMap = {};

	    for (var i = 0; i < groupCount; i += 1) {
	        var startCharCode = p.parseULong();
	        var endCharCode = p.parseULong();
	        var startGlyphId = p.parseULong();

	        for (var c = startCharCode; c <= endCharCode; c += 1) {
	            cmap.glyphIndexMap[c] = startGlyphId;
	            startGlyphId++;
	        }
	    }
	}

	function parseCmapTableFormat4(cmap, p, data, start, offset) {
	    // Length in bytes of the sub-tables.
	    cmap.length = p.parseUShort();
	    cmap.language = p.parseUShort();

	    // segCount is stored x 2.
	    var segCount;
	    cmap.segCount = segCount = p.parseUShort() >> 1;

	    // Skip searchRange, entrySelector, rangeShift.
	    p.skip('uShort', 3);

	    // The "unrolled" mapping from character codes to glyph indices.
	    cmap.glyphIndexMap = {};
	    var endCountParser = new parse.Parser(data, start + offset + 14);
	    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
	    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
	    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
	    var glyphIndexOffset = start + offset + 16 + segCount * 8;
	    for (var i = 0; i < segCount - 1; i += 1) {
	        var glyphIndex = (void 0);
	        var endCount = endCountParser.parseUShort();
	        var startCount = startCountParser.parseUShort();
	        var idDelta = idDeltaParser.parseShort();
	        var idRangeOffset = idRangeOffsetParser.parseUShort();
	        for (var c = startCount; c <= endCount; c += 1) {
	            if (idRangeOffset !== 0) {
	                // The idRangeOffset is relative to the current position in the idRangeOffset array.
	                // Take the current offset in the idRangeOffset array.
	                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

	                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
	                glyphIndexOffset += idRangeOffset;

	                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
	                glyphIndexOffset += (c - startCount) * 2;
	                glyphIndex = parse.getUShort(data, glyphIndexOffset);
	                if (glyphIndex !== 0) {
	                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
	                }
	            } else {
	                glyphIndex = (c + idDelta) & 0xFFFF;
	            }

	            cmap.glyphIndexMap[c] = glyphIndex;
	        }
	    }
	}

	// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
	// There are many available formats, but we only support the Windows format 4 and 12.
	// This function returns a `CmapEncoding` object or null if no supported format could be found.
	function parseCmapTable(data, start) {
	    var cmap = {};
	    cmap.version = parse.getUShort(data, start);
	    check.argument(cmap.version === 0, 'cmap table version should be 0.');

	    // The cmap table can contain many sub-tables, each with their own format.
	    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
	    cmap.numTables = parse.getUShort(data, start + 2);
	    var offset = -1;
	    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
	        var platformId = parse.getUShort(data, start + 4 + (i * 8));
	        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
	        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
	            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
	            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
	            break;
	        }
	    }

	    if (offset === -1) {
	        // There is no cmap table in the font that we support.
	        throw new Error('No valid cmap sub-tables found.');
	    }

	    var p = new parse.Parser(data, start + offset);
	    cmap.format = p.parseUShort();

	    if (cmap.format === 12) {
	        parseCmapTableFormat12(cmap, p);
	    } else if (cmap.format === 4) {
	        parseCmapTableFormat4(cmap, p, data, start, offset);
	    } else {
	        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
	    }

	    return cmap;
	}

	function addSegment(t, code, glyphIndex) {
	    t.segments.push({
	        end: code,
	        start: code,
	        delta: -(code - glyphIndex),
	        offset: 0,
	        glyphIndex: glyphIndex
	    });
	}

	function addTerminatorSegment(t) {
	    t.segments.push({
	        end: 0xFFFF,
	        start: 0xFFFF,
	        delta: 1,
	        offset: 0
	    });
	}

	// Make cmap table, format 4 by default, 12 if needed only
	function makeCmapTable(glyphs) {
	    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
	    var isPlan0Only = true;
	    var i;

	    // Check if we need to add cmap format 12 or if format 4 only is fine
	    for (i = glyphs.length - 1; i > 0; i -= 1) {
	        var g = glyphs.get(i);
	        if (g.unicode > 65535) {
	            console.log('Adding CMAP format 12 (needed!)');
	            isPlan0Only = false;
	            break;
	        }
	    }

	    var cmapTable = [
	        {name: 'version', type: 'USHORT', value: 0},
	        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

	        // CMAP 4 header
	        {name: 'platformID', type: 'USHORT', value: 3},
	        {name: 'encodingID', type: 'USHORT', value: 1},
	        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
	    ];

	    if (!isPlan0Only)
	        { cmapTable = cmapTable.concat([
	            // CMAP 12 header
	            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
	            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
	            {name: 'cmap12Offset', type: 'ULONG', value: 0}
	        ]); }

	    cmapTable = cmapTable.concat([
	        // CMAP 4 Subtable
	        {name: 'format', type: 'USHORT', value: 4},
	        {name: 'cmap4Length', type: 'USHORT', value: 0},
	        {name: 'language', type: 'USHORT', value: 0},
	        {name: 'segCountX2', type: 'USHORT', value: 0},
	        {name: 'searchRange', type: 'USHORT', value: 0},
	        {name: 'entrySelector', type: 'USHORT', value: 0},
	        {name: 'rangeShift', type: 'USHORT', value: 0}
	    ]);

	    var t = new table.Table('cmap', cmapTable);

	    t.segments = [];
	    for (i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        for (var j = 0; j < glyph.unicodes.length; j += 1) {
	            addSegment(t, glyph.unicodes[j], i);
	        }

	        t.segments = t.segments.sort(function (a, b) {
	            return a.start - b.start;
	        });
	    }

	    addTerminatorSegment(t);

	    var segCount = t.segments.length;
	    var segCountToRemove = 0;

	    // CMAP 4
	    // Set up parallel segment arrays.
	    var endCounts = [];
	    var startCounts = [];
	    var idDeltas = [];
	    var idRangeOffsets = [];
	    var glyphIds = [];

	    // CMAP 12
	    var cmap12Groups = [];

	    // Reminder this loop is not following the specification at 100%
	    // The specification -> find suites of characters and make a group
	    // Here we're doing one group for each letter
	    // Doing as the spec can save 8 times (or more) space
	    for (i = 0; i < segCount; i += 1) {
	        var segment = t.segments[i];

	        // CMAP 4
	        if (segment.end <= 65535 && segment.start <= 65535) {
	            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
	            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
	            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
	            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
	            if (segment.glyphId !== undefined) {
	                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
	            }
	        } else {
	            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
	            segCountToRemove += 1;
	        }

	        // CMAP 12
	        // Skip Terminator Segment
	        if (!isPlan0Only && segment.glyphIndex !== undefined) {
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
	        }
	    }

	    // CMAP 4 Subtable
	    t.segCountX2 = (segCount - segCountToRemove) * 2;
	    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
	    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
	    t.rangeShift = t.segCountX2 - t.searchRange;

	    t.fields = t.fields.concat(endCounts);
	    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
	    t.fields = t.fields.concat(startCounts);
	    t.fields = t.fields.concat(idDeltas);
	    t.fields = t.fields.concat(idRangeOffsets);
	    t.fields = t.fields.concat(glyphIds);

	    t.cmap4Length = 14 + // Subtable header
	        endCounts.length * 2 +
	        2 + // reservedPad
	        startCounts.length * 2 +
	        idDeltas.length * 2 +
	        idRangeOffsets.length * 2 +
	        glyphIds.length * 2;

	    if (!isPlan0Only) {
	        // CMAP 12 Subtable
	        var cmap12Length = 16 + // Subtable header
	            cmap12Groups.length * 4;

	        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
	        t.fields = t.fields.concat([
	            {name: 'cmap12Format', type: 'USHORT', value: 12},
	            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
	            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
	            {name: 'cmap12Language', type: 'ULONG', value: 0},
	            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
	        ]);

	        t.fields = t.fields.concat(cmap12Groups);
	    }

	    return t;
	}

	var cmap = { parse: parseCmapTable, make: makeCmapTable };

	// Glyph encoding

	var cffStandardStrings = [
	    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
	    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
	    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
	    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
	    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
	    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
	    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
	    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
	    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
	    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
	    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
	    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
	    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
	    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
	    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
	    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
	    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
	    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
	    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
	    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
	    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
	    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
	    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
	    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
	    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
	    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
	    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
	    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
	    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
	    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
	    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
	    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

	var cffStandardEncoding = [
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
	    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
	    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
	    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
	    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
	    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
	    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
	    'lslash', 'oslash', 'oe', 'germandbls'];

	var cffExpertEncoding = [
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
	    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
	    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
	    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
	    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
	    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
	    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
	    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
	    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
	    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
	    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
	    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
	    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
	    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
	    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
	    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
	    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
	    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

	var standardNames = [
	    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
	    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
	    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
	    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
	    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
	    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
	    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
	    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
	    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
	    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
	    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
	    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
	    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
	    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
	    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
	    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
	    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
	    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
	    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
	    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
	    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
	    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
	    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
	    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
	    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

	/**
	 * This is the encoding used for fonts created from scratch.
	 * It loops through all glyphs and finds the appropriate unicode value.
	 * Since it's linear time, other encodings will be faster.
	 * @exports opentype.DefaultEncoding
	 * @class
	 * @constructor
	 * @param {opentype.Font}
	 */
	function DefaultEncoding(font) {
	    this.font = font;
	}

	DefaultEncoding.prototype.charToGlyphIndex = function(c) {
	    var code = c.codePointAt(0);
	    var glyphs = this.font.glyphs;
	    if (glyphs) {
	        for (var i = 0; i < glyphs.length; i += 1) {
	            var glyph = glyphs.get(i);
	            for (var j = 0; j < glyph.unicodes.length; j += 1) {
	                if (glyph.unicodes[j] === code) {
	                    return i;
	                }
	            }
	        }
	    }
	    return null;
	};

	/**
	 * @exports opentype.CmapEncoding
	 * @class
	 * @constructor
	 * @param {Object} cmap - a object with the cmap encoded data
	 */
	function CmapEncoding(cmap) {
	    this.cmap = cmap;
	}

	/**
	 * @param  {string} c - the character
	 * @return {number} The glyph index.
	 */
	CmapEncoding.prototype.charToGlyphIndex = function(c) {
	    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
	};

	/**
	 * @exports opentype.CffEncoding
	 * @class
	 * @constructor
	 * @param {string} encoding - The encoding
	 * @param {Array} charset - The character set.
	 */
	function CffEncoding(encoding, charset) {
	    this.encoding = encoding;
	    this.charset = charset;
	}

	/**
	 * @param  {string} s - The character
	 * @return {number} The index.
	 */
	CffEncoding.prototype.charToGlyphIndex = function(s) {
	    var code = s.codePointAt(0);
	    var charName = this.encoding[code];
	    return this.charset.indexOf(charName);
	};

	/**
	 * @exports opentype.GlyphNames
	 * @class
	 * @constructor
	 * @param {Object} post
	 */
	function GlyphNames(post) {
	    switch (post.version) {
	        case 1:
	            this.names = standardNames.slice();
	            break;
	        case 2:
	            this.names = new Array(post.numberOfGlyphs);
	            for (var i = 0; i < post.numberOfGlyphs; i++) {
	                if (post.glyphNameIndex[i] < standardNames.length) {
	                    this.names[i] = standardNames[post.glyphNameIndex[i]];
	                } else {
	                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
	                }
	            }

	            break;
	        case 2.5:
	            this.names = new Array(post.numberOfGlyphs);
	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
	                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
	            }

	            break;
	        case 3:
	            this.names = [];
	            break;
	        default:
	            this.names = [];
	            break;
	    }
	}

	/**
	 * Gets the index of a glyph by name.
	 * @param  {string} name - The glyph name
	 * @return {number} The index
	 */
	GlyphNames.prototype.nameToGlyphIndex = function(name) {
	    return this.names.indexOf(name);
	};

	/**
	 * @param  {number} gid
	 * @return {string}
	 */
	GlyphNames.prototype.glyphIndexToName = function(gid) {
	    return this.names[gid];
	};

	function addGlyphNamesAll(font) {
	    var glyph;
	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
	    var charCodes = Object.keys(glyphIndexMap);

	    for (var i = 0; i < charCodes.length; i += 1) {
	        var c = charCodes[i];
	        var glyphIndex = glyphIndexMap[c];
	        glyph = font.glyphs.get(glyphIndex);
	        glyph.addUnicode(parseInt(c));
	    }

	    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
	        glyph = font.glyphs.get(i$1);
	        if (font.cffEncoding) {
	            if (font.isCIDFont) {
	                glyph.name = 'gid' + i$1;
	            } else {
	                glyph.name = font.cffEncoding.charset[i$1];
	            }
	        } else if (font.glyphNames.names) {
	            glyph.name = font.glyphNames.glyphIndexToName(i$1);
	        }
	    }
	}

	function addGlyphNamesToUnicodeMap(font) {
	    font._IndexToUnicodeMap = {};

	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
	    var charCodes = Object.keys(glyphIndexMap);

	    for (var i = 0; i < charCodes.length; i += 1) {
	        var c = charCodes[i];
	        var glyphIndex = glyphIndexMap[c];
	        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {
	            font._IndexToUnicodeMap[glyphIndex] = {
	                unicodes: [parseInt(c)]
	            };
	        } else {
	            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
	        }
	    }
	}

	/**
	 * @alias opentype.addGlyphNames
	 * @param {opentype.Font}
	 * @param {Object}
	 */
	function addGlyphNames(font, opt) {
	    if (opt.lowMemory) {
	        addGlyphNamesToUnicodeMap(font);
	    } else {
	        addGlyphNamesAll(font);
	    }
	}

	// Drawing utility functions.

	// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
	function line(ctx, x1, y1, x2, y2) {
	    ctx.beginPath();
	    ctx.moveTo(x1, y1);
	    ctx.lineTo(x2, y2);
	    ctx.stroke();
	}

	var draw = { line: line };

	// The Glyph object
	// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

	function getPathDefinition(glyph, path) {
	    var _path = path || new Path();
	    return {
	        configurable: true,

	        get: function() {
	            if (typeof _path === 'function') {
	                _path = _path();
	            }

	            return _path;
	        },

	        set: function(p) {
	            _path = p;
	        }
	    };
	}
	/**
	 * @typedef GlyphOptions
	 * @type Object
	 * @property {string} [name] - The glyph name
	 * @property {number} [unicode]
	 * @property {Array} [unicodes]
	 * @property {number} [xMin]
	 * @property {number} [yMin]
	 * @property {number} [xMax]
	 * @property {number} [yMax]
	 * @property {number} [advanceWidth]
	 */

	// A Glyph is an individual mark that often corresponds to a character.
	// Some glyphs, such as ligatures, are a combination of many characters.
	// Glyphs are the basic building blocks of a font.
	//
	// The `Glyph` class contains utility methods for drawing the path and its points.
	/**
	 * @exports opentype.Glyph
	 * @class
	 * @param {GlyphOptions}
	 * @constructor
	 */
	function Glyph(options) {
	    // By putting all the code on a prototype function (which is only declared once)
	    // we reduce the memory requirements for larger fonts by some 2%
	    this.bindConstructorValues(options);
	}

	/**
	 * @param  {GlyphOptions}
	 */
	Glyph.prototype.bindConstructorValues = function(options) {
	    this.index = options.index || 0;

	    // These three values cannot be deferred for memory optimization:
	    this.name = options.name || null;
	    this.unicode = options.unicode || undefined;
	    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

	    // But by binding these values only when necessary, we reduce can
	    // the memory requirements by almost 3% for larger fonts.
	    if ('xMin' in options) {
	        this.xMin = options.xMin;
	    }

	    if ('yMin' in options) {
	        this.yMin = options.yMin;
	    }

	    if ('xMax' in options) {
	        this.xMax = options.xMax;
	    }

	    if ('yMax' in options) {
	        this.yMax = options.yMax;
	    }

	    if ('advanceWidth' in options) {
	        this.advanceWidth = options.advanceWidth;
	    }

	    // The path for a glyph is the most memory intensive, and is bound as a value
	    // with a getter/setter to ensure we actually do path parsing only once the
	    // path is actually needed by anything.
	    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
	};

	/**
	 * @param {number}
	 */
	Glyph.prototype.addUnicode = function(unicode) {
	    if (this.unicodes.length === 0) {
	        this.unicode = unicode;
	    }

	    this.unicodes.push(unicode);
	};

	/**
	 * Calculate the minimum bounding box for this glyph.
	 * @return {opentype.BoundingBox}
	 */
	Glyph.prototype.getBoundingBox = function() {
	    return this.path.getBoundingBox();
	};

	/**
	 * Convert the glyph to a Path we can draw on a drawing context.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
	 * @param  {opentype.Font} if hinting is to be used, the font
	 * @return {opentype.Path}
	 */
	Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 72;
	    var commands;
	    var hPoints;
	    if (!options) { options = { }; }
	    var xScale = options.xScale;
	    var yScale = options.yScale;

	    if (options.hinting && font && font.hinting) {
	        // in case of hinting, the hinting engine takes care
	        // of scaling the points (not the path) before hinting.
	        hPoints = this.path && font.hinting.exec(this, fontSize);
	        // in case the hinting engine failed hPoints is undefined
	        // and thus reverts to plain rending
	    }

	    if (hPoints) {
	        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
	        commands = font.hinting.getCommands(hPoints);
	        x = Math.round(x);
	        y = Math.round(y);
	        // TODO in case of hinting xyScaling is not yet supported
	        xScale = yScale = 1;
	    } else {
	        commands = this.path.commands;
	        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;
	        if (xScale === undefined) { xScale = scale; }
	        if (yScale === undefined) { yScale = scale; }
	    }

	    var p = new Path();
	    for (var i = 0; i < commands.length; i += 1) {
	        var cmd = commands[i];
	        if (cmd.type === 'M') {
	            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'L') {
	            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'Q') {
	            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
	                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'C') {
	            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
	                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
	                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'Z') {
	            p.closePath();
	        }
	    }

	    return p;
	};

	/**
	 * Split the glyph into contours.
	 * This function is here for backwards compatibility, and to
	 * provide raw access to the TrueType glyph outlines.
	 * @return {Array}
	 */
	Glyph.prototype.getContours = function() {
	    if (this.points === undefined) {
	        return [];
	    }

	    var contours = [];
	    var currentContour = [];
	    for (var i = 0; i < this.points.length; i += 1) {
	        var pt = this.points[i];
	        currentContour.push(pt);
	        if (pt.lastPointOfContour) {
	            contours.push(currentContour);
	            currentContour = [];
	        }
	    }

	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
	    return contours;
	};

	/**
	 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
	 * @return {Object}
	 */
	Glyph.prototype.getMetrics = function() {
	    var commands = this.path.commands;
	    var xCoords = [];
	    var yCoords = [];
	    for (var i = 0; i < commands.length; i += 1) {
	        var cmd = commands[i];
	        if (cmd.type !== 'Z') {
	            xCoords.push(cmd.x);
	            yCoords.push(cmd.y);
	        }

	        if (cmd.type === 'Q' || cmd.type === 'C') {
	            xCoords.push(cmd.x1);
	            yCoords.push(cmd.y1);
	        }

	        if (cmd.type === 'C') {
	            xCoords.push(cmd.x2);
	            yCoords.push(cmd.y2);
	        }
	    }

	    var metrics = {
	        xMin: Math.min.apply(null, xCoords),
	        yMin: Math.min.apply(null, yCoords),
	        xMax: Math.max.apply(null, xCoords),
	        yMax: Math.max.apply(null, yCoords),
	        leftSideBearing: this.leftSideBearing
	    };

	    if (!isFinite(metrics.xMin)) {
	        metrics.xMin = 0;
	    }

	    if (!isFinite(metrics.xMax)) {
	        metrics.xMax = this.advanceWidth;
	    }

	    if (!isFinite(metrics.yMin)) {
	        metrics.yMin = 0;
	    }

	    if (!isFinite(metrics.yMax)) {
	        metrics.yMax = 0;
	    }

	    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
	    return metrics;
	};

	/**
	 * Draw the glyph on the given context.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
	 */
	Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
	    this.getPath(x, y, fontSize, options).draw(ctx);
	};

	/**
	 * Draw the points of the glyph.
	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 */
	Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
	    function drawCircles(l, x, y, scale) {
	        ctx.beginPath();
	        for (var j = 0; j < l.length; j += 1) {
	            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
	            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);
	        }

	        ctx.closePath();
	        ctx.fill();
	    }

	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 24;
	    var scale = 1 / this.path.unitsPerEm * fontSize;

	    var blueCircles = [];
	    var redCircles = [];
	    var path = this.path;
	    for (var i = 0; i < path.commands.length; i += 1) {
	        var cmd = path.commands[i];
	        if (cmd.x !== undefined) {
	            blueCircles.push({x: cmd.x, y: -cmd.y});
	        }

	        if (cmd.x1 !== undefined) {
	            redCircles.push({x: cmd.x1, y: -cmd.y1});
	        }

	        if (cmd.x2 !== undefined) {
	            redCircles.push({x: cmd.x2, y: -cmd.y2});
	        }
	    }

	    ctx.fillStyle = 'blue';
	    drawCircles(blueCircles, x, y, scale);
	    ctx.fillStyle = 'red';
	    drawCircles(redCircles, x, y, scale);
	};

	/**
	 * Draw lines indicating important font measurements.
	 * Black lines indicate the origin of the coordinate system (point 0,0).
	 * Blue lines indicate the glyph bounding box.
	 * Green line indicates the advance width of the glyph.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 */
	Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
	    var scale;
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 24;
	    scale = 1 / this.path.unitsPerEm * fontSize;
	    ctx.lineWidth = 1;

	    // Draw the origin
	    ctx.strokeStyle = 'black';
	    draw.line(ctx, x, -10000, x, 10000);
	    draw.line(ctx, -10000, y, 10000, y);

	    // This code is here due to memory optimization: by not using
	    // defaults in the constructor, we save a notable amount of memory.
	    var xMin = this.xMin || 0;
	    var yMin = this.yMin || 0;
	    var xMax = this.xMax || 0;
	    var yMax = this.yMax || 0;
	    var advanceWidth = this.advanceWidth || 0;

	    // Draw the glyph box
	    ctx.strokeStyle = 'blue';
	    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
	    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
	    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
	    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

	    // Draw the advance width
	    ctx.strokeStyle = 'green';
	    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
	};

	// The GlyphSet object

	// Define a property on the glyph that depends on the path being loaded.
	function defineDependentProperty(glyph, externalName, internalName) {
	    Object.defineProperty(glyph, externalName, {
	        get: function() {
	            // Request the path property to make sure the path is loaded.
	            glyph.path; // jshint ignore:line
	            return glyph[internalName];
	        },
	        set: function(newValue) {
	            glyph[internalName] = newValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	}

	/**
	 * A GlyphSet represents all glyphs available in the font, but modelled using
	 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
	 * necessary, to keep the memory footprint down.
	 * @exports opentype.GlyphSet
	 * @class
	 * @param {opentype.Font}
	 * @param {Array}
	 */
	function GlyphSet(font, glyphs) {
	    this.font = font;
	    this.glyphs = {};
	    if (Array.isArray(glyphs)) {
	        for (var i = 0; i < glyphs.length; i++) {
	            var glyph = glyphs[i];
	            glyph.path.unitsPerEm = font.unitsPerEm;
	            this.glyphs[i] = glyph;
	        }
	    }

	    this.length = (glyphs && glyphs.length) || 0;
	}

	/**
	 * @param  {number} index
	 * @return {opentype.Glyph}
	 */
	GlyphSet.prototype.get = function(index) {
	    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.
	    if (this.glyphs[index] === undefined) {
	        this.font._push(index);
	        if (typeof this.glyphs[index] === 'function') {
	            this.glyphs[index] = this.glyphs[index]();
	        }

	        var glyph = this.glyphs[index];
	        var unicodeObj = this.font._IndexToUnicodeMap[index];

	        if (unicodeObj) {
	            for (var j = 0; j < unicodeObj.unicodes.length; j++)
	                { glyph.addUnicode(unicodeObj.unicodes[j]); }
	        }

	        if (this.font.cffEncoding) {
	            if (this.font.isCIDFont) {
	                glyph.name = 'gid' + index;
	            } else {
	                glyph.name = this.font.cffEncoding.charset[index];
	            }
	        } else if (this.font.glyphNames.names) {
	            glyph.name = this.font.glyphNames.glyphIndexToName(index);
	        }

	        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
	        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
	    } else {
	        if (typeof this.glyphs[index] === 'function') {
	            this.glyphs[index] = this.glyphs[index]();
	        }
	    }

	    return this.glyphs[index];
	};

	/**
	 * @param  {number} index
	 * @param  {Object}
	 */
	GlyphSet.prototype.push = function(index, loader) {
	    this.glyphs[index] = loader;
	    this.length++;
	};

	/**
	 * @alias opentype.glyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @return {opentype.Glyph}
	 */
	function glyphLoader(font, index) {
	    return new Glyph({index: index, font: font});
	}

	/**
	 * Generate a stub glyph that can be filled with all metadata *except*
	 * the "points" and "path" properties, which must be loaded only once
	 * the glyph's path is actually requested for text shaping.
	 * @alias opentype.ttfGlyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @param  {Function} parseGlyph
	 * @param  {Object} data
	 * @param  {number} position
	 * @param  {Function} buildPath
	 * @return {opentype.Glyph}
	 */
	function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
	    return function() {
	        var glyph = new Glyph({index: index, font: font});

	        glyph.path = function() {
	            parseGlyph(glyph, data, position);
	            var path = buildPath(font.glyphs, glyph);
	            path.unitsPerEm = font.unitsPerEm;
	            return path;
	        };

	        defineDependentProperty(glyph, 'xMin', '_xMin');
	        defineDependentProperty(glyph, 'xMax', '_xMax');
	        defineDependentProperty(glyph, 'yMin', '_yMin');
	        defineDependentProperty(glyph, 'yMax', '_yMax');

	        return glyph;
	    };
	}
	/**
	 * @alias opentype.cffGlyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @param  {Function} parseCFFCharstring
	 * @param  {string} charstring
	 * @return {opentype.Glyph}
	 */
	function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
	    return function() {
	        var glyph = new Glyph({index: index, font: font});

	        glyph.path = function() {
	            var path = parseCFFCharstring(font, glyph, charstring);
	            path.unitsPerEm = font.unitsPerEm;
	            return path;
	        };

	        return glyph;
	    };
	}

	var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

	// The `CFF` table contains the glyph outlines in PostScript format.

	// Custom equals function that can also check lists.
	function equals(a, b) {
	    if (a === b) {
	        return true;
	    } else if (Array.isArray(a) && Array.isArray(b)) {
	        if (a.length !== b.length) {
	            return false;
	        }

	        for (var i = 0; i < a.length; i += 1) {
	            if (!equals(a[i], b[i])) {
	                return false;
	            }
	        }

	        return true;
	    } else {
	        return false;
	    }
	}

	// Subroutines are encoded using the negative half of the number space.
	// See type 2 chapter 4.7 "Subroutine operators".
	function calcCFFSubroutineBias(subrs) {
	    var bias;
	    if (subrs.length < 1240) {
	        bias = 107;
	    } else if (subrs.length < 33900) {
	        bias = 1131;
	    } else {
	        bias = 32768;
	    }

	    return bias;
	}

	// Parse a `CFF` INDEX array.
	// An index array consists of a list of offsets, then a list of objects at those offsets.
	function parseCFFIndex(data, start, conversionFn) {
	    var offsets = [];
	    var objects = [];
	    var count = parse.getCard16(data, start);
	    var objectOffset;
	    var endOffset;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	        var pos = start + 3;
	        for (var i = 0; i < count + 1; i += 1) {
	            offsets.push(parse.getOffset(data, pos, offsetSize));
	            pos += offsetSize;
	        }

	        // The total size of the index array is 4 header bytes + the value of the last offset.
	        endOffset = objectOffset + offsets[count];
	    } else {
	        endOffset = start + 2;
	    }

	    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
	        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
	        if (conversionFn) {
	            value = conversionFn(value);
	        }

	        objects.push(value);
	    }

	    return {objects: objects, startOffset: start, endOffset: endOffset};
	}

	function parseCFFIndexLowMemory(data, start) {
	    var offsets = [];
	    var count = parse.getCard16(data, start);
	    var objectOffset;
	    var endOffset;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	        var pos = start + 3;
	        for (var i = 0; i < count + 1; i += 1) {
	            offsets.push(parse.getOffset(data, pos, offsetSize));
	            pos += offsetSize;
	        }

	        // The total size of the index array is 4 header bytes + the value of the last offset.
	        endOffset = objectOffset + offsets[count];
	    } else {
	        endOffset = start + 2;
	    }

	    return {offsets: offsets, startOffset: start, endOffset: endOffset};
	}
	function getCffIndexObject(i, offsets, data, start, conversionFn) {
	    var count = parse.getCard16(data, start);
	    var objectOffset = 0;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	    }

	    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
	    if (conversionFn) {
	        value = conversionFn(value);
	    }
	    return value;
	}

	// Parse a `CFF` DICT real value.
	function parseFloatOperand(parser) {
	    var s = '';
	    var eof = 15;
	    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
	    while (true) {
	        var b = parser.parseByte();
	        var n1 = b >> 4;
	        var n2 = b & 15;

	        if (n1 === eof) {
	            break;
	        }

	        s += lookup[n1];

	        if (n2 === eof) {
	            break;
	        }

	        s += lookup[n2];
	    }

	    return parseFloat(s);
	}

	// Parse a `CFF` DICT operand.
	function parseOperand(parser, b0) {
	    var b1;
	    var b2;
	    var b3;
	    var b4;
	    if (b0 === 28) {
	        b1 = parser.parseByte();
	        b2 = parser.parseByte();
	        return b1 << 8 | b2;
	    }

	    if (b0 === 29) {
	        b1 = parser.parseByte();
	        b2 = parser.parseByte();
	        b3 = parser.parseByte();
	        b4 = parser.parseByte();
	        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
	    }

	    if (b0 === 30) {
	        return parseFloatOperand(parser);
	    }

	    if (b0 >= 32 && b0 <= 246) {
	        return b0 - 139;
	    }

	    if (b0 >= 247 && b0 <= 250) {
	        b1 = parser.parseByte();
	        return (b0 - 247) * 256 + b1 + 108;
	    }

	    if (b0 >= 251 && b0 <= 254) {
	        b1 = parser.parseByte();
	        return -(b0 - 251) * 256 - b1 - 108;
	    }

	    throw new Error('Invalid b0 ' + b0);
	}

	// Convert the entries returned by `parseDict` to a proper dictionary.
	// If a value is a list of one, it is unpacked.
	function entriesToObject(entries) {
	    var o = {};
	    for (var i = 0; i < entries.length; i += 1) {
	        var key = entries[i][0];
	        var values = entries[i][1];
	        var value = (void 0);
	        if (values.length === 1) {
	            value = values[0];
	        } else {
	            value = values;
	        }

	        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
	            throw new Error('Object ' + o + ' already has key ' + key);
	        }

	        o[key] = value;
	    }

	    return o;
	}

	// Parse a `CFF` DICT object.
	// A dictionary contains key-value pairs in a compact tokenized format.
	function parseCFFDict(data, start, size) {
	    start = start !== undefined ? start : 0;
	    var parser = new parse.Parser(data, start);
	    var entries = [];
	    var operands = [];
	    size = size !== undefined ? size : data.length;

	    while (parser.relativeOffset < size) {
	        var op = parser.parseByte();

	        // The first byte for each dict item distinguishes between operator (key) and operand (value).
	        // Values <= 21 are operators.
	        if (op <= 21) {
	            // Two-byte operators have an initial escape byte of 12.
	            if (op === 12) {
	                op = 1200 + parser.parseByte();
	            }

	            entries.push([op, operands]);
	            operands = [];
	        } else {
	            // Since the operands (values) come before the operators (keys), we store all operands in a list
	            // until we encounter an operator.
	            operands.push(parseOperand(parser, op));
	        }
	    }

	    return entriesToObject(entries);
	}

	// Given a String Index (SID), return the value of the string.
	// Strings below index 392 are standard CFF strings and are not encoded in the font.
	function getCFFString(strings, index) {
	    if (index <= 390) {
	        index = cffStandardStrings[index];
	    } else {
	        index = strings[index - 391];
	    }

	    return index;
	}

	// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
	// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
	function interpretDict(dict, meta, strings) {
	    var newDict = {};
	    var value;

	    // Because we also want to include missing values, we start out from the meta list
	    // and lookup values in the dict.
	    for (var i = 0; i < meta.length; i += 1) {
	        var m = meta[i];

	        if (Array.isArray(m.type)) {
	            var values = [];
	            values.length = m.type.length;
	            for (var j = 0; j < m.type.length; j++) {
	                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
	                if (value === undefined) {
	                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
	                }
	                if (m.type[j] === 'SID') {
	                    value = getCFFString(strings, value);
	                }
	                values[j] = value;
	            }
	            newDict[m.name] = values;
	        } else {
	            value = dict[m.op];
	            if (value === undefined) {
	                value = m.value !== undefined ? m.value : null;
	            }

	            if (m.type === 'SID') {
	                value = getCFFString(strings, value);
	            }
	            newDict[m.name] = value;
	        }
	    }

	    return newDict;
	}

	// Parse the CFF header.
	function parseCFFHeader(data, start) {
	    var header = {};
	    header.formatMajor = parse.getCard8(data, start);
	    header.formatMinor = parse.getCard8(data, start + 1);
	    header.size = parse.getCard8(data, start + 2);
	    header.offsetSize = parse.getCard8(data, start + 3);
	    header.startOffset = start;
	    header.endOffset = start + 4;
	    return header;
	}

	var TOP_DICT_META = [
	    {name: 'version', op: 0, type: 'SID'},
	    {name: 'notice', op: 1, type: 'SID'},
	    {name: 'copyright', op: 1200, type: 'SID'},
	    {name: 'fullName', op: 2, type: 'SID'},
	    {name: 'familyName', op: 3, type: 'SID'},
	    {name: 'weight', op: 4, type: 'SID'},
	    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
	    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
	    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
	    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
	    {name: 'paintType', op: 1205, type: 'number', value: 0},
	    {name: 'charstringType', op: 1206, type: 'number', value: 2},
	    {
	        name: 'fontMatrix',
	        op: 1207,
	        type: ['real', 'real', 'real', 'real', 'real', 'real'],
	        value: [0.001, 0, 0, 0.001, 0, 0]
	    },
	    {name: 'uniqueId', op: 13, type: 'number'},
	    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
	    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
	    {name: 'xuid', op: 14, type: [], value: null},
	    {name: 'charset', op: 15, type: 'offset', value: 0},
	    {name: 'encoding', op: 16, type: 'offset', value: 0},
	    {name: 'charStrings', op: 17, type: 'offset', value: 0},
	    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
	    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
	    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
	    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
	    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
	    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
	    {name: 'uidBase', op: 1235, type: 'number'},
	    {name: 'fdArray', op: 1236, type: 'offset'},
	    {name: 'fdSelect', op: 1237, type: 'offset'},
	    {name: 'fontName', op: 1238, type: 'SID'}
	];

	var PRIVATE_DICT_META = [
	    {name: 'subrs', op: 19, type: 'offset', value: 0},
	    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
	    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
	];

	// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
	// The top dictionary contains the essential metadata for the font, together with the private dictionary.
	function parseCFFTopDict(data, strings) {
	    var dict = parseCFFDict(data, 0, data.byteLength);
	    return interpretDict(dict, TOP_DICT_META, strings);
	}

	// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
	function parseCFFPrivateDict(data, start, size, strings) {
	    var dict = parseCFFDict(data, start, size);
	    return interpretDict(dict, PRIVATE_DICT_META, strings);
	}

	// Returns a list of "Top DICT"s found using an INDEX list.
	// Used to read both the usual high-level Top DICTs and also the FDArray
	// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
	// a Private DICT that is read and saved into the Top DICT.
	//
	// In addition to the expected/optional values as outlined in TOP_DICT_META
	// the following values might be saved into the Top DICT.
	//
	//    _subrs []        array of local CFF subroutines from Private DICT
	//    _subrsBias       bias value computed from number of subroutines
	//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
	//    _defaultWidthX   default widths for CFF characters
	//    _nominalWidthX   bias added to width embedded within glyph description
	//
	//    _privateDict     saved copy of parsed Private DICT from Top DICT
	function gatherCFFTopDicts(data, start, cffIndex, strings) {
	    var topDictArray = [];
	    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
	        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
	        var topDict = parseCFFTopDict(topDictData, strings);
	        topDict._subrs = [];
	        topDict._subrsBias = 0;
	        topDict._defaultWidthX = 0;
	        topDict._nominalWidthX = 0;
	        var privateSize = topDict.private[0];
	        var privateOffset = topDict.private[1];
	        if (privateSize !== 0 && privateOffset !== 0) {
	            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
	            topDict._defaultWidthX = privateDict.defaultWidthX;
	            topDict._nominalWidthX = privateDict.nominalWidthX;
	            if (privateDict.subrs !== 0) {
	                var subrOffset = privateOffset + privateDict.subrs;
	                var subrIndex = parseCFFIndex(data, subrOffset + start);
	                topDict._subrs = subrIndex.objects;
	                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
	            }
	            topDict._privateDict = privateDict;
	        }
	        topDictArray.push(topDict);
	    }
	    return topDictArray;
	}

	// Parse the CFF charset table, which contains internal names for all the glyphs.
	// This function will return a list of glyph names.
	// See Adobe TN #5176 chapter 13, "Charsets".
	function parseCFFCharset(data, start, nGlyphs, strings) {
	    var sid;
	    var count;
	    var parser = new parse.Parser(data, start);

	    // The .notdef glyph is not included, so subtract 1.
	    nGlyphs -= 1;
	    var charset = ['.notdef'];

	    var format = parser.parseCard8();
	    if (format === 0) {
	        for (var i = 0; i < nGlyphs; i += 1) {
	            sid = parser.parseSID();
	            charset.push(getCFFString(strings, sid));
	        }
	    } else if (format === 1) {
	        while (charset.length <= nGlyphs) {
	            sid = parser.parseSID();
	            count = parser.parseCard8();
	            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
	                charset.push(getCFFString(strings, sid));
	                sid += 1;
	            }
	        }
	    } else if (format === 2) {
	        while (charset.length <= nGlyphs) {
	            sid = parser.parseSID();
	            count = parser.parseCard16();
	            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
	                charset.push(getCFFString(strings, sid));
	                sid += 1;
	            }
	        }
	    } else {
	        throw new Error('Unknown charset format ' + format);
	    }

	    return charset;
	}

	// Parse the CFF encoding data. Only one encoding can be specified per font.
	// See Adobe TN #5176 chapter 12, "Encodings".
	function parseCFFEncoding(data, start, charset) {
	    var code;
	    var enc = {};
	    var parser = new parse.Parser(data, start);
	    var format = parser.parseCard8();
	    if (format === 0) {
	        var nCodes = parser.parseCard8();
	        for (var i = 0; i < nCodes; i += 1) {
	            code = parser.parseCard8();
	            enc[code] = i;
	        }
	    } else if (format === 1) {
	        var nRanges = parser.parseCard8();
	        code = 1;
	        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
	            var first = parser.parseCard8();
	            var nLeft = parser.parseCard8();
	            for (var j = first; j <= first + nLeft; j += 1) {
	                enc[j] = code;
	                code += 1;
	            }
	        }
	    } else {
	        throw new Error('Unknown encoding format ' + format);
	    }

	    return new CffEncoding(enc, charset);
	}

	// Take in charstring code and return a Glyph object.
	// The encoding is described in the Type 2 Charstring Format
	// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
	function parseCFFCharstring(font, glyph, code) {
	    var c1x;
	    var c1y;
	    var c2x;
	    var c2y;
	    var p = new Path();
	    var stack = [];
	    var nStems = 0;
	    var haveWidth = false;
	    var open = false;
	    var x = 0;
	    var y = 0;
	    var subrs;
	    var subrsBias;
	    var defaultWidthX;
	    var nominalWidthX;
	    if (font.isCIDFont) {
	        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
	        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
	        subrs = fdDict._subrs;
	        subrsBias = fdDict._subrsBias;
	        defaultWidthX = fdDict._defaultWidthX;
	        nominalWidthX = fdDict._nominalWidthX;
	    } else {
	        subrs = font.tables.cff.topDict._subrs;
	        subrsBias = font.tables.cff.topDict._subrsBias;
	        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
	        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
	    }
	    var width = defaultWidthX;

	    function newContour(x, y) {
	        if (open) {
	            p.closePath();
	        }

	        p.moveTo(x, y);
	        open = true;
	    }

	    function parseStems() {
	        var hasWidthArg;

	        // The number of stem operators on the stack is always even.
	        // If the value is uneven, that means a width is specified.
	        hasWidthArg = stack.length % 2 !== 0;
	        if (hasWidthArg && !haveWidth) {
	            width = stack.shift() + nominalWidthX;
	        }

	        nStems += stack.length >> 1;
	        stack.length = 0;
	        haveWidth = true;
	    }

	    function parse(code) {
	        var b1;
	        var b2;
	        var b3;
	        var b4;
	        var codeIndex;
	        var subrCode;
	        var jpx;
	        var jpy;
	        var c3x;
	        var c3y;
	        var c4x;
	        var c4y;

	        var i = 0;
	        while (i < code.length) {
	            var v = code[i];
	            i += 1;
	            switch (v) {
	                case 1: // hstem
	                    parseStems();
	                    break;
	                case 3: // vstem
	                    parseStems();
	                    break;
	                case 4: // vmoveto
	                    if (stack.length > 1 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    y += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 5: // rlineto
	                    while (stack.length > 0) {
	                        x += stack.shift();
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 6: // hlineto
	                    while (stack.length > 0) {
	                        x += stack.shift();
	                        p.lineTo(x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 7: // vlineto
	                    while (stack.length > 0) {
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        x += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 8: // rrcurveto
	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 10: // callsubr
	                    codeIndex = stack.pop() + subrsBias;
	                    subrCode = subrs[codeIndex];
	                    if (subrCode) {
	                        parse(subrCode);
	                    }

	                    break;
	                case 11: // return
	                    return;
	                case 12: // flex operators
	                    v = code[i];
	                    i += 1;
	                    switch (v) {
	                        case 35: // flex
	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y + stack.shift();    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = jpy + stack.shift();    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            x = c4x   + stack.shift();    // dx6
	                            y = c4y   + stack.shift();    // dy6
	                            stack.shift();                // flex depth
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 34: // hflex
	                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y;                      // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y;                    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = c2y;                    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = y;                      // dy5
	                            x = c4x + stack.shift();      // dx6
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 36: // hflex1
	                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y;                    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = c2y;                    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            x = c4x + stack.shift();      // dx6
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 37: // flex1
	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y + stack.shift();    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = jpy + stack.shift();    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
	                                x = c4x + stack.shift();
	                            } else {
	                                y = c4y + stack.shift();
	                            }

	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        default:
	                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
	                            stack.length = 0;
	                    }
	                    break;
	                case 14: // endchar
	                    if (stack.length > 0 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    if (open) {
	                        p.closePath();
	                        open = false;
	                    }

	                    break;
	                case 18: // hstemhm
	                    parseStems();
	                    break;
	                case 19: // hintmask
	                case 20: // cntrmask
	                    parseStems();
	                    i += (nStems + 7) >> 3;
	                    break;
	                case 21: // rmoveto
	                    if (stack.length > 2 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    y += stack.pop();
	                    x += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 22: // hmoveto
	                    if (stack.length > 1 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    x += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 23: // vstemhm
	                    parseStems();
	                    break;
	                case 24: // rcurveline
	                    while (stack.length > 2) {
	                        c1x = x + stack.shift();
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    x += stack.shift();
	                    y += stack.shift();
	                    p.lineTo(x, y);
	                    break;
	                case 25: // rlinecurve
	                    while (stack.length > 6) {
	                        x += stack.shift();
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    c1x = x + stack.shift();
	                    c1y = y + stack.shift();
	                    c2x = c1x + stack.shift();
	                    c2y = c1y + stack.shift();
	                    x = c2x + stack.shift();
	                    y = c2y + stack.shift();
	                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    break;
	                case 26: // vvcurveto
	                    if (stack.length % 2) {
	                        x += stack.shift();
	                    }

	                    while (stack.length > 0) {
	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x;
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 27: // hhcurveto
	                    if (stack.length % 2) {
	                        y += stack.shift();
	                    }

	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y;
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 28: // shortint
	                    b1 = code[i];
	                    b2 = code[i + 1];
	                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
	                    i += 2;
	                    break;
	                case 29: // callgsubr
	                    codeIndex = stack.pop() + font.gsubrsBias;
	                    subrCode = font.gsubrs[codeIndex];
	                    if (subrCode) {
	                        parse(subrCode);
	                    }

	                    break;
	                case 30: // vhcurveto
	                    while (stack.length > 0) {
	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        y = c2y + stack.shift();
	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 31: // hvcurveto
	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        y = c2y + stack.shift();
	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                default:
	                    if (v < 32) {
	                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
	                    } else if (v < 247) {
	                        stack.push(v - 139);
	                    } else if (v < 251) {
	                        b1 = code[i];
	                        i += 1;
	                        stack.push((v - 247) * 256 + b1 + 108);
	                    } else if (v < 255) {
	                        b1 = code[i];
	                        i += 1;
	                        stack.push(-(v - 251) * 256 - b1 - 108);
	                    } else {
	                        b1 = code[i];
	                        b2 = code[i + 1];
	                        b3 = code[i + 2];
	                        b4 = code[i + 3];
	                        i += 4;
	                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
	                    }
	            }
	        }
	    }

	    parse(code);

	    glyph.advanceWidth = width;
	    return p;
	}

	function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
	    var fdSelect = [];
	    var fdIndex;
	    var parser = new parse.Parser(data, start);
	    var format = parser.parseCard8();
	    if (format === 0) {
	        // Simple list of nGlyphs elements
	        for (var iGid = 0; iGid < nGlyphs; iGid++) {
	            fdIndex = parser.parseCard8();
	            if (fdIndex >= fdArrayCount) {
	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
	            }
	            fdSelect.push(fdIndex);
	        }
	    } else if (format === 3) {
	        // Ranges
	        var nRanges = parser.parseCard16();
	        var first = parser.parseCard16();
	        if (first !== 0) {
	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
	        }
	        var next;
	        for (var iRange = 0; iRange < nRanges; iRange++) {
	            fdIndex = parser.parseCard8();
	            next = parser.parseCard16();
	            if (fdIndex >= fdArrayCount) {
	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
	            }
	            if (next > nGlyphs) {
	                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
	            }
	            for (; first < next; first++) {
	                fdSelect.push(fdIndex);
	            }
	            first = next;
	        }
	        if (next !== nGlyphs) {
	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
	        }
	    } else {
	        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
	    }
	    return fdSelect;
	}

	// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
	function parseCFFTable(data, start, font, opt) {
	    font.tables.cff = {};
	    var header = parseCFFHeader(data, start);
	    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
	    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
	    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
	    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
	    font.gsubrs = globalSubrIndex.objects;
	    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

	    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
	    if (topDictArray.length !== 1) {
	        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
	    }

	    var topDict = topDictArray[0];
	    font.tables.cff.topDict = topDict;

	    if (topDict._privateDict) {
	        font.defaultWidthX = topDict._privateDict.defaultWidthX;
	        font.nominalWidthX = topDict._privateDict.nominalWidthX;
	    }

	    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
	        font.isCIDFont = true;
	    }

	    if (font.isCIDFont) {
	        var fdArrayOffset = topDict.fdArray;
	        var fdSelectOffset = topDict.fdSelect;
	        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
	            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
	        }
	        fdArrayOffset += start;
	        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
	        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
	        topDict._fdArray = fdArray;
	        fdSelectOffset += start;
	        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
	    }

	    var privateDictOffset = start + topDict.private[1];
	    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
	    font.defaultWidthX = privateDict.defaultWidthX;
	    font.nominalWidthX = privateDict.nominalWidthX;

	    if (privateDict.subrs !== 0) {
	        var subrOffset = privateDictOffset + privateDict.subrs;
	        var subrIndex = parseCFFIndex(data, subrOffset);
	        font.subrs = subrIndex.objects;
	        font.subrsBias = calcCFFSubroutineBias(font.subrs);
	    } else {
	        font.subrs = [];
	        font.subrsBias = 0;
	    }

	    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
	    var charStringsIndex;
	    if (opt.lowMemory) {
	        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
	        font.nGlyphs = charStringsIndex.offsets.length;
	    } else {
	        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
	        font.nGlyphs = charStringsIndex.objects.length;
	    }

	    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
	    if (topDict.encoding === 0) {
	        // Standard encoding
	        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
	    } else if (topDict.encoding === 1) {
	        // Expert encoding
	        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
	    } else {
	        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
	    }

	    // Prefer the CMAP encoding to the CFF encoding.
	    font.encoding = font.encoding || font.cffEncoding;

	    font.glyphs = new glyphset.GlyphSet(font);
	    if (opt.lowMemory) {
	        font._push = function(i) {
	            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);
	            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
	        };
	    } else {
	        for (var i = 0; i < font.nGlyphs; i += 1) {
	            var charString = charStringsIndex.objects[i];
	            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
	        }
	    }
	}

	// Convert a string to a String ID (SID).
	// The list of strings is modified in place.
	function encodeString(s, strings) {
	    var sid;

	    // Is the string in the CFF standard strings?
	    var i = cffStandardStrings.indexOf(s);
	    if (i >= 0) {
	        sid = i;
	    }

	    // Is the string already in the string index?
	    i = strings.indexOf(s);
	    if (i >= 0) {
	        sid = i + cffStandardStrings.length;
	    } else {
	        sid = cffStandardStrings.length + strings.length;
	        strings.push(s);
	    }

	    return sid;
	}

	function makeHeader() {
	    return new table.Record('Header', [
	        {name: 'major', type: 'Card8', value: 1},
	        {name: 'minor', type: 'Card8', value: 0},
	        {name: 'hdrSize', type: 'Card8', value: 4},
	        {name: 'major', type: 'Card8', value: 1}
	    ]);
	}

	function makeNameIndex(fontNames) {
	    var t = new table.Record('Name INDEX', [
	        {name: 'names', type: 'INDEX', value: []}
	    ]);
	    t.names = [];
	    for (var i = 0; i < fontNames.length; i += 1) {
	        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
	    }

	    return t;
	}

	// Given a dictionary's metadata, create a DICT structure.
	function makeDict(meta, attrs, strings) {
	    var m = {};
	    for (var i = 0; i < meta.length; i += 1) {
	        var entry = meta[i];
	        var value = attrs[entry.name];
	        if (value !== undefined && !equals(value, entry.value)) {
	            if (entry.type === 'SID') {
	                value = encodeString(value, strings);
	            }

	            m[entry.op] = {name: entry.name, type: entry.type, value: value};
	        }
	    }

	    return m;
	}

	// The Top DICT houses the global font attributes.
	function makeTopDict(attrs, strings) {
	    var t = new table.Record('Top DICT', [
	        {name: 'dict', type: 'DICT', value: {}}
	    ]);
	    t.dict = makeDict(TOP_DICT_META, attrs, strings);
	    return t;
	}

	function makeTopDictIndex(topDict) {
	    var t = new table.Record('Top DICT INDEX', [
	        {name: 'topDicts', type: 'INDEX', value: []}
	    ]);
	    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
	    return t;
	}

	function makeStringIndex(strings) {
	    var t = new table.Record('String INDEX', [
	        {name: 'strings', type: 'INDEX', value: []}
	    ]);
	    t.strings = [];
	    for (var i = 0; i < strings.length; i += 1) {
	        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
	    }

	    return t;
	}

	function makeGlobalSubrIndex() {
	    // Currently we don't use subroutines.
	    return new table.Record('Global Subr INDEX', [
	        {name: 'subrs', type: 'INDEX', value: []}
	    ]);
	}

	function makeCharsets(glyphNames, strings) {
	    var t = new table.Record('Charsets', [
	        {name: 'format', type: 'Card8', value: 0}
	    ]);
	    for (var i = 0; i < glyphNames.length; i += 1) {
	        var glyphName = glyphNames[i];
	        var glyphSID = encodeString(glyphName, strings);
	        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
	    }

	    return t;
	}

	function glyphToOps(glyph) {
	    var ops = [];
	    var path = glyph.path;
	    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
	    var x = 0;
	    var y = 0;
	    for (var i = 0; i < path.commands.length; i += 1) {
	        var dx = (void 0);
	        var dy = (void 0);
	        var cmd = path.commands[i];
	        if (cmd.type === 'Q') {
	            // CFF only supports bézier curves, so convert the quad to a bézier.
	            var _13 = 1 / 3;
	            var _23 = 2 / 3;

	            // We're going to create a new command so we don't change the original path.
	            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.
	            cmd = {
	                type: 'C',
	                x: cmd.x,
	                y: cmd.y,
	                x1: Math.round(_13 * x + _23 * cmd.x1),
	                y1: Math.round(_13 * y + _23 * cmd.y1),
	                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
	                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
	            };
	        }

	        if (cmd.type === 'M') {
	            dx = Math.round(cmd.x - x);
	            dy = Math.round(cmd.y - y);
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rmoveto', type: 'OP', value: 21});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        } else if (cmd.type === 'L') {
	            dx = Math.round(cmd.x - x);
	            dy = Math.round(cmd.y - y);
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rlineto', type: 'OP', value: 5});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        } else if (cmd.type === 'C') {
	            var dx1 = Math.round(cmd.x1 - x);
	            var dy1 = Math.round(cmd.y1 - y);
	            var dx2 = Math.round(cmd.x2 - cmd.x1);
	            var dy2 = Math.round(cmd.y2 - cmd.y1);
	            dx = Math.round(cmd.x - cmd.x2);
	            dy = Math.round(cmd.y - cmd.y2);
	            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
	            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
	            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
	            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        }

	        // Contours are closed automatically.
	    }

	    ops.push({name: 'endchar', type: 'OP', value: 14});
	    return ops;
	}

	function makeCharStringsIndex(glyphs) {
	    var t = new table.Record('CharStrings INDEX', [
	        {name: 'charStrings', type: 'INDEX', value: []}
	    ]);

	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        var ops = glyphToOps(glyph);
	        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
	    }

	    return t;
	}

	function makePrivateDict(attrs, strings) {
	    var t = new table.Record('Private DICT', [
	        {name: 'dict', type: 'DICT', value: {}}
	    ]);
	    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
	    return t;
	}

	function makeCFFTable(glyphs, options) {
	    var t = new table.Table('CFF ', [
	        {name: 'header', type: 'RECORD'},
	        {name: 'nameIndex', type: 'RECORD'},
	        {name: 'topDictIndex', type: 'RECORD'},
	        {name: 'stringIndex', type: 'RECORD'},
	        {name: 'globalSubrIndex', type: 'RECORD'},
	        {name: 'charsets', type: 'RECORD'},
	        {name: 'charStringsIndex', type: 'RECORD'},
	        {name: 'privateDict', type: 'RECORD'}
	    ]);

	    var fontScale = 1 / options.unitsPerEm;
	    // We use non-zero values for the offsets so that the DICT encodes them.
	    // This is important because the size of the Top DICT plays a role in offset calculation,
	    // and the size shouldn't change after we've written correct offsets.
	    var attrs = {
	        version: options.version,
	        fullName: options.fullName,
	        familyName: options.familyName,
	        weight: options.weightName,
	        fontBBox: options.fontBBox || [0, 0, 0, 0],
	        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
	        charset: 999,
	        encoding: 0,
	        charStrings: 999,
	        private: [0, 999]
	    };

	    var privateAttrs = {};

	    var glyphNames = [];
	    var glyph;

	    // Skip first glyph (.notdef)
	    for (var i = 1; i < glyphs.length; i += 1) {
	        glyph = glyphs.get(i);
	        glyphNames.push(glyph.name);
	    }

	    var strings = [];

	    t.header = makeHeader();
	    t.nameIndex = makeNameIndex([options.postScriptName]);
	    var topDict = makeTopDict(attrs, strings);
	    t.topDictIndex = makeTopDictIndex(topDict);
	    t.globalSubrIndex = makeGlobalSubrIndex();
	    t.charsets = makeCharsets(glyphNames, strings);
	    t.charStringsIndex = makeCharStringsIndex(glyphs);
	    t.privateDict = makePrivateDict(privateAttrs, strings);

	    // Needs to come at the end, to encode all custom strings used in the font.
	    t.stringIndex = makeStringIndex(strings);

	    var startOffset = t.header.sizeOf() +
	        t.nameIndex.sizeOf() +
	        t.topDictIndex.sizeOf() +
	        t.stringIndex.sizeOf() +
	        t.globalSubrIndex.sizeOf();
	    attrs.charset = startOffset;

	    // We use the CFF standard encoding; proper encoding will be handled in cmap.
	    attrs.encoding = 0;
	    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
	    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

	    // Recreate the Top DICT INDEX with the correct offsets.
	    topDict = makeTopDict(attrs, strings);
	    t.topDictIndex = makeTopDictIndex(topDict);

	    return t;
	}

	var cff = { parse: parseCFFTable, make: makeCFFTable };

	// The `head` table contains global information about the font.

	// Parse the header `head` table
	function parseHeadTable(data, start) {
	    var head = {};
	    var p = new parse.Parser(data, start);
	    head.version = p.parseVersion();
	    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
	    head.checkSumAdjustment = p.parseULong();
	    head.magicNumber = p.parseULong();
	    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
	    head.flags = p.parseUShort();
	    head.unitsPerEm = p.parseUShort();
	    head.created = p.parseLongDateTime();
	    head.modified = p.parseLongDateTime();
	    head.xMin = p.parseShort();
	    head.yMin = p.parseShort();
	    head.xMax = p.parseShort();
	    head.yMax = p.parseShort();
	    head.macStyle = p.parseUShort();
	    head.lowestRecPPEM = p.parseUShort();
	    head.fontDirectionHint = p.parseShort();
	    head.indexToLocFormat = p.parseShort();
	    head.glyphDataFormat = p.parseShort();
	    return head;
	}

	function makeHeadTable(options) {
	    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
	    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
	    var createdTimestamp = timestamp;

	    if (options.createdTimestamp) {
	        createdTimestamp = options.createdTimestamp + 2082844800;
	    }

	    return new table.Table('head', [
	        {name: 'version', type: 'FIXED', value: 0x00010000},
	        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
	        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
	        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
	        {name: 'flags', type: 'USHORT', value: 0},
	        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
	        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
	        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
	        {name: 'xMin', type: 'SHORT', value: 0},
	        {name: 'yMin', type: 'SHORT', value: 0},
	        {name: 'xMax', type: 'SHORT', value: 0},
	        {name: 'yMax', type: 'SHORT', value: 0},
	        {name: 'macStyle', type: 'USHORT', value: 0},
	        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
	        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
	        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
	        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
	    ], options);
	}

	var head = { parse: parseHeadTable, make: makeHeadTable };

	// The `hhea` table contains information for horizontal layout.

	// Parse the horizontal header `hhea` table
	function parseHheaTable(data, start) {
	    var hhea = {};
	    var p = new parse.Parser(data, start);
	    hhea.version = p.parseVersion();
	    hhea.ascender = p.parseShort();
	    hhea.descender = p.parseShort();
	    hhea.lineGap = p.parseShort();
	    hhea.advanceWidthMax = p.parseUShort();
	    hhea.minLeftSideBearing = p.parseShort();
	    hhea.minRightSideBearing = p.parseShort();
	    hhea.xMaxExtent = p.parseShort();
	    hhea.caretSlopeRise = p.parseShort();
	    hhea.caretSlopeRun = p.parseShort();
	    hhea.caretOffset = p.parseShort();
	    p.relativeOffset += 8;
	    hhea.metricDataFormat = p.parseShort();
	    hhea.numberOfHMetrics = p.parseUShort();
	    return hhea;
	}

	function makeHheaTable(options) {
	    return new table.Table('hhea', [
	        {name: 'version', type: 'FIXED', value: 0x00010000},
	        {name: 'ascender', type: 'FWORD', value: 0},
	        {name: 'descender', type: 'FWORD', value: 0},
	        {name: 'lineGap', type: 'FWORD', value: 0},
	        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
	        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
	        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
	        {name: 'xMaxExtent', type: 'FWORD', value: 0},
	        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
	        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
	        {name: 'caretOffset', type: 'SHORT', value: 0},
	        {name: 'reserved1', type: 'SHORT', value: 0},
	        {name: 'reserved2', type: 'SHORT', value: 0},
	        {name: 'reserved3', type: 'SHORT', value: 0},
	        {name: 'reserved4', type: 'SHORT', value: 0},
	        {name: 'metricDataFormat', type: 'SHORT', value: 0},
	        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
	    ], options);
	}

	var hhea = { parse: parseHheaTable, make: makeHheaTable };

	// The `hmtx` table contains the horizontal metrics for all glyphs.

	function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
	    var advanceWidth;
	    var leftSideBearing;
	    var p = new parse.Parser(data, start);
	    for (var i = 0; i < numGlyphs; i += 1) {
	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
	        if (i < numMetrics) {
	            advanceWidth = p.parseUShort();
	            leftSideBearing = p.parseShort();
	        }

	        var glyph = glyphs.get(i);
	        glyph.advanceWidth = advanceWidth;
	        glyph.leftSideBearing = leftSideBearing;
	    }
	}

	function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
	    font._hmtxTableData = {};

	    var advanceWidth;
	    var leftSideBearing;
	    var p = new parse.Parser(data, start);
	    for (var i = 0; i < numGlyphs; i += 1) {
	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
	        if (i < numMetrics) {
	            advanceWidth = p.parseUShort();
	            leftSideBearing = p.parseShort();
	        }

	        font._hmtxTableData[i] = {
	            advanceWidth: advanceWidth,
	            leftSideBearing: leftSideBearing
	        };
	    }
	}

	// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
	// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
	function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
	    if (opt.lowMemory)
	        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }
	    else
	        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }
	}

	function makeHmtxTable(glyphs) {
	    var t = new table.Table('hmtx', []);
	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        var advanceWidth = glyph.advanceWidth || 0;
	        var leftSideBearing = glyph.leftSideBearing || 0;
	        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
	        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
	    }

	    return t;
	}

	var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

	// The `ltag` table stores IETF BCP-47 language tags. It allows supporting

	function makeLtagTable(tags) {
	    var result = new table.Table('ltag', [
	        {name: 'version', type: 'ULONG', value: 1},
	        {name: 'flags', type: 'ULONG', value: 0},
	        {name: 'numTags', type: 'ULONG', value: tags.length}
	    ]);

	    var stringPool = '';
	    var stringPoolOffset = 12 + tags.length * 4;
	    for (var i = 0; i < tags.length; ++i) {
	        var pos = stringPool.indexOf(tags[i]);
	        if (pos < 0) {
	            pos = stringPool.length;
	            stringPool += tags[i];
	        }

	        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
	        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
	    }

	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
	    return result;
	}

	function parseLtagTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
	    // The 'ltag' specification does not define any flags; skip the field.
	    p.skip('uLong', 1);
	    var numTags = p.parseULong();

	    var tags = [];
	    for (var i = 0; i < numTags; i++) {
	        var tag = '';
	        var offset = start + p.parseUShort();
	        var length = p.parseUShort();
	        for (var j = offset; j < offset + length; ++j) {
	            tag += String.fromCharCode(data.getInt8(j));
	        }

	        tags.push(tag);
	    }

	    return tags;
	}

	var ltag = { make: makeLtagTable, parse: parseLtagTable };

	// The `maxp` table establishes the memory requirements for the font.

	// Parse the maximum profile `maxp` table.
	function parseMaxpTable(data, start) {
	    var maxp = {};
	    var p = new parse.Parser(data, start);
	    maxp.version = p.parseVersion();
	    maxp.numGlyphs = p.parseUShort();
	    if (maxp.version === 1.0) {
	        maxp.maxPoints = p.parseUShort();
	        maxp.maxContours = p.parseUShort();
	        maxp.maxCompositePoints = p.parseUShort();
	        maxp.maxCompositeContours = p.parseUShort();
	        maxp.maxZones = p.parseUShort();
	        maxp.maxTwilightPoints = p.parseUShort();
	        maxp.maxStorage = p.parseUShort();
	        maxp.maxFunctionDefs = p.parseUShort();
	        maxp.maxInstructionDefs = p.parseUShort();
	        maxp.maxStackElements = p.parseUShort();
	        maxp.maxSizeOfInstructions = p.parseUShort();
	        maxp.maxComponentElements = p.parseUShort();
	        maxp.maxComponentDepth = p.parseUShort();
	    }

	    return maxp;
	}

	function makeMaxpTable(numGlyphs) {
	    return new table.Table('maxp', [
	        {name: 'version', type: 'FIXED', value: 0x00005000},
	        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
	    ]);
	}

	var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

	// The `name` naming table.

	// NameIDs for the name table.
	var nameTableNames = [
	    'copyright',              // 0
	    'fontFamily',             // 1
	    'fontSubfamily',          // 2
	    'uniqueID',               // 3
	    'fullName',               // 4
	    'version',                // 5
	    'postScriptName',         // 6
	    'trademark',              // 7
	    'manufacturer',           // 8
	    'designer',               // 9
	    'description',            // 10
	    'manufacturerURL',        // 11
	    'designerURL',            // 12
	    'license',                // 13
	    'licenseURL',             // 14
	    'reserved',               // 15
	    'preferredFamily',        // 16
	    'preferredSubfamily',     // 17
	    'compatibleFullName',     // 18
	    'sampleText',             // 19
	    'postScriptFindFontName', // 20
	    'wwsFamily',              // 21
	    'wwsSubfamily'            // 22
	];

	var macLanguages = {
	    0: 'en',
	    1: 'fr',
	    2: 'de',
	    3: 'it',
	    4: 'nl',
	    5: 'sv',
	    6: 'es',
	    7: 'da',
	    8: 'pt',
	    9: 'no',
	    10: 'he',
	    11: 'ja',
	    12: 'ar',
	    13: 'fi',
	    14: 'el',
	    15: 'is',
	    16: 'mt',
	    17: 'tr',
	    18: 'hr',
	    19: 'zh-Hant',
	    20: 'ur',
	    21: 'hi',
	    22: 'th',
	    23: 'ko',
	    24: 'lt',
	    25: 'pl',
	    26: 'hu',
	    27: 'es',
	    28: 'lv',
	    29: 'se',
	    30: 'fo',
	    31: 'fa',
	    32: 'ru',
	    33: 'zh',
	    34: 'nl-BE',
	    35: 'ga',
	    36: 'sq',
	    37: 'ro',
	    38: 'cz',
	    39: 'sk',
	    40: 'si',
	    41: 'yi',
	    42: 'sr',
	    43: 'mk',
	    44: 'bg',
	    45: 'uk',
	    46: 'be',
	    47: 'uz',
	    48: 'kk',
	    49: 'az-Cyrl',
	    50: 'az-Arab',
	    51: 'hy',
	    52: 'ka',
	    53: 'mo',
	    54: 'ky',
	    55: 'tg',
	    56: 'tk',
	    57: 'mn-CN',
	    58: 'mn',
	    59: 'ps',
	    60: 'ks',
	    61: 'ku',
	    62: 'sd',
	    63: 'bo',
	    64: 'ne',
	    65: 'sa',
	    66: 'mr',
	    67: 'bn',
	    68: 'as',
	    69: 'gu',
	    70: 'pa',
	    71: 'or',
	    72: 'ml',
	    73: 'kn',
	    74: 'ta',
	    75: 'te',
	    76: 'si',
	    77: 'my',
	    78: 'km',
	    79: 'lo',
	    80: 'vi',
	    81: 'id',
	    82: 'tl',
	    83: 'ms',
	    84: 'ms-Arab',
	    85: 'am',
	    86: 'ti',
	    87: 'om',
	    88: 'so',
	    89: 'sw',
	    90: 'rw',
	    91: 'rn',
	    92: 'ny',
	    93: 'mg',
	    94: 'eo',
	    128: 'cy',
	    129: 'eu',
	    130: 'ca',
	    131: 'la',
	    132: 'qu',
	    133: 'gn',
	    134: 'ay',
	    135: 'tt',
	    136: 'ug',
	    137: 'dz',
	    138: 'jv',
	    139: 'su',
	    140: 'gl',
	    141: 'af',
	    142: 'br',
	    143: 'iu',
	    144: 'gd',
	    145: 'gv',
	    146: 'ga',
	    147: 'to',
	    148: 'el-polyton',
	    149: 'kl',
	    150: 'az',
	    151: 'nn'
	};

	// MacOS language ID → MacOS script ID
	//
	// Note that the script ID is not sufficient to determine what encoding
	// to use in TrueType files. For some languages, MacOS used a modification
	// of a mainstream script. For example, an Icelandic name would be stored
	// with smRoman in the TrueType naming table, but the actual encoding
	// is a special Icelandic version of the normal Macintosh Roman encoding.
	// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
	// Syllables but MacOS had run out of available script codes, so this was
	// done as a (pretty radical) "modification" of Ethiopic.
	//
	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
	var macLanguageToScript = {
	    0: 0,  // langEnglish → smRoman
	    1: 0,  // langFrench → smRoman
	    2: 0,  // langGerman → smRoman
	    3: 0,  // langItalian → smRoman
	    4: 0,  // langDutch → smRoman
	    5: 0,  // langSwedish → smRoman
	    6: 0,  // langSpanish → smRoman
	    7: 0,  // langDanish → smRoman
	    8: 0,  // langPortuguese → smRoman
	    9: 0,  // langNorwegian → smRoman
	    10: 5,  // langHebrew → smHebrew
	    11: 1,  // langJapanese → smJapanese
	    12: 4,  // langArabic → smArabic
	    13: 0,  // langFinnish → smRoman
	    14: 6,  // langGreek → smGreek
	    15: 0,  // langIcelandic → smRoman (modified)
	    16: 0,  // langMaltese → smRoman
	    17: 0,  // langTurkish → smRoman (modified)
	    18: 0,  // langCroatian → smRoman (modified)
	    19: 2,  // langTradChinese → smTradChinese
	    20: 4,  // langUrdu → smArabic
	    21: 9,  // langHindi → smDevanagari
	    22: 21,  // langThai → smThai
	    23: 3,  // langKorean → smKorean
	    24: 29,  // langLithuanian → smCentralEuroRoman
	    25: 29,  // langPolish → smCentralEuroRoman
	    26: 29,  // langHungarian → smCentralEuroRoman
	    27: 29,  // langEstonian → smCentralEuroRoman
	    28: 29,  // langLatvian → smCentralEuroRoman
	    29: 0,  // langSami → smRoman
	    30: 0,  // langFaroese → smRoman (modified)
	    31: 4,  // langFarsi → smArabic (modified)
	    32: 7,  // langRussian → smCyrillic
	    33: 25,  // langSimpChinese → smSimpChinese
	    34: 0,  // langFlemish → smRoman
	    35: 0,  // langIrishGaelic → smRoman (modified)
	    36: 0,  // langAlbanian → smRoman
	    37: 0,  // langRomanian → smRoman (modified)
	    38: 29,  // langCzech → smCentralEuroRoman
	    39: 29,  // langSlovak → smCentralEuroRoman
	    40: 0,  // langSlovenian → smRoman (modified)
	    41: 5,  // langYiddish → smHebrew
	    42: 7,  // langSerbian → smCyrillic
	    43: 7,  // langMacedonian → smCyrillic
	    44: 7,  // langBulgarian → smCyrillic
	    45: 7,  // langUkrainian → smCyrillic (modified)
	    46: 7,  // langByelorussian → smCyrillic
	    47: 7,  // langUzbek → smCyrillic
	    48: 7,  // langKazakh → smCyrillic
	    49: 7,  // langAzerbaijani → smCyrillic
	    50: 4,  // langAzerbaijanAr → smArabic
	    51: 24,  // langArmenian → smArmenian
	    52: 23,  // langGeorgian → smGeorgian
	    53: 7,  // langMoldavian → smCyrillic
	    54: 7,  // langKirghiz → smCyrillic
	    55: 7,  // langTajiki → smCyrillic
	    56: 7,  // langTurkmen → smCyrillic
	    57: 27,  // langMongolian → smMongolian
	    58: 7,  // langMongolianCyr → smCyrillic
	    59: 4,  // langPashto → smArabic
	    60: 4,  // langKurdish → smArabic
	    61: 4,  // langKashmiri → smArabic
	    62: 4,  // langSindhi → smArabic
	    63: 26,  // langTibetan → smTibetan
	    64: 9,  // langNepali → smDevanagari
	    65: 9,  // langSanskrit → smDevanagari
	    66: 9,  // langMarathi → smDevanagari
	    67: 13,  // langBengali → smBengali
	    68: 13,  // langAssamese → smBengali
	    69: 11,  // langGujarati → smGujarati
	    70: 10,  // langPunjabi → smGurmukhi
	    71: 12,  // langOriya → smOriya
	    72: 17,  // langMalayalam → smMalayalam
	    73: 16,  // langKannada → smKannada
	    74: 14,  // langTamil → smTamil
	    75: 15,  // langTelugu → smTelugu
	    76: 18,  // langSinhalese → smSinhalese
	    77: 19,  // langBurmese → smBurmese
	    78: 20,  // langKhmer → smKhmer
	    79: 22,  // langLao → smLao
	    80: 30,  // langVietnamese → smVietnamese
	    81: 0,  // langIndonesian → smRoman
	    82: 0,  // langTagalog → smRoman
	    83: 0,  // langMalayRoman → smRoman
	    84: 4,  // langMalayArabic → smArabic
	    85: 28,  // langAmharic → smEthiopic
	    86: 28,  // langTigrinya → smEthiopic
	    87: 28,  // langOromo → smEthiopic
	    88: 0,  // langSomali → smRoman
	    89: 0,  // langSwahili → smRoman
	    90: 0,  // langKinyarwanda → smRoman
	    91: 0,  // langRundi → smRoman
	    92: 0,  // langNyanja → smRoman
	    93: 0,  // langMalagasy → smRoman
	    94: 0,  // langEsperanto → smRoman
	    128: 0,  // langWelsh → smRoman (modified)
	    129: 0,  // langBasque → smRoman
	    130: 0,  // langCatalan → smRoman
	    131: 0,  // langLatin → smRoman
	    132: 0,  // langQuechua → smRoman
	    133: 0,  // langGuarani → smRoman
	    134: 0,  // langAymara → smRoman
	    135: 7,  // langTatar → smCyrillic
	    136: 4,  // langUighur → smArabic
	    137: 26,  // langDzongkha → smTibetan
	    138: 0,  // langJavaneseRom → smRoman
	    139: 0,  // langSundaneseRom → smRoman
	    140: 0,  // langGalician → smRoman
	    141: 0,  // langAfrikaans → smRoman
	    142: 0,  // langBreton → smRoman (modified)
	    143: 28,  // langInuktitut → smEthiopic (modified)
	    144: 0,  // langScottishGaelic → smRoman (modified)
	    145: 0,  // langManxGaelic → smRoman (modified)
	    146: 0,  // langIrishGaelicScript → smRoman (modified)
	    147: 0,  // langTongan → smRoman
	    148: 6,  // langGreekAncient → smRoman
	    149: 0,  // langGreenlandic → smRoman
	    150: 0,  // langAzerbaijanRoman → smRoman
	    151: 0   // langNynorsk → smRoman
	};

	// While Microsoft indicates a region/country for all its language
	// IDs, we omit the region code if it's equal to the "most likely
	// region subtag" according to Unicode CLDR. For scripts, we omit
	// the subtag if it is equal to the Suppress-Script entry in the
	// IANA language subtag registry for IETF BCP 47.
	//
	// For example, Microsoft states that its language code 0x041A is
	// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
	// and not 'hr-HR' because Croatia is the default country for Croatian,
	// according to Unicode CLDR. As another example, Microsoft states
	// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
	// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
	// for the Croatian language, according to IANA.
	//
	// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
	// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
	var windowsLanguages = {
	    0x0436: 'af',
	    0x041C: 'sq',
	    0x0484: 'gsw',
	    0x045E: 'am',
	    0x1401: 'ar-DZ',
	    0x3C01: 'ar-BH',
	    0x0C01: 'ar',
	    0x0801: 'ar-IQ',
	    0x2C01: 'ar-JO',
	    0x3401: 'ar-KW',
	    0x3001: 'ar-LB',
	    0x1001: 'ar-LY',
	    0x1801: 'ary',
	    0x2001: 'ar-OM',
	    0x4001: 'ar-QA',
	    0x0401: 'ar-SA',
	    0x2801: 'ar-SY',
	    0x1C01: 'aeb',
	    0x3801: 'ar-AE',
	    0x2401: 'ar-YE',
	    0x042B: 'hy',
	    0x044D: 'as',
	    0x082C: 'az-Cyrl',
	    0x042C: 'az',
	    0x046D: 'ba',
	    0x042D: 'eu',
	    0x0423: 'be',
	    0x0845: 'bn',
	    0x0445: 'bn-IN',
	    0x201A: 'bs-Cyrl',
	    0x141A: 'bs',
	    0x047E: 'br',
	    0x0402: 'bg',
	    0x0403: 'ca',
	    0x0C04: 'zh-HK',
	    0x1404: 'zh-MO',
	    0x0804: 'zh',
	    0x1004: 'zh-SG',
	    0x0404: 'zh-TW',
	    0x0483: 'co',
	    0x041A: 'hr',
	    0x101A: 'hr-BA',
	    0x0405: 'cs',
	    0x0406: 'da',
	    0x048C: 'prs',
	    0x0465: 'dv',
	    0x0813: 'nl-BE',
	    0x0413: 'nl',
	    0x0C09: 'en-AU',
	    0x2809: 'en-BZ',
	    0x1009: 'en-CA',
	    0x2409: 'en-029',
	    0x4009: 'en-IN',
	    0x1809: 'en-IE',
	    0x2009: 'en-JM',
	    0x4409: 'en-MY',
	    0x1409: 'en-NZ',
	    0x3409: 'en-PH',
	    0x4809: 'en-SG',
	    0x1C09: 'en-ZA',
	    0x2C09: 'en-TT',
	    0x0809: 'en-GB',
	    0x0409: 'en',
	    0x3009: 'en-ZW',
	    0x0425: 'et',
	    0x0438: 'fo',
	    0x0464: 'fil',
	    0x040B: 'fi',
	    0x080C: 'fr-BE',
	    0x0C0C: 'fr-CA',
	    0x040C: 'fr',
	    0x140C: 'fr-LU',
	    0x180C: 'fr-MC',
	    0x100C: 'fr-CH',
	    0x0462: 'fy',
	    0x0456: 'gl',
	    0x0437: 'ka',
	    0x0C07: 'de-AT',
	    0x0407: 'de',
	    0x1407: 'de-LI',
	    0x1007: 'de-LU',
	    0x0807: 'de-CH',
	    0x0408: 'el',
	    0x046F: 'kl',
	    0x0447: 'gu',
	    0x0468: 'ha',
	    0x040D: 'he',
	    0x0439: 'hi',
	    0x040E: 'hu',
	    0x040F: 'is',
	    0x0470: 'ig',
	    0x0421: 'id',
	    0x045D: 'iu',
	    0x085D: 'iu-Latn',
	    0x083C: 'ga',
	    0x0434: 'xh',
	    0x0435: 'zu',
	    0x0410: 'it',
	    0x0810: 'it-CH',
	    0x0411: 'ja',
	    0x044B: 'kn',
	    0x043F: 'kk',
	    0x0453: 'km',
	    0x0486: 'quc',
	    0x0487: 'rw',
	    0x0441: 'sw',
	    0x0457: 'kok',
	    0x0412: 'ko',
	    0x0440: 'ky',
	    0x0454: 'lo',
	    0x0426: 'lv',
	    0x0427: 'lt',
	    0x082E: 'dsb',
	    0x046E: 'lb',
	    0x042F: 'mk',
	    0x083E: 'ms-BN',
	    0x043E: 'ms',
	    0x044C: 'ml',
	    0x043A: 'mt',
	    0x0481: 'mi',
	    0x047A: 'arn',
	    0x044E: 'mr',
	    0x047C: 'moh',
	    0x0450: 'mn',
	    0x0850: 'mn-CN',
	    0x0461: 'ne',
	    0x0414: 'nb',
	    0x0814: 'nn',
	    0x0482: 'oc',
	    0x0448: 'or',
	    0x0463: 'ps',
	    0x0415: 'pl',
	    0x0416: 'pt',
	    0x0816: 'pt-PT',
	    0x0446: 'pa',
	    0x046B: 'qu-BO',
	    0x086B: 'qu-EC',
	    0x0C6B: 'qu',
	    0x0418: 'ro',
	    0x0417: 'rm',
	    0x0419: 'ru',
	    0x243B: 'smn',
	    0x103B: 'smj-NO',
	    0x143B: 'smj',
	    0x0C3B: 'se-FI',
	    0x043B: 'se',
	    0x083B: 'se-SE',
	    0x203B: 'sms',
	    0x183B: 'sma-NO',
	    0x1C3B: 'sms',
	    0x044F: 'sa',
	    0x1C1A: 'sr-Cyrl-BA',
	    0x0C1A: 'sr',
	    0x181A: 'sr-Latn-BA',
	    0x081A: 'sr-Latn',
	    0x046C: 'nso',
	    0x0432: 'tn',
	    0x045B: 'si',
	    0x041B: 'sk',
	    0x0424: 'sl',
	    0x2C0A: 'es-AR',
	    0x400A: 'es-BO',
	    0x340A: 'es-CL',
	    0x240A: 'es-CO',
	    0x140A: 'es-CR',
	    0x1C0A: 'es-DO',
	    0x300A: 'es-EC',
	    0x440A: 'es-SV',
	    0x100A: 'es-GT',
	    0x480A: 'es-HN',
	    0x080A: 'es-MX',
	    0x4C0A: 'es-NI',
	    0x180A: 'es-PA',
	    0x3C0A: 'es-PY',
	    0x280A: 'es-PE',
	    0x500A: 'es-PR',

	    // Microsoft has defined two different language codes for
	    // “Spanish with modern sorting” and “Spanish with traditional
	    // sorting”. This makes sense for collation APIs, and it would be
	    // possible to express this in BCP 47 language tags via Unicode
	    // extensions (eg., es-u-co-trad is Spanish with traditional
	    // sorting). However, for storing names in fonts, the distinction
	    // does not make sense, so we give “es” in both cases.
	    0x0C0A: 'es',
	    0x040A: 'es',

	    0x540A: 'es-US',
	    0x380A: 'es-UY',
	    0x200A: 'es-VE',
	    0x081D: 'sv-FI',
	    0x041D: 'sv',
	    0x045A: 'syr',
	    0x0428: 'tg',
	    0x085F: 'tzm',
	    0x0449: 'ta',
	    0x0444: 'tt',
	    0x044A: 'te',
	    0x041E: 'th',
	    0x0451: 'bo',
	    0x041F: 'tr',
	    0x0442: 'tk',
	    0x0480: 'ug',
	    0x0422: 'uk',
	    0x042E: 'hsb',
	    0x0420: 'ur',
	    0x0843: 'uz-Cyrl',
	    0x0443: 'uz',
	    0x042A: 'vi',
	    0x0452: 'cy',
	    0x0488: 'wo',
	    0x0485: 'sah',
	    0x0478: 'ii',
	    0x046A: 'yo'
	};

	// Returns a IETF BCP 47 language code, for example 'zh-Hant'
	// for 'Chinese in the traditional script'.
	function getLanguageCode(platformID, languageID, ltag) {
	    switch (platformID) {
	        case 0:  // Unicode
	            if (languageID === 0xFFFF) {
	                return 'und';
	            } else if (ltag) {
	                return ltag[languageID];
	            }

	            break;

	        case 1:  // Macintosh
	            return macLanguages[languageID];

	        case 3:  // Windows
	            return windowsLanguages[languageID];
	    }

	    return undefined;
	}

	var utf16 = 'utf-16';

	// MacOS script ID → encoding. This table stores the default case,
	// which can be overridden by macLanguageEncodings.
	var macScriptEncodings = {
	    0: 'macintosh',           // smRoman
	    1: 'x-mac-japanese',      // smJapanese
	    2: 'x-mac-chinesetrad',   // smTradChinese
	    3: 'x-mac-korean',        // smKorean
	    6: 'x-mac-greek',         // smGreek
	    7: 'x-mac-cyrillic',      // smCyrillic
	    9: 'x-mac-devanagai',     // smDevanagari
	    10: 'x-mac-gurmukhi',     // smGurmukhi
	    11: 'x-mac-gujarati',     // smGujarati
	    12: 'x-mac-oriya',        // smOriya
	    13: 'x-mac-bengali',      // smBengali
	    14: 'x-mac-tamil',        // smTamil
	    15: 'x-mac-telugu',       // smTelugu
	    16: 'x-mac-kannada',      // smKannada
	    17: 'x-mac-malayalam',    // smMalayalam
	    18: 'x-mac-sinhalese',    // smSinhalese
	    19: 'x-mac-burmese',      // smBurmese
	    20: 'x-mac-khmer',        // smKhmer
	    21: 'x-mac-thai',         // smThai
	    22: 'x-mac-lao',          // smLao
	    23: 'x-mac-georgian',     // smGeorgian
	    24: 'x-mac-armenian',     // smArmenian
	    25: 'x-mac-chinesesimp',  // smSimpChinese
	    26: 'x-mac-tibetan',      // smTibetan
	    27: 'x-mac-mongolian',    // smMongolian
	    28: 'x-mac-ethiopic',     // smEthiopic
	    29: 'x-mac-ce',           // smCentralEuroRoman
	    30: 'x-mac-vietnamese',   // smVietnamese
	    31: 'x-mac-extarabic'     // smExtArabic
	};

	// MacOS language ID → encoding. This table stores the exceptional
	// cases, which override macScriptEncodings. For writing MacOS naming
	// tables, we need to emit a MacOS script ID. Therefore, we cannot
	// merge macScriptEncodings into macLanguageEncodings.
	//
	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
	var macLanguageEncodings = {
	    15: 'x-mac-icelandic',    // langIcelandic
	    17: 'x-mac-turkish',      // langTurkish
	    18: 'x-mac-croatian',     // langCroatian
	    24: 'x-mac-ce',           // langLithuanian
	    25: 'x-mac-ce',           // langPolish
	    26: 'x-mac-ce',           // langHungarian
	    27: 'x-mac-ce',           // langEstonian
	    28: 'x-mac-ce',           // langLatvian
	    30: 'x-mac-icelandic',    // langFaroese
	    37: 'x-mac-romanian',     // langRomanian
	    38: 'x-mac-ce',           // langCzech
	    39: 'x-mac-ce',           // langSlovak
	    40: 'x-mac-ce',           // langSlovenian
	    143: 'x-mac-inuit',       // langInuktitut
	    146: 'x-mac-gaelic'       // langIrishGaelicScript
	};

	function getEncoding(platformID, encodingID, languageID) {
	    switch (platformID) {
	        case 0:  // Unicode
	            return utf16;

	        case 1:  // Apple Macintosh
	            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

	        case 3:  // Microsoft Windows
	            if (encodingID === 1 || encodingID === 10) {
	                return utf16;
	            }

	            break;
	    }

	    return undefined;
	}

	// Parse the naming `name` table.
	// FIXME: Format 1 additional fields are not supported yet.
	// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
	function parseNameTable(data, start, ltag) {
	    var name = {};
	    var p = new parse.Parser(data, start);
	    var format = p.parseUShort();
	    var count = p.parseUShort();
	    var stringOffset = p.offset + p.parseUShort();
	    for (var i = 0; i < count; i++) {
	        var platformID = p.parseUShort();
	        var encodingID = p.parseUShort();
	        var languageID = p.parseUShort();
	        var nameID = p.parseUShort();
	        var property = nameTableNames[nameID] || nameID;
	        var byteLength = p.parseUShort();
	        var offset = p.parseUShort();
	        var language = getLanguageCode(platformID, languageID, ltag);
	        var encoding = getEncoding(platformID, encodingID, languageID);
	        if (encoding !== undefined && language !== undefined) {
	            var text = (void 0);
	            if (encoding === utf16) {
	                text = decode.UTF16(data, stringOffset + offset, byteLength);
	            } else {
	                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
	            }

	            if (text) {
	                var translations = name[property];
	                if (translations === undefined) {
	                    translations = name[property] = {};
	                }

	                translations[language] = text;
	            }
	        }
	    }

	    var langTagCount = 0;
	    if (format === 1) {
	        // FIXME: Also handle Microsoft's 'name' table 1.
	        langTagCount = p.parseUShort();
	    }

	    return name;
	}

	// {23: 'foo'} → {'foo': 23}
	// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
	function reverseDict(dict) {
	    var result = {};
	    for (var key in dict) {
	        result[dict[key]] = parseInt(key);
	    }

	    return result;
	}

	function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
	    return new table.Record('NameRecord', [
	        {name: 'platformID', type: 'USHORT', value: platformID},
	        {name: 'encodingID', type: 'USHORT', value: encodingID},
	        {name: 'languageID', type: 'USHORT', value: languageID},
	        {name: 'nameID', type: 'USHORT', value: nameID},
	        {name: 'length', type: 'USHORT', value: length},
	        {name: 'offset', type: 'USHORT', value: offset}
	    ]);
	}

	// Finds the position of needle in haystack, or -1 if not there.
	// Like String.indexOf(), but for arrays.
	function findSubArray(needle, haystack) {
	    var needleLength = needle.length;
	    var limit = haystack.length - needleLength + 1;

	    loop:
	    for (var pos = 0; pos < limit; pos++) {
	        for (; pos < limit; pos++) {
	            for (var k = 0; k < needleLength; k++) {
	                if (haystack[pos + k] !== needle[k]) {
	                    continue loop;
	                }
	            }

	            return pos;
	        }
	    }

	    return -1;
	}

	function addStringToPool(s, pool) {
	    var offset = findSubArray(s, pool);
	    if (offset < 0) {
	        offset = pool.length;
	        var i = 0;
	        var len = s.length;
	        for (; i < len; ++i) {
	            pool.push(s[i]);
	        }

	    }

	    return offset;
	}

	function makeNameTable(names, ltag) {
	    var nameID;
	    var nameIDs = [];

	    var namesWithNumericKeys = {};
	    var nameTableIds = reverseDict(nameTableNames);
	    for (var key in names) {
	        var id = nameTableIds[key];
	        if (id === undefined) {
	            id = key;
	        }

	        nameID = parseInt(id);

	        if (isNaN(nameID)) {
	            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
	        }

	        namesWithNumericKeys[nameID] = names[key];
	        nameIDs.push(nameID);
	    }

	    var macLanguageIds = reverseDict(macLanguages);
	    var windowsLanguageIds = reverseDict(windowsLanguages);

	    var nameRecords = [];
	    var stringPool = [];

	    for (var i = 0; i < nameIDs.length; i++) {
	        nameID = nameIDs[i];
	        var translations = namesWithNumericKeys[nameID];
	        for (var lang in translations) {
	            var text = translations[lang];

	            // For MacOS, we try to emit the name in the form that was introduced
	            // in the initial version of the TrueType spec (in the late 1980s).
	            // However, this can fail for various reasons: the requested BCP 47
	            // language code might not have an old-style Mac equivalent;
	            // we might not have a codec for the needed character encoding;
	            // or the name might contain characters that cannot be expressed
	            // in the old-style Macintosh encoding. In case of failure, we emit
	            // the name in a more modern fashion (Unicode encoding with BCP 47
	            // language tags) that is recognized by MacOS 10.5, released in 2009.
	            // If fonts were only read by operating systems, we could simply
	            // emit all names in the modern form; this would be much easier.
	            // However, there are many applications and libraries that read
	            // 'name' tables directly, and these will usually only recognize
	            // the ancient form (silently skipping the unrecognized names).
	            var macPlatform = 1;  // Macintosh
	            var macLanguage = macLanguageIds[lang];
	            var macScript = macLanguageToScript[macLanguage];
	            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
	            var macName = encode.MACSTRING(text, macEncoding);
	            if (macName === undefined) {
	                macPlatform = 0;  // Unicode
	                macLanguage = ltag.indexOf(lang);
	                if (macLanguage < 0) {
	                    macLanguage = ltag.length;
	                    ltag.push(lang);
	                }

	                macScript = 4;  // Unicode 2.0 and later
	                macName = encode.UTF16(text);
	            }

	            var macNameOffset = addStringToPool(macName, stringPool);
	            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
	                                            nameID, macName.length, macNameOffset));

	            var winLanguage = windowsLanguageIds[lang];
	            if (winLanguage !== undefined) {
	                var winName = encode.UTF16(text);
	                var winNameOffset = addStringToPool(winName, stringPool);
	                nameRecords.push(makeNameRecord(3, 1, winLanguage,
	                                                nameID, winName.length, winNameOffset));
	            }
	        }
	    }

	    nameRecords.sort(function(a, b) {
	        return ((a.platformID - b.platformID) ||
	                (a.encodingID - b.encodingID) ||
	                (a.languageID - b.languageID) ||
	                (a.nameID - b.nameID));
	    });

	    var t = new table.Table('name', [
	        {name: 'format', type: 'USHORT', value: 0},
	        {name: 'count', type: 'USHORT', value: nameRecords.length},
	        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
	    ]);

	    for (var r = 0; r < nameRecords.length; r++) {
	        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
	    }

	    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
	    return t;
	}

	var _name = { parse: parseNameTable, make: makeNameTable };

	// The `OS/2` table contains metrics required in OpenType fonts.

	var unicodeRanges = [
	    {begin: 0x0000, end: 0x007F}, // Basic Latin
	    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
	    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
	    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
	    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
	    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
	    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
	    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
	    {begin: 0x2C80, end: 0x2CFF}, // Coptic
	    {begin: 0x0400, end: 0x04FF}, // Cyrillic
	    {begin: 0x0530, end: 0x058F}, // Armenian
	    {begin: 0x0590, end: 0x05FF}, // Hebrew
	    {begin: 0xA500, end: 0xA63F}, // Vai
	    {begin: 0x0600, end: 0x06FF}, // Arabic
	    {begin: 0x07C0, end: 0x07FF}, // NKo
	    {begin: 0x0900, end: 0x097F}, // Devanagari
	    {begin: 0x0980, end: 0x09FF}, // Bengali
	    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
	    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
	    {begin: 0x0B00, end: 0x0B7F}, // Oriya
	    {begin: 0x0B80, end: 0x0BFF}, // Tamil
	    {begin: 0x0C00, end: 0x0C7F}, // Telugu
	    {begin: 0x0C80, end: 0x0CFF}, // Kannada
	    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
	    {begin: 0x0E00, end: 0x0E7F}, // Thai
	    {begin: 0x0E80, end: 0x0EFF}, // Lao
	    {begin: 0x10A0, end: 0x10FF}, // Georgian
	    {begin: 0x1B00, end: 0x1B7F}, // Balinese
	    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
	    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
	    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
	    {begin: 0x2000, end: 0x206F}, // General Punctuation
	    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
	    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
	    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
	    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
	    {begin: 0x2150, end: 0x218F}, // Number Forms
	    {begin: 0x2190, end: 0x21FF}, // Arrows
	    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
	    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
	    {begin: 0x2400, end: 0x243F}, // Control Pictures
	    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
	    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
	    {begin: 0x2500, end: 0x257F}, // Box Drawing
	    {begin: 0x2580, end: 0x259F}, // Block Elements
	    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
	    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
	    {begin: 0x2700, end: 0x27BF}, // Dingbats
	    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
	    {begin: 0x3040, end: 0x309F}, // Hiragana
	    {begin: 0x30A0, end: 0x30FF}, // Katakana
	    {begin: 0x3100, end: 0x312F}, // Bopomofo
	    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
	    {begin: 0xA840, end: 0xA87F}, // Phags-pa
	    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
	    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
	    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
	    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
	    {begin: 0x10900, end: 0x1091F}, // Phoenicia
	    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
	    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
	    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
	    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
	    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
	    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
	    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
	    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
	    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
	    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
	    {begin: 0xFFF0, end: 0xFFFF}, // Specials
	    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
	    {begin: 0x0700, end: 0x074F}, // Syriac
	    {begin: 0x0780, end: 0x07BF}, // Thaana
	    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
	    {begin: 0x1000, end: 0x109F}, // Myanmar
	    {begin: 0x1200, end: 0x137F}, // Ethiopic
	    {begin: 0x13A0, end: 0x13FF}, // Cherokee
	    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
	    {begin: 0x1680, end: 0x169F}, // Ogham
	    {begin: 0x16A0, end: 0x16FF}, // Runic
	    {begin: 0x1780, end: 0x17FF}, // Khmer
	    {begin: 0x1800, end: 0x18AF}, // Mongolian
	    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
	    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
	    {begin: 0x1700, end: 0x171F}, // Tagalog
	    {begin: 0x10300, end: 0x1032F}, // Old Italic
	    {begin: 0x10330, end: 0x1034F}, // Gothic
	    {begin: 0x10400, end: 0x1044F}, // Deseret
	    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
	    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
	    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
	    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
	    {begin: 0xE0000, end: 0xE007F}, // Tags
	    {begin: 0x1900, end: 0x194F}, // Limbu
	    {begin: 0x1950, end: 0x197F}, // Tai Le
	    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
	    {begin: 0x1A00, end: 0x1A1F}, // Buginese
	    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
	    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
	    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
	    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
	    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
	    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
	    {begin: 0x10380, end: 0x1039F}, // Ugaritic
	    {begin: 0x103A0, end: 0x103DF}, // Old Persian
	    {begin: 0x10450, end: 0x1047F}, // Shavian
	    {begin: 0x10480, end: 0x104AF}, // Osmanya
	    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
	    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
	    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
	    {begin: 0x12000, end: 0x123FF}, // Cuneiform
	    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
	    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
	    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
	    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
	    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
	    {begin: 0xA900, end: 0xA92F}, // Kayah Li
	    {begin: 0xA930, end: 0xA95F}, // Rejang
	    {begin: 0xAA00, end: 0xAA5F}, // Cham
	    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
	    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
	    {begin: 0x102A0, end: 0x102DF}, // Carian
	    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
	];

	function getUnicodeRange(unicode) {
	    for (var i = 0; i < unicodeRanges.length; i += 1) {
	        var range = unicodeRanges[i];
	        if (unicode >= range.begin && unicode < range.end) {
	            return i;
	        }
	    }

	    return -1;
	}

	// Parse the OS/2 and Windows metrics `OS/2` table
	function parseOS2Table(data, start) {
	    var os2 = {};
	    var p = new parse.Parser(data, start);
	    os2.version = p.parseUShort();
	    os2.xAvgCharWidth = p.parseShort();
	    os2.usWeightClass = p.parseUShort();
	    os2.usWidthClass = p.parseUShort();
	    os2.fsType = p.parseUShort();
	    os2.ySubscriptXSize = p.parseShort();
	    os2.ySubscriptYSize = p.parseShort();
	    os2.ySubscriptXOffset = p.parseShort();
	    os2.ySubscriptYOffset = p.parseShort();
	    os2.ySuperscriptXSize = p.parseShort();
	    os2.ySuperscriptYSize = p.parseShort();
	    os2.ySuperscriptXOffset = p.parseShort();
	    os2.ySuperscriptYOffset = p.parseShort();
	    os2.yStrikeoutSize = p.parseShort();
	    os2.yStrikeoutPosition = p.parseShort();
	    os2.sFamilyClass = p.parseShort();
	    os2.panose = [];
	    for (var i = 0; i < 10; i++) {
	        os2.panose[i] = p.parseByte();
	    }

	    os2.ulUnicodeRange1 = p.parseULong();
	    os2.ulUnicodeRange2 = p.parseULong();
	    os2.ulUnicodeRange3 = p.parseULong();
	    os2.ulUnicodeRange4 = p.parseULong();
	    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
	    os2.fsSelection = p.parseUShort();
	    os2.usFirstCharIndex = p.parseUShort();
	    os2.usLastCharIndex = p.parseUShort();
	    os2.sTypoAscender = p.parseShort();
	    os2.sTypoDescender = p.parseShort();
	    os2.sTypoLineGap = p.parseShort();
	    os2.usWinAscent = p.parseUShort();
	    os2.usWinDescent = p.parseUShort();
	    if (os2.version >= 1) {
	        os2.ulCodePageRange1 = p.parseULong();
	        os2.ulCodePageRange2 = p.parseULong();
	    }

	    if (os2.version >= 2) {
	        os2.sxHeight = p.parseShort();
	        os2.sCapHeight = p.parseShort();
	        os2.usDefaultChar = p.parseUShort();
	        os2.usBreakChar = p.parseUShort();
	        os2.usMaxContent = p.parseUShort();
	    }

	    return os2;
	}

	function makeOS2Table(options) {
	    return new table.Table('OS/2', [
	        {name: 'version', type: 'USHORT', value: 0x0003},
	        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
	        {name: 'usWeightClass', type: 'USHORT', value: 0},
	        {name: 'usWidthClass', type: 'USHORT', value: 0},
	        {name: 'fsType', type: 'USHORT', value: 0},
	        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
	        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
	        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
	        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
	        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
	        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
	        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
	        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
	        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
	        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
	        {name: 'sFamilyClass', type: 'SHORT', value: 0},
	        {name: 'bFamilyType', type: 'BYTE', value: 0},
	        {name: 'bSerifStyle', type: 'BYTE', value: 0},
	        {name: 'bWeight', type: 'BYTE', value: 0},
	        {name: 'bProportion', type: 'BYTE', value: 0},
	        {name: 'bContrast', type: 'BYTE', value: 0},
	        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
	        {name: 'bArmStyle', type: 'BYTE', value: 0},
	        {name: 'bLetterform', type: 'BYTE', value: 0},
	        {name: 'bMidline', type: 'BYTE', value: 0},
	        {name: 'bXHeight', type: 'BYTE', value: 0},
	        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
	        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
	        {name: 'fsSelection', type: 'USHORT', value: 0},
	        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
	        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
	        {name: 'sTypoAscender', type: 'SHORT', value: 0},
	        {name: 'sTypoDescender', type: 'SHORT', value: 0},
	        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
	        {name: 'usWinAscent', type: 'USHORT', value: 0},
	        {name: 'usWinDescent', type: 'USHORT', value: 0},
	        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
	        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
	        {name: 'sxHeight', type: 'SHORT', value: 0},
	        {name: 'sCapHeight', type: 'SHORT', value: 0},
	        {name: 'usDefaultChar', type: 'USHORT', value: 0},
	        {name: 'usBreakChar', type: 'USHORT', value: 0},
	        {name: 'usMaxContext', type: 'USHORT', value: 0}
	    ], options);
	}

	var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

	// The `post` table stores additional PostScript information, such as glyph names.

	// Parse the PostScript `post` table
	function parsePostTable(data, start) {
	    var post = {};
	    var p = new parse.Parser(data, start);
	    post.version = p.parseVersion();
	    post.italicAngle = p.parseFixed();
	    post.underlinePosition = p.parseShort();
	    post.underlineThickness = p.parseShort();
	    post.isFixedPitch = p.parseULong();
	    post.minMemType42 = p.parseULong();
	    post.maxMemType42 = p.parseULong();
	    post.minMemType1 = p.parseULong();
	    post.maxMemType1 = p.parseULong();
	    switch (post.version) {
	        case 1:
	            post.names = standardNames.slice();
	            break;
	        case 2:
	            post.numberOfGlyphs = p.parseUShort();
	            post.glyphNameIndex = new Array(post.numberOfGlyphs);
	            for (var i = 0; i < post.numberOfGlyphs; i++) {
	                post.glyphNameIndex[i] = p.parseUShort();
	            }

	            post.names = [];
	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
	                if (post.glyphNameIndex[i$1] >= standardNames.length) {
	                    var nameLength = p.parseChar();
	                    post.names.push(p.parseString(nameLength));
	                }
	            }

	            break;
	        case 2.5:
	            post.numberOfGlyphs = p.parseUShort();
	            post.offset = new Array(post.numberOfGlyphs);
	            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
	                post.offset[i$2] = p.parseChar();
	            }

	            break;
	    }
	    return post;
	}

	function makePostTable() {
	    return new table.Table('post', [
	        {name: 'version', type: 'FIXED', value: 0x00030000},
	        {name: 'italicAngle', type: 'FIXED', value: 0},
	        {name: 'underlinePosition', type: 'FWORD', value: 0},
	        {name: 'underlineThickness', type: 'FWORD', value: 0},
	        {name: 'isFixedPitch', type: 'ULONG', value: 0},
	        {name: 'minMemType42', type: 'ULONG', value: 0},
	        {name: 'maxMemType42', type: 'ULONG', value: 0},
	        {name: 'minMemType1', type: 'ULONG', value: 0},
	        {name: 'maxMemType1', type: 'ULONG', value: 0}
	    ]);
	}

	var post = { parse: parsePostTable, make: makePostTable };

	// The `GSUB` table contains ligatures, among other things.

	var subtableParsers = new Array(9);         // subtableParsers[0] is unused

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
	subtableParsers[1] = function parseLookup1() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();
	    if (substFormat === 1) {
	        return {
	            substFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            deltaGlyphId: this.parseUShort()
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            substitute: this.parseOffset16List()
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
	subtableParsers[2] = function parseLookup2() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        sequences: this.parseListOfLists()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
	subtableParsers[3] = function parseLookup3() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        alternateSets: this.parseListOfLists()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
	subtableParsers[4] = function parseLookup4() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        ligatureSets: this.parseListOfLists(function() {
	            return {
	                ligGlyph: this.parseUShort(),
	                components: this.parseUShortList(this.parseUShort() - 1)
	            };
	        })
	    };
	};

	var lookupRecordDesc = {
	    sequenceIndex: Parser.uShort,
	    lookupListIndex: Parser.uShort
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
	subtableParsers[5] = function parseLookup5() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();

	    if (substFormat === 1) {
	        return {
	            substFormat: substFormat,
	            coverage: this.parsePointer(Parser.coverage),
	            ruleSets: this.parseListOfLists(function() {
	                var glyphCount = this.parseUShort();
	                var substCount = this.parseUShort();
	                return {
	                    input: this.parseUShortList(glyphCount - 1),
	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: substFormat,
	            coverage: this.parsePointer(Parser.coverage),
	            classDef: this.parsePointer(Parser.classDef),
	            classSets: this.parseListOfLists(function() {
	                var glyphCount = this.parseUShort();
	                var substCount = this.parseUShort();
	                return {
	                    classes: this.parseUShortList(glyphCount - 1),
	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 3) {
	        var glyphCount = this.parseUShort();
	        var substCount = this.parseUShort();
	        return {
	            substFormat: substFormat,
	            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
	            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
	subtableParsers[6] = function parseLookup6() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();
	    if (substFormat === 1) {
	        return {
	            substFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            chainRuleSets: this.parseListOfLists(function() {
	                return {
	                    backtrack: this.parseUShortList(),
	                    input: this.parseUShortList(this.parseShort() - 1),
	                    lookahead: this.parseUShortList(),
	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            backtrackClassDef: this.parsePointer(Parser.classDef),
	            inputClassDef: this.parsePointer(Parser.classDef),
	            lookaheadClassDef: this.parsePointer(Parser.classDef),
	            chainClassSet: this.parseListOfLists(function() {
	                return {
	                    backtrack: this.parseUShortList(),
	                    input: this.parseUShortList(this.parseShort() - 1),
	                    lookahead: this.parseUShortList(),
	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 3) {
	        return {
	            substFormat: 3,
	            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            lookupRecords: this.parseRecordList(lookupRecordDesc)
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
	subtableParsers[7] = function parseLookup7() {
	    // Extension Substitution subtable
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
	    var extensionLookupType = this.parseUShort();
	    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
	    return {
	        substFormat: 1,
	        lookupType: extensionLookupType,
	        extension: subtableParsers[extensionLookupType].call(extensionParser)
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
	subtableParsers[8] = function parseLookup8() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	        substitutes: this.parseUShortList()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/gsub.htm
	function parseGsubTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
	    if (tableVersion === 1) {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers)
	        };
	    } else {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers),
	            variations: p.parseFeatureVariationsList()
	        };
	    }

	}

	// GSUB Writing //////////////////////////////////////////////
	var subtableMakers = new Array(9);

	subtableMakers[1] = function makeLookup1(subtable) {
	    if (subtable.substFormat === 1) {
	        return new table.Table('substitutionTable', [
	            {name: 'substFormat', type: 'USHORT', value: 1},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
	            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
	        ]);
	    } else {
	        return new table.Table('substitutionTable', [
	            {name: 'substFormat', type: 'USHORT', value: 2},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	        ].concat(table.ushortList('substitute', subtable.substitute)));
	    }
	};

	subtableMakers[2] = function makeLookup2(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {
	        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));
	    })));
	};

	subtableMakers[3] = function makeLookup3(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
	        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
	    })));
	};

	subtableMakers[4] = function makeLookup4(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
	        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
	            return new table.Table('ligatureTable',
	                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
	                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
	            );
	        }));
	    })));
	};

	subtableMakers[6] = function makeLookup6(subtable) {
	    if (subtable.substFormat === 1) {
	        var returnTable = new table.Table('chainContextTable', [
	            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {
	            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {
	                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)
	                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))
	                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))
	                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));

	                chainRule.lookupRecords.forEach(function (record, i) {
	                    tableData = tableData
	                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
	                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
	                });
	                return new table.Table('chainRuleTable', tableData);
	            }));
	        })));
	        return returnTable;
	    } else if (subtable.substFormat === 2) {
	        check.assert(false, 'lookup type 6 format 2 is not yet supported.');
	    } else if (subtable.substFormat === 3) {
	        var tableData = [
	            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];

	        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});
	        subtable.backtrackCoverage.forEach(function (coverage, i) {
	            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
	        });
	        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});
	        subtable.inputCoverage.forEach(function (coverage, i) {
	            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
	        });
	        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});
	        subtable.lookaheadCoverage.forEach(function (coverage, i) {
	            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
	        });

	        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});
	        subtable.lookupRecords.forEach(function (record, i) {
	            tableData = tableData
	                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
	                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
	        });

	        var returnTable$1 = new table.Table('chainContextTable', tableData);

	        return returnTable$1;
	    }

	    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');
	};

	function makeGsubTable(gsub) {
	    return new table.Table('GSUB', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
	    ]);
	}

	var gsub = { parse: parseGsubTable, make: makeGsubTable };

	// The `GPOS` table contains kerning pairs, among other things.

	// Parse the metadata `meta` table.
	// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
	function parseMetaTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 1, 'Unsupported META table version.');
	    p.parseULong(); // flags - currently unused and set to 0
	    p.parseULong(); // tableOffset
	    var numDataMaps = p.parseULong();

	    var tags = {};
	    for (var i = 0; i < numDataMaps; i++) {
	        var tag = p.parseTag();
	        var dataOffset = p.parseULong();
	        var dataLength = p.parseULong();
	        var text = decode.UTF8(data, start + dataOffset, dataLength);

	        tags[tag] = text;
	    }
	    return tags;
	}

	function makeMetaTable(tags) {
	    var numTags = Object.keys(tags).length;
	    var stringPool = '';
	    var stringPoolOffset = 16 + numTags * 12;

	    var result = new table.Table('meta', [
	        {name: 'version', type: 'ULONG', value: 1},
	        {name: 'flags', type: 'ULONG', value: 0},
	        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
	        {name: 'numTags', type: 'ULONG', value: numTags}
	    ]);

	    for (var tag in tags) {
	        var pos = stringPool.length;
	        stringPool += tags[tag];

	        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
	        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
	        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
	    }

	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

	    return result;
	}

	var meta = { parse: parseMetaTable, make: makeMetaTable };

	// The `sfnt` wrapper provides organization for the tables in the font.

	function log2(v) {
	    return Math.log(v) / Math.log(2) | 0;
	}

	function computeCheckSum(bytes) {
	    while (bytes.length % 4 !== 0) {
	        bytes.push(0);
	    }

	    var sum = 0;
	    for (var i = 0; i < bytes.length; i += 4) {
	        sum += (bytes[i] << 24) +
	            (bytes[i + 1] << 16) +
	            (bytes[i + 2] << 8) +
	            (bytes[i + 3]);
	    }

	    sum %= Math.pow(2, 32);
	    return sum;
	}

	function makeTableRecord(tag, checkSum, offset, length) {
	    return new table.Record('Table Record', [
	        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
	        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
	        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
	        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
	    ]);
	}

	function makeSfntTable(tables) {
	    var sfnt = new table.Table('sfnt', [
	        {name: 'version', type: 'TAG', value: 'OTTO'},
	        {name: 'numTables', type: 'USHORT', value: 0},
	        {name: 'searchRange', type: 'USHORT', value: 0},
	        {name: 'entrySelector', type: 'USHORT', value: 0},
	        {name: 'rangeShift', type: 'USHORT', value: 0}
	    ]);
	    sfnt.tables = tables;
	    sfnt.numTables = tables.length;
	    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
	    sfnt.searchRange = 16 * highestPowerOf2;
	    sfnt.entrySelector = log2(highestPowerOf2);
	    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

	    var recordFields = [];
	    var tableFields = [];

	    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
	    while (offset % 4 !== 0) {
	        offset += 1;
	        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
	    }

	    for (var i = 0; i < tables.length; i += 1) {
	        var t = tables[i];
	        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
	        var tableLength = t.sizeOf();
	        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
	        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
	        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
	        offset += tableLength;
	        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
	        while (offset % 4 !== 0) {
	            offset += 1;
	            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
	        }
	    }

	    // Table records need to be sorted alphabetically.
	    recordFields.sort(function(r1, r2) {
	        if (r1.value.tag > r2.value.tag) {
	            return 1;
	        } else {
	            return -1;
	        }
	    });

	    sfnt.fields = sfnt.fields.concat(recordFields);
	    sfnt.fields = sfnt.fields.concat(tableFields);
	    return sfnt;
	}

	// Get the metrics for a character. If the string has more than one character
	// this function returns metrics for the first available character.
	// You can provide optional fallback metrics if no characters are available.
	function metricsForChar(font, chars, notFoundMetrics) {
	    for (var i = 0; i < chars.length; i += 1) {
	        var glyphIndex = font.charToGlyphIndex(chars[i]);
	        if (glyphIndex > 0) {
	            var glyph = font.glyphs.get(glyphIndex);
	            return glyph.getMetrics();
	        }
	    }

	    return notFoundMetrics;
	}

	function average(vs) {
	    var sum = 0;
	    for (var i = 0; i < vs.length; i += 1) {
	        sum += vs[i];
	    }

	    return sum / vs.length;
	}

	// Convert the font object to a SFNT data structure.
	// This structure contains all the necessary tables and metadata to create a binary OTF file.
	function fontToSfntTable(font) {
	    var xMins = [];
	    var yMins = [];
	    var xMaxs = [];
	    var yMaxs = [];
	    var advanceWidths = [];
	    var leftSideBearings = [];
	    var rightSideBearings = [];
	    var firstCharIndex;
	    var lastCharIndex = 0;
	    var ulUnicodeRange1 = 0;
	    var ulUnicodeRange2 = 0;
	    var ulUnicodeRange3 = 0;
	    var ulUnicodeRange4 = 0;

	    for (var i = 0; i < font.glyphs.length; i += 1) {
	        var glyph = font.glyphs.get(i);
	        var unicode = glyph.unicode | 0;

	        if (isNaN(glyph.advanceWidth)) {
	            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
	        }

	        if (firstCharIndex > unicode || firstCharIndex === undefined) {
	            // ignore .notdef char
	            if (unicode > 0) {
	                firstCharIndex = unicode;
	            }
	        }

	        if (lastCharIndex < unicode) {
	            lastCharIndex = unicode;
	        }

	        var position = os2.getUnicodeRange(unicode);
	        if (position < 32) {
	            ulUnicodeRange1 |= 1 << position;
	        } else if (position < 64) {
	            ulUnicodeRange2 |= 1 << position - 32;
	        } else if (position < 96) {
	            ulUnicodeRange3 |= 1 << position - 64;
	        } else if (position < 123) {
	            ulUnicodeRange4 |= 1 << position - 96;
	        } else {
	            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
	        }
	        // Skip non-important characters.
	        if (glyph.name === '.notdef') { continue; }
	        var metrics = glyph.getMetrics();
	        xMins.push(metrics.xMin);
	        yMins.push(metrics.yMin);
	        xMaxs.push(metrics.xMax);
	        yMaxs.push(metrics.yMax);
	        leftSideBearings.push(metrics.leftSideBearing);
	        rightSideBearings.push(metrics.rightSideBearing);
	        advanceWidths.push(glyph.advanceWidth);
	    }

	    var globals = {
	        xMin: Math.min.apply(null, xMins),
	        yMin: Math.min.apply(null, yMins),
	        xMax: Math.max.apply(null, xMaxs),
	        yMax: Math.max.apply(null, yMaxs),
	        advanceWidthMax: Math.max.apply(null, advanceWidths),
	        advanceWidthAvg: average(advanceWidths),
	        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
	        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
	        minRightSideBearing: Math.min.apply(null, rightSideBearings)
	    };
	    globals.ascender = font.ascender;
	    globals.descender = font.descender;

	    var headTable = head.make({
	        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
	        unitsPerEm: font.unitsPerEm,
	        xMin: globals.xMin,
	        yMin: globals.yMin,
	        xMax: globals.xMax,
	        yMax: globals.yMax,
	        lowestRecPPEM: 3,
	        createdTimestamp: font.createdTimestamp
	    });

	    var hheaTable = hhea.make({
	        ascender: globals.ascender,
	        descender: globals.descender,
	        advanceWidthMax: globals.advanceWidthMax,
	        minLeftSideBearing: globals.minLeftSideBearing,
	        minRightSideBearing: globals.minRightSideBearing,
	        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
	        numberOfHMetrics: font.glyphs.length
	    });

	    var maxpTable = maxp.make(font.glyphs.length);

	    var os2Table = os2.make(Object.assign({
	        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
	        usFirstCharIndex: firstCharIndex,
	        usLastCharIndex: lastCharIndex,
	        ulUnicodeRange1: ulUnicodeRange1,
	        ulUnicodeRange2: ulUnicodeRange2,
	        ulUnicodeRange3: ulUnicodeRange3,
	        ulUnicodeRange4: ulUnicodeRange4,
	        // See http://typophile.com/node/13081 for more info on vertical metrics.
	        // We get metrics for typical characters (such as "x" for xHeight).
	        // We provide some fallback characters if characters are unavailable: their
	        // ordering was chosen experimentally.
	        sTypoAscender: globals.ascender,
	        sTypoDescender: globals.descender,
	        sTypoLineGap: 0,
	        usWinAscent: globals.yMax,
	        usWinDescent: Math.abs(globals.yMin),
	        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
	        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
	        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
	        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
	        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.
	    }, font.tables.os2));

	    var hmtxTable = hmtx.make(font.glyphs);
	    var cmapTable = cmap.make(font.glyphs);

	    var englishFamilyName = font.getEnglishName('fontFamily');
	    var englishStyleName = font.getEnglishName('fontSubfamily');
	    var englishFullName = englishFamilyName + ' ' + englishStyleName;
	    var postScriptName = font.getEnglishName('postScriptName');
	    if (!postScriptName) {
	        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
	    }

	    var names = {};
	    for (var n in font.names) {
	        names[n] = font.names[n];
	    }

	    if (!names.uniqueID) {
	        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
	    }

	    if (!names.postScriptName) {
	        names.postScriptName = {en: postScriptName};
	    }

	    if (!names.preferredFamily) {
	        names.preferredFamily = font.names.fontFamily;
	    }

	    if (!names.preferredSubfamily) {
	        names.preferredSubfamily = font.names.fontSubfamily;
	    }

	    var languageTags = [];
	    var nameTable = _name.make(names, languageTags);
	    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

	    var postTable = post.make();
	    var cffTable = cff.make(font.glyphs, {
	        version: font.getEnglishName('version'),
	        fullName: englishFullName,
	        familyName: englishFamilyName,
	        weightName: englishStyleName,
	        postScriptName: postScriptName,
	        unitsPerEm: font.unitsPerEm,
	        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
	    });

	    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

	    // The order does not matter because makeSfntTable() will sort them.
	    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
	    if (ltagTable) {
	        tables.push(ltagTable);
	    }
	    // Optional tables
	    if (font.tables.gsub) {
	        tables.push(gsub.make(font.tables.gsub));
	    }
	    if (metaTable) {
	        tables.push(metaTable);
	    }

	    var sfntTable = makeSfntTable(tables);

	    // Compute the font's checkSum and store it in head.checkSumAdjustment.
	    var bytes = sfntTable.encode();
	    var checkSum = computeCheckSum(bytes);
	    var tableFields = sfntTable.fields;
	    var checkSumAdjusted = false;
	    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
	        if (tableFields[i$1].name === 'head table') {
	            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
	            checkSumAdjusted = true;
	            break;
	        }
	    }

	    if (!checkSumAdjusted) {
	        throw new Error('Could not find head table with checkSum to adjust.');
	    }

	    return sfntTable;
	}

	var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

	// The Layout object is the prototype of Substitution objects, and provides

	function searchTag(arr, tag) {
	    /* jshint bitwise: false */
	    var imin = 0;
	    var imax = arr.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        var val = arr[imid].tag;
	        if (val === tag) {
	            return imid;
	        } else if (val < tag) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    // Not found: return -1-insertion point
	    return -imin - 1;
	}

	function binSearch(arr, value) {
	    /* jshint bitwise: false */
	    var imin = 0;
	    var imax = arr.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        var val = arr[imid];
	        if (val === value) {
	            return imid;
	        } else if (val < value) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    // Not found: return -1-insertion point
	    return -imin - 1;
	}

	// binary search in a list of ranges (coverage, class definition)
	function searchRange(ranges, value) {
	    // jshint bitwise: false
	    var range;
	    var imin = 0;
	    var imax = ranges.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        range = ranges[imid];
	        var start = range.start;
	        if (start === value) {
	            return range;
	        } else if (start < value) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    if (imin > 0) {
	        range = ranges[imin - 1];
	        if (value > range.end) { return 0; }
	        return range;
	    }
	}

	/**
	 * @exports opentype.Layout
	 * @class
	 */
	function Layout(font, tableName) {
	    this.font = font;
	    this.tableName = tableName;
	}

	Layout.prototype = {

	    /**
	     * Binary search an object by "tag" property
	     * @instance
	     * @function searchTag
	     * @memberof opentype.Layout
	     * @param  {Array} arr
	     * @param  {string} tag
	     * @return {number}
	     */
	    searchTag: searchTag,

	    /**
	     * Binary search in a list of numbers
	     * @instance
	     * @function binSearch
	     * @memberof opentype.Layout
	     * @param  {Array} arr
	     * @param  {number} value
	     * @return {number}
	     */
	    binSearch: binSearch,

	    /**
	     * Get or create the Layout table (GSUB, GPOS etc).
	     * @param  {boolean} create - Whether to create a new one.
	     * @return {Object} The GSUB or GPOS table.
	     */
	    getTable: function(create) {
	        var layout = this.font.tables[this.tableName];
	        if (!layout && create) {
	            layout = this.font.tables[this.tableName] = this.createDefaultTable();
	        }
	        return layout;
	    },

	    /**
	     * Returns all scripts in the substitution table.
	     * @instance
	     * @return {Array}
	     */
	    getScriptNames: function() {
	        var layout = this.getTable();
	        if (!layout) { return []; }
	        return layout.scripts.map(function(script) {
	            return script.tag;
	        });
	    },

	    /**
	     * Returns the best bet for a script name.
	     * Returns 'DFLT' if it exists.
	     * If not, returns 'latn' if it exists.
	     * If neither exist, returns undefined.
	     */
	    getDefaultScriptName: function() {
	        var layout = this.getTable();
	        if (!layout) { return; }
	        var hasLatn = false;
	        for (var i = 0; i < layout.scripts.length; i++) {
	            var name = layout.scripts[i].tag;
	            if (name === 'DFLT') { return name; }
	            if (name === 'latn') { hasLatn = true; }
	        }
	        if (hasLatn) { return 'latn'; }
	    },

	    /**
	     * Returns all LangSysRecords in the given script.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
	     * @return {Object} An object with tag and script properties.
	     */
	    getScriptTable: function(script, create) {
	        var layout = this.getTable(create);
	        if (layout) {
	            script = script || 'DFLT';
	            var scripts = layout.scripts;
	            var pos = searchTag(layout.scripts, script);
	            if (pos >= 0) {
	                return scripts[pos].script;
	            } else if (create) {
	                var scr = {
	                    tag: script,
	                    script: {
	                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
	                        langSysRecords: []
	                    }
	                };
	                scripts.splice(-1 - pos, 0, scr);
	                return scr.script;
	            }
	        }
	    },

	    /**
	     * Returns a language system table
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
	     * @return {Object}
	     */
	    getLangSysTable: function(script, language, create) {
	        var scriptTable = this.getScriptTable(script, create);
	        if (scriptTable) {
	            if (!language || language === 'dflt' || language === 'DFLT') {
	                return scriptTable.defaultLangSys;
	            }
	            var pos = searchTag(scriptTable.langSysRecords, language);
	            if (pos >= 0) {
	                return scriptTable.langSysRecords[pos].langSys;
	            } else if (create) {
	                var langSysRecord = {
	                    tag: language,
	                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
	                };
	                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
	                return langSysRecord.langSys;
	            }
	        }
	    },

	    /**
	     * Get a specific feature table.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
	     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
	     * @return {Object}
	     */
	    getFeatureTable: function(script, language, feature, create) {
	        var langSysTable = this.getLangSysTable(script, language, create);
	        if (langSysTable) {
	            var featureRecord;
	            var featIndexes = langSysTable.featureIndexes;
	            var allFeatures = this.font.tables[this.tableName].features;
	            // The FeatureIndex array of indices is in arbitrary order,
	            // even if allFeatures is sorted alphabetically by feature tag.
	            for (var i = 0; i < featIndexes.length; i++) {
	                featureRecord = allFeatures[featIndexes[i]];
	                if (featureRecord.tag === feature) {
	                    return featureRecord.feature;
	                }
	            }
	            if (create) {
	                var index = allFeatures.length;
	                // Automatic ordering of features would require to shift feature indexes in the script list.
	                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
	                featureRecord = {
	                    tag: feature,
	                    feature: { params: 0, lookupListIndexes: [] }
	                };
	                allFeatures.push(featureRecord);
	                featIndexes.push(index);
	                return featureRecord.feature;
	            }
	        }
	    },

	    /**
	     * Get the lookup tables of a given type for a script/language/feature.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {string} feature - 4-letter feature code
	     * @param {number} lookupType - 1 to 9
	     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
	     * @return {Object[]}
	     */
	    getLookupTables: function(script, language, feature, lookupType, create) {
	        var featureTable = this.getFeatureTable(script, language, feature, create);
	        var tables = [];
	        if (featureTable) {
	            var lookupTable;
	            var lookupListIndexes = featureTable.lookupListIndexes;
	            var allLookups = this.font.tables[this.tableName].lookups;
	            // lookupListIndexes are in no particular order, so use naive search.
	            for (var i = 0; i < lookupListIndexes.length; i++) {
	                lookupTable = allLookups[lookupListIndexes[i]];
	                if (lookupTable.lookupType === lookupType) {
	                    tables.push(lookupTable);
	                }
	            }
	            if (tables.length === 0 && create) {
	                lookupTable = {
	                    lookupType: lookupType,
	                    lookupFlag: 0,
	                    subtables: [],
	                    markFilteringSet: undefined
	                };
	                var index = allLookups.length;
	                allLookups.push(lookupTable);
	                lookupListIndexes.push(index);
	                return [lookupTable];
	            }
	        }
	        return tables;
	    },

	    /**
	     * Find a glyph in a class definition table
	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
	     * @param {object} classDefTable - an OpenType Layout class definition table
	     * @param {number} glyphIndex - the index of the glyph to find
	     * @returns {number} -1 if not found
	     */
	    getGlyphClass: function(classDefTable, glyphIndex) {
	        switch (classDefTable.format) {
	            case 1:
	                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
	                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
	                }
	                return 0;
	            case 2:
	                var range = searchRange(classDefTable.ranges, glyphIndex);
	                return range ? range.classId : 0;
	        }
	    },

	    /**
	     * Find a glyph in a coverage table
	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
	     * @param {object} coverageTable - an OpenType Layout coverage table
	     * @param {number} glyphIndex - the index of the glyph to find
	     * @returns {number} -1 if not found
	     */
	    getCoverageIndex: function(coverageTable, glyphIndex) {
	        switch (coverageTable.format) {
	            case 1:
	                var index = binSearch(coverageTable.glyphs, glyphIndex);
	                return index >= 0 ? index : -1;
	            case 2:
	                var range = searchRange(coverageTable.ranges, glyphIndex);
	                return range ? range.index + glyphIndex - range.start : -1;
	        }
	    },

	    /**
	     * Returns the list of glyph indexes of a coverage table.
	     * Format 1: the list is stored raw
	     * Format 2: compact list as range records.
	     * @instance
	     * @param  {Object} coverageTable
	     * @return {Array}
	     */
	    expandCoverage: function(coverageTable) {
	        if (coverageTable.format === 1) {
	            return coverageTable.glyphs;
	        } else {
	            var glyphs = [];
	            var ranges = coverageTable.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                var start = range.start;
	                var end = range.end;
	                for (var j = start; j <= end; j++) {
	                    glyphs.push(j);
	                }
	            }
	            return glyphs;
	        }
	    }

	};

	// The Position object provides utility methods to manipulate

	/**
	 * @exports opentype.Position
	 * @class
	 * @extends opentype.Layout
	 * @param {opentype.Font}
	 * @constructor
	 */
	function Position(font) {
	    Layout.call(this, font, 'gpos');
	}

	Position.prototype = Layout.prototype;

	/**
	 * Init some data for faster and easier access later.
	 */
	Position.prototype.init = function() {
	    var script = this.getDefaultScriptName();
	    this.defaultKerningTables = this.getKerningTables(script);
	};

	/**
	 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
	 *
	 * @param {integer} leftIndex - left glyph index
	 * @param {integer} rightIndex - right glyph index
	 * @returns {integer}
	 */
	Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
	    for (var i = 0; i < kerningLookups.length; i++) {
	        var subtables = kerningLookups[i].subtables;
	        for (var j = 0; j < subtables.length; j++) {
	            var subtable = subtables[j];
	            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
	            if (covIndex < 0) { continue; }
	            switch (subtable.posFormat) {
	                case 1:
	                    // Search Pair Adjustment Positioning Format 1
	                    var pairSet = subtable.pairSets[covIndex];
	                    for (var k = 0; k < pairSet.length; k++) {
	                        var pair = pairSet[k];
	                        if (pair.secondGlyph === rightIndex) {
	                            return pair.value1 && pair.value1.xAdvance || 0;
	                        }
	                    }
	                    break;      // left glyph found, not right glyph - try next subtable
	                case 2:
	                    // Search Pair Adjustment Positioning Format 2
	                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
	                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
	                    var pair$1 = subtable.classRecords[class1][class2];
	                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
	            }
	        }
	    }
	    return 0;
	};

	/**
	 * List all kerning lookup tables.
	 *
	 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
	 * @param {string} [language='dflt']
	 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
	 */
	Position.prototype.getKerningTables = function(script, language) {
	    if (this.font.tables.gpos) {
	        return this.getLookupTables(script, language, 'kern', 2);
	    }
	};

	// The Substitution object provides utility methods to manipulate

	/**
	 * @exports opentype.Substitution
	 * @class
	 * @extends opentype.Layout
	 * @param {opentype.Font}
	 * @constructor
	 */
	function Substitution(font) {
	    Layout.call(this, font, 'gsub');
	}

	// Check if 2 arrays of primitives are equal.
	function arraysEqual(ar1, ar2) {
	    var n = ar1.length;
	    if (n !== ar2.length) { return false; }
	    for (var i = 0; i < n; i++) {
	        if (ar1[i] !== ar2[i]) { return false; }
	    }
	    return true;
	}

	// Find the first subtable of a lookup table in a particular format.
	function getSubstFormat(lookupTable, format, defaultSubtable) {
	    var subtables = lookupTable.subtables;
	    for (var i = 0; i < subtables.length; i++) {
	        var subtable = subtables[i];
	        if (subtable.substFormat === format) {
	            return subtable;
	        }
	    }
	    if (defaultSubtable) {
	        subtables.push(defaultSubtable);
	        return defaultSubtable;
	    }
	    return undefined;
	}

	Substitution.prototype = Layout.prototype;

	/**
	 * Create a default GSUB table.
	 * @return {Object} gsub - The GSUB table.
	 */
	Substitution.prototype.createDefaultTable = function() {
	    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
	    return {
	        version: 1,
	        scripts: [{
	            tag: 'DFLT',
	            script: {
	                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
	                langSysRecords: []
	            }
	        }],
	        features: [],
	        lookups: []
	    };
	};

	/**
	 * List all single substitutions (lookup type 1) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getSingle = function(feature, script, language) {
	    var substitutions = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 1);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var j = (void 0);
	            if (subtable.substFormat === 1) {
	                var delta = subtable.deltaGlyphId;
	                for (j = 0; j < glyphs.length; j++) {
	                    var glyph = glyphs[j];
	                    substitutions.push({ sub: glyph, by: glyph + delta });
	                }
	            } else {
	                var substitute = subtable.substitute;
	                for (j = 0; j < glyphs.length; j++) {
	                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
	                }
	            }
	        }
	    }
	    return substitutions;
	};

	/**
	 * List all multiple substitutions (lookup type 2) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('ccmp', 'stch')
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getMultiple = function(feature, script, language) {
	    var substitutions = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 2);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var j = (void 0);

	            for (j = 0; j < glyphs.length; j++) {
	                var glyph = glyphs[j];
	                var replacements = subtable.sequences[j];
	                substitutions.push({ sub: glyph, by: replacements });
	            }
	        }
	    }
	    return substitutions;
	};

	/**
	 * List all alternates (lookup type 3) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
	 * @return {Array} alternates - The list of alternates
	 */
	Substitution.prototype.getAlternates = function(feature, script, language) {
	    var alternates = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 3);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var alternateSets = subtable.alternateSets;
	            for (var j = 0; j < glyphs.length; j++) {
	                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
	            }
	        }
	    }
	    return alternates;
	};

	/**
	 * List all ligatures (lookup type 4) for a given script, language, and feature.
	 * The result is an array of ligature objects like { sub: [ids], by: id }
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @return {Array} ligatures - The list of ligatures.
	 */
	Substitution.prototype.getLigatures = function(feature, script, language) {
	    var ligatures = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 4);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var ligatureSets = subtable.ligatureSets;
	            for (var j = 0; j < glyphs.length; j++) {
	                var startGlyph = glyphs[j];
	                var ligSet = ligatureSets[j];
	                for (var k = 0; k < ligSet.length; k++) {
	                    var lig = ligSet[k];
	                    ligatures.push({
	                        sub: [startGlyph].concat(lig.components),
	                        by: lig.ligGlyph
	                    });
	                }
	            }
	        }
	    }
	    return ligatures;
	};

	/**
	 * Add or modify a single substitution (lookup type 1)
	 * Format 2, more flexible, is always used.
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addSingle = function(feature, substitution, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
	    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
	        substFormat: 2,
	        coverage: {format: 1, glyphs: []},
	        substitute: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.substitute.splice(pos, 0, 0);
	    }
	    subtable.substitute[pos] = substitution.by;
	};

	/**
	 * Add or modify a multiple substitution (lookup type 2)
	 * @param {string} feature - 4-letter feature name ('ccmp', 'stch')
	 * @param {Object} substitution - { sub: id, by: [id] } for format 2.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
	    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
	    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1
	        substFormat: 1,
	        coverage: {format: 1, glyphs: []},
	        sequences: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.sequences.splice(pos, 0, 0);
	    }
	    subtable.sequences[pos] = substitution.by;
	};

	/**
	 * Add or modify an alternate substitution (lookup type 3)
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} substitution - { sub: id, by: [ids] }
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
	        substFormat: 1,
	        coverage: {format: 1, glyphs: []},
	        alternateSets: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.alternateSets.splice(pos, 0, 0);
	    }
	    subtable.alternateSets[pos] = substitution.by;
	};

	/**
	 * Add a ligature (lookup type 4)
	 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} ligature - { sub: [ids], by: id }
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addLigature = function(feature, ligature, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
	    var subtable = lookupTable.subtables[0];
	    if (!subtable) {
	        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
	            substFormat: 1,
	            coverage: { format: 1, glyphs: [] },
	            ligatureSets: []
	        };
	        lookupTable.subtables[0] = subtable;
	    }
	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = ligature.sub[0];
	    var ligComponents = ligature.sub.slice(1);
	    var ligatureTable = {
	        ligGlyph: ligature.by,
	        components: ligComponents
	    };
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos >= 0) {
	        // ligatureSet already exists
	        var ligatureSet = subtable.ligatureSets[pos];
	        for (var i = 0; i < ligatureSet.length; i++) {
	            // If ligature already exists, return.
	            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
	                return;
	            }
	        }
	        // ligature does not exist: add it.
	        ligatureSet.push(ligatureTable);
	    } else {
	        // Create a new ligatureSet and add coverage for the first glyph.
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
	    }
	};

	/**
	 * List all feature data for a given script and language.
	 * @param {string} feature - 4-letter feature name
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getFeature = function(feature, script, language) {
	    if (/ss\d\d/.test(feature)) {
	        // ss01 - ss20
	        return this.getSingle(feature, script, language);
	    }
	    switch (feature) {
	        case 'aalt':
	        case 'salt':
	            return this.getSingle(feature, script, language)
	                    .concat(this.getAlternates(feature, script, language));
	        case 'dlig':
	        case 'liga':
	        case 'rlig':
	            return this.getLigatures(feature, script, language);
	        case 'ccmp':
	            return this.getMultiple(feature, script, language)
	                .concat(this.getLigatures(feature, script, language));
	        case 'stch':
	            return this.getMultiple(feature, script, language);
	    }
	    return undefined;
	};

	/**
	 * Add a substitution to a feature for a given script and language.
	 * @param {string} feature - 4-letter feature name
	 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.add = function(feature, sub, script, language) {
	    if (/ss\d\d/.test(feature)) {
	        // ss01 - ss20
	        return this.addSingle(feature, sub, script, language);
	    }
	    switch (feature) {
	        case 'aalt':
	        case 'salt':
	            if (typeof sub.by === 'number') {
	                return this.addSingle(feature, sub, script, language);
	            }
	            return this.addAlternate(feature, sub, script, language);
	        case 'dlig':
	        case 'liga':
	        case 'rlig':
	            return this.addLigature(feature, sub, script, language);
	        case 'ccmp':
	            if (sub.by instanceof Array) {
	                return this.addMultiple(feature, sub, script, language);
	            }
	            return this.addLigature(feature, sub, script, language);
	    }
	    return undefined;
	};

	function isBrowser() {
	    return typeof window !== 'undefined';
	}

	function nodeBufferToArrayBuffer(buffer) {
	    var ab = new ArrayBuffer(buffer.length);
	    var view = new Uint8Array(ab);
	    for (var i = 0; i < buffer.length; ++i) {
	        view[i] = buffer[i];
	    }

	    return ab;
	}

	function arrayBufferToNodeBuffer(ab) {
	    var buffer = new Buffer(ab.byteLength);
	    var view = new Uint8Array(ab);
	    for (var i = 0; i < buffer.length; ++i) {
	        buffer[i] = view[i];
	    }

	    return buffer;
	}

	function checkArgument(expression, message) {
	    if (!expression) {
	        throw message;
	    }
	}

	// The `glyf` table describes the glyphs in TrueType outline format.

	// Parse the coordinate data for a glyph.
	function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
	    var v;
	    if ((flag & shortVectorBitMask) > 0) {
	        // The coordinate is 1 byte long.
	        v = p.parseByte();
	        // The `same` bit is re-used for short values to signify the sign of the value.
	        if ((flag & sameBitMask) === 0) {
	            v = -v;
	        }

	        v = previousValue + v;
	    } else {
	        //  The coordinate is 2 bytes long.
	        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
	        if ((flag & sameBitMask) > 0) {
	            v = previousValue;
	        } else {
	            // Parse the coordinate as a signed 16-bit delta value.
	            v = previousValue + p.parseShort();
	        }
	    }

	    return v;
	}

	// Parse a TrueType glyph.
	function parseGlyph(glyph, data, start) {
	    var p = new parse.Parser(data, start);
	    glyph.numberOfContours = p.parseShort();
	    glyph._xMin = p.parseShort();
	    glyph._yMin = p.parseShort();
	    glyph._xMax = p.parseShort();
	    glyph._yMax = p.parseShort();
	    var flags;
	    var flag;

	    if (glyph.numberOfContours > 0) {
	        // This glyph is not a composite.
	        var endPointIndices = glyph.endPointIndices = [];
	        for (var i = 0; i < glyph.numberOfContours; i += 1) {
	            endPointIndices.push(p.parseUShort());
	        }

	        glyph.instructionLength = p.parseUShort();
	        glyph.instructions = [];
	        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
	            glyph.instructions.push(p.parseByte());
	        }

	        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
	        flags = [];
	        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
	            flag = p.parseByte();
	            flags.push(flag);
	            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
	            if ((flag & 8) > 0) {
	                var repeatCount = p.parseByte();
	                for (var j = 0; j < repeatCount; j += 1) {
	                    flags.push(flag);
	                    i$2 += 1;
	                }
	            }
	        }

	        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

	        if (endPointIndices.length > 0) {
	            var points = [];
	            var point;
	            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
	            if (numberOfCoordinates > 0) {
	                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
	                    flag = flags[i$3];
	                    point = {};
	                    point.onCurve = !!(flag & 1);
	                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
	                    points.push(point);
	                }

	                var px = 0;
	                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
	                    flag = flags[i$4];
	                    point = points[i$4];
	                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
	                    px = point.x;
	                }

	                var py = 0;
	                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
	                    flag = flags[i$5];
	                    point = points[i$5];
	                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
	                    py = point.y;
	                }
	            }

	            glyph.points = points;
	        } else {
	            glyph.points = [];
	        }
	    } else if (glyph.numberOfContours === 0) {
	        glyph.points = [];
	    } else {
	        glyph.isComposite = true;
	        glyph.points = [];
	        glyph.components = [];
	        var moreComponents = true;
	        while (moreComponents) {
	            flags = p.parseUShort();
	            var component = {
	                glyphIndex: p.parseUShort(),
	                xScale: 1,
	                scale01: 0,
	                scale10: 0,
	                yScale: 1,
	                dx: 0,
	                dy: 0
	            };
	            if ((flags & 1) > 0) {
	                // The arguments are words
	                if ((flags & 2) > 0) {
	                    // values are offset
	                    component.dx = p.parseShort();
	                    component.dy = p.parseShort();
	                } else {
	                    // values are matched points
	                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
	                }

	            } else {
	                // The arguments are bytes
	                if ((flags & 2) > 0) {
	                    // values are offset
	                    component.dx = p.parseChar();
	                    component.dy = p.parseChar();
	                } else {
	                    // values are matched points
	                    component.matchedPoints = [p.parseByte(), p.parseByte()];
	                }
	            }

	            if ((flags & 8) > 0) {
	                // We have a scale
	                component.xScale = component.yScale = p.parseF2Dot14();
	            } else if ((flags & 64) > 0) {
	                // We have an X / Y scale
	                component.xScale = p.parseF2Dot14();
	                component.yScale = p.parseF2Dot14();
	            } else if ((flags & 128) > 0) {
	                // We have a 2x2 transformation
	                component.xScale = p.parseF2Dot14();
	                component.scale01 = p.parseF2Dot14();
	                component.scale10 = p.parseF2Dot14();
	                component.yScale = p.parseF2Dot14();
	            }

	            glyph.components.push(component);
	            moreComponents = !!(flags & 32);
	        }
	        if (flags & 0x100) {
	            // We have instructions
	            glyph.instructionLength = p.parseUShort();
	            glyph.instructions = [];
	            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
	                glyph.instructions.push(p.parseByte());
	            }
	        }
	    }
	}

	// Transform an array of points and return a new array.
	function transformPoints(points, transform) {
	    var newPoints = [];
	    for (var i = 0; i < points.length; i += 1) {
	        var pt = points[i];
	        var newPt = {
	            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
	            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
	            onCurve: pt.onCurve,
	            lastPointOfContour: pt.lastPointOfContour
	        };
	        newPoints.push(newPt);
	    }

	    return newPoints;
	}

	function getContours(points) {
	    var contours = [];
	    var currentContour = [];
	    for (var i = 0; i < points.length; i += 1) {
	        var pt = points[i];
	        currentContour.push(pt);
	        if (pt.lastPointOfContour) {
	            contours.push(currentContour);
	            currentContour = [];
	        }
	    }

	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
	    return contours;
	}

	// Convert the TrueType glyph outline to a Path.
	function getPath(points) {
	    var p = new Path();
	    if (!points) {
	        return p;
	    }

	    var contours = getContours(points);

	    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
	        var contour = contours[contourIndex];

	        var prev = null;
	        var curr = contour[contour.length - 1];
	        var next = contour[0];

	        if (curr.onCurve) {
	            p.moveTo(curr.x, curr.y);
	        } else {
	            if (next.onCurve) {
	                p.moveTo(next.x, next.y);
	            } else {
	                // If both first and last points are off-curve, start at their middle.
	                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
	                p.moveTo(start.x, start.y);
	            }
	        }

	        for (var i = 0; i < contour.length; ++i) {
	            prev = curr;
	            curr = next;
	            next = contour[(i + 1) % contour.length];

	            if (curr.onCurve) {
	                // This is a straight line.
	                p.lineTo(curr.x, curr.y);
	            } else {
	                var prev2 = prev;
	                var next2 = next;

	                if (!prev.onCurve) {
	                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
	                }

	                if (!next.onCurve) {
	                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
	                }

	                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
	            }
	        }

	        p.closePath();
	    }
	    return p;
	}

	function buildPath(glyphs, glyph) {
	    if (glyph.isComposite) {
	        for (var j = 0; j < glyph.components.length; j += 1) {
	            var component = glyph.components[j];
	            var componentGlyph = glyphs.get(component.glyphIndex);
	            // Force the ttfGlyphLoader to parse the glyph.
	            componentGlyph.getPath();
	            if (componentGlyph.points) {
	                var transformedPoints = (void 0);
	                if (component.matchedPoints === undefined) {
	                    // component positioned by offset
	                    transformedPoints = transformPoints(componentGlyph.points, component);
	                } else {
	                    // component positioned by matched points
	                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
	                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
	                        throw Error('Matched points out of range in ' + glyph.name);
	                    }
	                    var firstPt = glyph.points[component.matchedPoints[0]];
	                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
	                    var transform = {
	                        xScale: component.xScale, scale01: component.scale01,
	                        scale10: component.scale10, yScale: component.yScale,
	                        dx: 0, dy: 0
	                    };
	                    secondPt = transformPoints([secondPt], transform)[0];
	                    transform.dx = firstPt.x - secondPt.x;
	                    transform.dy = firstPt.y - secondPt.y;
	                    transformedPoints = transformPoints(componentGlyph.points, transform);
	                }
	                glyph.points = glyph.points.concat(transformedPoints);
	            }
	        }
	    }

	    return getPath(glyph.points);
	}

	function parseGlyfTableAll(data, start, loca, font) {
	    var glyphs = new glyphset.GlyphSet(font);

	    // The last element of the loca table is invalid.
	    for (var i = 0; i < loca.length - 1; i += 1) {
	        var offset = loca[i];
	        var nextOffset = loca[i + 1];
	        if (offset !== nextOffset) {
	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
	        } else {
	            glyphs.push(i, glyphset.glyphLoader(font, i));
	        }
	    }

	    return glyphs;
	}

	function parseGlyfTableOnLowMemory(data, start, loca, font) {
	    var glyphs = new glyphset.GlyphSet(font);

	    font._push = function(i) {
	        var offset = loca[i];
	        var nextOffset = loca[i + 1];
	        if (offset !== nextOffset) {
	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
	        } else {
	            glyphs.push(i, glyphset.glyphLoader(font, i));
	        }
	    };

	    return glyphs;
	}

	// Parse all the glyphs according to the offsets from the `loca` table.
	function parseGlyfTable(data, start, loca, font, opt) {
	    if (opt.lowMemory)
	        { return parseGlyfTableOnLowMemory(data, start, loca, font); }
	    else
	        { return parseGlyfTableAll(data, start, loca, font); }
	}

	var glyf = { getPath: getPath, parse: parseGlyfTable};

	/* A TrueType font hinting interpreter.
	*
	* (c) 2017 Axel Kittenberger
	*
	* This interpreter has been implemented according to this documentation:
	* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
	*
	* According to the documentation F24DOT6 values are used for pixels.
	* That means calculation is 1/64 pixel accurate and uses integer operations.
	* However, Javascript has floating point operations by default and only
	* those are available. One could make a case to simulate the 1/64 accuracy
	* exactly by truncating after every division operation
	* (for example with << 0) to get pixel exactly results as other TrueType
	* implementations. It may make sense since some fonts are pixel optimized
	* by hand using DELTAP instructions. The current implementation doesn't
	* and rather uses full floating point precision.
	*
	* xScale, yScale and rotation is currently ignored.
	*
	* A few non-trivial instructions are missing as I didn't encounter yet
	* a font that used them to test a possible implementation.
	*
	* Some fonts seem to use undocumented features regarding the twilight zone.
	* Only some of them are implemented as they were encountered.
	*
	* The exports.DEBUG statements are removed on the minified distribution file.
	*/

	var instructionTable;
	var exec;
	var execGlyph;
	var execComponent;

	/*
	* Creates a hinting object.
	*
	* There ought to be exactly one
	* for each truetype font that is used for hinting.
	*/
	function Hinting(font) {
	    // the font this hinting object is for
	    this.font = font;

	    this.getCommands = function (hPoints) {
	        return glyf.getPath(hPoints).commands;
	    };

	    // cached states
	    this._fpgmState  =
	    this._prepState  =
	        undefined;

	    // errorState
	    // 0 ... all okay
	    // 1 ... had an error in a glyf,
	    //       continue working but stop spamming
	    //       the console
	    // 2 ... error at prep, stop hinting at this ppem
	    // 3 ... error at fpeg, stop hinting for this font at all
	    this._errorState = 0;
	}

	/*
	* Not rounding.
	*/
	function roundOff(v) {
	    return v;
	}

	/*
	* Rounding to grid.
	*/
	function roundToGrid(v) {
	    //Rounding in TT is supposed to "symmetrical around zero"
	    return Math.sign(v) * Math.round(Math.abs(v));
	}

	/*
	* Rounding to double grid.
	*/
	function roundToDoubleGrid(v) {
	    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
	}

	/*
	* Rounding to half grid.
	*/
	function roundToHalfGrid(v) {
	    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
	}

	/*
	* Rounding to up to grid.
	*/
	function roundUpToGrid(v) {
	    return Math.sign(v) * Math.ceil(Math.abs(v));
	}

	/*
	* Rounding to down to grid.
	*/
	function roundDownToGrid(v) {
	    return Math.sign(v) * Math.floor(Math.abs(v));
	}

	/*
	* Super rounding.
	*/
	var roundSuper = function (v) {
	    var period = this.srPeriod;
	    var phase = this.srPhase;
	    var threshold = this.srThreshold;
	    var sign = 1;

	    if (v < 0) {
	        v = -v;
	        sign = -1;
	    }

	    v += threshold - phase;

	    v = Math.trunc(v / period) * period;

	    v += phase;

	    // according to http://xgridfit.sourceforge.net/round.html
	    if (v < 0) { return phase * sign; }

	    return v * sign;
	};

	/*
	* Unit vector of x-axis.
	*/
	var xUnitVector = {
	    x: 1,

	    y: 0,

	    axis: 'x',

	    // Gets the projected distance between two points.
	    // o1/o2 ... if true, respective original position is used.
	    distance: function (p1, p2, o1, o2) {
	        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
	    },

	    // Moves point p so the moved position has the same relative
	    // position to the moved positions of rp1 and rp2 than the
	    // original positions had.
	    //
	    // See APPENDIX on INTERPOLATE at the bottom of this file.
	    interpolate: function (p, rp1, rp2, pv) {
	        var do1;
	        var do2;
	        var doa1;
	        var doa2;
	        var dm1;
	        var dm2;
	        var dt;

	        if (!pv || pv === this) {
	            do1 = p.xo - rp1.xo;
	            do2 = p.xo - rp2.xo;
	            dm1 = rp1.x - rp1.xo;
	            dm2 = rp2.x - rp2.xo;
	            doa1 = Math.abs(do1);
	            doa2 = Math.abs(do2);
	            dt = doa1 + doa2;

	            if (dt === 0) {
	                p.x = p.xo + (dm1 + dm2) / 2;
	                return;
	            }

	            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
	            return;
	        }

	        do1 = pv.distance(p, rp1, true, true);
	        do2 = pv.distance(p, rp2, true, true);
	        dm1 = pv.distance(rp1, rp1, false, true);
	        dm2 = pv.distance(rp2, rp2, false, true);
	        doa1 = Math.abs(do1);
	        doa2 = Math.abs(do2);
	        dt = doa1 + doa2;

	        if (dt === 0) {
	            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	            return;
	        }

	        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	    },

	    // Slope of line normal to this
	    normalSlope: Number.NEGATIVE_INFINITY,

	    // Sets the point 'p' relative to point 'rp'
	    // by the distance 'd'.
	    //
	    // See APPENDIX on SETRELATIVE at the bottom of this file.
	    //
	    // p   ... point to set
	    // rp  ... reference point
	    // d   ... distance on projection vector
	    // pv  ... projection vector (undefined = this)
	    // org ... if true, uses the original position of rp as reference.
	    setRelative: function (p, rp, d, pv, org) {
	        if (!pv || pv === this) {
	            p.x = (org ? rp.xo : rp.x) + d;
	            return;
	        }

	        var rpx = org ? rp.xo : rp.x;
	        var rpy = org ? rp.yo : rp.y;
	        var rpdx = rpx + d * pv.x;
	        var rpdy = rpy + d * pv.y;

	        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
	    },

	    // Slope of vector line.
	    slope: 0,

	    // Touches the point p.
	    touch: function (p) {
	        p.xTouched = true;
	    },

	    // Tests if a point p is touched.
	    touched: function (p) {
	        return p.xTouched;
	    },

	    // Untouches the point p.
	    untouch: function (p) {
	        p.xTouched = false;
	    }
	};

	/*
	* Unit vector of y-axis.
	*/
	var yUnitVector = {
	    x: 0,

	    y: 1,

	    axis: 'y',

	    // Gets the projected distance between two points.
	    // o1/o2 ... if true, respective original position is used.
	    distance: function (p1, p2, o1, o2) {
	        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
	    },

	    // Moves point p so the moved position has the same relative
	    // position to the moved positions of rp1 and rp2 than the
	    // original positions had.
	    //
	    // See APPENDIX on INTERPOLATE at the bottom of this file.
	    interpolate: function (p, rp1, rp2, pv) {
	        var do1;
	        var do2;
	        var doa1;
	        var doa2;
	        var dm1;
	        var dm2;
	        var dt;

	        if (!pv || pv === this) {
	            do1 = p.yo - rp1.yo;
	            do2 = p.yo - rp2.yo;
	            dm1 = rp1.y - rp1.yo;
	            dm2 = rp2.y - rp2.yo;
	            doa1 = Math.abs(do1);
	            doa2 = Math.abs(do2);
	            dt = doa1 + doa2;

	            if (dt === 0) {
	                p.y = p.yo + (dm1 + dm2) / 2;
	                return;
	            }

	            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
	            return;
	        }

	        do1 = pv.distance(p, rp1, true, true);
	        do2 = pv.distance(p, rp2, true, true);
	        dm1 = pv.distance(rp1, rp1, false, true);
	        dm2 = pv.distance(rp2, rp2, false, true);
	        doa1 = Math.abs(do1);
	        doa2 = Math.abs(do2);
	        dt = doa1 + doa2;

	        if (dt === 0) {
	            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	            return;
	        }

	        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	    },

	    // Slope of line normal to this.
	    normalSlope: 0,

	    // Sets the point 'p' relative to point 'rp'
	    // by the distance 'd'
	    //
	    // See APPENDIX on SETRELATIVE at the bottom of this file.
	    //
	    // p   ... point to set
	    // rp  ... reference point
	    // d   ... distance on projection vector
	    // pv  ... projection vector (undefined = this)
	    // org ... if true, uses the original position of rp as reference.
	    setRelative: function (p, rp, d, pv, org) {
	        if (!pv || pv === this) {
	            p.y = (org ? rp.yo : rp.y) + d;
	            return;
	        }

	        var rpx = org ? rp.xo : rp.x;
	        var rpy = org ? rp.yo : rp.y;
	        var rpdx = rpx + d * pv.x;
	        var rpdy = rpy + d * pv.y;

	        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
	    },

	    // Slope of vector line.
	    slope: Number.POSITIVE_INFINITY,

	    // Touches the point p.
	    touch: function (p) {
	        p.yTouched = true;
	    },

	    // Tests if a point p is touched.
	    touched: function (p) {
	        return p.yTouched;
	    },

	    // Untouches the point p.
	    untouch: function (p) {
	        p.yTouched = false;
	    }
	};

	Object.freeze(xUnitVector);
	Object.freeze(yUnitVector);

	/*
	* Creates a unit vector that is not x- or y-axis.
	*/
	function UnitVector(x, y) {
	    this.x = x;
	    this.y = y;
	    this.axis = undefined;
	    this.slope = y / x;
	    this.normalSlope = -x / y;
	    Object.freeze(this);
	}

	/*
	* Gets the projected distance between two points.
	* o1/o2 ... if true, respective original position is used.
	*/
	UnitVector.prototype.distance = function(p1, p2, o1, o2) {
	    return (
	        this.x * xUnitVector.distance(p1, p2, o1, o2) +
	        this.y * yUnitVector.distance(p1, p2, o1, o2)
	    );
	};

	/*
	* Moves point p so the moved position has the same relative
	* position to the moved positions of rp1 and rp2 than the
	* original positions had.
	*
	* See APPENDIX on INTERPOLATE at the bottom of this file.
	*/
	UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
	    var dm1;
	    var dm2;
	    var do1;
	    var do2;
	    var doa1;
	    var doa2;
	    var dt;

	    do1 = pv.distance(p, rp1, true, true);
	    do2 = pv.distance(p, rp2, true, true);
	    dm1 = pv.distance(rp1, rp1, false, true);
	    dm2 = pv.distance(rp2, rp2, false, true);
	    doa1 = Math.abs(do1);
	    doa2 = Math.abs(do2);
	    dt = doa1 + doa2;

	    if (dt === 0) {
	        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	        return;
	    }

	    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	};

	/*
	* Sets the point 'p' relative to point 'rp'
	* by the distance 'd'
	*
	* See APPENDIX on SETRELATIVE at the bottom of this file.
	*
	* p   ...  point to set
	* rp  ... reference point
	* d   ... distance on projection vector
	* pv  ... projection vector (undefined = this)
	* org ... if true, uses the original position of rp as reference.
	*/
	UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
	    pv = pv || this;

	    var rpx = org ? rp.xo : rp.x;
	    var rpy = org ? rp.yo : rp.y;
	    var rpdx = rpx + d * pv.x;
	    var rpdy = rpy + d * pv.y;

	    var pvns = pv.normalSlope;
	    var fvs = this.slope;

	    var px = p.x;
	    var py = p.y;

	    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
	    p.y = fvs * (p.x - px) + py;
	};

	/*
	* Touches the point p.
	*/
	UnitVector.prototype.touch = function(p) {
	    p.xTouched = true;
	    p.yTouched = true;
	};

	/*
	* Returns a unit vector with x/y coordinates.
	*/
	function getUnitVector(x, y) {
	    var d = Math.sqrt(x * x + y * y);

	    x /= d;
	    y /= d;

	    if (x === 1 && y === 0) { return xUnitVector; }
	    else if (x === 0 && y === 1) { return yUnitVector; }
	    else { return new UnitVector(x, y); }
	}

	/*
	* Creates a point in the hinting engine.
	*/
	function HPoint(
	    x,
	    y,
	    lastPointOfContour,
	    onCurve
	) {
	    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
	    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

	    this.lastPointOfContour = lastPointOfContour;
	    this.onCurve = onCurve;
	    this.prevPointOnContour = undefined;
	    this.nextPointOnContour = undefined;
	    this.xTouched = false;
	    this.yTouched = false;

	    Object.preventExtensions(this);
	}

	/*
	* Returns the next touched point on the contour.
	*
	* v  ... unit vector to test touch axis.
	*/
	HPoint.prototype.nextTouched = function(v) {
	    var p = this.nextPointOnContour;

	    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

	    return p;
	};

	/*
	* Returns the previous touched point on the contour
	*
	* v  ... unit vector to test touch axis.
	*/
	HPoint.prototype.prevTouched = function(v) {
	    var p = this.prevPointOnContour;

	    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

	    return p;
	};

	/*
	* The zero point.
	*/
	var HPZero = Object.freeze(new HPoint(0, 0));

	/*
	* The default state of the interpreter.
	*
	* Note: Freezing the defaultState and then deriving from it
	* makes the V8 Javascript engine going awkward,
	* so this is avoided, albeit the defaultState shouldn't
	* ever change.
	*/
	var defaultState = {
	    cvCutIn: 17 / 16,    // control value cut in
	    deltaBase: 9,
	    deltaShift: 0.125,
	    loop: 1,             // loops some instructions
	    minDis: 1,           // minimum distance
	    autoFlip: true
	};

	/*
	* The current state of the interpreter.
	*
	* env  ... 'fpgm' or 'prep' or 'glyf'
	* prog ... the program
	*/
	function State(env, prog) {
	    this.env = env;
	    this.stack = [];
	    this.prog = prog;

	    switch (env) {
	        case 'glyf' :
	            this.zp0 = this.zp1 = this.zp2 = 1;
	            this.rp0 = this.rp1 = this.rp2 = 0;
	            /* fall through */
	        case 'prep' :
	            this.fv = this.pv = this.dpv = xUnitVector;
	            this.round = roundToGrid;
	    }
	}

	/*
	* Executes a glyph program.
	*
	* This does the hinting for each glyph.
	*
	* Returns an array of moved points.
	*
	* glyph: the glyph to hint
	* ppem: the size the glyph is rendered for
	*/
	Hinting.prototype.exec = function(glyph, ppem) {
	    if (typeof ppem !== 'number') {
	        throw new Error('Point size is not a number!');
	    }

	    // Received a fatal error, don't do any hinting anymore.
	    if (this._errorState > 2) { return; }

	    var font = this.font;
	    var prepState = this._prepState;

	    if (!prepState || prepState.ppem !== ppem) {
	        var fpgmState = this._fpgmState;

	        if (!fpgmState) {
	            // Executes the fpgm state.
	            // This is used by fonts to define functions.
	            State.prototype = defaultState;

	            fpgmState =
	            this._fpgmState =
	                new State('fpgm', font.tables.fpgm);

	            fpgmState.funcs = [ ];
	            fpgmState.font = font;

	            if (exports.DEBUG) {
	                console.log('---EXEC FPGM---');
	                fpgmState.step = -1;
	            }

	            try {
	                exec(fpgmState);
	            } catch (e) {
	                console.log('Hinting error in FPGM:' + e);
	                this._errorState = 3;
	                return;
	            }
	        }

	        // Executes the prep program for this ppem setting.
	        // This is used by fonts to set cvt values
	        // depending on to be rendered font size.

	        State.prototype = fpgmState;
	        prepState =
	        this._prepState =
	            new State('prep', font.tables.prep);

	        prepState.ppem = ppem;

	        // Creates a copy of the cvt table
	        // and scales it to the current ppem setting.
	        var oCvt = font.tables.cvt;
	        if (oCvt) {
	            var cvt = prepState.cvt = new Array(oCvt.length);
	            var scale = ppem / font.unitsPerEm;
	            for (var c = 0; c < oCvt.length; c++) {
	                cvt[c] = oCvt[c] * scale;
	            }
	        } else {
	            prepState.cvt = [];
	        }

	        if (exports.DEBUG) {
	            console.log('---EXEC PREP---');
	            prepState.step = -1;
	        }

	        try {
	            exec(prepState);
	        } catch (e) {
	            if (this._errorState < 2) {
	                console.log('Hinting error in PREP:' + e);
	            }
	            this._errorState = 2;
	        }
	    }

	    if (this._errorState > 1) { return; }

	    try {
	        return execGlyph(glyph, prepState);
	    } catch (e) {
	        if (this._errorState < 1) {
	            console.log('Hinting error:' + e);
	            console.log('Note: further hinting errors are silenced');
	        }
	        this._errorState = 1;
	        return undefined;
	    }
	};

	/*
	* Executes the hinting program for a glyph.
	*/
	execGlyph = function(glyph, prepState) {
	    // original point positions
	    var xScale = prepState.ppem / prepState.font.unitsPerEm;
	    var yScale = xScale;
	    var components = glyph.components;
	    var contours;
	    var gZone;
	    var state;

	    State.prototype = prepState;
	    if (!components) {
	        state = new State('glyf', glyph.instructions);
	        if (exports.DEBUG) {
	            console.log('---EXEC GLYPH---');
	            state.step = -1;
	        }
	        execComponent(glyph, state, xScale, yScale);
	        gZone = state.gZone;
	    } else {
	        var font = prepState.font;
	        gZone = [];
	        contours = [];
	        for (var i = 0; i < components.length; i++) {
	            var c = components[i];
	            var cg = font.glyphs.get(c.glyphIndex);

	            state = new State('glyf', cg.instructions);

	            if (exports.DEBUG) {
	                console.log('---EXEC COMP ' + i + '---');
	                state.step = -1;
	            }

	            execComponent(cg, state, xScale, yScale);
	            // appends the computed points to the result array
	            // post processes the component points
	            var dx = Math.round(c.dx * xScale);
	            var dy = Math.round(c.dy * yScale);
	            var gz = state.gZone;
	            var cc = state.contours;
	            for (var pi = 0; pi < gz.length; pi++) {
	                var p = gz[pi];
	                p.xTouched = p.yTouched = false;
	                p.xo = p.x = p.x + dx;
	                p.yo = p.y = p.y + dy;
	            }

	            var gLen = gZone.length;
	            gZone.push.apply(gZone, gz);
	            for (var j = 0; j < cc.length; j++) {
	                contours.push(cc[j] + gLen);
	            }
	        }

	        if (glyph.instructions && !state.inhibitGridFit) {
	            // the composite has instructions on its own
	            state = new State('glyf', glyph.instructions);

	            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

	            state.contours = contours;

	            // note: HPZero cannot be used here, since
	            //       the point might be modified
	            gZone.push(
	                new HPoint(0, 0),
	                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
	            );

	            if (exports.DEBUG) {
	                console.log('---EXEC COMPOSITE---');
	                state.step = -1;
	            }

	            exec(state);

	            gZone.length -= 2;
	        }
	    }

	    return gZone;
	};

	/*
	* Executes the hinting program for a component of a multi-component glyph
	* or of the glyph itself for a non-component glyph.
	*/
	execComponent = function(glyph, state, xScale, yScale)
	{
	    var points = glyph.points || [];
	    var pLen = points.length;
	    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
	    var contours = state.contours = [];

	    // Scales the original points and
	    // makes copies for the hinted points.
	    var cp; // current point
	    for (var i = 0; i < pLen; i++) {
	        cp = points[i];

	        gZone[i] = new HPoint(
	            cp.x * xScale,
	            cp.y * yScale,
	            cp.lastPointOfContour,
	            cp.onCurve
	        );
	    }

	    // Chain links the contours.
	    var sp; // start point
	    var np; // next point

	    for (var i$1 = 0; i$1 < pLen; i$1++) {
	        cp = gZone[i$1];

	        if (!sp) {
	            sp = cp;
	            contours.push(i$1);
	        }

	        if (cp.lastPointOfContour) {
	            cp.nextPointOnContour = sp;
	            sp.prevPointOnContour = cp;
	            sp = undefined;
	        } else {
	            np = gZone[i$1 + 1];
	            cp.nextPointOnContour = np;
	            np.prevPointOnContour = cp;
	        }
	    }

	    if (state.inhibitGridFit) { return; }

	    if (exports.DEBUG) {
	        console.log('PROCESSING GLYPH', state.stack);
	        for (var i$2 = 0; i$2 < pLen; i$2++) {
	            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
	        }
	    }

	    gZone.push(
	        new HPoint(0, 0),
	        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
	    );

	    exec(state);

	    // Removes the extra points.
	    gZone.length -= 2;

	    if (exports.DEBUG) {
	        console.log('FINISHED GLYPH', state.stack);
	        for (var i$3 = 0; i$3 < pLen; i$3++) {
	            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
	        }
	    }
	};

	/*
	* Executes the program loaded in state.
	*/
	exec = function(state) {
	    var prog = state.prog;

	    if (!prog) { return; }

	    var pLen = prog.length;
	    var ins;

	    for (state.ip = 0; state.ip < pLen; state.ip++) {
	        if (exports.DEBUG) { state.step++; }
	        ins = instructionTable[prog[state.ip]];

	        if (!ins) {
	            throw new Error(
	                'unknown instruction: 0x' +
	                Number(prog[state.ip]).toString(16)
	            );
	        }

	        ins(state);

	        // very extensive debugging for each step
	        /*
	        if (exports.DEBUG) {
	            var da;
	            if (state.gZone) {
	                da = [];
	                for (let i = 0; i < state.gZone.length; i++)
	                {
	                    da.push(i + ' ' +
	                        state.gZone[i].x * 64 + ' ' +
	                        state.gZone[i].y * 64 + ' ' +
	                        (state.gZone[i].xTouched ? 'x' : '') +
	                        (state.gZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('GZ', da);
	            }

	            if (state.tZone) {
	                da = [];
	                for (let i = 0; i < state.tZone.length; i++) {
	                    da.push(i + ' ' +
	                        state.tZone[i].x * 64 + ' ' +
	                        state.tZone[i].y * 64 + ' ' +
	                        (state.tZone[i].xTouched ? 'x' : '') +
	                        (state.tZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('TZ', da);
	            }

	            if (state.stack.length > 10) {
	                console.log(
	                    state.stack.length,
	                    '...', state.stack.slice(state.stack.length - 10)
	                );
	            } else {
	                console.log(state.stack.length, state.stack);
	            }
	        }
	        */
	    }
	};

	/*
	* Initializes the twilight zone.
	*
	* This is only done if a SZPx instruction
	* refers to the twilight zone.
	*/
	function initTZone(state)
	{
	    var tZone = state.tZone = new Array(state.gZone.length);

	    // no idea if this is actually correct...
	    for (var i = 0; i < tZone.length; i++)
	    {
	        tZone[i] = new HPoint(0, 0);
	    }
	}

	/*
	* Skips the instruction pointer ahead over an IF/ELSE block.
	* handleElse .. if true breaks on matching ELSE
	*/
	function skip(state, handleElse)
	{
	    var prog = state.prog;
	    var ip = state.ip;
	    var nesting = 1;
	    var ins;

	    do {
	        ins = prog[++ip];
	        if (ins === 0x58) // IF
	            { nesting++; }
	        else if (ins === 0x59) // EIF
	            { nesting--; }
	        else if (ins === 0x40) // NPUSHB
	            { ip += prog[ip + 1] + 1; }
	        else if (ins === 0x41) // NPUSHW
	            { ip += 2 * prog[ip + 1] + 1; }
	        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
	            { ip += ins - 0xB0 + 1; }
	        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
	            { ip += (ins - 0xB8 + 1) * 2; }
	        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
	            { break; }
	    } while (nesting > 0);

	    state.ip = ip;
	}

	/*----------------------------------------------------------*
	*          And then a lot of instructions...                *
	*----------------------------------------------------------*/

	// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
	// 0x00-0x01
	function SVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

	    state.fv = state.pv = state.dpv = v;
	}

	// SPVTCA[a] Set Projection Vector to Coordinate Axis
	// 0x02-0x03
	function SPVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

	    state.pv = state.dpv = v;
	}

	// SFVTCA[a] Set Freedom Vector to Coordinate Axis
	// 0x04-0x05
	function SFVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

	    state.fv = v;
	}

	// SPVTL[a] Set Projection Vector To Line
	// 0x06-0x07
	function SPVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.pv = state.dpv = getUnitVector(dx, dy);
	}

	// SFVTL[a] Set Freedom Vector To Line
	// 0x08-0x09
	function SFVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.fv = getUnitVector(dx, dy);
	}

	// SPVFS[] Set Projection Vector From Stack
	// 0x0A
	function SPVFS(state) {
	    var stack = state.stack;
	    var y = stack.pop();
	    var x = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

	    state.pv = state.dpv = getUnitVector(x, y);
	}

	// SFVFS[] Set Freedom Vector From Stack
	// 0x0B
	function SFVFS(state) {
	    var stack = state.stack;
	    var y = stack.pop();
	    var x = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

	    state.fv = getUnitVector(x, y);
	}

	// GPV[] Get Projection Vector
	// 0x0C
	function GPV(state) {
	    var stack = state.stack;
	    var pv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

	    stack.push(pv.x * 0x4000);
	    stack.push(pv.y * 0x4000);
	}

	// GFV[] Get Freedom Vector
	// 0x0C
	function GFV(state) {
	    var stack = state.stack;
	    var fv = state.fv;

	    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

	    stack.push(fv.x * 0x4000);
	    stack.push(fv.y * 0x4000);
	}

	// SFVTPV[] Set Freedom Vector To Projection Vector
	// 0x0E
	function SFVTPV(state) {
	    state.fv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
	}

	// ISECT[] moves point p to the InterSECTion of two lines
	// 0x0F
	function ISECT(state)
	{
	    var stack = state.stack;
	    var pa0i = stack.pop();
	    var pa1i = stack.pop();
	    var pb0i = stack.pop();
	    var pb1i = stack.pop();
	    var pi = stack.pop();
	    var z0 = state.z0;
	    var z1 = state.z1;
	    var pa0 = z0[pa0i];
	    var pa1 = z0[pa1i];
	    var pb0 = z1[pb0i];
	    var pb1 = z1[pb1i];
	    var p = state.z2[pi];

	    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

	    // math from
	    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

	    var x1 = pa0.x;
	    var y1 = pa0.y;
	    var x2 = pa1.x;
	    var y2 = pa1.y;
	    var x3 = pb0.x;
	    var y3 = pb0.y;
	    var x4 = pb1.x;
	    var y4 = pb1.y;

	    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	    var f1 = x1 * y2 - y1 * x2;
	    var f2 = x3 * y4 - y3 * x4;

	    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
	    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
	}

	// SRP0[] Set Reference Point 0
	// 0x10
	function SRP0(state) {
	    state.rp0 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
	}

	// SRP1[] Set Reference Point 1
	// 0x11
	function SRP1(state) {
	    state.rp1 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
	}

	// SRP1[] Set Reference Point 2
	// 0x12
	function SRP2(state) {
	    state.rp2 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
	}

	// SZP0[] Set Zone Pointer 0
	// 0x13
	function SZP0(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

	    state.zp0 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z0 = state.tZone;
	            break;
	        case 1 :
	            state.z0 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZP1[] Set Zone Pointer 1
	// 0x14
	function SZP1(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

	    state.zp1 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z1 = state.tZone;
	            break;
	        case 1 :
	            state.z1 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZP2[] Set Zone Pointer 2
	// 0x15
	function SZP2(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

	    state.zp2 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z2 = state.tZone;
	            break;
	        case 1 :
	            state.z2 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZPS[] Set Zone PointerS
	// 0x16
	function SZPS(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

	    state.zp0 = state.zp1 = state.zp2 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z0 = state.z1 = state.z2 = state.tZone;
	            break;
	        case 1 :
	            state.z0 = state.z1 = state.z2 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SLOOP[] Set LOOP variable
	// 0x17
	function SLOOP(state) {
	    state.loop = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
	}

	// RTG[] Round To Grid
	// 0x18
	function RTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

	    state.round = roundToGrid;
	}

	// RTHG[] Round To Half Grid
	// 0x19
	function RTHG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

	    state.round = roundToHalfGrid;
	}

	// SMD[] Set Minimum Distance
	// 0x1A
	function SMD(state) {
	    var d = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

	    state.minDis = d / 0x40;
	}

	// ELSE[] ELSE clause
	// 0x1B
	function ELSE(state) {
	    // This instruction has been reached by executing a then branch
	    // so it just skips ahead until matching EIF.
	    //
	    // In case the IF was negative the IF[] instruction already
	    // skipped forward over the ELSE[]

	    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

	    skip(state, false);
	}

	// JMPR[] JuMP Relative
	// 0x1C
	function JMPR(state) {
	    var o = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

	    // A jump by 1 would do nothing.
	    state.ip += o - 1;
	}

	// SCVTCI[] Set Control Value Table Cut-In
	// 0x1D
	function SCVTCI(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

	    state.cvCutIn = n / 0x40;
	}

	// DUP[] DUPlicate top stack element
	// 0x20
	function DUP(state) {
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

	    stack.push(stack[stack.length - 1]);
	}

	// POP[] POP top stack element
	// 0x21
	function POP(state) {
	    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

	    state.stack.pop();
	}

	// CLEAR[] CLEAR the stack
	// 0x22
	function CLEAR(state) {
	    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

	    state.stack.length = 0;
	}

	// SWAP[] SWAP the top two elements on the stack
	// 0x23
	function SWAP(state) {
	    var stack = state.stack;

	    var a = stack.pop();
	    var b = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

	    stack.push(a);
	    stack.push(b);
	}

	// DEPTH[] DEPTH of the stack
	// 0x24
	function DEPTH(state) {
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

	    stack.push(stack.length);
	}

	// LOOPCALL[] LOOPCALL function
	// 0x2A
	function LOOPCALL(state) {
	    var stack = state.stack;
	    var fn = stack.pop();
	    var c = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

	    // saves callers program
	    var cip = state.ip;
	    var cprog = state.prog;

	    state.prog = state.funcs[fn];

	    // executes the function
	    for (var i = 0; i < c; i++) {
	        exec(state);

	        if (exports.DEBUG) { console.log(
	            ++state.step,
	            i + 1 < c ? 'next loopcall' : 'done loopcall',
	            i
	        ); }
	    }

	    // restores the callers program
	    state.ip = cip;
	    state.prog = cprog;
	}

	// CALL[] CALL function
	// 0x2B
	function CALL(state) {
	    var fn = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

	    // saves callers program
	    var cip = state.ip;
	    var cprog = state.prog;

	    state.prog = state.funcs[fn];

	    // executes the function
	    exec(state);

	    // restores the callers program
	    state.ip = cip;
	    state.prog = cprog;

	    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
	}

	// CINDEX[] Copy the INDEXed element to the top of the stack
	// 0x25
	function CINDEX(state) {
	    var stack = state.stack;
	    var k = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

	    // In case of k == 1, it copies the last element after popping
	    // thus stack.length - k.
	    stack.push(stack[stack.length - k]);
	}

	// MINDEX[] Move the INDEXed element to the top of the stack
	// 0x26
	function MINDEX(state) {
	    var stack = state.stack;
	    var k = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

	    stack.push(stack.splice(stack.length - k, 1)[0]);
	}

	// FDEF[] Function DEFinition
	// 0x2C
	function FDEF(state) {
	    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
	    var stack = state.stack;
	    var prog = state.prog;
	    var ip = state.ip;

	    var fn = stack.pop();
	    var ipBegin = ip;

	    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

	    while (prog[++ip] !== 0x2D){ }

	    state.ip = ip;
	    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
	}

	// MDAP[a] Move Direct Absolute Point
	// 0x2E-0x2F
	function MDAP(round, state) {
	    var pi = state.stack.pop();
	    var p = state.z0[pi];
	    var fv = state.fv;
	    var pv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

	    var d = pv.distance(p, HPZero);

	    if (round) { d = state.round(d); }

	    fv.setRelative(p, HPZero, d, pv);
	    fv.touch(p);

	    state.rp0 = state.rp1 = pi;
	}

	// IUP[a] Interpolate Untouched Points through the outline
	// 0x30
	function IUP(v, state) {
	    var z2 = state.z2;
	    var pLen = z2.length - 2;
	    var cp;
	    var pp;
	    var np;

	    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

	    for (var i = 0; i < pLen; i++) {
	        cp = z2[i]; // current point

	        // if this point has been touched go on
	        if (v.touched(cp)) { continue; }

	        pp = cp.prevTouched(v);

	        // no point on the contour has been touched?
	        if (pp === cp) { continue; }

	        np = cp.nextTouched(v);

	        if (pp === np) {
	            // only one point on the contour has been touched
	            // so simply moves the point like that

	            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
	        }

	        v.interpolate(cp, pp, np, v);
	    }
	}

	// SHP[] SHift Point using reference point
	// 0x32-0x33
	function SHP(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var loop = state.loop;
	    var z2 = state.z2;

	    while (loop--)
	    {
	        var pi = stack.pop();
	        var p = z2[pi];

	        var d = pv.distance(rp, rp, false, true);
	        fv.setRelative(p, p, d, pv);
	        fv.touch(p);

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ?
	                   'loop ' + (state.loop - loop) + ': ' :
	                   ''
	                ) +
	                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
	            );
	        }
	    }

	    state.loop = 1;
	}

	// SHC[] SHift Contour using reference point
	// 0x36-0x37
	function SHC(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var ci = stack.pop();
	    var sp = state.z2[state.contours[ci]];
	    var p = sp;

	    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

	    var d = pv.distance(rp, rp, false, true);

	    do {
	        if (p !== rp) { fv.setRelative(p, p, d, pv); }
	        p = p.nextPointOnContour;
	    } while (p !== sp);
	}

	// SHZ[] SHift Zone using reference point
	// 0x36-0x37
	function SHZ(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;

	    var e = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

	    var z;
	    switch (e) {
	        case 0 : z = state.tZone; break;
	        case 1 : z = state.gZone; break;
	        default : throw new Error('Invalid zone');
	    }

	    var p;
	    var d = pv.distance(rp, rp, false, true);
	    var pLen = z.length - 2;
	    for (var i = 0; i < pLen; i++)
	    {
	        p = z[i];
	        fv.setRelative(p, p, d, pv);
	        //if (p !== rp) fv.setRelative(p, p, d, pv);
	    }
	}

	// SHPIX[] SHift point by a PIXel amount
	// 0x38
	function SHPIX(state) {
	    var stack = state.stack;
	    var loop = state.loop;
	    var fv = state.fv;
	    var d = stack.pop() / 0x40;
	    var z2 = state.z2;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z2[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'SHPIX[]', pi, d
	            );
	        }

	        fv.setRelative(p, p, d);
	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// IP[] Interpolate Point
	// 0x39
	function IP(state) {
	    var stack = state.stack;
	    var rp1i = state.rp1;
	    var rp2i = state.rp2;
	    var loop = state.loop;
	    var rp1 = state.z0[rp1i];
	    var rp2 = state.z1[rp2i];
	    var fv = state.fv;
	    var pv = state.dpv;
	    var z2 = state.z2;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z2[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'IP[]', pi, rp1i, '<->', rp2i
	            );
	        }

	        fv.interpolate(p, rp1, rp2, pv);

	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// MSIRP[a] Move Stack Indirect Relative Point
	// 0x3A-0x3B
	function MSIRP(a, state) {
	    var stack = state.stack;
	    var d = stack.pop() / 64;
	    var pi = stack.pop();
	    var p = state.z1[pi];
	    var rp0 = state.z0[state.rp0];
	    var fv = state.fv;
	    var pv = state.pv;

	    fv.setRelative(p, rp0, d, pv);
	    fv.touch(p);

	    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

	    state.rp1 = state.rp0;
	    state.rp2 = pi;
	    if (a) { state.rp0 = pi; }
	}

	// ALIGNRP[] Align to reference point.
	// 0x3C
	function ALIGNRP(state) {
	    var stack = state.stack;
	    var rp0i = state.rp0;
	    var rp0 = state.z0[rp0i];
	    var loop = state.loop;
	    var fv = state.fv;
	    var pv = state.pv;
	    var z1 = state.z1;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z1[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'ALIGNRP[]', pi
	            );
	        }

	        fv.setRelative(p, rp0, 0, pv);
	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// RTG[] Round To Double Grid
	// 0x3D
	function RTDG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

	    state.round = roundToDoubleGrid;
	}

	// MIAP[a] Move Indirect Absolute Point
	// 0x3E-0x3F
	function MIAP(round, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var pi = stack.pop();
	    var p = state.z0[pi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var cv = state.cvt[n];

	    if (exports.DEBUG) {
	        console.log(
	            state.step,
	            'MIAP[' + round + ']',
	            n, '(', cv, ')', pi
	        );
	    }

	    var d = pv.distance(p, HPZero);

	    if (round) {
	        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

	        d = state.round(d);
	    }

	    fv.setRelative(p, HPZero, d, pv);

	    if (state.zp0 === 0) {
	        p.xo = p.x;
	        p.yo = p.y;
	    }

	    fv.touch(p);

	    state.rp0 = state.rp1 = pi;
	}

	// NPUSB[] PUSH N Bytes
	// 0x40
	function NPUSHB(state) {
	    var prog = state.prog;
	    var ip = state.ip;
	    var stack = state.stack;

	    var n = prog[++ip];

	    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

	    state.ip = ip;
	}

	// NPUSHW[] PUSH N Words
	// 0x41
	function NPUSHW(state) {
	    var ip = state.ip;
	    var prog = state.prog;
	    var stack = state.stack;
	    var n = prog[++ip];

	    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

	    for (var i = 0; i < n; i++) {
	        var w = (prog[++ip] << 8) | prog[++ip];
	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
	        stack.push(w);
	    }

	    state.ip = ip;
	}

	// WS[] Write Store
	// 0x42
	function WS(state) {
	    var stack = state.stack;
	    var store = state.store;

	    if (!store) { store = state.store = []; }

	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

	    store[l] = v;
	}

	// RS[] Read Store
	// 0x43
	function RS(state) {
	    var stack = state.stack;
	    var store = state.store;

	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

	    var v = (store && store[l]) || 0;

	    stack.push(v);
	}

	// WCVTP[] Write Control Value Table in Pixel units
	// 0x44
	function WCVTP(state) {
	    var stack = state.stack;

	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

	    state.cvt[l] = v / 0x40;
	}

	// RCVT[] Read Control Value Table entry
	// 0x45
	function RCVT(state) {
	    var stack = state.stack;
	    var cvte = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

	    stack.push(state.cvt[cvte] * 0x40);
	}

	// GC[] Get Coordinate projected onto the projection vector
	// 0x46-0x47
	function GC(a, state) {
	    var stack = state.stack;
	    var pi = stack.pop();
	    var p = state.z2[pi];

	    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

	    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
	}

	// MD[a] Measure Distance
	// 0x49-0x4A
	function MD(a, state) {
	    var stack = state.stack;
	    var pi2 = stack.pop();
	    var pi1 = stack.pop();
	    var p2 = state.z1[pi2];
	    var p1 = state.z0[pi1];
	    var d = state.dpv.distance(p1, p2, a, a);

	    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

	    state.stack.push(Math.round(d * 64));
	}

	// MPPEM[] Measure Pixels Per EM
	// 0x4B
	function MPPEM(state) {
	    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
	    state.stack.push(state.ppem);
	}

	// FLIPON[] set the auto FLIP Boolean to ON
	// 0x4D
	function FLIPON(state) {
	    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
	    state.autoFlip = true;
	}

	// LT[] Less Than
	// 0x50
	function LT(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

	    stack.push(e1 < e2 ? 1 : 0);
	}

	// LTEQ[] Less Than or EQual
	// 0x53
	function LTEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

	    stack.push(e1 <= e2 ? 1 : 0);
	}

	// GTEQ[] Greater Than
	// 0x52
	function GT(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

	    stack.push(e1 > e2 ? 1 : 0);
	}

	// GTEQ[] Greater Than or EQual
	// 0x53
	function GTEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

	    stack.push(e1 >= e2 ? 1 : 0);
	}

	// EQ[] EQual
	// 0x54
	function EQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

	    stack.push(e2 === e1 ? 1 : 0);
	}

	// NEQ[] Not EQual
	// 0x55
	function NEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

	    stack.push(e2 !== e1 ? 1 : 0);
	}

	// ODD[] ODD
	// 0x56
	function ODD(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

	    stack.push(Math.trunc(n) % 2 ? 1 : 0);
	}

	// EVEN[] EVEN
	// 0x57
	function EVEN(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

	    stack.push(Math.trunc(n) % 2 ? 0 : 1);
	}

	// IF[] IF test
	// 0x58
	function IF(state) {
	    var test = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

	    // if test is true it just continues
	    // if not the ip is skipped until matching ELSE or EIF
	    if (!test) {
	        skip(state, true);

	        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }
	    }
	}

	// EIF[] End IF
	// 0x59
	function EIF(state) {
	    // this can be reached normally when
	    // executing an else branch.
	    // -> just ignore it

	    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
	}

	// AND[] logical AND
	// 0x5A
	function AND(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

	    stack.push(e2 && e1 ? 1 : 0);
	}

	// OR[] logical OR
	// 0x5B
	function OR(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

	    stack.push(e2 || e1 ? 1 : 0);
	}

	// NOT[] logical NOT
	// 0x5C
	function NOT(state) {
	    var stack = state.stack;
	    var e = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

	    stack.push(e ? 0 : 1);
	}

	// DELTAP1[] DELTA exception P1
	// DELTAP2[] DELTA exception P2
	// DELTAP3[] DELTA exception P3
	// 0x5D, 0x71, 0x72
	function DELTAP123(b, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var fv = state.fv;
	    var pv = state.pv;
	    var ppem = state.ppem;
	    var base = state.deltaBase + (b - 1) * 16;
	    var ds = state.deltaShift;
	    var z0 = state.z0;

	    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

	    for (var i = 0; i < n; i++) {
	        var pi = stack.pop();
	        var arg = stack.pop();
	        var appem = base + ((arg & 0xF0) >> 4);
	        if (appem !== ppem) { continue; }

	        var mag = (arg & 0x0F) - 8;
	        if (mag >= 0) { mag++; }
	        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

	        var p = z0[pi];
	        fv.setRelative(p, p, mag * ds, pv);
	    }
	}

	// SDB[] Set Delta Base in the graphics state
	// 0x5E
	function SDB(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

	    state.deltaBase = n;
	}

	// SDS[] Set Delta Shift in the graphics state
	// 0x5F
	function SDS(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

	    state.deltaShift = Math.pow(0.5, n);
	}

	// ADD[] ADD
	// 0x60
	function ADD(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

	    stack.push(n1 + n2);
	}

	// SUB[] SUB
	// 0x61
	function SUB(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

	    stack.push(n1 - n2);
	}

	// DIV[] DIV
	// 0x62
	function DIV(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

	    stack.push(n1 * 64 / n2);
	}

	// MUL[] MUL
	// 0x63
	function MUL(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

	    stack.push(n1 * n2 / 64);
	}

	// ABS[] ABSolute value
	// 0x64
	function ABS(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

	    stack.push(Math.abs(n));
	}

	// NEG[] NEGate
	// 0x65
	function NEG(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

	    stack.push(-n);
	}

	// FLOOR[] FLOOR
	// 0x66
	function FLOOR(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

	    stack.push(Math.floor(n / 0x40) * 0x40);
	}

	// CEILING[] CEILING
	// 0x67
	function CEILING(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

	    stack.push(Math.ceil(n / 0x40) * 0x40);
	}

	// ROUND[ab] ROUND value
	// 0x68-0x6B
	function ROUND(dt, state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

	    stack.push(state.round(n / 0x40) * 0x40);
	}

	// WCVTF[] Write Control Value Table in Funits
	// 0x70
	function WCVTF(state) {
	    var stack = state.stack;
	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

	    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
	}

	// DELTAC1[] DELTA exception C1
	// DELTAC2[] DELTA exception C2
	// DELTAC3[] DELTA exception C3
	// 0x73, 0x74, 0x75
	function DELTAC123(b, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var ppem = state.ppem;
	    var base = state.deltaBase + (b - 1) * 16;
	    var ds = state.deltaShift;

	    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

	    for (var i = 0; i < n; i++) {
	        var c = stack.pop();
	        var arg = stack.pop();
	        var appem = base + ((arg & 0xF0) >> 4);
	        if (appem !== ppem) { continue; }

	        var mag = (arg & 0x0F) - 8;
	        if (mag >= 0) { mag++; }

	        var delta = mag * ds;

	        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

	        state.cvt[c] += delta;
	    }
	}

	// SROUND[] Super ROUND
	// 0x76
	function SROUND(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

	    state.round = roundSuper;

	    var period;

	    switch (n & 0xC0) {
	        case 0x00:
	            period = 0.5;
	            break;
	        case 0x40:
	            period = 1;
	            break;
	        case 0x80:
	            period = 2;
	            break;
	        default:
	            throw new Error('invalid SROUND value');
	    }

	    state.srPeriod = period;

	    switch (n & 0x30) {
	        case 0x00:
	            state.srPhase = 0;
	            break;
	        case 0x10:
	            state.srPhase = 0.25 * period;
	            break;
	        case 0x20:
	            state.srPhase = 0.5  * period;
	            break;
	        case 0x30:
	            state.srPhase = 0.75 * period;
	            break;
	        default: throw new Error('invalid SROUND value');
	    }

	    n &= 0x0F;

	    if (n === 0) { state.srThreshold = 0; }
	    else { state.srThreshold = (n / 8 - 0.5) * period; }
	}

	// S45ROUND[] Super ROUND 45 degrees
	// 0x77
	function S45ROUND(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

	    state.round = roundSuper;

	    var period;

	    switch (n & 0xC0) {
	        case 0x00:
	            period = Math.sqrt(2) / 2;
	            break;
	        case 0x40:
	            period = Math.sqrt(2);
	            break;
	        case 0x80:
	            period = 2 * Math.sqrt(2);
	            break;
	        default:
	            throw new Error('invalid S45ROUND value');
	    }

	    state.srPeriod = period;

	    switch (n & 0x30) {
	        case 0x00:
	            state.srPhase = 0;
	            break;
	        case 0x10:
	            state.srPhase = 0.25 * period;
	            break;
	        case 0x20:
	            state.srPhase = 0.5  * period;
	            break;
	        case 0x30:
	            state.srPhase = 0.75 * period;
	            break;
	        default:
	            throw new Error('invalid S45ROUND value');
	    }

	    n &= 0x0F;

	    if (n === 0) { state.srThreshold = 0; }
	    else { state.srThreshold = (n / 8 - 0.5) * period; }
	}

	// ROFF[] Round Off
	// 0x7A
	function ROFF(state) {
	    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

	    state.round = roundOff;
	}

	// RUTG[] Round Up To Grid
	// 0x7C
	function RUTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

	    state.round = roundUpToGrid;
	}

	// RDTG[] Round Down To Grid
	// 0x7D
	function RDTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

	    state.round = roundDownToGrid;
	}

	// SCANCTRL[] SCAN conversion ConTRoL
	// 0x85
	function SCANCTRL(state) {
	    var n = state.stack.pop();

	    // ignored by opentype.js

	    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
	}

	// SDPVTL[a] Set Dual Projection Vector To Line
	// 0x86-0x87
	function SDPVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.dpv = getUnitVector(dx, dy);
	}

	// GETINFO[] GET INFOrmation
	// 0x88
	function GETINFO(state) {
	    var stack = state.stack;
	    var sel = stack.pop();
	    var r = 0;

	    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

	    // v35 as in no subpixel hinting
	    if (sel & 0x01) { r = 35; }

	    // TODO rotation and stretch currently not supported
	    // and thus those GETINFO are always 0.

	    // opentype.js is always gray scaling
	    if (sel & 0x20) { r |= 0x1000; }

	    stack.push(r);
	}

	// ROLL[] ROLL the top three stack elements
	// 0x8A
	function ROLL(state) {
	    var stack = state.stack;
	    var a = stack.pop();
	    var b = stack.pop();
	    var c = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

	    stack.push(b);
	    stack.push(a);
	    stack.push(c);
	}

	// MAX[] MAXimum of top two stack elements
	// 0x8B
	function MAX(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

	    stack.push(Math.max(e1, e2));
	}

	// MIN[] MINimum of top two stack elements
	// 0x8C
	function MIN(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

	    stack.push(Math.min(e1, e2));
	}

	// SCANTYPE[] SCANTYPE
	// 0x8D
	function SCANTYPE(state) {
	    var n = state.stack.pop();
	    // ignored by opentype.js
	    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
	}

	// INSTCTRL[] INSTCTRL
	// 0x8D
	function INSTCTRL(state) {
	    var s = state.stack.pop();
	    var v = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

	    switch (s) {
	        case 1 : state.inhibitGridFit = !!v; return;
	        case 2 : state.ignoreCvt = !!v; return;
	        default: throw new Error('invalid INSTCTRL[] selector');
	    }
	}

	// PUSHB[abc] PUSH Bytes
	// 0xB0-0xB7
	function PUSHB(n, state) {
	    var stack = state.stack;
	    var prog = state.prog;
	    var ip = state.ip;

	    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

	    state.ip = ip;
	}

	// PUSHW[abc] PUSH Words
	// 0xB8-0xBF
	function PUSHW(n, state) {
	    var ip = state.ip;
	    var prog = state.prog;
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

	    for (var i = 0; i < n; i++) {
	        var w = (prog[++ip] << 8) | prog[++ip];
	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
	        stack.push(w);
	    }

	    state.ip = ip;
	}

	// MDRP[abcde] Move Direct Relative Point
	// 0xD0-0xEF
	// (if indirect is 0)
	//
	// and
	//
	// MIRP[abcde] Move Indirect Relative Point
	// 0xE0-0xFF
	// (if indirect is 1)

	function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
	    var stack = state.stack;
	    var cvte = indirect && stack.pop();
	    var pi = stack.pop();
	    var rp0i = state.rp0;
	    var rp = state.z0[rp0i];
	    var p = state.z1[pi];

	    var md = state.minDis;
	    var fv = state.fv;
	    var pv = state.dpv;
	    var od; // original distance
	    var d; // moving distance
	    var sign; // sign of distance
	    var cv;

	    d = od = pv.distance(p, rp, true, true);
	    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

	    // TODO consider autoFlip
	    d = Math.abs(d);

	    if (indirect) {
	        cv = state.cvt[cvte];

	        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
	    }

	    if (keepD && d < md) { d = md; }

	    if (ro) { d = state.round(d); }

	    fv.setRelative(p, rp, sign * d, pv);
	    fv.touch(p);

	    if (exports.DEBUG) {
	        console.log(
	            state.step,
	            (indirect ? 'MIRP[' : 'MDRP[') +
	            (setRp0 ? 'M' : 'm') +
	            (keepD ? '>' : '_') +
	            (ro ? 'R' : '_') +
	            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
	            ']',
	            indirect ?
	                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
	                '',
	            pi,
	            '(d =', od, '->', sign * d, ')'
	        );
	    }

	    state.rp1 = state.rp0;
	    state.rp2 = pi;
	    if (setRp0) { state.rp0 = pi; }
	}

	/*
	* The instruction table.
	*/
	instructionTable = [
	    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
	    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
	    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
	    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
	    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
	    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
	    /* 0x06 */ SPVTL.bind(undefined, 0),
	    /* 0x07 */ SPVTL.bind(undefined, 1),
	    /* 0x08 */ SFVTL.bind(undefined, 0),
	    /* 0x09 */ SFVTL.bind(undefined, 1),
	    /* 0x0A */ SPVFS,
	    /* 0x0B */ SFVFS,
	    /* 0x0C */ GPV,
	    /* 0x0D */ GFV,
	    /* 0x0E */ SFVTPV,
	    /* 0x0F */ ISECT,
	    /* 0x10 */ SRP0,
	    /* 0x11 */ SRP1,
	    /* 0x12 */ SRP2,
	    /* 0x13 */ SZP0,
	    /* 0x14 */ SZP1,
	    /* 0x15 */ SZP2,
	    /* 0x16 */ SZPS,
	    /* 0x17 */ SLOOP,
	    /* 0x18 */ RTG,
	    /* 0x19 */ RTHG,
	    /* 0x1A */ SMD,
	    /* 0x1B */ ELSE,
	    /* 0x1C */ JMPR,
	    /* 0x1D */ SCVTCI,
	    /* 0x1E */ undefined,   // TODO SSWCI
	    /* 0x1F */ undefined,   // TODO SSW
	    /* 0x20 */ DUP,
	    /* 0x21 */ POP,
	    /* 0x22 */ CLEAR,
	    /* 0x23 */ SWAP,
	    /* 0x24 */ DEPTH,
	    /* 0x25 */ CINDEX,
	    /* 0x26 */ MINDEX,
	    /* 0x27 */ undefined,   // TODO ALIGNPTS
	    /* 0x28 */ undefined,
	    /* 0x29 */ undefined,   // TODO UTP
	    /* 0x2A */ LOOPCALL,
	    /* 0x2B */ CALL,
	    /* 0x2C */ FDEF,
	    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
	    /* 0x2E */ MDAP.bind(undefined, 0),
	    /* 0x2F */ MDAP.bind(undefined, 1),
	    /* 0x30 */ IUP.bind(undefined, yUnitVector),
	    /* 0x31 */ IUP.bind(undefined, xUnitVector),
	    /* 0x32 */ SHP.bind(undefined, 0),
	    /* 0x33 */ SHP.bind(undefined, 1),
	    /* 0x34 */ SHC.bind(undefined, 0),
	    /* 0x35 */ SHC.bind(undefined, 1),
	    /* 0x36 */ SHZ.bind(undefined, 0),
	    /* 0x37 */ SHZ.bind(undefined, 1),
	    /* 0x38 */ SHPIX,
	    /* 0x39 */ IP,
	    /* 0x3A */ MSIRP.bind(undefined, 0),
	    /* 0x3B */ MSIRP.bind(undefined, 1),
	    /* 0x3C */ ALIGNRP,
	    /* 0x3D */ RTDG,
	    /* 0x3E */ MIAP.bind(undefined, 0),
	    /* 0x3F */ MIAP.bind(undefined, 1),
	    /* 0x40 */ NPUSHB,
	    /* 0x41 */ NPUSHW,
	    /* 0x42 */ WS,
	    /* 0x43 */ RS,
	    /* 0x44 */ WCVTP,
	    /* 0x45 */ RCVT,
	    /* 0x46 */ GC.bind(undefined, 0),
	    /* 0x47 */ GC.bind(undefined, 1),
	    /* 0x48 */ undefined,   // TODO SCFS
	    /* 0x49 */ MD.bind(undefined, 0),
	    /* 0x4A */ MD.bind(undefined, 1),
	    /* 0x4B */ MPPEM,
	    /* 0x4C */ undefined,   // TODO MPS
	    /* 0x4D */ FLIPON,
	    /* 0x4E */ undefined,   // TODO FLIPOFF
	    /* 0x4F */ undefined,   // TODO DEBUG
	    /* 0x50 */ LT,
	    /* 0x51 */ LTEQ,
	    /* 0x52 */ GT,
	    /* 0x53 */ GTEQ,
	    /* 0x54 */ EQ,
	    /* 0x55 */ NEQ,
	    /* 0x56 */ ODD,
	    /* 0x57 */ EVEN,
	    /* 0x58 */ IF,
	    /* 0x59 */ EIF,
	    /* 0x5A */ AND,
	    /* 0x5B */ OR,
	    /* 0x5C */ NOT,
	    /* 0x5D */ DELTAP123.bind(undefined, 1),
	    /* 0x5E */ SDB,
	    /* 0x5F */ SDS,
	    /* 0x60 */ ADD,
	    /* 0x61 */ SUB,
	    /* 0x62 */ DIV,
	    /* 0x63 */ MUL,
	    /* 0x64 */ ABS,
	    /* 0x65 */ NEG,
	    /* 0x66 */ FLOOR,
	    /* 0x67 */ CEILING,
	    /* 0x68 */ ROUND.bind(undefined, 0),
	    /* 0x69 */ ROUND.bind(undefined, 1),
	    /* 0x6A */ ROUND.bind(undefined, 2),
	    /* 0x6B */ ROUND.bind(undefined, 3),
	    /* 0x6C */ undefined,   // TODO NROUND[ab]
	    /* 0x6D */ undefined,   // TODO NROUND[ab]
	    /* 0x6E */ undefined,   // TODO NROUND[ab]
	    /* 0x6F */ undefined,   // TODO NROUND[ab]
	    /* 0x70 */ WCVTF,
	    /* 0x71 */ DELTAP123.bind(undefined, 2),
	    /* 0x72 */ DELTAP123.bind(undefined, 3),
	    /* 0x73 */ DELTAC123.bind(undefined, 1),
	    /* 0x74 */ DELTAC123.bind(undefined, 2),
	    /* 0x75 */ DELTAC123.bind(undefined, 3),
	    /* 0x76 */ SROUND,
	    /* 0x77 */ S45ROUND,
	    /* 0x78 */ undefined,   // TODO JROT[]
	    /* 0x79 */ undefined,   // TODO JROF[]
	    /* 0x7A */ ROFF,
	    /* 0x7B */ undefined,
	    /* 0x7C */ RUTG,
	    /* 0x7D */ RDTG,
	    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
	    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
	    /* 0x80 */ undefined,   // TODO FLIPPT
	    /* 0x81 */ undefined,   // TODO FLIPRGON
	    /* 0x82 */ undefined,   // TODO FLIPRGOFF
	    /* 0x83 */ undefined,
	    /* 0x84 */ undefined,
	    /* 0x85 */ SCANCTRL,
	    /* 0x86 */ SDPVTL.bind(undefined, 0),
	    /* 0x87 */ SDPVTL.bind(undefined, 1),
	    /* 0x88 */ GETINFO,
	    /* 0x89 */ undefined,   // TODO IDEF
	    /* 0x8A */ ROLL,
	    /* 0x8B */ MAX,
	    /* 0x8C */ MIN,
	    /* 0x8D */ SCANTYPE,
	    /* 0x8E */ INSTCTRL,
	    /* 0x8F */ undefined,
	    /* 0x90 */ undefined,
	    /* 0x91 */ undefined,
	    /* 0x92 */ undefined,
	    /* 0x93 */ undefined,
	    /* 0x94 */ undefined,
	    /* 0x95 */ undefined,
	    /* 0x96 */ undefined,
	    /* 0x97 */ undefined,
	    /* 0x98 */ undefined,
	    /* 0x99 */ undefined,
	    /* 0x9A */ undefined,
	    /* 0x9B */ undefined,
	    /* 0x9C */ undefined,
	    /* 0x9D */ undefined,
	    /* 0x9E */ undefined,
	    /* 0x9F */ undefined,
	    /* 0xA0 */ undefined,
	    /* 0xA1 */ undefined,
	    /* 0xA2 */ undefined,
	    /* 0xA3 */ undefined,
	    /* 0xA4 */ undefined,
	    /* 0xA5 */ undefined,
	    /* 0xA6 */ undefined,
	    /* 0xA7 */ undefined,
	    /* 0xA8 */ undefined,
	    /* 0xA9 */ undefined,
	    /* 0xAA */ undefined,
	    /* 0xAB */ undefined,
	    /* 0xAC */ undefined,
	    /* 0xAD */ undefined,
	    /* 0xAE */ undefined,
	    /* 0xAF */ undefined,
	    /* 0xB0 */ PUSHB.bind(undefined, 1),
	    /* 0xB1 */ PUSHB.bind(undefined, 2),
	    /* 0xB2 */ PUSHB.bind(undefined, 3),
	    /* 0xB3 */ PUSHB.bind(undefined, 4),
	    /* 0xB4 */ PUSHB.bind(undefined, 5),
	    /* 0xB5 */ PUSHB.bind(undefined, 6),
	    /* 0xB6 */ PUSHB.bind(undefined, 7),
	    /* 0xB7 */ PUSHB.bind(undefined, 8),
	    /* 0xB8 */ PUSHW.bind(undefined, 1),
	    /* 0xB9 */ PUSHW.bind(undefined, 2),
	    /* 0xBA */ PUSHW.bind(undefined, 3),
	    /* 0xBB */ PUSHW.bind(undefined, 4),
	    /* 0xBC */ PUSHW.bind(undefined, 5),
	    /* 0xBD */ PUSHW.bind(undefined, 6),
	    /* 0xBE */ PUSHW.bind(undefined, 7),
	    /* 0xBF */ PUSHW.bind(undefined, 8),
	    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
	    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
	    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
	    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
	    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
	    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
	    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
	    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
	    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
	    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
	    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
	    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
	    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
	    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
	    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
	    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
	    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
	    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
	    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
	    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
	    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
	    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
	    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
	    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
	    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
	    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
	    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
	    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
	    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
	    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
	    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
	    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
	    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
	    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
	    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
	    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
	    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
	    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
	    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
	    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
	    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
	    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
	    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
	    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
	    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
	    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
	    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
	    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
	    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
	    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
	    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
	    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
	    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
	    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
	    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
	    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
	    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
	    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
	    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
	    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
	    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
	    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
	    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
	    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
	];

	/*****************************
	  Mathematical Considerations
	******************************

	fv ... refers to freedom vector
	pv ... refers to projection vector
	rp ... refers to reference point
	p  ... refers to to point being operated on
	d  ... refers to distance

	SETRELATIVE:
	============

	case freedom vector == x-axis:
	------------------------------

	                        (pv)
	                     .-'
	              rpd .-'
	               .-*
	          d .-'90°'
	         .-'       '
	      .-'           '
	   *-'               ' b
	  rp                  '
	                       '
	                        '
	            p *----------*-------------- (fv)
	                          pm

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b

	   y - rpdy = pvns * (x- rpdx)

	   y = p.y

	   x = rpdx + ( p.y - rpdy ) / pvns


	case freedom vector == y-axis:
	------------------------------

	    * pm
	    |\
	    | \
	    |  \
	    |   \
	    |    \
	    |     \
	    |      \
	    |       \
	    |        \
	    |         \ b
	    |          \
	    |           \
	    |            \    .-' (pv)
	    |         90° \.-'
	    |           .-'* rpd
	    |        .-'
	    *     *-'  d
	    p     rp

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b:
	           pvns ... normal slope to pv

	   y - rpdy = pvns * (x - rpdx)

	   x = p.x

	   y = rpdy +  pvns * (p.x - rpdx)



	generic case:
	-------------


	                              .'(fv)
	                            .'
	                          .* pm
	                        .' !
	                      .'    .
	                    .'      !
	                  .'         . b
	                .'           !
	               *              .
	              p               !
	                         90°   .    ... (pv)
	                           ...-*-'''
	                  ...---'''    rpd
	         ...---'''   d
	   *--'''
	  rp

	    rpdx = rpx + d * pv.x
	    rpdy = rpy + d * pv.y

	 equation of line b:
	    pvns... normal slope to pv

	    y - rpdy = pvns * (x - rpdx)

	 equation of freedom vector line:
	    fvs ... slope of freedom vector (=fy/fx)

	    y - py = fvs * (x - px)


	  on pm both equations are true for same x/y

	    y - rpdy = pvns * (x - rpdx)

	    y - py = fvs * (x - px)

	  form to y and set equal:

	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

	  expand:

	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

	  switch:

	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

	  solve for x:

	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



	          fvs * px - pvns * rpdx + rpdy - py
	    x =  -----------------------------------
	                 fvs - pvns

	  and:

	    y = fvs * (x - px) + py



	INTERPOLATE:
	============

	Examples of point interpolation.

	The weight of the movement of the reference point gets bigger
	the further the other reference point is away, thus the safest
	option (that is avoiding 0/0 divisions) is to weight the
	original distance of the other point by the sum of both distances.

	If the sum of both distances is 0, then move the point by the
	arithmetic average of the movement of both reference points.




	           (+6)
	    rp1o *---->*rp1
	         .     .                          (+12)
	         .     .                  rp2o *---------->* rp2
	         .     .                       .           .
	         .     .                       .           .
	         .    10          20           .           .
	         |.........|...................|           .
	               .   .                               .
	               .   . (+8)                          .
	                po *------>*p                      .
	               .           .                       .
	               .    12     .          24           .
	               |...........|.......................|
	                                  36


	-------



	           (+10)
	    rp1o *-------->*rp1
	         .         .                      (-10)
	         .         .              rp2 *<---------* rpo2
	         .         .                   .         .
	         .         .                   .         .
	         .    10   .          30       .         .
	         |.........|.............................|
	                   .                   .
	                   . (+5)              .
	                po *--->* p            .
	                   .    .              .
	                   .    .   20         .
	                   |....|..............|
	                     5        15


	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .
	    rp2o *-------->*rp2


	                               (+10)
	                          po *-------->* p

	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .(+30)
	    rp2o *---------------------------->*rp2


	                                        (+25)
	                          po *----------------------->* p



	vim: set ts=4 sw=4 expandtab:
	*****/

	/**
	 * Converts a string into a list of tokens.
	 */

	/**
	 * Create a new token
	 * @param {string} char a single char
	 */
	function Token(char) {
	    this.char = char;
	    this.state = {};
	    this.activeState = null;
	}

	/**
	 * Create a new context range
	 * @param {number} startIndex range start index
	 * @param {number} endOffset range end index offset
	 * @param {string} contextName owner context name
	 */
	function ContextRange(startIndex, endOffset, contextName) {
	    this.contextName = contextName;
	    this.startIndex = startIndex;
	    this.endOffset = endOffset;
	}

	/**
	 * Check context start and end
	 * @param {string} contextName a unique context name
	 * @param {function} checkStart a predicate function the indicates a context's start
	 * @param {function} checkEnd a predicate function the indicates a context's end
	 */
	function ContextChecker(contextName, checkStart, checkEnd) {
	    this.contextName = contextName;
	    this.openRange = null;
	    this.ranges = [];
	    this.checkStart = checkStart;
	    this.checkEnd = checkEnd;
	}

	/**
	 * @typedef ContextParams
	 * @type Object
	 * @property {array} context context items
	 * @property {number} currentIndex current item index
	 */

	/**
	 * Create a context params
	 * @param {array} context a list of items
	 * @param {number} currentIndex current item index
	 */
	function ContextParams(context, currentIndex) {
	    this.context = context;
	    this.index = currentIndex;
	    this.length = context.length;
	    this.current = context[currentIndex];
	    this.backtrack = context.slice(0, currentIndex);
	    this.lookahead = context.slice(currentIndex + 1);
	}

	/**
	 * Create an event instance
	 * @param {string} eventId event unique id
	 */
	function Event(eventId) {
	    this.eventId = eventId;
	    this.subscribers = [];
	}

	/**
	 * Initialize a core events and auto subscribe required event handlers
	 * @param {any} events an object that enlists core events handlers
	 */
	function initializeCoreEvents(events) {
	    var this$1 = this;

	    var coreEvents = [
	        'start', 'end', 'next', 'newToken', 'contextStart',
	        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
	        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
	    ];

	    coreEvents.forEach(function (eventId) {
	        Object.defineProperty(this$1.events, eventId, {
	            value: new Event(eventId)
	        });
	    });

	    if (!!events) {
	        coreEvents.forEach(function (eventId) {
	            var event = events[eventId];
	            if (typeof event === 'function') {
	                this$1.events[eventId].subscribe(event);
	            }
	        });
	    }
	    var requiresContextUpdate = [
	        'insertToken', 'removeToken', 'removeRange',
	        'replaceToken', 'replaceRange', 'composeRUD'
	    ];
	    requiresContextUpdate.forEach(function (eventId) {
	        this$1.events[eventId].subscribe(
	            this$1.updateContextsRanges
	        );
	    });
	}

	/**
	 * Converts a string into a list of tokens
	 * @param {any} events tokenizer core events
	 */
	function Tokenizer(events) {
	    this.tokens = [];
	    this.registeredContexts = {};
	    this.contextCheckers = [];
	    this.events = {};
	    this.registeredModifiers = [];

	    initializeCoreEvents.call(this, events);
	}

	/**
	 * Sets the state of a token, usually called by a state modifier.
	 * @param {string} key state item key
	 * @param {any} value state item value
	 */
	Token.prototype.setState = function(key, value) {
	    this.state[key] = value;
	    this.activeState = { key: key, value: this.state[key] };
	    return this.activeState;
	};

	Token.prototype.getState = function (stateId) {
	    return this.state[stateId] || null;
	};

	/**
	 * Checks if an index exists in the tokens list.
	 * @param {number} index token index
	 */
	Tokenizer.prototype.inboundIndex = function(index) {
	    return index >= 0 && index < this.tokens.length;
	};

	/**
	 * Compose and apply a list of operations (replace, update, delete)
	 * @param {array} RUDs replace, update and delete operations
	 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
	 */
	Tokenizer.prototype.composeRUD = function (RUDs) {
	    var this$1 = this;

	    var silent = true;
	    var state = RUDs.map(function (RUD) { return (
	        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))
	    ); });
	    var hasFAILObject = function (obj) { return (
	        typeof obj === 'object' &&
	        obj.hasOwnProperty('FAIL')
	    ); };
	    if (state.every(hasFAILObject)) {
	        return {
	            FAIL: "composeRUD: one or more operations hasn't completed successfully",
	            report: state.filter(hasFAILObject)
	        };
	    }
	    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
	};

	/**
	 * Replace a range of tokens with a list of tokens
	 * @param {number} startIndex range start index
	 * @param {number} offset range offset
	 * @param {token} tokens a list of tokens to replace
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
	    offset = offset !== null ? offset : this.tokens.length;
	    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
	    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
	        var replaced = this.tokens.splice.apply(
	            this.tokens, [startIndex, offset].concat(tokens)
	        );
	        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
	        return [replaced, tokens];
	    } else {
	        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
	    }
	};

	/**
	 * Replace a token with another token
	 * @param {number} index token index
	 * @param {token} token a token to replace
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.replaceToken = function (index, token, silent) {
	    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
	        var replaced = this.tokens.splice(index, 1, token);
	        if (!silent) { this.dispatch('replaceToken', [index, token]); }
	        return [replaced[0], token];
	    } else {
	        return { FAIL: 'replaceToken: invalid token or index.' };
	    }
	};

	/**
	 * Removes a range of tokens
	 * @param {number} startIndex range start index
	 * @param {number} offset range offset
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
	    offset = !isNaN(offset) ? offset : this.tokens.length;
	    var tokens = this.tokens.splice(startIndex, offset);
	    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
	    return tokens;
	};

	/**
	 * Remove a token at a certain index
	 * @param {number} index token index
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.removeToken = function(index, silent) {
	    if (!isNaN(index) && this.inboundIndex(index)) {
	        var token = this.tokens.splice(index, 1);
	        if (!silent) { this.dispatch('removeToken', [token, index]); }
	        return token;
	    } else {
	        return { FAIL: 'removeToken: invalid token index.' };
	    }
	};

	/**
	 * Insert a list of tokens at a certain index
	 * @param {array} tokens a list of tokens to insert
	 * @param {number} index insert the list of tokens at index
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.insertToken = function (tokens, index, silent) {
	    var tokenType = tokens.every(
	        function (token) { return token instanceof Token; }
	    );
	    if (tokenType) {
	        this.tokens.splice.apply(
	            this.tokens, [index, 0].concat(tokens)
	        );
	        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
	        return tokens;
	    } else {
	        return { FAIL: 'insertToken: invalid token(s).' };
	    }
	};

	/**
	 * A state modifier that is called on 'newToken' event
	 * @param {string} modifierId state modifier id
	 * @param {function} condition a predicate function that returns true or false
	 * @param {function} modifier a function to update token state
	 */
	Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
	    this.events.newToken.subscribe(function(token, contextParams) {
	        var conditionParams = [token, contextParams];
	        var canApplyModifier = (
	            condition === null ||
	            condition.apply(this, conditionParams) === true
	        );
	        var modifierParams = [token, contextParams];
	        if (canApplyModifier) {
	            var newStateValue = modifier.apply(this, modifierParams);
	            token.setState(modifierId, newStateValue);
	        }
	    });
	    this.registeredModifiers.push(modifierId);
	};

	/**
	 * Subscribe a handler to an event
	 * @param {function} eventHandler an event handler function
	 */
	Event.prototype.subscribe = function (eventHandler) {
	    if (typeof eventHandler === 'function') {
	        return ((this.subscribers.push(eventHandler)) - 1);
	    } else {
	        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
	    }
	};

	/**
	 * Unsubscribe an event handler
	 * @param {string} subsId subscription id
	 */
	Event.prototype.unsubscribe = function (subsId) {
	    this.subscribers.splice(subsId, 1);
	};

	/**
	 * Sets context params current value index
	 * @param {number} index context params current value index
	 */
	ContextParams.prototype.setCurrentIndex = function(index) {
	    this.index = index;
	    this.current = this.context[index];
	    this.backtrack = this.context.slice(0, index);
	    this.lookahead = this.context.slice(index + 1);
	};

	/**
	 * Get an item at an offset from the current value
	 * example (current value is 3):
	 *  1    2   [3]   4    5   |   items values
	 * -2   -1    0    1    2   |   offset values
	 * @param {number} offset an offset from current value index
	 */
	ContextParams.prototype.get = function (offset) {
	    switch (true) {
	        case (offset === 0):
	            return this.current;
	        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
	            return this.backtrack.slice(offset)[0];
	        case (offset > 0 && offset <= this.lookahead.length):
	            return this.lookahead[offset - 1];
	        default:
	            return null;
	    }
	};

	/**
	 * Converts a context range into a string value
	 * @param {contextRange} range a context range
	 */
	Tokenizer.prototype.rangeToText = function (range) {
	    if (range instanceof ContextRange) {
	        return (
	            this.getRangeTokens(range)
	                .map(function (token) { return token.char; }).join('')
	        );
	    }
	};

	/**
	 * Converts all tokens into a string
	 */
	Tokenizer.prototype.getText = function () {
	    return this.tokens.map(function (token) { return token.char; }).join('');
	};

	/**
	 * Get a context by name
	 * @param {string} contextName context name to get
	 */
	Tokenizer.prototype.getContext = function (contextName) {
	    var context = this.registeredContexts[contextName];
	    return !!context ? context : null;
	};

	/**
	 * Subscribes a new event handler to an event
	 * @param {string} eventName event name to subscribe to
	 * @param {function} eventHandler a function to be invoked on event
	 */
	Tokenizer.prototype.on = function(eventName, eventHandler) {
	    var event = this.events[eventName];
	    if (!!event) {
	        return event.subscribe(eventHandler);
	    } else {
	        return null;
	    }
	};

	/**
	 * Dispatches an event
	 * @param {string} eventName event name
	 * @param {any} args event handler arguments
	 */
	Tokenizer.prototype.dispatch = function(eventName, args) {
	    var this$1 = this;

	    var event = this.events[eventName];
	    if (event instanceof Event) {
	        event.subscribers.forEach(function (subscriber) {
	            subscriber.apply(this$1, args || []);
	        });
	    }
	};

	/**
	 * Register a new context checker
	 * @param {string} contextName a unique context name
	 * @param {function} contextStartCheck a predicate function that returns true on context start
	 * @param {function} contextEndCheck  a predicate function that returns true on context end
	 * TODO: call tokenize on registration to update context ranges with the new context.
	 */
	Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
	    if (!!this.getContext(contextName)) { return {
	        FAIL:
	        ("context name '" + contextName + "' is already registered.")
	    }; }
	    if (typeof contextStartCheck !== 'function') { return {
	        FAIL:
	        "missing context start check."
	    }; }
	    if (typeof contextEndCheck !== 'function') { return {
	        FAIL:
	        "missing context end check."
	    }; }
	    var contextCheckers = new ContextChecker(
	        contextName, contextStartCheck, contextEndCheck
	    );
	    this.registeredContexts[contextName] = contextCheckers;
	    this.contextCheckers.push(contextCheckers);
	    return contextCheckers;
	};

	/**
	 * Gets a context range tokens
	 * @param {contextRange} range a context range
	 */
	Tokenizer.prototype.getRangeTokens = function(range) {
	    var endIndex = range.startIndex + range.endOffset;
	    return [].concat(
	        this.tokens
	            .slice(range.startIndex, endIndex)
	    );
	};

	/**
	 * Gets the ranges of a context
	 * @param {string} contextName context name
	 */
	Tokenizer.prototype.getContextRanges = function(contextName) {
	    var context = this.getContext(contextName);
	    if (!!context) {
	        return context.ranges;
	    } else {
	        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
	    }
	};

	/**
	 * Resets context ranges to run context update
	 */
	Tokenizer.prototype.resetContextsRanges = function () {
	    var registeredContexts = this.registeredContexts;
	    for (var contextName in registeredContexts) {
	        if (registeredContexts.hasOwnProperty(contextName)) {
	            var context = registeredContexts[contextName];
	            context.ranges = [];
	        }
	    }
	};

	/**
	 * Updates context ranges
	 */
	Tokenizer.prototype.updateContextsRanges = function () {
	    this.resetContextsRanges();
	    var chars = this.tokens.map(function (token) { return token.char; });
	    for (var i = 0; i < chars.length; i++) {
	        var contextParams = new ContextParams(chars, i);
	        this.runContextCheck(contextParams);
	    }
	    this.dispatch('updateContextsRanges', [this.registeredContexts]);
	};

	/**
	 * Sets the end offset of an open range
	 * @param {number} offset range end offset
	 * @param {string} contextName context name
	 */
	Tokenizer.prototype.setEndOffset = function (offset, contextName) {
	    var startIndex = this.getContext(contextName).openRange.startIndex;
	    var range = new ContextRange(startIndex, offset, contextName);
	    var ranges = this.getContext(contextName).ranges;
	    range.rangeId = contextName + "." + (ranges.length);
	    ranges.push(range);
	    this.getContext(contextName).openRange = null;
	    return range;
	};

	/**
	 * Runs a context check on the current context
	 * @param {contextParams} contextParams current context params
	 */
	Tokenizer.prototype.runContextCheck = function(contextParams) {
	    var this$1 = this;

	    var index = contextParams.index;
	    this.contextCheckers.forEach(function (contextChecker) {
	        var contextName = contextChecker.contextName;
	        var openRange = this$1.getContext(contextName).openRange;
	        if (!openRange && contextChecker.checkStart(contextParams)) {
	            openRange = new ContextRange(index, null, contextName);
	            this$1.getContext(contextName).openRange = openRange;
	            this$1.dispatch('contextStart', [contextName, index]);
	        }
	        if (!!openRange && contextChecker.checkEnd(contextParams)) {
	            var offset = (index - openRange.startIndex) + 1;
	            var range = this$1.setEndOffset(offset, contextName);
	            this$1.dispatch('contextEnd', [contextName, range]);
	        }
	    });
	};

	/**
	 * Converts a text into a list of tokens
	 * @param {string} text a text to tokenize
	 */
	Tokenizer.prototype.tokenize = function (text) {
	    this.tokens = [];
	    this.resetContextsRanges();
	    var chars = Array.from(text);
	    this.dispatch('start');
	    for (var i = 0; i < chars.length; i++) {
	        var char = chars[i];
	        var contextParams = new ContextParams(chars, i);
	        this.dispatch('next', [contextParams]);
	        this.runContextCheck(contextParams);
	        var token = new Token(char);
	        this.tokens.push(token);
	        this.dispatch('newToken', [token, contextParams]);
	    }
	    this.dispatch('end', [this.tokens]);
	    return this.tokens;
	};

	// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮
	// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊
	// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯
	// jscs:disable maximumLineLength
	/**
	 * Check if a char is Arabic
	 * @param {string} c a single char
	 */
	function isArabicChar(c) {
	    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
	}

	/**
	 * Check if a char is an isolated arabic char
	 * @param {string} c a single char
	 */
	function isIsolatedArabicChar(char) {
	    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
	}

	/**
	 * Check if a char is an Arabic Tashkeel char
	 * @param {string} c a single char
	 */
	function isTashkeelArabicChar(char) {
	    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
	}

	/**
	 * Check if a char is Latin
	 * @param {string} c a single char
	 */
	function isLatinChar(c) {
	    return /[A-z]/.test(c);
	}

	/**
	 * Check if a char is whitespace char
	 * @param {string} c a single char
	 */
	function isWhiteSpace(c) {
	    return /\s/.test(c);
	}

	/**
	 * Query a feature by some of it's properties to lookup a glyph substitution.
	 */

	/**
	 * Create feature query instance
	 * @param {Font} font opentype font instance
	 */
	function FeatureQuery(font) {
	    this.font = font;
	    this.features = {};
	}

	/**
	 * @typedef SubstitutionAction
	 * @type Object
	 * @property {number} id substitution type
	 * @property {string} tag feature tag
	 * @property {any} substitution substitution value(s)
	 */

	/**
	 * Create a substitution action instance
	 * @param {SubstitutionAction} action
	 */
	function SubstitutionAction(action) {
	    this.id = action.id;
	    this.tag = action.tag;
	    this.substitution = action.substitution;
	}

	/**
	 * Lookup a coverage table
	 * @param {number} glyphIndex glyph index
	 * @param {CoverageTable} coverage coverage table
	 */
	function lookupCoverage(glyphIndex, coverage) {
	    if (!glyphIndex) { return -1; }
	    switch (coverage.format) {
	        case 1:
	            return coverage.glyphs.indexOf(glyphIndex);

	        case 2:
	            var ranges = coverage.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                if (glyphIndex >= range.start && glyphIndex <= range.end) {
	                    var offset = glyphIndex - range.start;
	                    return range.index + offset;
	                }
	            }
	            break;
	        default:
	            return -1; // not found
	    }
	    return -1;
	}

	/**
	 * Handle a single substitution - format 1
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function singleSubstitutionFormat1(glyphIndex, subtable) {
	    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (substituteIndex === -1) { return null; }
	    return glyphIndex + subtable.deltaGlyphId;
	}

	/**
	 * Handle a single substitution - format 2
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function singleSubstitutionFormat2(glyphIndex, subtable) {
	    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (substituteIndex === -1) { return null; }
	    return subtable.substitute[substituteIndex];
	}

	/**
	 * Lookup a list of coverage tables
	 * @param {any} coverageList a list of coverage tables
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function lookupCoverageList(coverageList, contextParams) {
	    var lookupList = [];
	    for (var i = 0; i < coverageList.length; i++) {
	        var coverage = coverageList[i];
	        var glyphIndex = contextParams.current;
	        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
	        var lookupIndex = lookupCoverage(glyphIndex, coverage);
	        if (lookupIndex !== -1) {
	            lookupList.push(lookupIndex);
	        }
	    }
	    if (lookupList.length !== coverageList.length) { return -1; }
	    return lookupList;
	}

	/**
	 * Handle chaining context substitution - format 3
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function chainingSubstitutionFormat3(contextParams, subtable) {
	    var lookupsCount = (
	        subtable.inputCoverage.length +
	        subtable.lookaheadCoverage.length +
	        subtable.backtrackCoverage.length
	    );
	    if (contextParams.context.length < lookupsCount) { return []; }
	    // INPUT LOOKUP //
	    var inputLookups = lookupCoverageList(
	        subtable.inputCoverage, contextParams
	    );
	    if (inputLookups === -1) { return []; }
	    // LOOKAHEAD LOOKUP //
	    var lookaheadOffset = subtable.inputCoverage.length - 1;
	    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }
	    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
	    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
	        lookaheadContext.shift();
	    }
	    var lookaheadParams = new ContextParams(lookaheadContext, 0);
	    var lookaheadLookups = lookupCoverageList(
	        subtable.lookaheadCoverage, lookaheadParams
	    );
	    // BACKTRACK LOOKUP //
	    var backtrackContext = [].concat(contextParams.backtrack);
	    backtrackContext.reverse();
	    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
	        backtrackContext.shift();
	    }
	    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }
	    var backtrackParams = new ContextParams(backtrackContext, 0);
	    var backtrackLookups = lookupCoverageList(
	        subtable.backtrackCoverage, backtrackParams
	    );
	    var contextRulesMatch = (
	        inputLookups.length === subtable.inputCoverage.length &&
	        lookaheadLookups.length === subtable.lookaheadCoverage.length &&
	        backtrackLookups.length === subtable.backtrackCoverage.length
	    );
	    var substitutions = [];
	    if (contextRulesMatch) {
	        for (var i = 0; i < subtable.lookupRecords.length; i++) {
	            var lookupRecord = subtable.lookupRecords[i];
	            var lookupListIndex = lookupRecord.lookupListIndex;
	            var lookupTable = this.getLookupByIndex(lookupListIndex);
	            for (var s = 0; s < lookupTable.subtables.length; s++) {
	                var subtable$1 = lookupTable.subtables[s];
	                var lookup = this.getLookupMethod(lookupTable, subtable$1);
	                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
	                if (substitutionType === '12') {
	                    for (var n = 0; n < inputLookups.length; n++) {
	                        var glyphIndex = contextParams.get(n);
	                        var substitution = lookup(glyphIndex);
	                        if (substitution) { substitutions.push(substitution); }
	                    }
	                }
	            }
	        }
	    }
	    return substitutions;
	}

	/**
	 * Handle ligature substitution - format 1
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function ligatureSubstitutionFormat1(contextParams, subtable) {
	    // COVERAGE LOOKUP //
	    var glyphIndex = contextParams.current;
	    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (ligSetIndex === -1) { return null; }
	    // COMPONENTS LOOKUP
	    // (!) note, components are ordered in the written direction.
	    var ligature;
	    var ligatureSet = subtable.ligatureSets[ligSetIndex];
	    for (var s = 0; s < ligatureSet.length; s++) {
	        ligature = ligatureSet[s];
	        for (var l = 0; l < ligature.components.length; l++) {
	            var lookaheadItem = contextParams.lookahead[l];
	            var component = ligature.components[l];
	            if (lookaheadItem !== component) { break; }
	            if (l === ligature.components.length - 1) { return ligature; }
	        }
	    }
	    return null;
	}

	/**
	 * Handle decomposition substitution - format 1
	 * @param {number} glyphIndex glyph index
	 * @param {any} subtable subtable
	 */
	function decompositionSubstitutionFormat1(glyphIndex, subtable) {
	    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (substituteIndex === -1) { return null; }
	    return subtable.sequences[substituteIndex];
	}

	/**
	 * Get default script features indexes
	 */
	FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {
	    var scripts = this.font.tables.gsub.scripts;
	    for (var s = 0; s < scripts.length; s++) {
	        var script = scripts[s];
	        if (script.tag === 'DFLT') { return (
	            script.script.defaultLangSys.featureIndexes
	        ); }
	    }
	    return [];
	};

	/**
	 * Get feature indexes of a specific script
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
	    var tables = this.font.tables;
	    if (!tables.gsub) { return []; }
	    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }
	    var scripts = this.font.tables.gsub.scripts;
	    for (var i = 0; i < scripts.length; i++) {
	        var script = scripts[i];
	        if (script.tag === scriptTag && script.script.defaultLangSys) {
	            return script.script.defaultLangSys.featureIndexes;
	        } else {
	            var langSysRecords = script.langSysRecords;
	            if (!!langSysRecords) {
	                for (var j = 0; j < langSysRecords.length; j++) {
	                    var langSysRecord = langSysRecords[j];
	                    if (langSysRecord.tag === scriptTag) {
	                        var langSys = langSysRecord.langSys;
	                        return langSys.featureIndexes;
	                    }
	                }
	            }
	        }
	    }
	    return this.getDefaultScriptFeaturesIndexes();
	};

	/**
	 * Map a feature tag to a gsub feature
	 * @param {any} features gsub features
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
	    var tags = {};
	    for (var i = 0; i < features.length; i++) {
	        var tag = features[i].tag;
	        var feature = features[i].feature;
	        tags[tag] = feature;
	    }
	    this.features[scriptTag].tags = tags;
	};

	/**
	 * Get features of a specific script
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
	    var features = this.features[scriptTag];
	    if (this.features.hasOwnProperty(scriptTag)) { return features; }
	    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
	    if (!featuresIndexes) { return null; }
	    var gsub = this.font.tables.gsub;
	    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
	    this.features[scriptTag] = features;
	    this.mapTagsToFeatures(features, scriptTag);
	    return features;
	};

	/**
	 * Get substitution type
	 * @param {any} lookupTable lookup table
	 * @param {any} subtable subtable
	 */
	FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
	    var lookupType = lookupTable.lookupType.toString();
	    var substFormat = subtable.substFormat.toString();
	    return lookupType + substFormat;
	};

	/**
	 * Get lookup method
	 * @param {any} lookupTable lookup table
	 * @param {any} subtable subtable
	 */
	FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
	    var this$1 = this;

	    var substitutionType = this.getSubstitutionType(lookupTable, subtable);
	    switch (substitutionType) {
	        case '11':
	            return function (glyphIndex) { return singleSubstitutionFormat1.apply(
	                this$1, [glyphIndex, subtable]
	            ); };
	        case '12':
	            return function (glyphIndex) { return singleSubstitutionFormat2.apply(
	                this$1, [glyphIndex, subtable]
	            ); };
	        case '63':
	            return function (contextParams) { return chainingSubstitutionFormat3.apply(
	                this$1, [contextParams, subtable]
	            ); };
	        case '41':
	            return function (contextParams) { return ligatureSubstitutionFormat1.apply(
	                this$1, [contextParams, subtable]
	            ); };
	        case '21':
	            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(
	                this$1, [glyphIndex, subtable]
	            ); };
	        default:
	            throw new Error(
	                "lookupType: " + (lookupTable.lookupType) + " - " +
	                "substFormat: " + (subtable.substFormat) + " " +
	                "is not yet supported"
	            );
	    }
	};

	/**
	 * [ LOOKUP TYPES ]
	 * -------------------------------
	 * Single                        1;
	 * Multiple                      2;
	 * Alternate                     3;
	 * Ligature                      4;
	 * Context                       5;
	 * ChainingContext               6;
	 * ExtensionSubstitution         7;
	 * ReverseChainingContext        8;
	 * -------------------------------
	 *
	 */

	/**
	 * @typedef FQuery
	 * @type Object
	 * @param {string} tag feature tag
	 * @param {string} script feature script
	 * @param {ContextParams} contextParams context params
	 */

	/**
	 * Lookup a feature using a query parameters
	 * @param {FQuery} query feature query
	 */
	FeatureQuery.prototype.lookupFeature = function (query) {
	    var contextParams = query.contextParams;
	    var currentIndex = contextParams.index;
	    var feature = this.getFeature({
	        tag: query.tag, script: query.script
	    });
	    if (!feature) { return new Error(
	        "font '" + (this.font.names.fullName.en) + "' " +
	        "doesn't support feature '" + (query.tag) + "' " +
	        "for script '" + (query.script) + "'."
	    ); }
	    var lookups = this.getFeatureLookups(feature);
	    var substitutions = [].concat(contextParams.context);
	    for (var l = 0; l < lookups.length; l++) {
	        var lookupTable = lookups[l];
	        var subtables = this.getLookupSubtables(lookupTable);
	        for (var s = 0; s < subtables.length; s++) {
	            var subtable = subtables[s];
	            var substType = this.getSubstitutionType(lookupTable, subtable);
	            var lookup = this.getLookupMethod(lookupTable, subtable);
	            var substitution = (void 0);
	            switch (substType) {
	                case '11':
	                    substitution = lookup(contextParams.current);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 11, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '12':
	                    substitution = lookup(contextParams.current);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 12, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '63':
	                    substitution = lookup(contextParams);
	                    if (Array.isArray(substitution) && substitution.length) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 63, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '41':
	                    substitution = lookup(contextParams);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 41, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '21':
	                    substitution = lookup(contextParams.current);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 21, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	            }
	            contextParams = new ContextParams(substitutions, currentIndex);
	            if (Array.isArray(substitution) && !substitution.length) { continue; }
	            substitution = null;
	        }
	    }
	    return substitutions.length ? substitutions : null;
	};

	/**
	 * Checks if a font supports a specific features
	 * @param {FQuery} query feature query object
	 */
	FeatureQuery.prototype.supports = function (query) {
	    if (!query.script) { return false; }
	    this.getScriptFeatures(query.script);
	    var supportedScript = this.features.hasOwnProperty(query.script);
	    if (!query.tag) { return supportedScript; }
	    var supportedFeature = (
	        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })
	    );
	    return supportedScript && supportedFeature;
	};

	/**
	 * Get lookup table subtables
	 * @param {any} lookupTable lookup table
	 */
	FeatureQuery.prototype.getLookupSubtables = function (lookupTable) {
	    return lookupTable.subtables || null;
	};

	/**
	 * Get lookup table by index
	 * @param {number} index lookup table index
	 */
	FeatureQuery.prototype.getLookupByIndex = function (index) {
	    var lookups = this.font.tables.gsub.lookups;
	    return lookups[index] || null;
	};

	/**
	 * Get lookup tables for a feature
	 * @param {string} feature
	 */
	FeatureQuery.prototype.getFeatureLookups = function (feature) {
	    // TODO: memoize
	    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
	};

	/**
	 * Query a feature by it's properties
	 * @param {any} query an object that describes the properties of a query
	 */
	FeatureQuery.prototype.getFeature = function getFeature(query) {
	    if (!this.font) { return { FAIL: "No font was found"}; }
	    if (!this.features.hasOwnProperty(query.script)) {
	        this.getScriptFeatures(query.script);
	    }
	    var scriptFeatures = this.features[query.script];
	    if (!scriptFeatures) { return (
	        { FAIL: ("No feature for script " + (query.script))}
	    ); }
	    if (!scriptFeatures.tags[query.tag]) { return null; }
	    return this.features[query.script].tags[query.tag];
	};

	/**
	 * Arabic word context checkers
	 */

	function arabicWordStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? arabic first char
	        (prevChar === null && isArabicChar(char)) ||
	        // ? arabic char preceded with a non arabic char
	        (!isArabicChar(prevChar) && isArabicChar(char))
	    );
	}

	function arabicWordEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    return (
	        // ? last arabic char
	        (nextChar === null) ||
	        // ? next char is not arabic
	        (!isArabicChar(nextChar))
	    );
	}

	var arabicWordCheck = {
	    startCheck: arabicWordStartCheck,
	    endCheck: arabicWordEndCheck
	};

	/**
	 * Arabic sentence context checkers
	 */

	function arabicSentenceStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? an arabic char preceded with a non arabic char
	        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
	        !isArabicChar(prevChar)
	    );
	}

	function arabicSentenceEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    switch (true) {
	        case nextChar === null:
	            return true;
	        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
	            var nextIsWhitespace = isWhiteSpace(nextChar);
	            if (!nextIsWhitespace) { return true; }
	            if (nextIsWhitespace) {
	                var arabicCharAhead = false;
	                arabicCharAhead = (
	                    contextParams.lookahead.some(
	                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
	                    )
	                );
	                if (!arabicCharAhead) { return true; }
	            }
	            break;
	        default:
	            return false;
	    }
	}

	var arabicSentenceCheck = {
	    startCheck: arabicSentenceStartCheck,
	    endCheck: arabicSentenceEndCheck
	};

	/**
	 * Apply single substitution format 1
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function singleSubstitutionFormat1$1(action, tokens, index) {
	    tokens[index].setState(action.tag, action.substitution);
	}

	/**
	 * Apply single substitution format 2
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function singleSubstitutionFormat2$1(action, tokens, index) {
	    tokens[index].setState(action.tag, action.substitution);
	}

	/**
	 * Apply chaining context substitution format 3
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function chainingSubstitutionFormat3$1(action, tokens, index) {
	    action.substitution.forEach(function (subst, offset) {
	        var token = tokens[index + offset];
	        token.setState(action.tag, subst);
	    });
	}

	/**
	 * Apply ligature substitution format 1
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function ligatureSubstitutionFormat1$1(action, tokens, index) {
	    var token = tokens[index];
	    token.setState(action.tag, action.substitution.ligGlyph);
	    var compsCount = action.substitution.components.length;
	    for (var i = 0; i < compsCount; i++) {
	        token = tokens[index + i + 1];
	        token.setState('deleted', true);
	    }
	}

	/**
	 * Supported substitutions
	 */
	var SUBSTITUTIONS = {
	    11: singleSubstitutionFormat1$1,
	    12: singleSubstitutionFormat2$1,
	    63: chainingSubstitutionFormat3$1,
	    41: ligatureSubstitutionFormat1$1
	};

	/**
	 * Apply substitutions to a list of tokens
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function applySubstitution(action, tokens, index) {
	    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
	        SUBSTITUTIONS[action.id](action, tokens, index);
	    }
	}

	/**
	 * Apply Arabic presentation forms to a range of tokens
	 */

	/**
	 * Check if a char can be connected to it's preceding char
	 * @param {ContextParams} charContextParams context params of a char
	 */
	function willConnectPrev(charContextParams) {
	    var backtrack = [].concat(charContextParams.backtrack);
	    for (var i = backtrack.length - 1; i >= 0; i--) {
	        var prevChar = backtrack[i];
	        var isolated = isIsolatedArabicChar(prevChar);
	        var tashkeel = isTashkeelArabicChar(prevChar);
	        if (!isolated && !tashkeel) { return true; }
	        if (isolated) { return false; }
	    }
	    return false;
	}

	/**
	 * Check if a char can be connected to it's proceeding char
	 * @param {ContextParams} charContextParams context params of a char
	 */
	function willConnectNext(charContextParams) {
	    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
	    for (var i = 0; i < charContextParams.lookahead.length; i++) {
	        var nextChar = charContextParams.lookahead[i];
	        var tashkeel = isTashkeelArabicChar(nextChar);
	        if (!tashkeel) { return true; }
	    }
	    return false;
	}

	/**
	 * Apply arabic presentation forms to a list of tokens
	 * @param {ContextRange} range a range of tokens
	 */
	function arabicPresentationForms(range) {
	    var this$1 = this;

	    var script = 'arab';
	    var tags = this.featuresTags[script];
	    var tokens = this.tokenizer.getRangeTokens(range);
	    if (tokens.length === 1) { return; }
	    var contextParams = new ContextParams(
	        tokens.map(function (token) { return token.getState('glyphIndex'); }
	    ), 0);
	    var charContextParams = new ContextParams(
	        tokens.map(function (token) { return token.char; }
	    ), 0);
	    tokens.forEach(function (token, index) {
	        if (isTashkeelArabicChar(token.char)) { return; }
	        contextParams.setCurrentIndex(index);
	        charContextParams.setCurrentIndex(index);
	        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
	        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
	        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
	        var tag;
	        switch (CONNECT) {
	            case 1: (tag = 'fina'); break;
	            case 2: (tag = 'init'); break;
	            case 3: (tag = 'medi'); break;
	        }
	        if (tags.indexOf(tag) === -1) { return; }
	        var substitutions = this$1.query.lookupFeature({
	            tag: tag, script: script, contextParams: contextParams
	        });
	        if (substitutions instanceof Error) { return console.info(substitutions.message); }
	        substitutions.forEach(function (action, index) {
	            if (action instanceof SubstitutionAction) {
	                applySubstitution(action, tokens, index);
	                contextParams.context[index] = action.substitution;
	            }
	        });
	    });
	}

	/**
	 * Apply Arabic required ligatures feature to a range of tokens
	 */

	/**
	 * Update context params
	 * @param {any} tokens a list of tokens
	 * @param {number} index current item index
	 */
	function getContextParams(tokens, index) {
	    var context = tokens.map(function (token) { return token.activeState.value; });
	    return new ContextParams(context, index || 0);
	}

	/**
	 * Apply Arabic required ligatures to a context range
	 * @param {ContextRange} range a range of tokens
	 */
	function arabicRequiredLigatures(range) {
	    var this$1 = this;

	    var script = 'arab';
	    var tokens = this.tokenizer.getRangeTokens(range);
	    var contextParams = getContextParams(tokens);
	    contextParams.context.forEach(function (glyphIndex, index) {
	        contextParams.setCurrentIndex(index);
	        var substitutions = this$1.query.lookupFeature({
	            tag: 'rlig', script: script, contextParams: contextParams
	        });
	        if (substitutions.length) {
	            substitutions.forEach(
	                function (action) { return applySubstitution(action, tokens, index); }
	            );
	            contextParams = getContextParams(tokens);
	        }
	    });
	}

	/**
	 * Latin word context checkers
	 */

	function latinWordStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? latin first char
	        (prevChar === null && isLatinChar(char)) ||
	        // ? latin char preceded with a non latin char
	        (!isLatinChar(prevChar) && isLatinChar(char))
	    );
	}

	function latinWordEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    return (
	        // ? last latin char
	        (nextChar === null) ||
	        // ? next char is not latin
	        (!isLatinChar(nextChar))
	    );
	}

	var latinWordCheck = {
	    startCheck: latinWordStartCheck,
	    endCheck: latinWordEndCheck
	};

	/**
	 * Apply Latin ligature feature to a range of tokens
	 */

	/**
	 * Update context params
	 * @param {any} tokens a list of tokens
	 * @param {number} index current item index
	 */
	function getContextParams$1(tokens, index) {
	    var context = tokens.map(function (token) { return token.activeState.value; });
	    return new ContextParams(context, index || 0);
	}

	/**
	 * Apply Arabic required ligatures to a context range
	 * @param {ContextRange} range a range of tokens
	 */
	function latinLigature(range) {
	    var this$1 = this;

	    var script = 'latn';
	    var tokens = this.tokenizer.getRangeTokens(range);
	    var contextParams = getContextParams$1(tokens);
	    contextParams.context.forEach(function (glyphIndex, index) {
	        contextParams.setCurrentIndex(index);
	        var substitutions = this$1.query.lookupFeature({
	            tag: 'liga', script: script, contextParams: contextParams
	        });
	        if (substitutions.length) {
	            substitutions.forEach(
	                function (action) { return applySubstitution(action, tokens, index); }
	            );
	            contextParams = getContextParams$1(tokens);
	        }
	    });
	}

	/**
	 * Infer bidirectional properties for a given text and apply
	 * the corresponding layout rules.
	 */

	/**
	 * Create Bidi. features
	 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
	 */
	function Bidi(baseDir) {
	    this.baseDir = baseDir || 'ltr';
	    this.tokenizer = new Tokenizer();
	    this.featuresTags = {};
	}

	/**
	 * Sets Bidi text
	 * @param {string} text a text input
	 */
	Bidi.prototype.setText = function (text) {
	    this.text = text;
	};

	/**
	 * Store essential context checks:
	 * arabic word check for applying gsub features
	 * arabic sentence check for adjusting arabic layout
	 */
	Bidi.prototype.contextChecks = ({
	    latinWordCheck: latinWordCheck,
	    arabicWordCheck: arabicWordCheck,
	    arabicSentenceCheck: arabicSentenceCheck
	});

	/**
	 * Register arabic word check
	 */
	function registerContextChecker(checkId) {
	    var check = this.contextChecks[(checkId + "Check")];
	    return this.tokenizer.registerContextChecker(
	        checkId, check.startCheck, check.endCheck
	    );
	}

	/**
	 * Perform pre tokenization procedure then
	 * tokenize text input
	 */
	function tokenizeText() {
	    registerContextChecker.call(this, 'latinWord');
	    registerContextChecker.call(this, 'arabicWord');
	    registerContextChecker.call(this, 'arabicSentence');
	    return this.tokenizer.tokenize(this.text);
	}

	/**
	 * Reverse arabic sentence layout
	 * TODO: check base dir before applying adjustments - priority low
	 */
	function reverseArabicSentences() {
	    var this$1 = this;

	    var ranges = this.tokenizer.getContextRanges('arabicSentence');
	    ranges.forEach(function (range) {
	        var rangeTokens = this$1.tokenizer.getRangeTokens(range);
	        this$1.tokenizer.replaceRange(
	            range.startIndex,
	            range.endOffset,
	            rangeTokens.reverse()
	        );
	    });
	}

	/**
	 * Register supported features tags
	 * @param {script} script script tag
	 * @param {Array} tags features tags list
	 */
	Bidi.prototype.registerFeatures = function (script, tags) {
	    var this$1 = this;

	    var supportedTags = tags.filter(
	        function (tag) { return this$1.query.supports({script: script, tag: tag}); }
	    );
	    if (!this.featuresTags.hasOwnProperty(script)) {
	        this.featuresTags[script] = supportedTags;
	    } else {
	        this.featuresTags[script] =
	        this.featuresTags[script].concat(supportedTags);
	    }
	};

	/**
	 * Apply GSUB features
	 * @param {Array} tagsList a list of features tags
	 * @param {string} script a script tag
	 * @param {Font} font opentype font instance
	 */
	Bidi.prototype.applyFeatures = function (font, features) {
	    if (!font) { throw new Error(
	        'No valid font was provided to apply features'
	    ); }
	    if (!this.query) { this.query = new FeatureQuery(font); }
	    for (var f = 0; f < features.length; f++) {
	        var feature = features[f];
	        if (!this.query.supports({script: feature.script})) { continue; }
	        this.registerFeatures(feature.script, feature.tags);
	    }
	};

	/**
	 * Register a state modifier
	 * @param {string} modifierId state modifier id
	 * @param {function} condition a predicate function that returns true or false
	 * @param {function} modifier a modifier function to set token state
	 */
	Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
	    this.tokenizer.registerModifier(modifierId, condition, modifier);
	};

	/**
	 * Check if 'glyphIndex' is registered
	 */
	function checkGlyphIndexStatus() {
	    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
	        throw new Error(
	            'glyphIndex modifier is required to apply ' +
	            'arabic presentation features.'
	        );
	    }
	}

	/**
	 * Apply arabic presentation forms features
	 */
	function applyArabicPresentationForms() {
	    var this$1 = this;

	    var script = 'arab';
	    if (!this.featuresTags.hasOwnProperty(script)) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('arabicWord');
	    ranges.forEach(function (range) {
	        arabicPresentationForms.call(this$1, range);
	    });
	}

	/**
	 * Apply required arabic ligatures
	 */
	function applyArabicRequireLigatures() {
	    var this$1 = this;

	    var script = 'arab';
	    if (!this.featuresTags.hasOwnProperty(script)) { return; }
	    var tags = this.featuresTags[script];
	    if (tags.indexOf('rlig') === -1) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('arabicWord');
	    ranges.forEach(function (range) {
	        arabicRequiredLigatures.call(this$1, range);
	    });
	}

	/**
	 * Apply required arabic ligatures
	 */
	function applyLatinLigatures() {
	    var this$1 = this;

	    var script = 'latn';
	    if (!this.featuresTags.hasOwnProperty(script)) { return; }
	    var tags = this.featuresTags[script];
	    if (tags.indexOf('liga') === -1) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('latinWord');
	    ranges.forEach(function (range) {
	        latinLigature.call(this$1, range);
	    });
	}

	/**
	 * Check if a context is registered
	 * @param {string} contextId context id
	 */
	Bidi.prototype.checkContextReady = function (contextId) {
	    return !!this.tokenizer.getContext(contextId);
	};

	/**
	 * Apply features to registered contexts
	 */
	Bidi.prototype.applyFeaturesToContexts = function () {
	    if (this.checkContextReady('arabicWord')) {
	        applyArabicPresentationForms.call(this);
	        applyArabicRequireLigatures.call(this);
	    }
	    if (this.checkContextReady('latinWord')) {
	        applyLatinLigatures.call(this);
	    }
	    if (this.checkContextReady('arabicSentence')) {
	        reverseArabicSentences.call(this);
	    }
	};

	/**
	 * process text input
	 * @param {string} text an input text
	 */
	Bidi.prototype.processText = function(text) {
	    if (!this.text || this.text !== text) {
	        this.setText(text);
	        tokenizeText.call(this);
	        this.applyFeaturesToContexts();
	    }
	};

	/**
	 * Process a string of text to identify and adjust
	 * bidirectional text entities.
	 * @param {string} text input text
	 */
	Bidi.prototype.getBidiText = function (text) {
	    this.processText(text);
	    return this.tokenizer.getText();
	};

	/**
	 * Get the current state index of each token
	 * @param {text} text an input text
	 */
	Bidi.prototype.getTextGlyphs = function (text) {
	    this.processText(text);
	    var indexes = [];
	    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
	        var token = this.tokenizer.tokens[i];
	        if (token.state.deleted) { continue; }
	        var index = token.activeState.value;
	        indexes.push(Array.isArray(index) ? index[0] : index);
	    }
	    return indexes;
	};

	// The Font object

	/**
	 * @typedef FontOptions
	 * @type Object
	 * @property {Boolean} empty - whether to create a new empty font
	 * @property {string} familyName
	 * @property {string} styleName
	 * @property {string=} fullName
	 * @property {string=} postScriptName
	 * @property {string=} designer
	 * @property {string=} designerURL
	 * @property {string=} manufacturer
	 * @property {string=} manufacturerURL
	 * @property {string=} license
	 * @property {string=} licenseURL
	 * @property {string=} version
	 * @property {string=} description
	 * @property {string=} copyright
	 * @property {string=} trademark
	 * @property {Number} unitsPerEm
	 * @property {Number} ascender
	 * @property {Number} descender
	 * @property {Number} createdTimestamp
	 * @property {string=} weightClass
	 * @property {string=} widthClass
	 * @property {string=} fsSelection
	 */

	/**
	 * A Font represents a loaded OpenType font file.
	 * It contains a set of glyphs and methods to draw text on a drawing context,
	 * or to get a path representing the text.
	 * @exports opentype.Font
	 * @class
	 * @param {FontOptions}
	 * @constructor
	 */
	function Font(options) {
	    options = options || {};
	    options.tables = options.tables || {};

	    if (!options.empty) {
	        // Check that we've provided the minimum set of names.
	        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
	        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
	        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
	        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
	        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');

	        // OS X will complain if the names are empty, so we put a single space everywhere by default.
	        this.names = {
	            fontFamily: {en: options.familyName || ' '},
	            fontSubfamily: {en: options.styleName || ' '},
	            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
	            // postScriptName may not contain any whitespace
	            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
	            designer: {en: options.designer || ' '},
	            designerURL: {en: options.designerURL || ' '},
	            manufacturer: {en: options.manufacturer || ' '},
	            manufacturerURL: {en: options.manufacturerURL || ' '},
	            license: {en: options.license || ' '},
	            licenseURL: {en: options.licenseURL || ' '},
	            version: {en: options.version || 'Version 0.1'},
	            description: {en: options.description || ' '},
	            copyright: {en: options.copyright || ' '},
	            trademark: {en: options.trademark || ' '}
	        };
	        this.unitsPerEm = options.unitsPerEm || 1000;
	        this.ascender = options.ascender;
	        this.descender = options.descender;
	        this.createdTimestamp = options.createdTimestamp;
	        this.tables = Object.assign(options.tables, {
	            os2: Object.assign({
	                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
	                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
	                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,
	            }, options.tables.os2)
	        });
	    }

	    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
	    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
	    this.encoding = new DefaultEncoding(this);
	    this.position = new Position(this);
	    this.substitution = new Substitution(this);
	    this.tables = this.tables || {};

	    // needed for low memory mode only.
	    this._push = null;
	    this._hmtxTableData = {};

	    Object.defineProperty(this, 'hinting', {
	        get: function() {
	            if (this._hinting) { return this._hinting; }
	            if (this.outlinesFormat === 'truetype') {
	                return (this._hinting = new Hinting(this));
	            }
	        }
	    });
	}

	/**
	 * Check if the font has a glyph for the given character.
	 * @param  {string}
	 * @return {Boolean}
	 */
	Font.prototype.hasChar = function(c) {
	    return this.encoding.charToGlyphIndex(c) !== null;
	};

	/**
	 * Convert the given character to a single glyph index.
	 * Note that this function assumes that there is a one-to-one mapping between
	 * the given character and a glyph; for complex scripts this might not be the case.
	 * @param  {string}
	 * @return {Number}
	 */
	Font.prototype.charToGlyphIndex = function(s) {
	    return this.encoding.charToGlyphIndex(s);
	};

	/**
	 * Convert the given character to a single Glyph object.
	 * Note that this function assumes that there is a one-to-one mapping between
	 * the given character and a glyph; for complex scripts this might not be the case.
	 * @param  {string}
	 * @return {opentype.Glyph}
	 */
	Font.prototype.charToGlyph = function(c) {
	    var glyphIndex = this.charToGlyphIndex(c);
	    var glyph = this.glyphs.get(glyphIndex);
	    if (!glyph) {
	        // .notdef
	        glyph = this.glyphs.get(0);
	    }

	    return glyph;
	};

	/**
	 * Update features
	 * @param {any} options features options
	 */
	Font.prototype.updateFeatures = function (options) {
	    // TODO: update all features options not only 'latn'.
	    return this.defaultRenderOptions.features.map(function (feature) {
	        if (feature.script === 'latn') {
	            return {
	                script: 'latn',
	                tags: feature.tags.filter(function (tag) { return options[tag]; })
	            };
	        } else {
	            return feature;
	        }
	    });
	};

	/**
	 * Convert the given text to a list of Glyph objects.
	 * Note that there is no strict one-to-one mapping between characters and
	 * glyphs, so the list of returned glyphs can be larger or smaller than the
	 * length of the given string.
	 * @param  {string}
	 * @param  {GlyphRenderOptions} [options]
	 * @return {opentype.Glyph[]}
	 */
	Font.prototype.stringToGlyphs = function(s, options) {
	    var this$1 = this;


	    var bidi = new Bidi();

	    // Create and register 'glyphIndex' state modifier
	    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };
	    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);

	    // roll-back to default features
	    var features = options ?
	    this.updateFeatures(options.features) :
	    this.defaultRenderOptions.features;

	    bidi.applyFeatures(this, features);

	    var indexes = bidi.getTextGlyphs(s);

	    var length = indexes.length;

	    // convert glyph indexes to glyph objects
	    var glyphs = new Array(length);
	    var notdef = this.glyphs.get(0);
	    for (var i = 0; i < length; i += 1) {
	        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
	    }
	    return glyphs;
	};

	/**
	 * @param  {string}
	 * @return {Number}
	 */
	Font.prototype.nameToGlyphIndex = function(name) {
	    return this.glyphNames.nameToGlyphIndex(name);
	};

	/**
	 * @param  {string}
	 * @return {opentype.Glyph}
	 */
	Font.prototype.nameToGlyph = function(name) {
	    var glyphIndex = this.nameToGlyphIndex(name);
	    var glyph = this.glyphs.get(glyphIndex);
	    if (!glyph) {
	        // .notdef
	        glyph = this.glyphs.get(0);
	    }

	    return glyph;
	};

	/**
	 * @param  {Number}
	 * @return {String}
	 */
	Font.prototype.glyphIndexToName = function(gid) {
	    if (!this.glyphNames.glyphIndexToName) {
	        return '';
	    }

	    return this.glyphNames.glyphIndexToName(gid);
	};

	/**
	 * Retrieve the value of the kerning pair between the left glyph (or its index)
	 * and the right glyph (or its index). If no kerning pair is found, return 0.
	 * The kerning value gets added to the advance width when calculating the spacing
	 * between glyphs.
	 * For GPOS kerning, this method uses the default script and language, which covers
	 * most use cases. To have greater control, use font.position.getKerningValue .
	 * @param  {opentype.Glyph} leftGlyph
	 * @param  {opentype.Glyph} rightGlyph
	 * @return {Number}
	 */
	Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
	    leftGlyph = leftGlyph.index || leftGlyph;
	    rightGlyph = rightGlyph.index || rightGlyph;
	    var gposKerning = this.position.defaultKerningTables;
	    if (gposKerning) {
	        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
	    }
	    // "kern" table
	    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
	};

	/**
	 * @typedef GlyphRenderOptions
	 * @type Object
	 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
	 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
	 * @property {string} [language='dflt'] - language system used to determine which features to apply.
	 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
	 * @property {boolean} [kerning=true] - whether to include kerning values
	 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
	 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
	 */
	Font.prototype.defaultRenderOptions = {
	    kerning: true,
	    features: [
	        /**
	         * these 4 features are required to render Arabic text properly
	         * and shouldn't be turned off when rendering arabic text.
	         */
	        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },
	        { script: 'latn', tags: ['liga', 'rlig'] }
	    ]
	};

	/**
	 * Helper function that invokes the given callback for each glyph in the given text.
	 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
	 * @param {string} text - The text to apply.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @param  {Function} callback
	 */
	Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 72;
	    options = Object.assign({}, this.defaultRenderOptions, options);
	    var fontScale = 1 / this.unitsPerEm * fontSize;
	    var glyphs = this.stringToGlyphs(text, options);
	    var kerningLookups;
	    if (options.kerning) {
	        var script = options.script || this.position.getDefaultScriptName();
	        kerningLookups = this.position.getKerningTables(script, options.language);
	    }
	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs[i];
	        callback.call(this, glyph, x, y, fontSize, options);
	        if (glyph.advanceWidth) {
	            x += glyph.advanceWidth * fontScale;
	        }

	        if (options.kerning && i < glyphs.length - 1) {
	            // We should apply position adjustment lookups in a more generic way.
	            // Here we only use the xAdvance value.
	            var kerningValue = kerningLookups ?
	                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
	                  this.getKerningValue(glyph, glyphs[i + 1]);
	            x += kerningValue * fontScale;
	        }

	        if (options.letterSpacing) {
	            x += options.letterSpacing * fontSize;
	        } else if (options.tracking) {
	            x += (options.tracking / 1000) * fontSize;
	        }
	    }
	    return x;
	};

	/**
	 * Create a Path object that represents the given text.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return {opentype.Path}
	 */
	Font.prototype.getPath = function(text, x, y, fontSize, options) {
	    var fullPath = new Path();
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
	        fullPath.extend(glyphPath);
	    });
	    return fullPath;
	};

	/**
	 * Create an array of Path objects that represent the glyphs of a given text.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return {opentype.Path[]}
	 */
	Font.prototype.getPaths = function(text, x, y, fontSize, options) {
	    var glyphPaths = [];
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
	        glyphPaths.push(glyphPath);
	    });

	    return glyphPaths;
	};

	/**
	 * Returns the advance width of a text.
	 *
	 * This is something different than Path.getBoundingBox() as for example a
	 * suffixed whitespace increases the advanceWidth but not the bounding box
	 * or an overhanging letter like a calligraphic 'f' might have a quite larger
	 * bounding box than its advance width.
	 *
	 * This corresponds to canvas2dContext.measureText(text).width
	 *
	 * @param  {string} text - The text to create.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return advance width
	 */
	Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
	    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
	};

	/**
	 * Draw the text on the given drawing context.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 */
	Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
	    this.getPath(text, x, y, fontSize, options).draw(ctx);
	};

	/**
	 * Draw the points of all glyphs in the text.
	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param {string} text - The text to create.
	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param {GlyphRenderOptions=} options
	 */
	Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        glyph.drawPoints(ctx, gX, gY, gFontSize);
	    });
	};

	/**
	 * Draw lines indicating important font measurements for all glyphs in the text.
	 * Black lines indicate the origin of the coordinate system (point 0,0).
	 * Blue lines indicate the glyph bounding box.
	 * Green line indicates the advance width of the glyph.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param {string} text - The text to create.
	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param {GlyphRenderOptions=} options
	 */
	Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        glyph.drawMetrics(ctx, gX, gY, gFontSize);
	    });
	};

	/**
	 * @param  {string}
	 * @return {string}
	 */
	Font.prototype.getEnglishName = function(name) {
	    var translations = this.names[name];
	    if (translations) {
	        return translations.en;
	    }
	};

	/**
	 * Validate
	 */
	Font.prototype.validate = function() {
	    var _this = this;

	    function assert(predicate, message) {
	    }

	    function assertNamePresent(name) {
	        var englishName = _this.getEnglishName(name);
	        assert(englishName && englishName.trim().length > 0);
	    }

	    // Identification information
	    assertNamePresent('fontFamily');
	    assertNamePresent('weightName');
	    assertNamePresent('manufacturer');
	    assertNamePresent('copyright');
	    assertNamePresent('version');

	    // Dimension information
	    assert(this.unitsPerEm > 0);
	};

	/**
	 * Convert the font object to a SFNT data structure.
	 * This structure contains all the necessary tables and metadata to create a binary OTF file.
	 * @return {opentype.Table}
	 */
	Font.prototype.toTables = function() {
	    return sfnt.fontToTable(this);
	};
	/**
	 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
	 */
	Font.prototype.toBuffer = function() {
	    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
	    return this.toArrayBuffer();
	};
	/**
	 * Converts a `opentype.Font` into an `ArrayBuffer`
	 * @return {ArrayBuffer}
	 */
	Font.prototype.toArrayBuffer = function() {
	    var sfntTable = this.toTables();
	    var bytes = sfntTable.encode();
	    var buffer = new ArrayBuffer(bytes.length);
	    var intArray = new Uint8Array(buffer);
	    for (var i = 0; i < bytes.length; i++) {
	        intArray[i] = bytes[i];
	    }

	    return buffer;
	};

	/**
	 * Initiate a download of the OpenType font.
	 */
	Font.prototype.download = function(fileName) {
	    var familyName = this.getEnglishName('fontFamily');
	    var styleName = this.getEnglishName('fontSubfamily');
	    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
	    var arrayBuffer = this.toArrayBuffer();

	    if (isBrowser()) {
	        window.URL = window.URL || window.webkitURL;

	        if (window.URL) {
	            var dataView = new DataView(arrayBuffer);
	            var blob = new Blob([dataView], {type: 'font/opentype'});

	            var link = document.createElement('a');
	            link.href = window.URL.createObjectURL(blob);
	            link.download = fileName;

	            var event = document.createEvent('MouseEvents');
	            event.initEvent('click', true, false);
	            link.dispatchEvent(event);
	        } else {
	            console.warn('Font file could not be downloaded. Try using a different browser.');
	        }
	    } else {
	        var fs = require('fs');
	        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
	        fs.writeFileSync(fileName, buffer);
	    }
	};
	/**
	 * @private
	 */
	Font.prototype.fsSelectionValues = {
	    ITALIC:              0x001, //1
	    UNDERSCORE:          0x002, //2
	    NEGATIVE:            0x004, //4
	    OUTLINED:            0x008, //8
	    STRIKEOUT:           0x010, //16
	    BOLD:                0x020, //32
	    REGULAR:             0x040, //64
	    USER_TYPO_METRICS:   0x080, //128
	    WWS:                 0x100, //256
	    OBLIQUE:             0x200  //512
	};

	/**
	 * @private
	 */
	Font.prototype.usWidthClasses = {
	    ULTRA_CONDENSED: 1,
	    EXTRA_CONDENSED: 2,
	    CONDENSED: 3,
	    SEMI_CONDENSED: 4,
	    MEDIUM: 5,
	    SEMI_EXPANDED: 6,
	    EXPANDED: 7,
	    EXTRA_EXPANDED: 8,
	    ULTRA_EXPANDED: 9
	};

	/**
	 * @private
	 */
	Font.prototype.usWeightClasses = {
	    THIN: 100,
	    EXTRA_LIGHT: 200,
	    LIGHT: 300,
	    NORMAL: 400,
	    MEDIUM: 500,
	    SEMI_BOLD: 600,
	    BOLD: 700,
	    EXTRA_BOLD: 800,
	    BLACK:    900
	};

	// The `fvar` table stores font variation axes and instances.

	function addName(name, names) {
	    var nameString = JSON.stringify(name);
	    var nameID = 256;
	    for (var nameKey in names) {
	        var n = parseInt(nameKey);
	        if (!n || n < 256) {
	            continue;
	        }

	        if (JSON.stringify(names[nameKey]) === nameString) {
	            return n;
	        }

	        if (nameID <= n) {
	            nameID = n + 1;
	        }
	    }

	    names[nameID] = name;
	    return nameID;
	}

	function makeFvarAxis(n, axis, names) {
	    var nameID = addName(axis.name, names);
	    return [
	        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
	        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
	        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
	        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
	        {name: 'flags_' + n, type: 'USHORT', value: 0},
	        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
	    ];
	}

	function parseFvarAxis(data, start, names) {
	    var axis = {};
	    var p = new parse.Parser(data, start);
	    axis.tag = p.parseTag();
	    axis.minValue = p.parseFixed();
	    axis.defaultValue = p.parseFixed();
	    axis.maxValue = p.parseFixed();
	    p.skip('uShort', 1);  // reserved for flags; no values defined
	    axis.name = names[p.parseUShort()] || {};
	    return axis;
	}

	function makeFvarInstance(n, inst, axes, names) {
	    var nameID = addName(inst.name, names);
	    var fields = [
	        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
	        {name: 'flags_' + n, type: 'USHORT', value: 0}
	    ];

	    for (var i = 0; i < axes.length; ++i) {
	        var axisTag = axes[i].tag;
	        fields.push({
	            name: 'axis_' + n + ' ' + axisTag,
	            type: 'FIXED',
	            value: inst.coordinates[axisTag] << 16
	        });
	    }

	    return fields;
	}

	function parseFvarInstance(data, start, axes, names) {
	    var inst = {};
	    var p = new parse.Parser(data, start);
	    inst.name = names[p.parseUShort()] || {};
	    p.skip('uShort', 1);  // reserved for flags; no values defined

	    inst.coordinates = {};
	    for (var i = 0; i < axes.length; ++i) {
	        inst.coordinates[axes[i].tag] = p.parseFixed();
	    }

	    return inst;
	}

	function makeFvarTable(fvar, names) {
	    var result = new table.Table('fvar', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'offsetToData', type: 'USHORT', value: 0},
	        {name: 'countSizePairs', type: 'USHORT', value: 2},
	        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
	        {name: 'axisSize', type: 'USHORT', value: 20},
	        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
	        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
	    ]);
	    result.offsetToData = result.sizeOf();

	    for (var i = 0; i < fvar.axes.length; i++) {
	        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
	    }

	    for (var j = 0; j < fvar.instances.length; j++) {
	        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
	    }

	    return result;
	}

	function parseFvarTable(data, start, names) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
	    var offsetToData = p.parseOffset16();
	    // Skip countSizePairs.
	    p.skip('uShort', 1);
	    var axisCount = p.parseUShort();
	    var axisSize = p.parseUShort();
	    var instanceCount = p.parseUShort();
	    var instanceSize = p.parseUShort();

	    var axes = [];
	    for (var i = 0; i < axisCount; i++) {
	        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
	    }

	    var instances = [];
	    var instanceStart = start + offsetToData + axisCount * axisSize;
	    for (var j = 0; j < instanceCount; j++) {
	        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
	    }

	    return {axes: axes, instances: instances};
	}

	var fvar = { make: makeFvarTable, parse: parseFvarTable };

	// The `GDEF` table contains various glyph properties

	var attachList = function() {
	    return {
	        coverage: this.parsePointer(Parser.coverage),
	        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))
	    };
	};

	var caretValue = function() {
	    var format = this.parseUShort();
	    check.argument(format === 1 || format === 2 || format === 3,
	        'Unsupported CaretValue table version.');
	    if (format === 1) {
	        return { coordinate: this.parseShort() };
	    } else if (format === 2) {
	        return { pointindex: this.parseShort() };
	    } else if (format === 3) {
	        // Device / Variation Index tables unsupported
	        return { coordinate: this.parseShort() };
	    }
	};

	var ligGlyph = function() {
	    return this.parseList(Parser.pointer(caretValue));
	};

	var ligCaretList = function() {
	    return {
	        coverage: this.parsePointer(Parser.coverage),
	        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))
	    };
	};

	var markGlyphSets = function() {
	    this.parseUShort(); // Version
	    return this.parseList(Parser.pointer(Parser.coverage));
	};

	function parseGDEFTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
	        'Unsupported GDEF table version.');
	    var gdef = {
	        version: tableVersion,
	        classDef: p.parsePointer(Parser.classDef),
	        attachList: p.parsePointer(attachList),
	        ligCaretList: p.parsePointer(ligCaretList),
	        markAttachClassDef: p.parsePointer(Parser.classDef)
	    };
	    if (tableVersion >= 1.2) {
	        gdef.markGlyphSets = p.parsePointer(markGlyphSets);
	    }
	    return gdef;
	}
	var gdef = { parse: parseGDEFTable };

	// The `GPOS` table contains kerning pairs, among other things.

	var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
	// this = Parser instance
	subtableParsers$1[1] = function parseLookup1() {
	    var start = this.offset + this.relativeOffset;
	    var posformat = this.parseUShort();
	    if (posformat === 1) {
	        return {
	            posFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            value: this.parseValueRecord()
	        };
	    } else if (posformat === 2) {
	        return {
	            posFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            values: this.parseValueRecordList()
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
	};

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
	subtableParsers$1[2] = function parseLookup2() {
	    var start = this.offset + this.relativeOffset;
	    var posFormat = this.parseUShort();
	    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
	    var coverage = this.parsePointer(Parser.coverage);
	    var valueFormat1 = this.parseUShort();
	    var valueFormat2 = this.parseUShort();
	    if (posFormat === 1) {
	        // Adjustments for Glyph Pairs
	        return {
	            posFormat: posFormat,
	            coverage: coverage,
	            valueFormat1: valueFormat1,
	            valueFormat2: valueFormat2,
	            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
	                return {        // pairValueRecord
	                    secondGlyph: this.parseUShort(),
	                    value1: this.parseValueRecord(valueFormat1),
	                    value2: this.parseValueRecord(valueFormat2)
	                };
	            })))
	        };
	    } else if (posFormat === 2) {
	        var classDef1 = this.parsePointer(Parser.classDef);
	        var classDef2 = this.parsePointer(Parser.classDef);
	        var class1Count = this.parseUShort();
	        var class2Count = this.parseUShort();
	        return {
	            // Class Pair Adjustment
	            posFormat: posFormat,
	            coverage: coverage,
	            valueFormat1: valueFormat1,
	            valueFormat2: valueFormat2,
	            classDef1: classDef1,
	            classDef2: classDef2,
	            class1Count: class1Count,
	            class2Count: class2Count,
	            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
	                return {
	                    value1: this.parseValueRecord(valueFormat1),
	                    value2: this.parseValueRecord(valueFormat2)
	                };
	            }))
	        };
	    }
	};

	subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
	subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
	subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
	subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
	subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
	subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
	subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
	function parseGposTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

	    if (tableVersion === 1) {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers$1)
	        };
	    } else {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers$1),
	            variations: p.parseFeatureVariationsList()
	        };
	    }

	}

	// GPOS Writing //////////////////////////////////////////////
	// NOT SUPPORTED
	var subtableMakers$1 = new Array(10);

	function makeGposTable(gpos) {
	    return new table.Table('GPOS', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
	    ]);
	}

	var gpos = { parse: parseGposTable, make: makeGposTable };

	// The `kern` table contains kerning pairs.

	function parseWindowsKernTable(p) {
	    var pairs = {};
	    // Skip nTables.
	    p.skip('uShort');
	    var subtableVersion = p.parseUShort();
	    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
	    // Skip subtableLength, subtableCoverage
	    p.skip('uShort', 2);
	    var nPairs = p.parseUShort();
	    // Skip searchRange, entrySelector, rangeShift.
	    p.skip('uShort', 3);
	    for (var i = 0; i < nPairs; i += 1) {
	        var leftIndex = p.parseUShort();
	        var rightIndex = p.parseUShort();
	        var value = p.parseShort();
	        pairs[leftIndex + ',' + rightIndex] = value;
	    }
	    return pairs;
	}

	function parseMacKernTable(p) {
	    var pairs = {};
	    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
	    // Skip the rest.
	    p.skip('uShort');
	    var nTables = p.parseULong();
	    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
	    if (nTables > 1) {
	        console.warn('Only the first kern subtable is supported.');
	    }
	    p.skip('uLong');
	    var coverage = p.parseUShort();
	    var subtableVersion = coverage & 0xFF;
	    p.skip('uShort');
	    if (subtableVersion === 0) {
	        var nPairs = p.parseUShort();
	        // Skip searchRange, entrySelector, rangeShift.
	        p.skip('uShort', 3);
	        for (var i = 0; i < nPairs; i += 1) {
	            var leftIndex = p.parseUShort();
	            var rightIndex = p.parseUShort();
	            var value = p.parseShort();
	            pairs[leftIndex + ',' + rightIndex] = value;
	        }
	    }
	    return pairs;
	}

	// Parse the `kern` table which contains kerning pairs.
	function parseKernTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseUShort();
	    if (tableVersion === 0) {
	        return parseWindowsKernTable(p);
	    } else if (tableVersion === 1) {
	        return parseMacKernTable(p);
	    } else {
	        throw new Error('Unsupported kern table version (' + tableVersion + ').');
	    }
	}

	var kern = { parse: parseKernTable };

	// The `loca` table stores the offsets to the locations of the glyphs in the font.

	// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
	// relative to the beginning of the glyphData table.
	// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
	// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
	// version where offsets are stored as uLongs. The `head` table specifies which version to use
	// (under indexToLocFormat).
	function parseLocaTable(data, start, numGlyphs, shortVersion) {
	    var p = new parse.Parser(data, start);
	    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
	    // There is an extra entry after the last index element to compute the length of the last glyph.
	    // That's why we use numGlyphs + 1.
	    var glyphOffsets = [];
	    for (var i = 0; i < numGlyphs + 1; i += 1) {
	        var glyphOffset = parseFn.call(p);
	        if (shortVersion) {
	            // The short table version stores the actual offset divided by 2.
	            glyphOffset *= 2;
	        }

	        glyphOffsets.push(glyphOffset);
	    }

	    return glyphOffsets;
	}

	var loca = { parse: parseLocaTable };

	// opentype.js

	/**
	 * The opentype library.
	 * @namespace opentype
	 */

	// File loaders /////////////////////////////////////////////////////////
	/**
	 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
	 * @param  {string} path - The path of the file
	 * @param  {Function} callback - The function to call when the font load completes
	 */
	function loadFromFile(path, callback) {
	    var fs = require('fs');
	    fs.readFile(path, function(err, buffer) {
	        if (err) {
	            return callback(err.message);
	        }

	        callback(null, nodeBufferToArrayBuffer(buffer));
	    });
	}
	/**
	 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
	 * @param  {string} url - The URL of the font file.
	 * @param  {Function} callback - The function to call when the font load completes
	 */
	function loadFromUrl(url, callback) {
	    var request = new XMLHttpRequest();
	    request.open('get', url, true);
	    request.responseType = 'arraybuffer';
	    request.onload = function() {
	        if (request.response) {
	            return callback(null, request.response);
	        } else {
	            return callback('Font could not be loaded: ' + request.statusText);
	        }
	    };

	    request.onerror = function () {
	        callback('Font could not be loaded');
	    };

	    request.send();
	}

	// Table Directory Entries //////////////////////////////////////////////
	/**
	 * Parses OpenType table entries.
	 * @param  {DataView}
	 * @param  {Number}
	 * @return {Object[]}
	 */
	function parseOpenTypeTableEntries(data, numTables) {
	    var tableEntries = [];
	    var p = 12;
	    for (var i = 0; i < numTables; i += 1) {
	        var tag = parse.getTag(data, p);
	        var checksum = parse.getULong(data, p + 4);
	        var offset = parse.getULong(data, p + 8);
	        var length = parse.getULong(data, p + 12);
	        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
	        p += 16;
	    }

	    return tableEntries;
	}

	/**
	 * Parses WOFF table entries.
	 * @param  {DataView}
	 * @param  {Number}
	 * @return {Object[]}
	 */
	function parseWOFFTableEntries(data, numTables) {
	    var tableEntries = [];
	    var p = 44; // offset to the first table directory entry.
	    for (var i = 0; i < numTables; i += 1) {
	        var tag = parse.getTag(data, p);
	        var offset = parse.getULong(data, p + 4);
	        var compLength = parse.getULong(data, p + 8);
	        var origLength = parse.getULong(data, p + 12);
	        var compression = (void 0);
	        if (compLength < origLength) {
	            compression = 'WOFF';
	        } else {
	            compression = false;
	        }

	        tableEntries.push({tag: tag, offset: offset, compression: compression,
	            compressedLength: compLength, length: origLength});
	        p += 20;
	    }

	    return tableEntries;
	}

	/**
	 * @typedef TableData
	 * @type Object
	 * @property {DataView} data - The DataView
	 * @property {number} offset - The data offset.
	 */

	/**
	 * @param  {DataView}
	 * @param  {Object}
	 * @return {TableData}
	 */
	function uncompressTable(data, tableEntry) {
	    if (tableEntry.compression === 'WOFF') {
	        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
	        var outBuffer = new Uint8Array(tableEntry.length);
	        tinyInflate(inBuffer, outBuffer);
	        if (outBuffer.byteLength !== tableEntry.length) {
	            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
	        }

	        var view = new DataView(outBuffer.buffer, 0);
	        return {data: view, offset: 0};
	    } else {
	        return {data: data, offset: tableEntry.offset};
	    }
	}

	// Public API ///////////////////////////////////////////////////////////

	/**
	 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
	 * Throws an error if the font could not be parsed.
	 * @param  {ArrayBuffer}
	 * @param  {Object} opt - options for parsing
	 * @return {opentype.Font}
	 */
	function parseBuffer(buffer, opt) {
	    opt = (opt === undefined || opt === null) ?  {} : opt;

	    var indexToLocFormat;
	    var ltagTable;

	    // Since the constructor can also be called to create new fonts from scratch, we indicate this
	    // should be an empty font that we'll fill with our own data.
	    var font = new Font({empty: true});

	    // OpenType fonts use big endian byte ordering.
	    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
	    // Instead we use DataViews where we can specify endianness.
	    var data = new DataView(buffer, 0);
	    var numTables;
	    var tableEntries = [];
	    var signature = parse.getTag(data, 0);
	    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
	        font.outlinesFormat = 'truetype';
	        numTables = parse.getUShort(data, 4);
	        tableEntries = parseOpenTypeTableEntries(data, numTables);
	    } else if (signature === 'OTTO') {
	        font.outlinesFormat = 'cff';
	        numTables = parse.getUShort(data, 4);
	        tableEntries = parseOpenTypeTableEntries(data, numTables);
	    } else if (signature === 'wOFF') {
	        var flavor = parse.getTag(data, 4);
	        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
	            font.outlinesFormat = 'truetype';
	        } else if (flavor === 'OTTO') {
	            font.outlinesFormat = 'cff';
	        } else {
	            throw new Error('Unsupported OpenType flavor ' + signature);
	        }

	        numTables = parse.getUShort(data, 12);
	        tableEntries = parseWOFFTableEntries(data, numTables);
	    } else {
	        throw new Error('Unsupported OpenType signature ' + signature);
	    }

	    var cffTableEntry;
	    var fvarTableEntry;
	    var glyfTableEntry;
	    var gdefTableEntry;
	    var gposTableEntry;
	    var gsubTableEntry;
	    var hmtxTableEntry;
	    var kernTableEntry;
	    var locaTableEntry;
	    var nameTableEntry;
	    var metaTableEntry;
	    var p;

	    for (var i = 0; i < numTables; i += 1) {
	        var tableEntry = tableEntries[i];
	        var table = (void 0);
	        switch (tableEntry.tag) {
	            case 'cmap':
	                table = uncompressTable(data, tableEntry);
	                font.tables.cmap = cmap.parse(table.data, table.offset);
	                font.encoding = new CmapEncoding(font.tables.cmap);
	                break;
	            case 'cvt ' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
	                break;
	            case 'fvar':
	                fvarTableEntry = tableEntry;
	                break;
	            case 'fpgm' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.fpgm = p.parseByteList(tableEntry.length);
	                break;
	            case 'head':
	                table = uncompressTable(data, tableEntry);
	                font.tables.head = head.parse(table.data, table.offset);
	                font.unitsPerEm = font.tables.head.unitsPerEm;
	                indexToLocFormat = font.tables.head.indexToLocFormat;
	                break;
	            case 'hhea':
	                table = uncompressTable(data, tableEntry);
	                font.tables.hhea = hhea.parse(table.data, table.offset);
	                font.ascender = font.tables.hhea.ascender;
	                font.descender = font.tables.hhea.descender;
	                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
	                break;
	            case 'hmtx':
	                hmtxTableEntry = tableEntry;
	                break;
	            case 'ltag':
	                table = uncompressTable(data, tableEntry);
	                ltagTable = ltag.parse(table.data, table.offset);
	                break;
	            case 'maxp':
	                table = uncompressTable(data, tableEntry);
	                font.tables.maxp = maxp.parse(table.data, table.offset);
	                font.numGlyphs = font.tables.maxp.numGlyphs;
	                break;
	            case 'name':
	                nameTableEntry = tableEntry;
	                break;
	            case 'OS/2':
	                table = uncompressTable(data, tableEntry);
	                font.tables.os2 = os2.parse(table.data, table.offset);
	                break;
	            case 'post':
	                table = uncompressTable(data, tableEntry);
	                font.tables.post = post.parse(table.data, table.offset);
	                font.glyphNames = new GlyphNames(font.tables.post);
	                break;
	            case 'prep' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.prep = p.parseByteList(tableEntry.length);
	                break;
	            case 'glyf':
	                glyfTableEntry = tableEntry;
	                break;
	            case 'loca':
	                locaTableEntry = tableEntry;
	                break;
	            case 'CFF ':
	                cffTableEntry = tableEntry;
	                break;
	            case 'kern':
	                kernTableEntry = tableEntry;
	                break;
	            case 'GDEF':
	                gdefTableEntry = tableEntry;
	                break;
	            case 'GPOS':
	                gposTableEntry = tableEntry;
	                break;
	            case 'GSUB':
	                gsubTableEntry = tableEntry;
	                break;
	            case 'meta':
	                metaTableEntry = tableEntry;
	                break;
	        }
	    }

	    var nameTable = uncompressTable(data, nameTableEntry);
	    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
	    font.names = font.tables.name;

	    if (glyfTableEntry && locaTableEntry) {
	        var shortVersion = indexToLocFormat === 0;
	        var locaTable = uncompressTable(data, locaTableEntry);
	        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
	        var glyfTable = uncompressTable(data, glyfTableEntry);
	        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
	    } else if (cffTableEntry) {
	        var cffTable = uncompressTable(data, cffTableEntry);
	        cff.parse(cffTable.data, cffTable.offset, font, opt);
	    } else {
	        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
	    }

	    var hmtxTable = uncompressTable(data, hmtxTableEntry);
	    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
	    addGlyphNames(font, opt);

	    if (kernTableEntry) {
	        var kernTable = uncompressTable(data, kernTableEntry);
	        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
	    } else {
	        font.kerningPairs = {};
	    }

	    if (gdefTableEntry) {
	        var gdefTable = uncompressTable(data, gdefTableEntry);
	        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
	    }

	    if (gposTableEntry) {
	        var gposTable = uncompressTable(data, gposTableEntry);
	        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
	        font.position.init();
	    }

	    if (gsubTableEntry) {
	        var gsubTable = uncompressTable(data, gsubTableEntry);
	        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
	    }

	    if (fvarTableEntry) {
	        var fvarTable = uncompressTable(data, fvarTableEntry);
	        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
	    }

	    if (metaTableEntry) {
	        var metaTable = uncompressTable(data, metaTableEntry);
	        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
	        font.metas = font.tables.meta;
	    }

	    return font;
	}

	/**
	 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
	 * with two arguments `(err, font)`. The `err` will be null on success,
	 * the `font` is a Font object.
	 * We use the node.js callback convention so that
	 * opentype.js can integrate with frameworks like async.js.
	 * @alias opentype.load
	 * @param  {string} url - The URL of the font to load.
	 * @param  {Function} callback - The callback.
	 */
	function load(url, callback, opt) {
	    opt = (opt === undefined || opt === null) ?  {} : opt;
	    var isNode = typeof window === 'undefined';
	    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;

	    return new Promise(function (resolve, reject) {
	        loadFn(url, function(err, arrayBuffer) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                } else {
	                    reject(err);
	                }
	            }
	            var font;
	            try {
	                font = parseBuffer(arrayBuffer, opt);
	            } catch (e) {
	                if (callback) {
	                    return callback(e, null);
	                } else {
	                    reject(e);
	                }
	            }
	            if (callback) {
	                return callback(null, font);
	            } else {
	                resolve(font);
	            }
	        });
	    });
	}

	/**
	 * Synchronously load the font from a URL or file.
	 * When done, returns the font object or throws an error.
	 * @alias opentype.loadSync
	 * @param  {string} url - The URL of the font to load.
	 * @param  {Object} opt - opt.lowMemory
	 * @return {opentype.Font}
	 */
	function loadSync(url, opt) {
	    var fs = require('fs');
	    var buffer = fs.readFileSync(url);
	    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);
	}

	var opentype = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Font: Font,
		Glyph: Glyph,
		Path: Path,
		BoundingBox: BoundingBox,
		_parse: parse,
		parse: parseBuffer,
		load: load,
		loadSync: loadSync
	});

	exports.BoundingBox = BoundingBox;
	exports.Font = Font;
	exports.Glyph = Glyph;
	exports.Path = Path;
	exports._parse = parse;
	exports.default = opentype;
	exports.load = load;
	exports.loadSync = loadSync;
	exports.parse = parseBuffer;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
// end js/opentype.js
// start js/earcut.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.earcut = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    var filteredBridge = filterPoints(bridge, bridge.next);
    filterPoints(bridgeReverse, bridgeReverse.next);

    // Check if input node was removed by the filtering
    return outerNode === bridge ? filteredBridge : outerNode;
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}]},{},[1])(1)
});

// end js/earcut.js
// start js/vargetset.js
(()=>{"use strict";const t=0,e=2,i=2,a=3,s=5;CABLES.VarSetOpWrapper=class{constructor(r,h,_,o,n,p){this._valuePort=_,this._varNamePort=o,this._op=r,this._type=h,this._typeId=-1,this._triggerPort=n,this._nextPort=p,this._btnCreate=r.inTriggerButton("Create new variable"),this._btnCreate.setUiAttribs({hidePort:!0}),this._btnCreate.onTriggered=this._createVar.bind(this),this._helper=r.inUiTriggerButtons("",["Rename"]),this._helper.setUiAttribs({hidePort:!0}),this._helper.onTriggered=t=>{"Rename"==t&&CABLES.CMD.PATCH.renameVariable(r.varName.get())},this._op.setPortGroup("Variable",[this._helper,this._varNamePort,this._btnCreate]),this._op.on("uiParamPanel",this._updateVarNamesDropdown.bind(this)),this._op.patch.addEventListener("variablesChanged",this._updateName.bind(this)),this._op.patch.addEventListener("variableRename",this._renameVar.bind(this)),this._varNamePort.onChange=this._updateName.bind(this),this._isTexture="texture"===this._valuePort.uiAttribs.objType,this._valuePort.changeAlways=!0,this._triggerPort?this._triggerPort.onTriggered=()=>{this._setVarValue(!0)}:this._valuePort.onChange=this._setVarValue.bind(this),this._op.init=()=>{this._updateName(),this._triggerPort||this._setVarValue(),this._updateErrorUi()},this._typeId="array"==h?a:"object"==h?e:"string"==h?s:"texture"==h?i:t}_updateErrorUi(){CABLES.UI&&(this._varNamePort.get()?this._op.hasUiErrors&&this._op.setUiError("novarname",null):this._op.setUiError("novarname","no variable selected"))}_updateName(){const t=this._varNamePort.get();this._op.setTitle("var set"),this._op.setUiAttrib({extendTitle:"#"+t}),this._updateErrorUi();const e=this._op.patch.getVar(t);e&&!e.type&&(e.type=this._type),this._op.patch.hasVar(t)||0==t||this._triggerPort||this._setVarValue(),!this._op.patch.hasVar(t)&&0!=t&&this._triggerPort&&("string"==this._type||"number"==this._type?this._op.patch.setVarValue(t,""):this._op.patch.setVarValue(t,null)),this._op.isCurrentUiOp()&&(this._updateVarNamesDropdown(),this._op.refreshParams()),this._updateDisplay(),this._op.patch.emitEvent("opVariableNameChanged",this._op,this._varNamePort.get())}_createVar(){CABLES.CMD.PATCH.createVariable(this._op,this._type,(()=>{this._updateName()}))}_updateDisplay(){this._valuePort.setUiAttribs({greyout:!this._varNamePort.get()})}_updateVarNamesDropdown(){if(CABLES.UI&&CABLES.UI.loaded&&CABLES.UI.loaded){const t=CABLES.UI.uiProfiler.start("[vars] _updateVarNamesDropdown"),e=[],i=this._op.patch.getVars();for(const t in i)i[t].type==this._type&&"0"!=t&&e.push(t);this._varNamePort.uiAttribs.values=e,t.finish()}}_renameVar(t,e){t==this._varNamePort.get()&&(this._varNamePort.set(e),this._updateName())}_setVarValue(i){const r=this._varNamePort.get();if(!r)return;const h=this._valuePort.get();this._typeId==t||this._typeId==s?this._op.patch.setVarValue(r,h):this._typeId==a?(this._arr=[],CABLES.copyArray(h,this._arr),this._op.patch.setVarValue(r,this._arr)):(this._typeId==e&&(this._isTexture?this._op.patch.setVarValue(r,CGL.Texture.getEmptyTexture(this._op.patch.cgl)):this._op.patch.setVarValue(r,null),h&&h.tex&&h._cgl&&!this._isTexture?this._op.setUiError("texobj","Dont use object variables for textures, use varSetTexture"):this._op.setUiError("texobj",null)),this._op.patch.setVarValue(r,h)),i&&this._nextPort&&this._nextPort.trigger()}},CABLES.VarGetOpWrapper=class{constructor(t,e,i,a){this._op=t,this._type=e,this._varnamePort=i,this._variable=null,this._valueOutPort=a,this._listenerId=null,this._op.on("uiParamPanel",this._updateVarNamesDropdown.bind(this)),this._op.on("uiErrorChange",this._updateTitle.bind(this)),this._op.patch.on("variableRename",this._renameVar.bind(this)),this._op.patch.on("variableDeleted",(t=>{this._op.isCurrentUiOp()&&this._op.refreshParams()})),this._varnamePort.onChange=this._changeVar.bind(this),this._op.patch.addEventListener("variablesChanged",this._init.bind(this)),this._op.onDelete=()=>{this._variable&&this._listenerId&&this._variable.off(this._listenerId)},this._op.init=()=>{this._init()}}get variable(){return this._variable}_changeVar(){this._variable&&this._listenerId&&this._variable.off(this._listenerId),this._init()}_renameVar(t,e){t==this._varnamePort.get()&&(this._varnamePort.set(e),this._updateVarNamesDropdown(),this._updateTitle(),this._listenerId=this._variable.on("change",this._setValueOut.bind(this)))}_updateVarNamesDropdown(){if(CABLES.UI&&CABLES.UI.loaded){const t=[],e=this._op.patch.getVars();for(const i in e)e[i].type==this._type&&"0"!=i&&t.push(i);this._op.varName.uiAttribs.values=t}}_setValueOut(t){this._valueOutPort&&this._valueOutPort.set(t)}_updateTitle(){this._variable?(this._op.setUiError("unknownvar",null),this._op.setTitle("var get"),this._op.setUiAttrib({extendTitle:"#"+this._varnamePort.get()}),this._valueOutPort&&this._valueOutPort.set(this._variable.getValue())):(this._op.setUiError("unknownvar","unknown variable! - there is no setVariable with this name ("+this._varnamePort.get()+")"),this._op.setUiAttrib({extendTitle:"#invalid"}),this._valueOutPort&&this._valueOutPort.set(0))}_init(){this._updateVarNamesDropdown(),this._variable&&this._listenerId&&this._variable.off(this._listenerId),this._variable=this._op.patch.getVar(this._op.varName.get()),this._variable&&(this._listenerId=this._variable.on("change",this._setValueOut.bind(this))),this._updateTitle(),this._op.patch.emitEvent("opVariableNameChanged",this._op,this._varnamePort.get())}},((this.CABLES=this.CABLES||{}).COREMODULES=this.CABLES.COREMODULES||{}).Vargetset={}.Cables})();// end js/vargetset.js
// start js/cgl_shadermodifier.js
(()=>{"use strict";CGL.ShaderModifier=class{constructor(e,t,s){this._cgl=e,this._name=t,this._origShaders={},this._uniforms=[],this._structUniforms=[],this._definesToggled={},this._defines={},this._mods=[],this._textures=[],this._boundShader=null,this._changedDefines=!0,this._changedUniforms=!0,this._modulesChanged=!1,this.needsTexturePush=!1,this._lastShader=null,this._attributes=[],s&&s.opId&&(this.opId=s.opId),1==this._cgl.glVersion&&(this._cgl.enableExtension("OES_texture_float"),this._cgl.enableExtension("OES_texture_float_linear"),this._cgl.enableExtension("OES_texture_half_float"),this._cgl.enableExtension("OES_texture_half_float_linear"))}bind(e,t){const s=e||this._cgl.getShader();if(!s)return;this._boundShader=this._origShaders[s.id];let i=!1;if(this._boundShader&&this._lastShader!=this._boundShader.shader&&(this._boundShader.shader.hasModule(this._mods[0].id)||(i=!0)),(i||!this._boundShader||s.lastCompile!=this._boundShader.lastCompile||this._modulesChanged||s._needsRecompile)&&(this._boundShader&&this._boundShader.shader.dispose(),s._needsRecompile&&s.compile(),this._boundShader=this._origShaders[s.id]={lastCompile:s.lastCompile,orig:s,shader:s.copy()},this._addModulesToShader(this._boundShader.shader),this._updateDefinesShader(this._boundShader.shader),this._updateUniformsShader(this._boundShader.shader)),this._boundShader.wireframe=s.wireframe,this._changedDefines&&this._updateDefines(),this._changedUniforms&&this._updateUniforms(),!1!==t&&this._cgl.pushShader(this._boundShader.shader),this._boundShader.shader.copyUniformValues(this._boundShader.orig),this.needsTexturePush){for(let e=0;e<this._textures.length;e+=1){const t=this._textures[e][0],s=this._textures[e][1],i=this._textures[e][2];if(this._getUniform(t)){const e=this.getPrefixedName(t),r=this._boundShader.shader.getUniform(e);r&&this._boundShader.shader.pushTexture(r,s,i)}}this.needsTexturePush=!1,this._textures.length=0}return this._modulesChanged=!1,this._boundShader.shader.fromMod=this,this.onBind&&this.onBind(this._boundShader.shader),this._boundShader.shader}unbind(e){this._boundShader&&!1!==e&&this._cgl.popShader(),this._boundShader=null}_addModulesToShader(e){let t;this._mods.length>1&&(t=this._mods[0]);for(let s=0;s<this._mods.length;s++)e.addModule(this._mods[s],t)}_removeModulesFromShader(e){for(const t in this._origShaders)this._origShaders[t].shader.removeModule(e)}addModule(e){this._mods.push(e),this._modulesChanged=!0}removeModule(e){const t=[];let s=!1;for(let i=0;i<this._mods.length;i++)this._mods[i].title==e&&(s=!0,this._removeModulesFromShader(this._mods[i]),t.push(i));for(let e=t.length-1;e>=0;e-=1)this._mods.splice(t[e],1);this._modulesChanged=!0}_updateUniformsShader(e){for(let t=0;t<this._uniforms.length;t++){const s=this._uniforms[t],i=this.getPrefixedName(s.name);if(!e.hasUniform(i)&&!s.structName){let t=null;"both"===s.shaderType?(t=e.addUniformBoth(s.type,i,s.v1,s.v2,s.v3,s.v4),t.comment="mod: "+this._name):"frag"===s.shaderType?(t=e.addUniformFrag(s.type,i,s.v1,s.v2,s.v3,s.v4),t.comment="mod: "+this._name):"vert"===s.shaderType&&(t=e.addUniformVert(s.type,i,s.v1,s.v2,s.v3,s.v4),t.comment="mod: "+this._name)}}for(let t=0;t<this._structUniforms.length;t+=1){const s=this._structUniforms[t];let i=s.uniformName,r=s.structName;const h=s.members;i=this.getPrefixedName(s.uniformName),r=this.getPrefixedName(s.structName),"frag"===s.shaderType&&e.addUniformStructFrag(r,i,h),"vert"===s.shaderType&&e.addUniformStructVert(r,i,h),"both"===s.shaderType&&e.addUniformStructBoth(r,i,h)}}_updateUniforms(){for(const e in this._origShaders)this._updateUniformsShader(this._origShaders[e].shader);this._changedUniforms=!1}_setUniformValue(e,t,s){const i=e.getUniform(t);i&&i.setValue(s)}setUniformValue(e,t){if(!this._getUniform(e))return;const s=this.getPrefixedName(e);for(const e in this._origShaders)this._setUniformValue(this._origShaders[e].shader,s,t)}hasUniform(e){return this._getUniform(e)}_getUniform(e){for(let t=0;t<this._uniforms.length;t++){if(this._uniforms[t].name==e)return this._uniforms[t];if(this._uniforms[t].structName&&this._uniforms[t].propertyName==e)return this._uniforms[t]}return!1}_getStructUniform(e){for(let t=0;t<this._structUniforms.length;t+=1)if(this._structUniforms[t].uniformName===e)return this._structUniforms[t];return null}_isStructUniform(e){for(let t=0;t<this._uniforms.length;t++){if(this._uniforms[t].name==e)return!1;if(this._uniforms[t].structName&&this._uniforms[t].propertyName==e)return!0}return!1}addUniform(e,t,s,i,r,h,n,o,d,a){if(!this._getUniform(t)){let m="both";a&&(m=a),this._uniforms.push({type:e,name:t,v1:s,v2:i,v3:r,v4:h,structUniformName:n,structName:o,propertyName:d,shaderType:m}),this._changedUniforms=!0}}addUniformFrag(e,t,s,i,r,h){this.addUniform(e,t,s,i,r,h,null,null,null,"frag"),this._changedUniforms=!0}addUniformVert(e,t,s,i,r,h){this.addUniform(e,t,s,i,r,h,null,null,null,"vert"),this._changedUniforms=!0}addUniformBoth(e,t,s,i,r,h){this.addUniform(e,t,s,i,r,h,null,null,null,"both"),this._changedUniforms=!0}addUniformStruct(e,t,s,i){for(let r=0;r<s.length;r+=1){const h=s[r];"2i"!==h.type&&"i"!==h.type&&"3i"!==h.type||"both"!==i||console.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:",e," with member:",h.name," of type:",h.type,"."),this._getUniform(t+"."+h.name)||this.addUniform(h.type,t+"."+h.name,h.v1,h.v2,h.v3,h.v4,t,e,h.name,i)}this._getStructUniform(t)||this._structUniforms.push({structName:e,uniformName:t,members:s,shaderType:i})}addUniformStructVert(e,t,s){this.addUniformStruct(e,t,s,"vert")}addUniformStructFrag(e,t,s){this.addUniformStruct(e,t,s,"frag")}addUniformStructBoth(e,t,s){this.addUniformStruct(e,t,s,"both")}addAttribute(e){for(let t=0;t<this._attributes.length;t++)if(this._attributes[t].name==e.name&&this._attributes[t].nameFrag==e.nameFrag)return;this._attributes.push(e)}pushTexture(e,t,s){if(!t)throw new Error("no texture given to texturestack");this._textures.push([e,t,s]),this.needsTexturePush=!0}_removeUniformFromShader(e,t){t.hasUniform(e)&&t.removeUniform(e)}removeUniform(e){if(this._getUniform(e)){for(let t=this._uniforms.length-1;t>=0;t-=1){const s=e;if(this._uniforms[t].name==e&&!this._uniforms[t].structName){for(const e in this._origShaders)this._removeUniformFromShader(this.getPrefixedName(s),this._origShaders[e].shader);this._uniforms.splice(t,1)}}this._changedUniforms=!0}}removeUniformStruct(e){if(this._getStructUniform(e)){for(let t=this._structUniforms.length-1;t>=0;t-=1){const s=this._structUniforms[t];if(s.uniformName===e){for(const e in this._origShaders)for(let t=0;t<s.members.length;t+=1){const i=s.members[t];this._removeUniformFromShader(this.getPrefixedName(i.name),this._origShaders[e].shader)}this._structUniforms.splice(t,1)}}this._changedUniforms=!0}}getPrefixedName(e){const t=this._mods[0].group;if(void 0!==t)return 0==e.indexOf("MOD_")&&(e="mod"+t+"_"+(e=e.substr("MOD_".length))),e}_updateDefinesShader(e){for(const t in this._defines){const s=this.getPrefixedName(t);null!==this._defines[t]&&void 0!==this._defines[t]?e.define(s,this._defines[t]):e.removeDefine(s)}for(const t in this._definesToggled){const s=this.getPrefixedName(t);e.toggleDefine(s,this._definesToggled[t])}}_updateDefines(){for(const e in this._origShaders)this._updateDefinesShader(this._origShaders[e].shader);this._changedDefines=!1}define(e,t){void 0===t&&(t=!0),this._defines[e]=t,this._changedDefines=!0}removeDefine(e){this._defines[e]=null,this._changedDefines=!0}hasDefine(e){return null!==this._defines[e]&&void 0!==this._defines[e]}toggleDefine(e,t){this._changedDefines=!0,this._definesToggled[e]=t}currentShader(){return this._boundShader?this._boundShader.shader:null}dispose(){}},((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Shadermodifier={}.Shadermodifier})();// end js/cgl_shadermodifier.js
// start js/cgl_pixelreader.js
(()=>{"use strict";CGL.PixelReader=class{constructor(){this.pixelData=null,this._finishedFence=!0,this._size=0,this._pbo=null}_fence(e){const t=e.gl;return this._finishedFence=!1,new Promise((function(i,n){if(e.aborted)return;let r=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);r&&(t.flush(),function s(){if(e.aborted)return;const l=t.clientWaitSync(r,0,0);if(l==t.WAIT_FAILED)console.error("fence wait failed"),n&&n();else{if(l==t.TIMEOUT_EXPIRED)return setTimeout(s,0);l==t.CONDITION_SATISFIED||l==t.ALREADY_SIGNALED?(i(),t.deleteSync(r)):console.log("unknown fence status",l)}}())}))}read(e,t,i,n,r,s,l,a){if(CABLES.UI&&(!CABLES.UI.loaded||performance.now()-CABLES.UI.loadedTime<1e3))return;if(!this._finishedFence)return;const _=e.gl;let f=1;if(e.aborted)return;if(!t)return;i===CGL.Texture.TYPE_FLOAT&&(i=CGL.Texture.PFORMATSTR_RGBA32F);let h=CGL.Texture.isPixelFormatFloat(i);h&&(f=4);const o=CGL.Texture.setUpGlPixelFormat(e,i),u=o.numColorChannels*s*l;if(0==s||0==l||0==u)return;this._pixelData&&this._size==u*f||(this._pixelData=h?new Float32Array(u*f):new Uint8Array(u),this._size=u*f);let F=_.UNSIGNED_BYTE;if(h&&(F=_.FLOAT),0==this._size||!this._pixelData)return void console.error("readpixel size 0",this._size,s,l);this._finishedFence&&(this._pbo=_.createBuffer(),_.bindBuffer(_.PIXEL_PACK_BUFFER,this._pbo),_.bufferData(_.PIXEL_PACK_BUFFER,this._pixelData.byteLength,_.DYNAMIC_READ),_.bindFramebuffer(_.FRAMEBUFFER,t),_.bindBuffer(_.PIXEL_PACK_BUFFER,this._pbo),e.profileData.profileFencedPixelRead++,_.readPixels(n,r,s,l,_.RGBA,o.glDataType,0),_.bindBuffer(_.PIXEL_PACK_BUFFER,null),_.bindFramebuffer(_.FRAMEBUFFER,null));let E=this._pixelData.byteLength;this._finishedFence&&this._pbo&&this._fence(e).then((e=>{this._wasTriggered=!1,this._finishedFence=!0,!e&&this._pixelData&&this._pixelData.byteLength==E&&(_.bindBuffer(_.PIXEL_PACK_BUFFER,this._pbo),_.getBufferSubData(_.PIXEL_PACK_BUFFER,0,this._pixelData),_.bindBuffer(_.PIXEL_PACK_BUFFER,null),a&&a(this._pixelData)),_.deleteBuffer(this._pbo),this._pbo=null}))}},((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Pixelreader={}.Pixelreader})();// end js/cgl_pixelreader.js
// start js/subpatchop.js
(()=>{const t="Ops.Ui.SubPatchInput",a="Ops.Ui.SubPatchOutput";CABLES.SubPatchOp=class{constructor(t,a){a=a||{},this._op=t,t.patchId=t.addInPort(new CABLES.Port(t,"patchId",CABLES.OP_PORT_TYPE_STRING,{display:"readonly",hidePort:!0})),t.setUiAttribs({subPatchOp:{version:2}}),t.uiAttribs.parentOfSubpatch?t.patchId.set(t.uiAttribs.parentOfSubpatch):a.subId?t.patchId.set(a.subId):t.patchId.set(CABLES.generateUUID()),t.patchId.onChange=()=>{a.subId&&(t.patchId.value=a.subId)},t.patch.on("subpatchCreated",(()=>{this.createInOutOps()})),t.on("loadedValueSet",(()=>{this.createInOutOps()})),t.init=()=>{t.setStorage({subPatchVer:2})},t.on("delete",(()=>{t.patch.clearSubPatchCache&&t.patch.clearSubPatchCache(this.patchId);const a=t.patch.ops;for(let h=a.length-1;h>=0;h--)a[h]&&a[h].uiAttribs&&a[h].uiAttribs.subPatch==t.patchId.get()&&t.patch.deleteOp(a[h].id)})),this._op.isExposableSubpatchOp=()=>!0}get patchId(){return this._op.patchId.get()}createInOutOps(){this._op.patch.clearSubPatchCache&&this._op.patch.clearSubPatchCache(this.patchId);let h=this._op.patch.getSubPatchOp(this.patchId,t),c=this._op.patch.getSubPatchOp(this.patchId,a);h||this._op.patch.addOp(t,{subPatch:this.patchId,translate:{x:0,y:0}}),c||this._op.patch.addOp(a,{subPatch:this.patchId,translate:{x:0,y:0}})}},((this.CABLES=this.CABLES||{}).COREMODULES=this.CABLES.COREMODULES||{}).Subpatchop={}.Cables})();// end js/subpatchop.js
